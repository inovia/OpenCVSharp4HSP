%dll
OpenCvSharpExtern.dll
%ver
1.00
%date
2021/11/30
%author
inovia
%url
https://hsp.moe/
%note
#include "OpenCvSharpExtern32.as"
#include "OpenCvSharpExtern64.as"
使用するHSPランタイムのビット数に合わせたインクルードファイルを使用すること
%type
OpenCVSharpラッパーDLL
%port
Win
%index
aruco_DetectorParameters_create
[32/64bit] aruco_DetectorParameters_create
%prm
p1
p1 = var : out DetectorParameters.NativeStruct returnValue
%inst
元関数名(C#): aruco_DetectorParameters_create
元DLLエクスポート名: aruco_DetectorParameters_create
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_aruco.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) aruco_DetectorParameters_create(aruco_DetectorParameters *returnValue)
{
    BEGIN_WRAP
    const auto p = cv::aruco::DetectorParameters::create();
    *returnValue = c(p);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_aruco

%index
aruco_detectMarkers
[32/64bit] 基本的なマーカー検出
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr image
p2 = sptr : IntPtr dictionary
p3 = sptr : IntPtr corners
p4 = sptr : IntPtr ids
p5 = var : ref DetectorParameters.NativeStruct detectParameters
p6 = sptr : IntPtr outrejectedImgPoints
%inst
入力画像のマーカー検出を行う．特定の辞書に含まれるマーカのみが検索されます．検出された各マーカーに対して，画像中のコーナーの2次元位置と，それに対応する識別子が返されます．参照：estimatePoseSingleMarkers, estimatePoseBoard

元関数名(C#): aruco_detectMarkers
元DLLエクスポート名: aruco_detectMarkers
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_aruco.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) aruco_detectMarkers(
    cv::_InputArray *image, 
    cv::Ptr&amp;lt;cv::aruco::Dictionary&amp;gt; *dictionary, 
    std::vector&amp;lt; std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt; *corners,
    std::vector&amp;lt;int&amp;gt; *ids, 
    aruco_DetectorParameters *parameters,
    std::vector&amp;lt; std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt; *rejectedImgPoints)
{
    BEGIN_WRAP
    const auto p = cpp(*parameters);
    cv::aruco::detectMarkers(*image, *dictionary, *corners, *ids, p, *rejectedImgPoints);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_aruco

%index
aruco_drawDetectedMarkers
[32bit] 検出されたマーカーを画像に描画します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr image
p2 = sptr : [MarshalAs(UnmanagedType.LPArray)] IntPtr[] corners
p3 = int : int cornerSize1
p4 = var : int[] contoursSize2
p5 = var : [MarshalAs(UnmanagedType.LPArray)] int[] ids
p6 = int : int idxLength
p7 = ARGS_SCALAR : Scalar borderColor
%inst
検出されたマーカーコーナーの配列と，それに対応する ID が与えられると，この関数は，画像中にマーカーを描画します．マーカーの境界が描画され，マーカーの識別子が与えられていればそれも描画されます．デバッグ用に便利です。

元関数名(C#): aruco_drawDetectedMarkers
元DLLエクスポート名: aruco_drawDetectedMarkers
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_aruco.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) aruco_drawDetectedMarkers(
    cv::_InputOutputArray *image,
    cv::Point2f **corners,
    int cornerSize1,
    int *cornerSize2,
    int *idx, int idxCount, MyCvScalar borderColor)
{
    BEGIN_WRAP
    std::vector&amp;lt; std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt; cornerVec(cornerSize1);
    std::vector&amp;lt;int&amp;gt; idxVec;

    for (int i = 0; i &amp;lt; cornerSize1; i++)
        cornerVec[i] = std::vector&amp;lt;cv::Point2f&amp;gt;(corners[i], corners[i] + cornerSize2[i]);
    if (idx != nullptr)
        idxVec = std::vector&amp;lt;int&amp;gt;(idx, idx + idxCount);

    cv::aruco::drawDetectedMarkers(*image, cornerVec, idxVec, cpp(borderColor));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_aruco

%index
aruco_drawDetectedMarkers
[64bit] 検出されたマーカーを画像に描画します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr image
p2 = sptr : [MarshalAs(UnmanagedType.LPArray)] IntPtr[] corners
p3 = int : int cornerSize1
p4 = var : int[] contoursSize2
p5 = var : [MarshalAs(UnmanagedType.LPArray)] int[] ids
p6 = int : int idxLength
p7 = var : Scalar borderColor
%inst
検出されたマーカーコーナーの配列と，それに対応する ID が与えられると，この関数は，画像中にマーカーを描画します．マーカーの境界が描画され，マーカーの識別子が与えられていればそれも描画されます．デバッグ用に便利です。

元関数名(C#): aruco_drawDetectedMarkers
元DLLエクスポート名: aruco_drawDetectedMarkers
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_aruco.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) aruco_drawDetectedMarkers(
    cv::_InputOutputArray *image,
    cv::Point2f **corners,
    int cornerSize1,
    int *cornerSize2,
    int *idx, int idxCount, MyCvScalar borderColor)
{
    BEGIN_WRAP
    std::vector&amp;lt; std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt; cornerVec(cornerSize1);
    std::vector&amp;lt;int&amp;gt; idxVec;

    for (int i = 0; i &amp;lt; cornerSize1; i++)
        cornerVec[i] = std::vector&amp;lt;cv::Point2f&amp;gt;(corners[i], corners[i] + cornerSize2[i]);
    if (idx != nullptr)
        idxVec = std::vector&amp;lt;int&amp;gt;(idx, idx + idxCount);

    cv::aruco::drawDetectedMarkers(*image, cornerVec, idxVec, cpp(borderColor));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_aruco

%index
aruco_drawMarker
[32/64bit] 標準的なマーカー画像を描画します。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr dictionary
p2 = int : int id
p3 = int : int sidePixels
p4 = sptr : IntPtr mat
p5 = int : int borderBits
%inst
この関数は、マーカー画像を正規の形式で（つまり、すぐに印刷できる状態で）返します。

元関数名(C#): aruco_drawMarker
元DLLエクスポート名: aruco_drawMarker
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_aruco.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) aruco_drawMarker(
    cv::Ptr&amp;lt;cv::aruco::Dictionary&amp;gt; *dictionary, int id, int sidePixels, cv::_OutputArray *img, int borderBits)
{
    BEGIN_WRAP
    cv::aruco::drawMarker(*dictionary, id, sidePixels, *img, borderBits);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_aruco

%index
aruco_estimatePoseSingleMarkers
[32/64bit] 単一のマーカに対する姿勢推定
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : [MarshalAs(UnmanagedType.LPArray)] IntPtr[] corners
p2 = int : int cornersLength1
p3 = var : int[] cornersLengths2
p4 = float : float markerLength
p5 = sptr : IntPtr cameraMatrix
p6 = sptr : IntPtr distCoeffs
p7 = sptr : IntPtr rvecs
p8 = sptr : IntPtr tvecs
p9 = sptr : IntPtr objPoints
%inst
See alsodetectMarkersSee alsoRodrigues）（例：std::vector<cv::Vec3d>）。この関数は，検出されたマーカを受け取り，カメラに対する姿勢の推定値を個別に返します．つまり，各マーカーに対して，1つの回転ベクトルと並進ベクトルが返されます．返される変換は，各マーカの座標系からカメラの座標系へと点を変換するものです．マーカー座標系は、マーカーの中央を中心とし、Z軸はマーカー平面に垂直です。マーカーの四隅の座標を独自の座標系で表すと(-markerLength/2, markerLength/2, 0)、(markerLength/2, markerLength/2, 0)、(markerLength/2, -markerLength/2, 0)、(-markerLength/2, -markerLength/2, 0)

元関数名(C#): aruco_estimatePoseSingleMarkers
元DLLエクスポート名: aruco_estimatePoseSingleMarkers
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_aruco.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) aruco_estimatePoseSingleMarkers(
    cv::Point2f **corners, int cornersLength1,
    int *cornersLengths2, float markerLength,
    cv::_InputArray *cameraMatrix,
    cv::_InputArray *distCoeffs,
    cv::_OutputArray *rvecs, 
    cv::_OutputArray *tvecs,
    cv::_OutputArray *objPoints)
{
    BEGIN_WRAP
    std::vector&amp;lt;std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt; cornersVec(cornersLength1);
    for (int i = 0; i &amp;lt; cornersLength1; i++)    
        cornersVec[i] = std::vector&amp;lt;cv::Point2f&amp;gt;(corners[i], corners[i] + cornersLengths2[i]);    

    cv::aruco::estimatePoseSingleMarkers(cornersVec, markerLength, *cameraMatrix, *distCoeffs, *rvecs, *tvecs, entity(objPoints));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_aruco

%index
aruco_drawAxis
[32/64bit] ポーズ推定から座標系の軸を描画します。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr image
p2 = sptr : IntPtr cameraMatrix
p3 = sptr : IntPtr distCoeffs
p4 = sptr : IntPtr rvec
p5 = sptr : IntPtr tvec
p6 = float : float length
%inst
Rodrigues も参照のこと）.マーカーやボードの姿勢推定が与えられたときに、ワールド座標系、つまりマーカーやボードを中心とした座標系の軸を描画する関数である。Deprecated:use cv::drawFrameAxesExamples: samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp.

元関数名(C#): aruco_drawAxis
元DLLエクスポート名: aruco_drawAxis
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_aruco.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) aruco_drawAxis(
    cv::_InputOutputArray *image,
    cv::_InputArray *cameraMatrix,
    cv::_InputArray *distCoeffs,
    cv::_InputArray *rvec,
    cv::_InputArray *tvec,
    float length)
{
    BEGIN_WRAP
    cv::aruco::drawAxis(*image, *cameraMatrix, *distCoeffs, *rvec, *tvec, length);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_aruco

%index
aruco_getPredefinedDictionary
[32/64bit] PREDEFINED_DICTIONARY_NAME で定義された定義済みの辞書の一つを返します。
%prm
p1,p2
p1 = int : int name
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): aruco_getPredefinedDictionary
元DLLエクスポート名: aruco_getPredefinedDictionary
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_aruco.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) aruco_getPredefinedDictionary(int name, cv::Ptr&amp;lt;cv::aruco::Dictionary&amp;gt;** returnValue)
{
    BEGIN_WRAP
    const auto dictionary = cv::aruco::getPredefinedDictionary(static_cast&amp;lt;cv::aruco::PREDEFINED_DICTIONARY_NAME&amp;gt;(name));
    *returnValue = new cv::Ptr&amp;lt;cv::aruco::Dictionary&amp;gt;(dictionary);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_aruco

%index
aruco_detectCharucoDiamond
[32/64bit] ChArUcoダイヤモンドマーカーを検出します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = sptr : IntPtr image
p2 = sptr : [MarshalAs(UnmanagedType.LPArray)] IntPtr[] markerCorners
p3 = int : int markerCornersSize1
p4 = var : int[] markerCornersSize2
p5 = sptr : IntPtr markerIds
p6 = float : float squareMarkerLengthRate
p7 = sptr : IntPtr diamondCorners
p8 = sptr : IntPtr diamondIds
p9 = sptr : IntPtr cameraMatrix
p10 = sptr : IntPtr distCoeffs
%inst
この関数は，以前に検出されたアルコマーカからダイアモンドマーカを検出します．ダイアモンドは， diamondCorners と diamondIds パラメータで返されます．カメラのキャリブレーションパラメータが提供されている場合、ダイヤモンドの探索は再投影に基づいて行われます。提供されていない場合は、ホモグラフィーに基づいてダイヤモンドを探索します。ホモグラフィーはリプロジェクションよりも高速ですが、検出率が若干低下します。

元関数名(C#): aruco_detectCharucoDiamond
元DLLエクスポート名: aruco_detectCharucoDiamond
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_aruco.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) aruco_detectCharucoDiamond(
    cv::_InputArray *image,
    cv::Point2f **markerCorners,
    int markerCornersSize1,
    int *markerCornersSize2,
    std::vector&amp;lt;int&amp;gt; *markerIds,
    float squareMarkerLengthRate,
    std::vector&amp;lt; std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt; *diamondCorners,
    std::vector&amp;lt;cv::Vec4i&amp;gt; *diamondIds,
    cv::_InputArray *cameraMatrix, cv::_InputArray *distCoeffs)
{
    BEGIN_WRAP
    std::vector&amp;lt; std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt; markerCornerVec(markerCornersSize1);
    for (int i = 0; i &amp;lt; markerCornersSize1; i++)
        markerCornerVec[i] = std::vector&amp;lt;cv::Point2f&amp;gt;(markerCorners[i], markerCorners[i] + markerCornersSize2[i]);

    cv::aruco::detectCharucoDiamond(*image, markerCornerVec, *markerIds, squareMarkerLengthRate,
        *diamondCorners, *diamondIds, entity(cameraMatrix), entity(distCoeffs));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_aruco

%index
aruco_drawDetectedDiamonds
[32bit] 検出されたChArUcoダイヤモンドマーカーのセットを描画します。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr image
p2 = sptr : [MarshalAs(UnmanagedType.LPArray)] IntPtr[] corners
p3 = int : int cornerSize1
p4 = var : int[] contoursSize2
p5 = sptr : IntPtr ids
p6 = ARGS_SCALAR : Scalar borderColor
%inst
検出されたダイヤモンドの配列が与えられると，この関数はそれらを画像上に描画します．マーカーの境界線が描画され、マーカーの識別子が指定されていればそれも描画されます。デバッグ用に便利です。

元関数名(C#): aruco_drawDetectedDiamonds
元DLLエクスポート名: aruco_drawDetectedDiamonds
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_aruco.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) aruco_drawDetectedDiamonds(
    cv::_InputOutputArray *image,
    cv::Point2f **corners,
    int cornerSize1,
    int *cornerSize2,
    std::vector&amp;lt;cv::Vec4i&amp;gt; *ids,
    MyCvScalar borderColor)
{
    BEGIN_WRAP
    std::vector&amp;lt; std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt; cornerVec(cornerSize1);

    for (int i = 0; i &amp;lt; cornerSize1; i++)
        cornerVec[i] = std::vector&amp;lt;cv::Point2f&amp;gt;(corners[i], corners[i] + cornerSize2[i]);

    const cv::_InputArray idArray = (ids != nullptr) ? *ids : static_cast&amp;lt;cv::_InputArray&amp;gt;(cv::noArray());

    cv::aruco::drawDetectedDiamonds(*image, cornerVec, idArray, cpp(borderColor));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_aruco

%index
aruco_drawDetectedDiamonds
[64bit] 検出されたChArUcoダイヤモンドマーカーのセットを描画します。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr image
p2 = sptr : [MarshalAs(UnmanagedType.LPArray)] IntPtr[] corners
p3 = int : int cornerSize1
p4 = var : int[] contoursSize2
p5 = sptr : IntPtr ids
p6 = var : Scalar borderColor
%inst
検出されたダイヤモンドの配列が与えられると，この関数はそれらを画像上に描画します．マーカーの境界線が描画され、マーカーの識別子が指定されていればそれも描画されます。デバッグ用に便利です。

元関数名(C#): aruco_drawDetectedDiamonds
元DLLエクスポート名: aruco_drawDetectedDiamonds
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_aruco.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) aruco_drawDetectedDiamonds(
    cv::_InputOutputArray *image,
    cv::Point2f **corners,
    int cornerSize1,
    int *cornerSize2,
    std::vector&amp;lt;cv::Vec4i&amp;gt; *ids,
    MyCvScalar borderColor)
{
    BEGIN_WRAP
    std::vector&amp;lt; std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt; cornerVec(cornerSize1);

    for (int i = 0; i &amp;lt; cornerSize1; i++)
        cornerVec[i] = std::vector&amp;lt;cv::Point2f&amp;gt;(corners[i], corners[i] + cornerSize2[i]);

    const cv::_InputArray idArray = (ids != nullptr) ? *ids : static_cast&amp;lt;cv::_InputArray&amp;gt;(cv::noArray());

    cv::aruco::drawDetectedDiamonds(*image, cornerVec, idArray, cpp(borderColor));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_aruco

%index
aruco_Ptr_Dictionary_delete
[32/64bit] cv::aruco::Dictionary のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
マーカーの辞書／セット。内部のコード化を含みます。

bytesListには、マーカーのコードワードが含まれています。

bytesList.rowsは、辞書のサイズです。

各マーカーは nbytes = ceil(markerSize*markerSize/8.) でエンコードされます。

各行には、マーカーの4つの回転がすべて含まれているので、その長さは4*nbytesです。



bytesList.ptr(i)[k*nbytes + j]は、i番目のマーカーのk番目の回転におけるj番目のバイトになります。


元関数名(C#): aruco_Ptr_Dictionary_delete
元DLLエクスポート名: aruco_Ptr_Dictionary_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_aruco.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) aruco_Ptr_Dictionary_delete(cv::Ptr&amp;lt;cv::aruco::Dictionary&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_aruco

%index
aruco_Ptr_Dictionary_get
[32/64bit] cv::aruco::Dictionary のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
マーカーの辞書／セット。内部のコード化を含みます。

bytesListには、マーカーのコードワードが含まれています。

bytesList.rowsは、辞書のサイズです。

各マーカーは nbytes = ceil(markerSize*markerSize/8.) でエンコードされます。

各行には、マーカーの4つの回転がすべて含まれているので、その長さは4*nbytesです。



bytesList.ptr(i)[k*nbytes + j]は、i番目のマーカーのk番目の回転におけるj番目のバイトになります。


元関数名(C#): aruco_Ptr_Dictionary_get
元DLLエクスポート名: aruco_Ptr_Dictionary_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_aruco.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) aruco_Ptr_Dictionary_get(cv::Ptr&amp;lt;cv::aruco::Dictionary&amp;gt; *ptr, cv::aruco::Dictionary **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_aruco

%index
aruco_Dictionary_setMarkerSize
[32/64bit] cv::aruco::Dictionary::markerSize 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst



元関数名(C#): aruco_Dictionary_setMarkerSize
元DLLエクスポート名: aruco_Dictionary_setMarkerSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_aruco.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) aruco_Dictionary_setMarkerSize(cv::aruco::Dictionary *obj, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;markerSize = value;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_aruco

%index
aruco_Dictionary_setMaxCorrectionBits
[32/64bit] cv::aruco::Dictionary::maxCorrectionBits 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst



元関数名(C#): aruco_Dictionary_setMaxCorrectionBits
元DLLエクスポート名: aruco_Dictionary_setMaxCorrectionBits
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_aruco.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) aruco_Dictionary_setMaxCorrectionBits(cv::aruco::Dictionary *obj, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;maxCorrectionBits = value;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_aruco

%index
aruco_Dictionary_getBytesList
[32/64bit] cv::aruco::Dictionary::bytesList 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): aruco_Dictionary_getBytesList
元DLLエクスポート名: aruco_Dictionary_getBytesList
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_aruco.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) aruco_Dictionary_getBytesList(cv::aruco::Dictionary *obj, cv::Mat** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(obj-&amp;gt;bytesList);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_aruco

%index
aruco_Dictionary_getMarkerSize
[32/64bit] cv::aruco::Dictionary::markerSize 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): aruco_Dictionary_getMarkerSize
元DLLエクスポート名: aruco_Dictionary_getMarkerSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_aruco.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) aruco_Dictionary_getMarkerSize(cv::aruco::Dictionary *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;markerSize;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_aruco

%index
aruco_Dictionary_getMaxCorrectionBits
[32/64bit] cv::aruco::Dictionary::maxCorrectionBits 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): aruco_Dictionary_getMaxCorrectionBits
元DLLエクスポート名: aruco_Dictionary_getMaxCorrectionBits
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_aruco.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) aruco_Dictionary_getMaxCorrectionBits(cv::aruco::Dictionary *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;maxCorrectionBits;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_aruco

%index
bgsegm_createBackgroundSubtractorMOG
[32/64bit] mixture of-gaussian background subtractorを作成する。
%prm
p1,p2,p3,p4,p5
p1 = int : int history
p2 = int : int nMixtures
p3 = double : double backgroundRatio
p4 = double : double noiseSigma
p5 = var : out IntPtr returnValue
%inst
元関数名(C#): bgsegm_createBackgroundSubtractorMOG
元DLLエクスポート名: bgsegm_createBackgroundSubtractorMOG
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_createBackgroundSubtractorMOG(
    int history, int nmixtures, double backgroundRatio, double noiseSigma, cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorMOG&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::bgsegm::createBackgroundSubtractorMOG(history, nmixtures, backgroundRatio, noiseSigma);
    *returnValue = new cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorMOG&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_Ptr_BackgroundSubtractorMOG_delete
[32/64bit] cv::bgsegm::BackgroundSubtractorMOG のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
Gaussian Mixture-based Background/Foreground Segmentation Algorithm.

このクラスは， [122] で述べられているアルゴリズムを実装しています．


元関数名(C#): bgsegm_Ptr_BackgroundSubtractorMOG_delete
元DLLエクスポート名: bgsegm_Ptr_BackgroundSubtractorMOG_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_Ptr_BackgroundSubtractorMOG_delete(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorMOG&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_Ptr_BackgroundSubtractorMOG_get
[32/64bit] cv::bgsegm::BackgroundSubtractorMOG のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
Gaussian Mixture-based Background/Foreground Segmentation Algorithm.

このクラスは， [122] で述べられているアルゴリズムを実装しています．


元関数名(C#): bgsegm_Ptr_BackgroundSubtractorMOG_get
元DLLエクスポート名: bgsegm_Ptr_BackgroundSubtractorMOG_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_Ptr_BackgroundSubtractorMOG_get(
    cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorMOG&amp;gt; *ptr, cv::bgsegm::BackgroundSubtractorMOG **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorMOG_getHistory
[32/64bit] bgsegm_BackgroundSubtractorMOG_getHistory
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out int returnValue
%inst
元関数名(C#): bgsegm_BackgroundSubtractorMOG_getHistory
元DLLエクスポート名: bgsegm_BackgroundSubtractorMOG_getHistory
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorMOG_getHistory(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorMOG&amp;gt; *ptr, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getHistory();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorMOG_setHistory
[32/64bit] bgsegm_BackgroundSubtractorMOG_setHistory
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = int : int value
%inst
元関数名(C#): bgsegm_BackgroundSubtractorMOG_setHistory
元DLLエクスポート名: bgsegm_BackgroundSubtractorMOG_setHistory
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorMOG_setHistory(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorMOG&amp;gt; *ptr, int value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setHistory(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorMOG_getNMixtures
[32/64bit] bgsegm_BackgroundSubtractorMOG_getNMixtures
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out int returnValue
%inst
元関数名(C#): bgsegm_BackgroundSubtractorMOG_getNMixtures
元DLLエクスポート名: bgsegm_BackgroundSubtractorMOG_getNMixtures
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorMOG_getNMixtures(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorMOG&amp;gt; *ptr, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getNMixtures();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorMOG_setNMixtures
[32/64bit] bgsegm_BackgroundSubtractorMOG_setNMixtures
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = int : int value
%inst
元関数名(C#): bgsegm_BackgroundSubtractorMOG_setNMixtures
元DLLエクスポート名: bgsegm_BackgroundSubtractorMOG_setNMixtures
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorMOG_setNMixtures(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorMOG&amp;gt; *ptr, int value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setNMixtures(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorMOG_getBackgroundRatio
[32/64bit] bgsegm_BackgroundSubtractorMOG_getBackgroundRatio
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out double returnValue
%inst
元関数名(C#): bgsegm_BackgroundSubtractorMOG_getBackgroundRatio
元DLLエクスポート名: bgsegm_BackgroundSubtractorMOG_getBackgroundRatio
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorMOG_getBackgroundRatio(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorMOG&amp;gt; *ptr, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getBackgroundRatio();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorMOG_setBackgroundRatio
[32/64bit] bgsegm_BackgroundSubtractorMOG_setBackgroundRatio
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = double : double value
%inst
元関数名(C#): bgsegm_BackgroundSubtractorMOG_setBackgroundRatio
元DLLエクスポート名: bgsegm_BackgroundSubtractorMOG_setBackgroundRatio
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorMOG_setBackgroundRatio(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorMOG&amp;gt; *ptr, double value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setBackgroundRatio(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorMOG_getNoiseSigma
[32/64bit] bgsegm_BackgroundSubtractorMOG_getNoiseSigma
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out double returnValue
%inst
元関数名(C#): bgsegm_BackgroundSubtractorMOG_getNoiseSigma
元DLLエクスポート名: bgsegm_BackgroundSubtractorMOG_getNoiseSigma
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorMOG_getNoiseSigma(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorMOG&amp;gt; *ptr, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getNoiseSigma();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorMOG_setNoiseSigma
[32/64bit] bgsegm_BackgroundSubtractorMOG_setNoiseSigma
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = double : double value
%inst
元関数名(C#): bgsegm_BackgroundSubtractorMOG_setNoiseSigma
元DLLエクスポート名: bgsegm_BackgroundSubtractorMOG_setNoiseSigma
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorMOG_setNoiseSigma(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorMOG&amp;gt; *ptr, double value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setNoiseSigma(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_createBackgroundSubtractorGMG
[32/64bit] GMG背景減算器を作成します．
%prm
p1,p2,p3
p1 = int : int initializationFrames
p2 = double : double decisionThreshold
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): bgsegm_createBackgroundSubtractorGMG
元DLLエクスポート名: bgsegm_createBackgroundSubtractorGMG
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_createBackgroundSubtractorGMG(
    int initializationFrames, double decisionThreshold, cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::bgsegm::createBackgroundSubtractorGMG(initializationFrames, decisionThreshold);
    *returnValue = new cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_Ptr_BackgroundSubtractorGMG_delete
[32/64bit] cv::bgsegm::BackgroundSubtractorGMG のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
Background Subtractorモジュールは，[92]で示されたアルゴリズムに基づいています．

一連の画像を受け取り，同じ大きさのマスク（8UC1）画像のシーケンスを返します（255は前景，0は背景を表します）．このクラスは，"Visual Tracking of Human Visitors under Variable-Lighting Conditions for a Responsive API "に記載されているアルゴリズムを実装しています．

Visual Tracking of Human Visitors under Variable-Lighting Conditions for a Responsive Audio Art Installation," A. Godbehere, A. Matsukawa, K. Goldberg, American Control Conference, Montreal, June 2012.


元関数名(C#): bgsegm_Ptr_BackgroundSubtractorGMG_delete
元DLLエクスポート名: bgsegm_Ptr_BackgroundSubtractorGMG_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_Ptr_BackgroundSubtractorGMG_delete(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_Ptr_BackgroundSubtractorGMG_get
[32/64bit] cv::bgsegm::BackgroundSubtractorGMG のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
Background Subtractorモジュールは，[92]で示されたアルゴリズムに基づいています．

一連の画像を受け取り，同じ大きさのマスク（8UC1）画像のシーケンスを返します（255は前景，0は背景を表します）．このクラスは，"Visual Tracking of Human Visitors under Variable-Lighting Conditions for a Responsive API "に記載されているアルゴリズムを実装しています．

Visual Tracking of Human Visitors under Variable-Lighting Conditions for a Responsive Audio Art Installation," A. Godbehere, A. Matsukawa, K. Goldberg, American Control Conference, Montreal, June 2012.


元関数名(C#): bgsegm_Ptr_BackgroundSubtractorGMG_get
元DLLエクスポート名: bgsegm_Ptr_BackgroundSubtractorGMG_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_Ptr_BackgroundSubtractorGMG_get(
    cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, cv::bgsegm::BackgroundSubtractorGMG **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_getMaxFeatures
[32/64bit] ヒストグラムで保持する識別色の総数を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out int returnValue
%inst
元関数名(C#): bgsegm_BackgroundSubtractorGMG_getMaxFeatures
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_getMaxFeatures
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_getMaxFeatures(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getMaxFeatures();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_setMaxFeatures
[32/64bit] ヒストグラムで保持する異なる色の総数を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = int : int value
%inst
元関数名(C#): bgsegm_BackgroundSubtractorGMG_setMaxFeatures
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_setMaxFeatures
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_setMaxFeatures(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, int value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setMaxFeatures(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_getDefaultLearningRate
[32/64bit] アルゴリズムの学習率を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out double returnValue
%inst
0.0から1.0の間です。この値は、ヒストグラムから特徴がどれだけ早く「忘れられる」かを決定します。

元関数名(C#): bgsegm_BackgroundSubtractorGMG_getDefaultLearningRate
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_getDefaultLearningRate
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_getDefaultLearningRate(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getDefaultLearningRate();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_setDefaultLearningRate
[32/64bit] アルゴリズムの学習率を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = double : double value
%inst
元関数名(C#): bgsegm_BackgroundSubtractorGMG_setDefaultLearningRate
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_setDefaultLearningRate
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_setDefaultLearningRate(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, double value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setDefaultLearningRate(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_getNumFrames
[32/64bit] 背景モデルの初期化に使われたフレームの数を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out int returnValue
%inst
元関数名(C#): bgsegm_BackgroundSubtractorGMG_getNumFrames
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_getNumFrames
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_getNumFrames(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getNumFrames();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_setNumFrames
[32/64bit] 背景モデルの初期化に使われるフレームの数を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = int : int value
%inst
元関数名(C#): bgsegm_BackgroundSubtractorGMG_setNumFrames
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_setNumFrames
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_setNumFrames(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, int value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setNumFrames(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_getQuantizationLevels
[32/64bit] Return the parameter used for quantization of color-space.
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out int returnValue
%inst
ヒストグラムで使用する各チャンネルの離散的なレベルの数を指定します。

元関数名(C#): bgsegm_BackgroundSubtractorGMG_getQuantizationLevels
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_getQuantizationLevels
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_getQuantizationLevels(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getQuantizationLevels();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_setQuantizationLevels
[32/64bit] 色空間の量子化に用いられるパラメータを設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = int : int value
%inst
元関数名(C#): bgsegm_BackgroundSubtractorGMG_setQuantizationLevels
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_setQuantizationLevels
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_setQuantizationLevels(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, int value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setQuantizationLevels(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_getBackgroundPrior
[32/64bit] ODA：各ピクセルが背景ピクセルである事前確率を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out double returnValue
%inst
元関数名(C#): bgsegm_BackgroundSubtractorGMG_getBackgroundPrior
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_getBackgroundPrior
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_getBackgroundPrior(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getBackgroundPrior();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_setBackgroundPrior
[32/64bit] 各々のピクセルが背景ピクセルであるという事前確率を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = double : double value
%inst
元関数名(C#): bgsegm_BackgroundSubtractorGMG_setBackgroundPrior
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_setBackgroundPrior
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_setBackgroundPrior(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, double value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setBackgroundPrior(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_getSmoothingRadius
[32/64bit] Morphological operationに使われるカーネル半径を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out int returnValue
%inst
元関数名(C#): bgsegm_BackgroundSubtractorGMG_getSmoothingRadius
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_getSmoothingRadius
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_getSmoothingRadius(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getSmoothingRadius();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_setSmoothingRadius
[32/64bit] モルフォロジー演算に使われるカーネル半径を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = int : int value
%inst
元関数名(C#): bgsegm_BackgroundSubtractorGMG_setSmoothingRadius
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_setSmoothingRadius
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_setSmoothingRadius(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, int value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setSmoothingRadius(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_getDecisionThreshold
[32/64bit] 決定閾値の値を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out double returnValue
%inst
決定しきい値とは、ピクセルがFGであると判断される値のことです。

元関数名(C#): bgsegm_BackgroundSubtractorGMG_getDecisionThreshold
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_getDecisionThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_getDecisionThreshold(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getDecisionThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_setDecisionThreshold
[32/64bit] 決定しきい値の値を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = double : double value
%inst
元関数名(C#): bgsegm_BackgroundSubtractorGMG_setDecisionThreshold
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_setDecisionThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_setDecisionThreshold(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, double value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setDecisionThreshold(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_getUpdateBackgroundModel
[32/64bit] background model update のステータスを返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out int returnValue
%inst
元関数名(C#): bgsegm_BackgroundSubtractorGMG_getUpdateBackgroundModel
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_getUpdateBackgroundModel
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_getUpdateBackgroundModel(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getUpdateBackgroundModel() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_setUpdateBackgroundModel
[32/64bit] 背景モデルのアップデートの状態を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = int : int value
%inst
元関数名(C#): bgsegm_BackgroundSubtractorGMG_setUpdateBackgroundModel
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_setUpdateBackgroundModel
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_setUpdateBackgroundModel(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, int value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setUpdateBackgroundModel(value != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_getMinVal
[32/64bit] Returns the minimum value took on pixels in image sequence 画素の最小値を返します。通常は0です。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out double returnValue
%inst
元関数名(C#): bgsegm_BackgroundSubtractorGMG_getMinVal
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_getMinVal
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_getMinVal(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getMinVal();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_setMinVal
[32/64bit] イメージシーケンス内のピクセルで取られた最小値を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = double : double value
%inst
元関数名(C#): bgsegm_BackgroundSubtractorGMG_setMinVal
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_setMinVal
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_setMinVal(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, double value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setMinVal(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_getMaxVal
[32/64bit] RETURN：イメージシーケンス内のピクセルに適用される最大値を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out double returnValue
%inst
元関数名(C#): bgsegm_BackgroundSubtractorGMG_getMaxVal
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_getMaxVal
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_getMaxVal(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getMaxVal();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
bgsegm_BackgroundSubtractorGMG_setMaxVal
[32/64bit] イメージシーケンス内のピクセルにかかる最大値を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = double : double value
%inst
元関数名(C#): bgsegm_BackgroundSubtractorGMG_setMaxVal
元DLLエクスポート名: bgsegm_BackgroundSubtractorGMG_setMaxVal
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_bgsegm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) bgsegm_BackgroundSubtractorGMG_setMaxVal(cv::Ptr&amp;lt;cv::bgsegm::BackgroundSubtractorGMG&amp;gt; *ptr, double value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setMaxVal(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_bgsegm

%index
dnn_superres_DnnSuperResImpl_new1
[32/64bit] cv::dnn_superres::DnnSuperResImpl のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst
畳み込みニューラルネットワークを使って画像をアップスケールするクラスです。以下の4つのモデルが実装されています。



edsr

espcn

fsrcnn

lapsrn


元関数名(C#): dnn_superres_DnnSuperResImpl_new1
元DLLエクスポート名: dnn_superres_DnnSuperResImpl_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_dnn_superres.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_superres_DnnSuperResImpl_new1(
    cv::dnn_superres::DnnSuperResImpl** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::dnn_superres::DnnSuperResImpl;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_superres

%index
dnn_superres_DnnSuperResImpl_new2
[32/64bit] cv::dnn_superres::DnnSuperResImpl のインスタンスを生成します
%prm
p1,p2,p3
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string algo
p2 = int : int scale
p3 = var : out IntPtr returnValue
%inst
畳み込みニューラルネットワークを使って画像をアップスケールするクラスです。以下の4つのモデルが実装されています。



edsr

espcn

fsrcnn

lapsrn


元関数名(C#): dnn_superres_DnnSuperResImpl_new2
元DLLエクスポート名: dnn_superres_DnnSuperResImpl_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_dnn_superres.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_superres_DnnSuperResImpl_new2(
    const char* algo, int scale, cv::dnn_superres::DnnSuperResImpl** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::dnn_superres::DnnSuperResImpl(algo, scale);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_superres

%index
dnn_superres_DnnSuperResImpl_delete
[32/64bit] cv::dnn_superres::DnnSuperResImpl のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
畳み込みニューラルネットワークを使って画像をアップスケールするクラスです。以下の4つのモデルが実装されています。



edsr

espcn

fsrcnn

lapsrn


元関数名(C#): dnn_superres_DnnSuperResImpl_delete
元DLLエクスポート名: dnn_superres_DnnSuperResImpl_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_dnn_superres.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_superres_DnnSuperResImpl_delete(cv::dnn_superres::DnnSuperResImpl* obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_superres

%index
dnn_superres_DnnSuperResImpl_readModel1
[32/64bit] 与えられたパスからモデルを読み込みます。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string path
%inst
元関数名(C#): dnn_superres_DnnSuperResImpl_readModel1
元DLLエクスポート名: dnn_superres_DnnSuperResImpl_readModel1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_dnn_superres.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_superres_DnnSuperResImpl_readModel1(
    cv::dnn_superres::DnnSuperResImpl* obj, const char *path)
{
    BEGIN_WRAP
    obj-&amp;gt;readModel(path);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_superres

%index
dnn_superres_DnnSuperResImpl_readModel2
[32/64bit] 与えられたパスからモデルを読み込みます。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string weights
p3 = str : [MarshalAs(UnmanagedType.LPStr)] string definition
%inst
元関数名(C#): dnn_superres_DnnSuperResImpl_readModel2
元DLLエクスポート名: dnn_superres_DnnSuperResImpl_readModel2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_dnn_superres.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_superres_DnnSuperResImpl_readModel2(
    cv::dnn_superres::DnnSuperResImpl* obj, const char* weights, const char *definition)
{
    BEGIN_WRAP
    obj-&amp;gt;readModel(weights, definition);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_superres

%index
dnn_superres_DnnSuperResImpl_setModel
[32/64bit] 目的のモデルを設定する。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string algo
p3 = int : int scale
%inst
元関数名(C#): dnn_superres_DnnSuperResImpl_setModel
元DLLエクスポート名: dnn_superres_DnnSuperResImpl_setModel
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_dnn_superres.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_superres_DnnSuperResImpl_setModel(
    cv::dnn_superres::DnnSuperResImpl* obj, const char* algo, int scale)
{
    BEGIN_WRAP
    obj-&amp;gt;setModel(algo, scale);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_superres

%index
dnn_superres_DnnSuperResImpl_setPreferableBackend
[32/64bit] 計算バックエンドの設定
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int backendId
%inst
元関数名(C#): dnn_superres_DnnSuperResImpl_setPreferableBackend
元DLLエクスポート名: dnn_superres_DnnSuperResImpl_setPreferableBackend
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_dnn_superres.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_superres_DnnSuperResImpl_setPreferableBackend(
    cv::dnn_superres::DnnSuperResImpl* obj, int backendId)
{
    BEGIN_WRAP
    obj-&amp;gt;setPreferableBackend(backendId);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_superres

%index
dnn_superres_DnnSuperResImpl_setPreferableTarget
[32/64bit] 計算対象を設定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int targetId
%inst
元関数名(C#): dnn_superres_DnnSuperResImpl_setPreferableTarget
元DLLエクスポート名: dnn_superres_DnnSuperResImpl_setPreferableTarget
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_dnn_superres.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_superres_DnnSuperResImpl_setPreferableTarget(
    cv::dnn_superres::DnnSuperResImpl* obj, int targetId)
{
    BEGIN_WRAP
    obj-&amp;gt;setPreferableTarget(targetId);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_superres

%index
dnn_superres_DnnSuperResImpl_upsample
[32/64bit] ニューラルネットワークでアップサンプルします。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr img
p3 = sptr : IntPtr result
%inst
元関数名(C#): dnn_superres_DnnSuperResImpl_upsample
元DLLエクスポート名: dnn_superres_DnnSuperResImpl_upsample
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_dnn_superres.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_superres_DnnSuperResImpl_upsample(
    cv::dnn_superres::DnnSuperResImpl* obj, cv::_InputArray *img, cv::_OutputArray *result)
{
    BEGIN_WRAP
    obj-&amp;gt;upsample(*img, *result);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_superres

%index
dnn_superres_DnnSuperResImpl_upsampleMultioutput
[32/64bit] 複数出力のニューラルネットワークによるアップサンプル。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr img
p3 = sptr : IntPtr imgsNew
p4 = var : int[] scaleFactors
p5 = int : int scaleFactorsSize
p6 = var : string[] nodeNames
p7 = int : int nodeNamesSize
%inst
元関数名(C#): dnn_superres_DnnSuperResImpl_upsampleMultioutput
元DLLエクスポート名: dnn_superres_DnnSuperResImpl_upsampleMultioutput
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_dnn_superres.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_superres_DnnSuperResImpl_upsampleMultioutput(
    cv::dnn_superres::DnnSuperResImpl* obj, cv::_InputArray *img, std::vector&amp;lt;cv::Mat&amp;gt; *imgs_new, 
    const int* scale_factors, int scale_factors_size,
    const char **node_names, int node_names_size)
{
    BEGIN_WRAP

    const std::vector&amp;lt;int&amp;gt; scale_factors_vec(scale_factors, scale_factors + scale_factors_size);
    std::vector&amp;lt;cv::String&amp;gt; node_names_vec(node_names_size);
    for (int i = 0; i &amp;lt; node_names_size; i++)
    {
        node_names_vec[i].assign(cv::String(node_names[i]));
    }

    obj-&amp;gt;upsampleMultioutput(*img, *imgs_new, scale_factors_vec, node_names_vec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_superres

%index
dnn_superres_DnnSuperResImpl_getScale
[32/64bit] モデルのスケールファクターを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): dnn_superres_DnnSuperResImpl_getScale
元DLLエクスポート名: dnn_superres_DnnSuperResImpl_getScale
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_dnn_superres.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_superres_DnnSuperResImpl_getScale(
    cv::dnn_superres::DnnSuperResImpl* obj, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getScale();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_superres

%index
dnn_superres_DnnSuperResImpl_getAlgorithm
[32/64bit] モデルのスケールファクターを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr returnValue
%inst
元関数名(C#): dnn_superres_DnnSuperResImpl_getAlgorithm
元DLLエクスポート名: dnn_superres_DnnSuperResImpl_getAlgorithm
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_dnn_superres.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_superres_DnnSuperResImpl_getAlgorithm(
    cv::dnn_superres::DnnSuperResImpl* obj, std::string* returnValue)
{
    BEGIN_WRAP
    returnValue-&amp;gt;assign(obj-&amp;gt;getAlgorithm());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_superres

%index
flann_Index_new
[32/64bit] cv::flann::GenericIndex のインスタンスを生成します
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr features
p2 = sptr : IntPtr @params
p3 = int : int distType
p4 = var : out IntPtr returnValue
%inst
FLANNの最近傍インデックスクラスです．このクラスは，インデックスが作成される要素の種類によってテンプレート化されています．


元関数名(C#): flann_Index_new
元DLLエクスポート名: flann_Index_new
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Index_new(
    cv::_InputArray *features, cv::flann::IndexParams* params, cvflann::flann_distance_t distType, cv::flann::Index **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::flann::Index(*features, *params, distType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Index_delete
[32/64bit] cv::flann::GenericIndex のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): flann_Index_delete
元DLLエクスポート名: flann_Index_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Index_delete(cv::flann::Index* obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Index_knnSearch1
[32/64bit] flann_Index_knnSearch1
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr obj
p2 = var : [In] float[] queries
p3 = int : int queriesLength
p4 = var : [Out] int[] indices
p5 = var : [Out] float[] dists
p6 = int : int knn
p7 = sptr : IntPtr @params
%inst
元関数名(C#): flann_Index_knnSearch1
元DLLエクスポート名: flann_Index_knnSearch1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Index_knnSearch1(cv::flann::Index* obj, float* queries, int queries_length, int* indices, float* dists, int knn, cv::flann::SearchParams* params)
{
    BEGIN_WRAP
    const std::vector&amp;lt;float&amp;gt; queries_vec(queries, queries + queries_length);
    std::vector&amp;lt;int&amp;gt; indices_vec(knn);
    std::vector&amp;lt;float&amp;gt; dists_vec(knn);
    obj-&amp;gt;knnSearch(queries_vec, indices_vec, dists_vec, knn, *params);
    memcpy(indices, &amp;indices_vec[0], sizeof(int) * knn);
    memcpy(dists, &amp;dists_vec[0], sizeof(float) * knn);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Index_knnSearch2
[32/64bit] flann_Index_knnSearch2
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr queries
p3 = sptr : IntPtr indices
p4 = sptr : IntPtr dists
p5 = int : int knn
p6 = sptr : IntPtr @params
%inst
元関数名(C#): flann_Index_knnSearch2
元DLLエクスポート名: flann_Index_knnSearch2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Index_knnSearch2(cv::flann::Index* obj, cv::Mat* queries, cv::Mat* indices, cv::Mat* dists, int knn, cv::flann::SearchParams* params)
{
    BEGIN_WRAP
    obj-&amp;gt;knnSearch(*queries, *indices, *dists, knn, *params);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Index_knnSearch3
[32/64bit] flann_Index_knnSearch3
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr queries
p3 = var : [Out] int[] indices
p4 = var : [Out] float[] dists
p5 = int : int knn
p6 = sptr : IntPtr @params
%inst
元関数名(C#): flann_Index_knnSearch3
元DLLエクスポート名: flann_Index_knnSearch3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Index_knnSearch3(cv::flann::Index* obj, cv::Mat* queries, int* indices, float* dists, int knn, cv::flann::SearchParams* params)
{
    BEGIN_WRAP
    cv::Mat indices_mat(1, knn, CV_32SC1);
    cv::Mat dists_mat(1, knn, CV_32FC1);
    obj-&amp;gt;knnSearch(*queries, indices_mat, dists_mat, knn, *params);
    memcpy(indices, indices_mat.ptr&amp;lt;int&amp;gt;(0), sizeof(int) * knn);
    memcpy(dists, dists_mat.ptr&amp;lt;float&amp;gt;(0), sizeof(float) * knn);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Index_radiusSearch1
[32/64bit] flann_Index_radiusSearch1
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = sptr : IntPtr obj
p2 = var : [In] float[] queries
p3 = int : int queriesLength
p4 = var : [Out] int[] indices
p5 = int : int indicesLength
p6 = var : [Out] float[] dists
p7 = int : int distsLength
p8 = double : double radius
p9 = int : int maxResults
p10 = sptr : IntPtr @params
%inst
元関数名(C#): flann_Index_radiusSearch1
元DLLエクスポート名: flann_Index_radiusSearch1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Index_radiusSearch1(cv::flann::Index* obj, float* queries, int queries_length, int* indices, int indices_length, float* dists, int dists_length, double radius, int maxResults, cv::flann::SearchParams* params)
{
    BEGIN_WRAP
    const std::vector&amp;lt;float&amp;gt; queries_vec(queries, queries + queries_length);
    std::vector&amp;lt;int&amp;gt; indices_vec(indices_length);
    std::vector&amp;lt;float&amp;gt; dists_vec(dists_length);
    obj-&amp;gt;radiusSearch(queries_vec, indices_vec, dists_vec, radius, maxResults, *params);
    memcpy(indices, &amp;indices_vec[0], sizeof(int) * indices_length);
    memcpy(dists, &amp;dists_vec[0], sizeof(float) * dists_length);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Index_radiusSearch2
[32/64bit] flann_Index_radiusSearch2
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr queries
p3 = sptr : IntPtr indices
p4 = sptr : IntPtr dists
p5 = double : double radius
p6 = int : int maxResults
p7 = sptr : IntPtr @params
%inst
元関数名(C#): flann_Index_radiusSearch2
元DLLエクスポート名: flann_Index_radiusSearch2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Index_radiusSearch2(cv::flann::Index* obj, cv::Mat* queries, cv::Mat* indices, cv::Mat* dists, double radius, int maxResults, cv::flann::SearchParams* params)
{
    BEGIN_WRAP
    obj-&amp;gt;radiusSearch(*queries, *indices, *dists, radius, maxResults, *params);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Index_radiusSearch3
[32/64bit] flann_Index_radiusSearch3
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr queries
p3 = var : [Out] int[] indices
p4 = int : int indicesLength
p5 = var : [Out] float[] dists
p6 = int : int distsLength
p7 = double : double radius
p8 = int : int maxResults
p9 = sptr : IntPtr @params
%inst
元関数名(C#): flann_Index_radiusSearch3
元DLLエクスポート名: flann_Index_radiusSearch3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Index_radiusSearch3(cv::flann::Index* obj, cv::Mat* queries, int* indices, int indices_length, float* dists, int dists_length, double radius, int maxResults, cv::flann::SearchParams* params)
{
    BEGIN_WRAP
    cv::Mat indices_mat(1, indices_length, CV_32SC1);
    cv::Mat dists_mat(1, dists_length, CV_32FC1);
    obj-&amp;gt;radiusSearch(*queries, indices_mat, dists_mat, radius, maxResults, *params);
    memcpy(indices, indices_mat.ptr&amp;lt;int&amp;gt;(0), sizeof(int) * indices_length);
    memcpy(dists, dists_mat.ptr&amp;lt;float&amp;gt;(0), sizeof(float) * dists_length);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Index_save
[32/64bit] flann_Index_save
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
%inst
元関数名(C#): flann_Index_save
元DLLエクスポート名: flann_Index_save
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Index_save(cv::flann::Index* obj, const char* filename)
{
    BEGIN_WRAP
    obj-&amp;gt;save(filename);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_IndexParams_new
[32/64bit] cv::flann::IndexParams のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst



元関数名(C#): flann_Ptr_IndexParams_new
元DLLエクスポート名: flann_Ptr_IndexParams_new
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_IndexParams_new(cv::Ptr&amp;lt;cv::flann::IndexParams&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Ptr&amp;lt;cv::flann::IndexParams&amp;gt;(new cv::flann::IndexParams);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_IndexParams_get
[32/64bit] cv::flann::IndexParams のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): flann_Ptr_IndexParams_get
元DLLエクスポート名: flann_Ptr_IndexParams_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_IndexParams_get(
    cv::Ptr&amp;lt;cv::flann::IndexParams&amp;gt; *ptr, cv::flann::IndexParams **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_IndexParams_delete
[32/64bit] cv::flann::IndexParams のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): flann_Ptr_IndexParams_delete
元DLLエクスポート名: flann_Ptr_IndexParams_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_IndexParams_delete(cv::Ptr&amp;lt;cv::flann::IndexParams&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_IndexParams_getString
[32/64bit] flann_IndexParams_getString
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string key
p3 = str : [MarshalAs(UnmanagedType.LPStr)] string? defaultVal
p4 = sptr : IntPtr returnValue
%inst
元関数名(C#): flann_IndexParams_getString
元DLLエクスポート名: flann_IndexParams_getString
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_IndexParams_getString(
    cv::flann::IndexParams *obj, const char *key, const char *defaultVal, std::string *returnValue)
{
    BEGIN_WRAP
    returnValue-&amp;gt;assign(obj-&amp;gt;getString(key, defaultVal));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_IndexParams_getInt
[32/64bit] flann_IndexParams_getInt
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string key
p3 = int : int defaultVal
p4 = var : out int returnValue
%inst
元関数名(C#): flann_IndexParams_getInt
元DLLエクスポート名: flann_IndexParams_getInt
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_IndexParams_getInt(cv::flann::IndexParams* obj, const char* key, int defaultVal, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getInt(key, defaultVal);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_IndexParams_getDouble
[32/64bit] flann_IndexParams_getDouble
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string key
p3 = double : double defaultVal
p4 = var : out double returnValue
%inst
元関数名(C#): flann_IndexParams_getDouble
元DLLエクスポート名: flann_IndexParams_getDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_IndexParams_getDouble(cv::flann::IndexParams* obj, const char* key, double defaultVal, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getDouble(key, defaultVal);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_IndexParams_setString
[32/64bit] flann_IndexParams_setString
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string key
p3 = str : [MarshalAs(UnmanagedType.LPStr)] string value
%inst
元関数名(C#): flann_IndexParams_setString
元DLLエクスポート名: flann_IndexParams_setString
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_IndexParams_setString(cv::flann::IndexParams* obj, const char* key, const char* value)
{
    BEGIN_WRAP
    obj-&amp;gt;setString(key, value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_IndexParams_setInt
[32/64bit] flann_IndexParams_setInt
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string key
p3 = int : int value
%inst
元関数名(C#): flann_IndexParams_setInt
元DLLエクスポート名: flann_IndexParams_setInt
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_IndexParams_setInt(cv::flann::IndexParams* obj, const char* key, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;setInt(key, value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_IndexParams_setDouble
[32/64bit] flann_IndexParams_setDouble
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string key
p3 = double : double value
%inst
元関数名(C#): flann_IndexParams_setDouble
元DLLエクスポート名: flann_IndexParams_setDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_IndexParams_setDouble(cv::flann::IndexParams* obj, const char* key, double value)
{
    BEGIN_WRAP
    obj-&amp;gt;setDouble(key, value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_IndexParams_setFloat
[32/64bit] flann_IndexParams_setFloat
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string key
p3 = float : float value
%inst
元関数名(C#): flann_IndexParams_setFloat
元DLLエクスポート名: flann_IndexParams_setFloat
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_IndexParams_setFloat(cv::flann::IndexParams* obj, const char* key, float value)
{
    BEGIN_WRAP
    obj-&amp;gt;setFloat(key, value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_IndexParams_setBool
[32/64bit] flann_IndexParams_setBool
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string key
p3 = int : int value
%inst
元関数名(C#): flann_IndexParams_setBool
元DLLエクスポート名: flann_IndexParams_setBool
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_IndexParams_setBool(cv::flann::IndexParams* obj, const char* key, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;setBool(key, (value != 0));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_IndexParams_setAlgorithm
[32/64bit] flann_IndexParams_setAlgorithm
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): flann_IndexParams_setAlgorithm
元DLLエクスポート名: flann_IndexParams_setAlgorithm
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_IndexParams_setAlgorithm(cv::flann::IndexParams* obj, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;setAlgorithm(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_LinearIndexParams_new
[32/64bit] cv::flann::LinearIndexParams のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst
このインデックスは、直線的なブルートフォースサーチを行います。


元関数名(C#): flann_Ptr_LinearIndexParams_new
元DLLエクスポート名: flann_Ptr_LinearIndexParams_new
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_LinearIndexParams_new(cv::Ptr&amp;lt;cv::flann::LinearIndexParams&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Ptr&amp;lt;cv::flann::LinearIndexParams&amp;gt;(new cv::flann::LinearIndexParams);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_LinearIndexParams_get
[32/64bit] cv::flann::LinearIndexParams のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): flann_Ptr_LinearIndexParams_get
元DLLエクスポート名: flann_Ptr_LinearIndexParams_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_LinearIndexParams_get(
    cv::Ptr&amp;lt;cv::flann::LinearIndexParams&amp;gt; *ptr, cv::flann::LinearIndexParams **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_LinearIndexParams_delete
[32/64bit] cv::flann::LinearIndexParams のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): flann_Ptr_LinearIndexParams_delete
元DLLエクスポート名: flann_Ptr_LinearIndexParams_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_LinearIndexParams_delete(cv::Ptr&amp;lt;cv::flann::LinearIndexParams&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_KDTreeIndexParams_new
[32/64bit] cv::flann::KDTreeIndexParams のインスタンスを生成します
%prm
p1,p2
p1 = int : int trees
p2 = var : out IntPtr returnValue
%inst
構築されたインデックスは、並列に検索されるランダム化されたKDツリーのセットで構成されます。


元関数名(C#): flann_Ptr_KDTreeIndexParams_new
元DLLエクスポート名: flann_Ptr_KDTreeIndexParams_new
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_KDTreeIndexParams_new(int trees, cv::Ptr&amp;lt;cv::flann::KDTreeIndexParams&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Ptr&amp;lt;cv::flann::KDTreeIndexParams&amp;gt;(new cv::flann::KDTreeIndexParams(trees));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_KDTreeIndexParams_get
[32/64bit] cv::flann::KDTreeIndexParams のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): flann_Ptr_KDTreeIndexParams_get
元DLLエクスポート名: flann_Ptr_KDTreeIndexParams_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_KDTreeIndexParams_get(
    cv::Ptr&amp;lt;cv::flann::KDTreeIndexParams&amp;gt; *ptr, cv::flann::KDTreeIndexParams **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_KDTreeIndexParams_delete
[32/64bit] cv::flann::KDTreeIndexParams のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): flann_Ptr_KDTreeIndexParams_delete
元DLLエクスポート名: flann_Ptr_KDTreeIndexParams_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_KDTreeIndexParams_delete(cv::Ptr&amp;lt;cv::flann::KDTreeIndexParams&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_KMeansIndexParams_new
[32/64bit] cv::flann::KMeansIndexParams のインスタンスを生成します
%prm
p1,p2,p3,p4,p5
p1 = int : int branching
p2 = int : int iterations
p3 = int : [MarshalAs(UnmanagedType.I4)] FlannCentersInit centersInit
p4 = float : float cbIndex
p5 = var : out IntPtr returnValue
%inst
構築されたインデックスは、階層的なk-meansツリー（デフォルトでは1つのツリー）となり、各点の集合をn個のクラスタに分割し、そのバリセンターを反復的に改良します。なお，このアルゴリズムは，knnの検索速度を重視する場合にLSHの代替手段として，バイナリベクトルをサポートするように拡張されています．また、ほとんどの次元でポイントが同じ値を持つデータセットを直接（MCA/PCAを使用せずに）処理する場合にも、LSHを上回る性能を発揮します。バイナリデータでは、複数のツリーを設定することをお勧めします。


元関数名(C#): flann_Ptr_KMeansIndexParams_new
元DLLエクスポート名: flann_Ptr_KMeansIndexParams_new
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_KMeansIndexParams_new(
    int branching, int iterations, cvflann::flann_centers_init_t centers_init, float cb_index, cv::Ptr&amp;lt;cv::flann::KMeansIndexParams&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Ptr&amp;lt;cv::flann::KMeansIndexParams&amp;gt;(new cv::flann::KMeansIndexParams(branching, iterations, centers_init, cb_index));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_KMeansIndexParams_get
[32/64bit] cv::flann::KMeansIndexParams のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): flann_Ptr_KMeansIndexParams_get
元DLLエクスポート名: flann_Ptr_KMeansIndexParams_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_KMeansIndexParams_get(
    cv::Ptr&amp;lt;cv::flann::KMeansIndexParams&amp;gt; *ptr, cv::flann::KMeansIndexParams **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_KMeansIndexParams_delete
[32/64bit] cv::flann::KMeansIndexParams のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): flann_Ptr_KMeansIndexParams_delete
元DLLエクスポート名: flann_Ptr_KMeansIndexParams_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_KMeansIndexParams_delete(cv::Ptr&amp;lt;cv::flann::KMeansIndexParams&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_LshIndexParams_new
[32/64bit] cv::flann::LshIndexParams のインスタンスを生成します
%prm
p1,p2,p3,p4
p1 = int : int tableNumber
p2 = int : int keySize
p3 = int : int multiProbeLevel
p4 = var : out IntPtr returnValue
%inst
作成されたインデックスは，マルチプローブLSH（Multi-Probe LSH: Efficient Indexing for High-Dimensional Similarity Search by Qin Lv, William Josephson, Zhe Wang, Moses Charikar, Kai Li., Proceedings of the 33rd International Conference on Very Large Data Bases (VLDB).ウィーン、オーストリア。September 2007）に掲載されています。このアルゴリズムは，2値ベクトルを対象としています．


元関数名(C#): flann_Ptr_LshIndexParams_new
元DLLエクスポート名: flann_Ptr_LshIndexParams_new
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_LshIndexParams_new(
    int table_number, int key_size, int multi_probe_level, cv::Ptr&amp;lt;cv::flann::LshIndexParams&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Ptr&amp;lt;cv::flann::LshIndexParams&amp;gt;(new cv::flann::LshIndexParams(table_number, key_size, multi_probe_level));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_LshIndexParams_get
[32/64bit] cv::flann::LshIndexParams のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): flann_Ptr_LshIndexParams_get
元DLLエクスポート名: flann_Ptr_LshIndexParams_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_LshIndexParams_get(
    cv::Ptr&amp;lt;cv::flann::LshIndexParams&amp;gt; *ptr, cv::flann::LshIndexParams **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_LshIndexParams_delete
[32/64bit] cv::flann::LshIndexParams のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): flann_Ptr_LshIndexParams_delete
元DLLエクスポート名: flann_Ptr_LshIndexParams_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_LshIndexParams_delete(cv::Ptr&amp;lt;cv::flann::LshIndexParams&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_CompositeIndexParams_new
[32/64bit] cv::flann::CompositeIndexParams のインスタンスを生成します
%prm
p1,p2,p3,p4,p5,p6
p1 = int : int trees
p2 = int : int branching
p3 = int : int iterations
p4 = int : FlannCentersInit centersInit
p5 = float : float cbIndex
p6 = var : out IntPtr returnValue
%inst
作成されたインデックスは、ランダム化されたKDツリーと階層化されたk-meansツリーを組み合わせたものです。


元関数名(C#): flann_Ptr_CompositeIndexParams_new
元DLLエクスポート名: flann_Ptr_CompositeIndexParams_new
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_CompositeIndexParams_new(
    int trees, int branching, int iterations, cvflann::flann_centers_init_t centers_init, float cb_index, cv::Ptr&amp;lt;cv::flann::CompositeIndexParams&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Ptr&amp;lt;cv::flann::CompositeIndexParams&amp;gt;(new cv::flann::CompositeIndexParams(trees, branching, iterations, centers_init, cb_index));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_CompositeIndexParams_get
[32/64bit] cv::flann::CompositeIndexParams のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): flann_Ptr_CompositeIndexParams_get
元DLLエクスポート名: flann_Ptr_CompositeIndexParams_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_CompositeIndexParams_get(
    cv::Ptr&amp;lt;cv::flann::CompositeIndexParams&amp;gt; *ptr, cv::flann::CompositeIndexParams **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_CompositeIndexParams_delete
[32/64bit] cv::flann::CompositeIndexParams のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): flann_Ptr_CompositeIndexParams_delete
元DLLエクスポート名: flann_Ptr_CompositeIndexParams_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_CompositeIndexParams_delete(cv::Ptr&amp;lt;cv::flann::CompositeIndexParams&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_AutotunedIndexParams_new
[32/64bit] cv::flann::AutotunedIndexParams のインスタンスを生成します
%prm
p1,p2,p3,p4,p5
p1 = float : float targetPrecision
p2 = float : float buildWeight
p3 = float : float memoryWeight
p4 = float : float sampleFraction
p5 = var : out IntPtr returnValue
%inst
作成されたインデックスは，提供されたデータセットに対して最適なインデックスタイプ（ランダム化 kd-trees，階層的 kmeans，linear）とパラメータを選択することで，最高の性能を発揮するように自動的に調整されます．


元関数名(C#): flann_Ptr_AutotunedIndexParams_new
元DLLエクスポート名: flann_Ptr_AutotunedIndexParams_new
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_AutotunedIndexParams_new(
    float target_precision, float build_weight, float memory_weight, float sample_fraction, cv::Ptr&amp;lt;cv::flann::AutotunedIndexParams&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Ptr&amp;lt;cv::flann::AutotunedIndexParams&amp;gt;(new cv::flann::AutotunedIndexParams(target_precision, build_weight, memory_weight, sample_fraction));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_AutotunedIndexParams_get
[32/64bit] cv::flann::AutotunedIndexParams のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): flann_Ptr_AutotunedIndexParams_get
元DLLエクスポート名: flann_Ptr_AutotunedIndexParams_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_AutotunedIndexParams_get(
    cv::Ptr&amp;lt;cv::flann::AutotunedIndexParams&amp;gt; *ptr, cv::flann::AutotunedIndexParams **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_AutotunedIndexParams_delete
[32/64bit] cv::flann::AutotunedIndexParams のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): flann_Ptr_AutotunedIndexParams_delete
元DLLエクスポート名: flann_Ptr_AutotunedIndexParams_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_AutotunedIndexParams_delete(cv::Ptr&amp;lt;cv::flann::AutotunedIndexParams&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_SavedIndexParams_new
[32/64bit] cv::flann::SavedIndexParams のインスタンスを生成します
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
p2 = var : out IntPtr returnValue
%inst
以前に保存したインデックスをディスクから読み込む。


元関数名(C#): flann_Ptr_SavedIndexParams_new
元DLLエクスポート名: flann_Ptr_SavedIndexParams_new
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_SavedIndexParams_new(const char* filename, cv::Ptr&amp;lt;cv::flann::SavedIndexParams&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Ptr&amp;lt;cv::flann::SavedIndexParams&amp;gt;(new cv::flann::SavedIndexParams(filename));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_SavedIndexParams_get
[32/64bit] cv::flann::SavedIndexParams のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): flann_Ptr_SavedIndexParams_get
元DLLエクスポート名: flann_Ptr_SavedIndexParams_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_SavedIndexParams_get(
    cv::Ptr&amp;lt;cv::flann::SavedIndexParams&amp;gt; *ptr, cv::flann::SavedIndexParams **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_SavedIndexParams_delete
[32/64bit] cv::flann::SavedIndexParams のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): flann_Ptr_SavedIndexParams_delete
元DLLエクスポート名: flann_Ptr_SavedIndexParams_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_SavedIndexParams_delete(cv::Ptr&amp;lt;cv::flann::SavedIndexParams&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_SearchParams_new
[32/64bit] cv::flann::SearchParams のインスタンスを生成します
%prm
p1,p2,p3,p4
p1 = int : int checks
p2 = float : float eps
p3 = int : int sorted
p4 = var : out IntPtr returnValue
%inst



元関数名(C#): flann_Ptr_SearchParams_new
元DLLエクスポート名: flann_Ptr_SearchParams_new
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_SearchParams_new(int checks, float eps, int sorted, cv::Ptr&amp;lt;cv::flann::SearchParams&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Ptr&amp;lt;cv::flann::SearchParams&amp;gt;(new cv::flann::SearchParams(checks, eps, (sorted != 0)));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_SearchParams_get
[32/64bit] cv::flann::SearchParams のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): flann_Ptr_SearchParams_get
元DLLエクスポート名: flann_Ptr_SearchParams_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_SearchParams_get(
    cv::Ptr&amp;lt;cv::flann::SearchParams&amp;gt; *ptr, cv::flann::SearchParams **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
flann_Ptr_SearchParams_delete
[32/64bit] cv::flann::SearchParams のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): flann_Ptr_SearchParams_delete
元DLLエクスポート名: flann_Ptr_SearchParams_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_flann.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) flann_Ptr_SearchParams_delete(cv::Ptr&amp;lt;cv::flann::SearchParams&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_flann

%index
highgui_namedWindow
[32/64bit] ウィンドウを作成します．
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string winName
p2 = int : int flags
%inst
関数 namedWindow は，画像やトラックバーのプレースホルダとして利用可能なウィンドウを作成します．作成されたウィンドウは，その名前で参照されます．同じ名前のウィンドウが既に存在する場合，この関数は何もしません．ウィンドウを閉じて，関連するメモリ使用量の割り当てを解除するには， cv::destroyWindow または cv::destroyAllWindows を呼び出すことができます．NoteQt バックエンドは，次のような追加フラグをサポートしています： WINDOW_NORMAL または WINDOW_AUTOSIZE: WINDOW_NORMAL は，ウィンドウサイズを変更することができますが，WINDOW_AUTOSIZE は，表示されている画像に合わせてウィンドウサイズを自動的に調整するので（ imshow を参照してください），ウィンドウサイズを手動で変更することはできません．

WINDOW_FREERATIO または WINDOW_KEEPRATIO: WINDOW_FREERATIO は画像の比率を無視して画像を調整しますが、WINDOW_KEEPRATIO は画像の比率を維持します。

WINDOW_GUI_NORMAL または WINDOW_GUI_EXPANDED: WINDOW_GUI_NORMAL はステータスバーやツールバーのない古いウィンドウの描き方で、WINDOW_GUI_EXPANDED は新しい拡張された GUI です。デフォルトでは、flags == WINDOW_AUTOSIZE | WINDOW_KEEPRATIO | WINDOW_GUI_EXPANDEDExamples: samples/cpp/camshiftdemo.cpp, samples/cpp/connected_components.cpp, samples/cpp/contours2.cpp, samples/cpp/create_mask.cpp, samples/cpp/demhist.cpp, samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/laplace.cpp, samples/cpp/lkdemo.cpp, samples/cpp/pca.cpp, samples/cpp/polar_transforms.cpp, samples/cpp/segment_objects.cpp.cpp, samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp、samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp、samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp、samples/cpp/warpPerspective_demo.cpp、samples/cpp/watershed.cpp、samples/dnn/classification.cpp、samples/dnn/object_detection.cpp、samples/dnn/segmentation.cpp、samples/tapi/squares.cppです。

元関数名(C#): highgui_namedWindow
元DLLエクスポート名: highgui_namedWindow
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_namedWindow(const char *winname, int flags)
{
    BEGIN_WRAP
    cv::namedWindow(winname, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_destroyWindow
[32/64bit] 指定されたウィンドウを破棄します。
%prm
p1
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string winName
%inst
例: modules/shape/samples/shape_example.cpp, samples/cpp/camshiftdemo.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/grabcut.cpp.

元関数名(C#): highgui_destroyWindow
元DLLエクスポート名: highgui_destroyWindow
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_destroyWindow(const char *winName)
{
    BEGIN_WRAP
    cv::destroyWindow(winName);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_destroyAllWindows
[32/64bit] HighGUIのすべてのウィンドウを破棄します。
%prm

%inst
関数 destroyAllWindows は、開いているすべての HighGUI ウィンドウを破棄します。

元関数名(C#): highgui_destroyAllWindows
元DLLエクスポート名: highgui_destroyAllWindows
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_destroyAllWindows()
{
    BEGIN_WRAP
    cv::destroyAllWindows();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_startWindowThread
[32/64bit] highgui_startWindowThread
%prm
p1
p1 = var : out int returnValue
%inst
元関数名(C#): highgui_startWindowThread
元DLLエクスポート名: highgui_startWindowThread
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_startWindowThread(int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::startWindowThread();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_imshow
[32/64bit] 指定されたウィンドウに画像を表示します。
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string winName
p2 = sptr : IntPtr mat
%inst
関数imshowは，指定されたウィンドウに画像を表示します．cv::WINDOW_AUTOSIZE フラグを指定してウィンドウを作成した場合，画像は元のサイズで表示されますが，スクリーンの解像度によって制限されます．そうでない場合，画像はウィンドウに合わせてスケーリングされます．この関数は，画像の深度に応じて画像をスケーリングします：画像が8ビット符号なしの場合は，そのまま表示されます．

画像が8ビット符号なしの場合は，そのまま表示されます。画像が16ビット符号なしまたは32ビット整数の場合は，ピクセルが256で分割されます。つまり、[0,255*256]の値域が[0,255]にマッピングされます。

画像が32ビットまたは64ビットの浮動小数点である場合、ピクセル値は255倍されます。つまり，値の範囲 [0,1] は [0,255] にマッピングされます．OpenGL をサポートするウィンドウが作成された場合，cv::imshow は入力として ogl::Buffer , ogl::Texture2D, cuda::GpuMat もサポートします．この関数より前にウィンドウが作成されていない場合は，cv::WINDOW_AUTOSIZE でウィンドウを作成したものとみなされます．スクリーンの解像度よりも大きな画像を表示する必要がある場合は，imshowの前に namedWindow("", WINDOW_NORMAL) を呼び出す必要があります． 注意この関数は，与えられた画像を実際に表示したり，ウィンドウがマウスやキーボードのイベントに反応したりするのに必要なGUIハウスキーピングタスクを行うために，cv::waitKey または cv::pollKey の呼び出しの後に実行されるべきです．そうしないと，画像が表示されず，ウィンドウがロックしてしまうかもしれません．例えば，waitKey(0) は，任意のキーが押されるまで無限にウィンドウを表示します（画像表示に適しています）． waitKey(25) は，1 フレームを表示し，キーが押されるまで約 25 ms 待ちます（ビデオを 1 フレームごとに表示するのに適しています）．ウィンドウを削除するには，cv::destroyWindowを利用します．[Windows Backend Only] Ctrl+Cを押すと，画像をクリップボードにコピーします．[Windows Backend Only] Ctrl+Sを押すと，画像を保存するためのダイアログが表示されます．例: fld_lines.cpp, modules/shape/samples/shape_example.cpp, samples/cpp/camshiftdemo.cpp、samples/cpp/connected_components.cpp、samples/cpp/contours2.cpp、samples/cpp/convexhull.cpp、samples/cpp/create_mask.cpp、samples/cpp/demhist.cpp、samples/cpp/distrans.cpp、samples/cpp/edge.cpp、samples/cpp/facedetect.cpp、samples/cpp/falecolor.cpp、samples/cpp/ffilldemo.cpp、samples/cpp/fitellipse.cpp。cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/intersectExample.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp, samples/cpp/laplace.cpp, samples/cpp/lkdemo.cpp, samples/cpp/minarea.cpp, samples/cpp/pca.cpp, samples/cpp/peopledetect.cpp, samples/cpp/polar_transforms.cpp, samples/cpp/segment_objects.cpp, samples/cpp/squares.cpp, samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/cpp/videowriter_basic.cpp、samples/cpp/warpPerspective_demo.cpp、samples/cpp/watershed.cpp、samples/dnn/classification.cpp、samples/dnn/colorization.cpp、samples/dnn/object_detection.cpp、samples/dnn/openpose.cpp、samples/dnn/segmentation.cpp、samples/dnn/text_detection.cpp、samples/tapi/hog.cpp、samples/tapi/squares.cppです。

元関数名(C#): highgui_imshow
元DLLエクスポート名: highgui_imshow
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_imshow(const char *winname, cv::Mat *mat)
{
    BEGIN_WRAP
    cv::imshow(winname, *mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_imshow_umat
[32/64bit] 指定されたウィンドウに画像を表示します。
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string winName
p2 = sptr : IntPtr mat
%inst
関数imshowは，指定されたウィンドウに画像を表示します．cv::WINDOW_AUTOSIZE フラグを指定してウィンドウを作成した場合，画像は元のサイズで表示されますが，スクリーンの解像度によって制限されます．そうでない場合，画像はウィンドウに合わせてスケーリングされます．この関数は，画像の深度に応じて画像をスケーリングします：画像が8ビット符号なしの場合は，そのまま表示されます．

画像が8ビット符号なしの場合は，そのまま表示されます。画像が16ビット符号なしまたは32ビット整数の場合は，ピクセルが256で分割されます。つまり、[0,255*256]の値域が[0,255]にマッピングされます。

画像が32ビットまたは64ビットの浮動小数点である場合、ピクセル値は255倍されます。つまり，値の範囲 [0,1] は [0,255] にマッピングされます．OpenGL をサポートするウィンドウが作成された場合，cv::imshow は入力として ogl::Buffer , ogl::Texture2D, cuda::GpuMat もサポートします．この関数より前にウィンドウが作成されていない場合は，cv::WINDOW_AUTOSIZE でウィンドウを作成したものとみなされます．スクリーンの解像度よりも大きな画像を表示する必要がある場合は，imshowの前に namedWindow("", WINDOW_NORMAL) を呼び出す必要があります． 注意この関数は，与えられた画像を実際に表示したり，ウィンドウがマウスやキーボードのイベントに反応したりするのに必要なGUIハウスキーピングタスクを行うために，cv::waitKey または cv::pollKey の呼び出しの後に実行されるべきです．そうしないと，画像が表示されず，ウィンドウがロックしてしまうかもしれません．例えば，waitKey(0) は，任意のキーが押されるまで無限にウィンドウを表示します（画像表示に適しています）． waitKey(25) は，1 フレームを表示し，キーが押されるまで約 25 ms 待ちます（ビデオを 1 フレームごとに表示するのに適しています）．ウィンドウを削除するには，cv::destroyWindowを利用します．[Windows Backend Only] Ctrl+Cを押すと，画像をクリップボードにコピーします．[Windows Backend Only] Ctrl+Sを押すと，画像を保存するためのダイアログが表示されます．例: fld_lines.cpp, modules/shape/samples/shape_example.cpp, samples/cpp/camshiftdemo.cpp、samples/cpp/connected_components.cpp、samples/cpp/contours2.cpp、samples/cpp/convexhull.cpp、samples/cpp/create_mask.cpp、samples/cpp/demhist.cpp、samples/cpp/distrans.cpp、samples/cpp/edge.cpp、samples/cpp/facedetect.cpp、samples/cpp/falecolor.cpp、samples/cpp/ffilldemo.cpp、samples/cpp/fitellipse.cpp。cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/intersectExample.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp, samples/cpp/laplace.cpp, samples/cpp/lkdemo.cpp, samples/cpp/minarea.cpp, samples/cpp/pca.cpp, samples/cpp/peopledetect.cpp, samples/cpp/polar_transforms.cpp, samples/cpp/segment_objects.cpp, samples/cpp/squares.cpp, samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/cpp/videowriter_basic.cpp、samples/cpp/warpPerspective_demo.cpp、samples/cpp/watershed.cpp、samples/dnn/classification.cpp、samples/dnn/colorization.cpp、samples/dnn/object_detection.cpp、samples/dnn/openpose.cpp、samples/dnn/segmentation.cpp、samples/dnn/text_detection.cpp、samples/tapi/hog.cpp、samples/tapi/squares.cppです。

元関数名(C#): highgui_imshow_umat
元DLLエクスポート名: highgui_imshow_umat
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_imshow_umat(const char* winname, cv::UMat* mat)
{
    BEGIN_WRAP
        cv::imshow(winname, *mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_waitKey
[32/64bit] waitKeyと似ていますが、完全なキーコードを返します。
%prm
p1,p2
p1 = int : int delay
p2 = var : out int returnValue
%inst
NoteKeyのコードは実装によって異なり、使用するバックエンドに依存します。QT/GTK/Win32/その他

元関数名(C#): highgui_waitKey
元DLLエクスポート名: highgui_waitKey
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_waitKeyEx(int delay, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::waitKeyEx(delay);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_waitKeyEx
[32/64bit] waitKeyと似ていますが、完全なキーコードを返します。
%prm
p1,p2
p1 = int : int delay
p2 = var : out int returnValue
%inst
NoteKeyのコードは実装によって異なり、使用するバックエンドに依存します。QT/GTK/Win32/その他

元関数名(C#): highgui_waitKeyEx
元DLLエクスポート名: highgui_waitKeyEx
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_waitKeyEx(int delay, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::waitKeyEx(delay);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_resizeWindow
[32/64bit] 指定されたサイズにウィンドウをリサイズします。
%prm
p1,p2,p3
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string winName
p2 = int : int width
p3 = int : int height
%inst
注意：指定されたウィンドウサイズは画像領域のサイズです。ツールバーはカウントされません．

cv::WINDOW_AUTOSIZE フラグを持たずに作成されたウィンドウだけが，リサイズ可能です．

元関数名(C#): highgui_resizeWindow
元DLLエクスポート名: highgui_resizeWindow
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_resizeWindow(const char *winName, int width, int height)
{
    BEGIN_WRAP
    cv::resizeWindow(winName, width, height);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_moveWindow
[32/64bit] ウィンドウを指定された位置に移動させます．
%prm
p1,p2,p3
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string winName
p2 = int : int x
p3 = int : int y
%inst
例: modules/shape/samples/shape_example.cpp、samples/cpp/image_alignment.cpp、samples/cpp/polar_transforms.cpp、samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp、samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp、samples/cpp/warpPerspective_demo.cpp.

元関数名(C#): highgui_moveWindow
元DLLエクスポート名: highgui_moveWindow
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_moveWindow(const char *winName, int x, int y)
{
    BEGIN_WRAP
    cv::moveWindow(winName, x, y);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_setWindowProperty
[32/64bit] ウィンドウのパラメータを動的に変更します。
%prm
p1,p2,p3
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string winName
p2 = int : int propId
p3 = double : double propValue
%inst
関数 setWindowProperty は，ウィンドウのプロパティを変更することができます．

元関数名(C#): highgui_setWindowProperty
元DLLエクスポート名: highgui_setWindowProperty
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_setWindowProperty(const char *winName, int propId, double propValue)
{
    BEGIN_WRAP
    cv::setWindowProperty(winName, propId, propValue);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_setWindowTitle
[32/64bit] ウィンドウのタイトルを更新します．
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string winName
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string title
%inst
元関数名(C#): highgui_setWindowTitle
元DLLエクスポート名: highgui_setWindowTitle
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_setWindowTitle(const char *winname, const char *title)
{
    BEGIN_WRAP
    // TODO Resolve:
#ifndef _WINRT_DLL
    cv::setWindowTitle(winname, title);
#endif
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_getWindowProperty
[32/64bit] ウィンドウのパラメータを提供します．
%prm
p1,p2,p3
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string winName
p2 = int : int propId
p3 = var : out double returnValue
%inst
関数 getWindowProperty は，ウィンドウのプロパティを返します．

元関数名(C#): highgui_getWindowProperty
元DLLエクスポート名: highgui_getWindowProperty
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_getWindowProperty(const char *winName, int propId, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::getWindowProperty(winName, propId);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_getWindowImageRect
[32/64bit] ウィンドウ内の画像の矩形領域を提供します．
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string winName
p2 = var : out Rect returnValue
%inst
関数 getWindowImageRectは、イメージのレンダリング領域のクライアント スクリーン座標、幅、高さを返します。

元関数名(C#): highgui_getWindowImageRect
元DLLエクスポート名: highgui_getWindowImageRect
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_getWindowImageRect(const char *winName, MyCvRect *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(cv::getWindowImageRect(winName));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_setMouseCallback
[32/64bit] 指定されたウィンドウのマウス ハンドラを設定します。
%prm
p1,p2,p3
p1 = str : string winName
p2 = sptr : [MarshalAs(UnmanagedType.FunctionPtr)] MouseCallback onMouse
p3 = sptr : IntPtr userData
%inst
例： samples/cpp/camshiftdemo.cpp，samples/cpp/create_mask.cpp，samples/cpp/ffilldemo.cpp，samples/cpp/grabcut.cpp，samples/cpp/lkdemo.cpp，samples/cpp/warpPerspective_demo.cpp，samples/cpp/watershed.cpp．

元関数名(C#): highgui_setMouseCallback
元DLLエクスポート名: highgui_setMouseCallback
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_setMouseCallback(const char *winName, cv::MouseCallback onMouse, void* userData)
{
    BEGIN_WRAP
    cv::setMouseCallback(winName, onMouse, userData);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_getMouseWheelDelta
[32/64bit] マウスホイールイベント cv::EVENT_MOUSEWHEEL と cv::EVENT_MOUSEHWHEEL を扱う際に，マウスホイールの動きのデルタ値を取得します．
%prm
p1,p2
p1 = int : int flags
p2 = var : out int returnValue
%inst
スクロールホイールを備えた通常のマウスでは，delta は 120 の倍数になります．値120は，ホイールの1ノッチ回転に相当し，アクションを起こすための閾値となり，deltaごとに1つのアクションが発生します．cv::EVENT_MOUSEWHEEL において，正の値は前方へのスクロールを，負の値は後方へのスクロールを意味します．cv::EVENT_MOUSEHWHEEL では，正と負の値は，それぞれ前方と後方へのスクロールを意味し，正と負の値は，それぞれ右と左へのスクロールを意味する．

元関数名(C#): highgui_getMouseWheelDelta
元DLLエクスポート名: highgui_getMouseWheelDelta
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_getMouseWheelDelta(int flags, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::getMouseWheelDelta(flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_selectROI1
[32/64bit] 与えられた画像上の ROI を選択することができる．
%prm
p1,p2,p3,p4,p5
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string windowName
p2 = sptr : IntPtr img
p3 = int : int showCrosshair
p4 = int : int fromCenter
p5 = var : out Rect returnValue
%inst
この関数は、ウィンドウを作成し、ユーザがマウスを使ってROIを選択できるようにします。コントロール：選択を終了するには，Space または Enter キーを利用し，選択をキャンセルするには，c キーを利用します（この関数は，ゼロの cv::Rect を返します）．注意この関数は，cv::setMouseCallback(windowName, ...)を用いて，指定されたウィンドウに対する独自のマウスコールバックを設定します．作業終了後は，使用されたウィンドウに対して空のコールバックがセットされます．

元関数名(C#): highgui_selectROI1
元DLLエクスポート名: highgui_selectROI1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_selectROI1(const char *windowName, cv::_InputArray *img, int showCrosshair, int fromCenter, MyCvRect *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(cv::selectROI(windowName, *img, showCrosshair != 0, fromCenter != 0));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_selectROI2
[32/64bit] 与えられた画像上の ROI を選択することができる．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr img
p2 = int : int showCrosshair
p3 = int : int fromCenter
p4 = var : out Rect returnValue
%inst
この関数は、ウィンドウを作成し、ユーザがマウスを使ってROIを選択できるようにします。コントロール：選択を終了するには，Space または Enter キーを利用し，選択をキャンセルするには，c キーを利用します（この関数は，ゼロの cv::Rect を返します）．注意この関数は，cv::setMouseCallback(windowName, ...)を用いて，指定されたウィンドウに対する独自のマウスコールバックを設定します．作業終了後は，使用されたウィンドウに対して空のコールバックがセットされます．

元関数名(C#): highgui_selectROI2
元DLLエクスポート名: highgui_selectROI2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_selectROI2(cv::_InputArray *img, int showCrosshair, int fromCenter, MyCvRect *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(cv::selectROI(*img, showCrosshair != 0, fromCenter != 0));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_selectROIs
[32/64bit] ユーザは，与えられた画像上の複数のROIを選択することができます．
%prm
p1,p2,p3,p4,p5
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string windowName
p2 = sptr : IntPtr img
p3 = sptr : IntPtr boundingBoxes
p4 = int : int showCrosshair
p5 = int : int fromCenter
%inst
この関数は，ウィンドウを作成し，ユーザがマウスを使って複数のROIを選択できるようにします．注意この関数は，cv::setMouseCallback(windowName, ...)を用いて，指定されたウィンドウに対する独自のマウスコールバックを設定します．作業終了後は，使用されたウィンドウに対して空のコールバックがセットされます．

元関数名(C#): highgui_selectROIs
元DLLエクスポート名: highgui_selectROIs
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_selectROIs(const char * windowName, cv::_InputArray *img,
                             std::vector&amp;lt;cv::Rect&amp;gt; *boundingBoxes, int showCrosshair, int fromCenter)
{
    BEGIN_WRAP
    cv::selectROIs(windowName, *img, *boundingBoxes, showCrosshair != 0, fromCenter != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_createTrackbar
[32/64bit] トラックバーを作成して，指定されたウィンドウに取り付けます．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string trackbarName
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string winName
p3 = sptr : IntPtr value
p4 = int : int count
p5 = sptr : IntPtr onChange
p6 = sptr : IntPtr userData
p7 = var : out int returnValue
%inst
関数 createTrackbar は、指定された名前と範囲のトラックバー（スライダやレンジコントロール）を作成し、トラックバーと同期した位置となる変数値を割り当て、トラックバーの位置変更時に呼び出されるコールバック関数 onChange を指定します。各トラックバーのラベルをクリックすると，トラックバーの値を手動で編集することができます．例：samples/cpp/camshiftdemo.cpp，samples/cpp/connected_components.cpp，samples/cpp/contours2.cpp，samples/cpp/demhist.cpp，samples/cpp/distrans.cpp，samples/cpp/edge.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/fitellipse.cpp, samples/cpp/laplace.cpp, samples/cpp/pca.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp、samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp、samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp、samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp、samples/dnn/object_detection.cpp。

元関数名(C#): highgui_createTrackbar
元DLLエクスポート名: highgui_createTrackbar
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_createTrackbar(const char *trackbarName, const char *winName,
    int* value, int count, cv::TrackbarCallback onChange, void* userData, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::createTrackbar(trackbarName, winName, value, count, onChange, userData);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_getTrackbarPos
[32/64bit] トラックバーの位置を返す。
%prm
p1,p2,p3
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string trackbarName
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string winName
p3 = var : out int returnValue
%inst
注意[Qt Backend Only] トラックバーがコントロールパネルに取り付けられている場合、winnameは空にすることができます。

元関数名(C#): highgui_getTrackbarPos
元DLLエクスポート名: highgui_getTrackbarPos
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_getTrackbarPos(const char *trackbarName, const char *winName, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::getTrackbarPos(trackbarName, winName);
    END_WRAP  
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_setTrackbarPos
[32/64bit] トラックバーの位置を設定します。
%prm
p1,p2,p3
p1 = str : string trackbarName
p2 = str : string winName
p3 = int : int pos
%inst
注意[Qt Backend Only] トラックバーがコントロールパネルに取り付けられている場合、winnameは空にすることができます。例: samples/cpp/falecolor.cpp.

元関数名(C#): highgui_setTrackbarPos
元DLLエクスポート名: highgui_setTrackbarPos
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_setTrackbarPos(const char *trackbarName, const char *winName, int pos)
{
    BEGIN_WRAP
    cv::setTrackbarPos(trackbarName, winName, pos);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_setTrackbarMax
[32/64bit] トラックバーの最大位置を設定します。
%prm
p1,p2,p3
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string trackbarName
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string winName
p3 = int : int maxVal
%inst
注意[Qt Backend Only] トラックバーがコントロールパネルに取り付けられている場合、winnameは空にすることができます.例: samples/cpp/falecolor.cpp.

元関数名(C#): highgui_setTrackbarMax
元DLLエクスポート名: highgui_setTrackbarMax
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_setTrackbarMax(const char *trackbarName, const char *winName, int maxVal)
{
    BEGIN_WRAP
    cv::setTrackbarMax(trackbarName, winName, maxVal);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_setTrackbarMin
[32/64bit] トラックバーの最小位置を設定します。
%prm
p1,p2,p3
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string trackbarName
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string winName
p3 = int : int minVal
%inst
注意[Qt Backend Only] トラックバーがコントロールパネルに装着されている場合、winnameは空にすることができます.例: samples/cpp/falecolor.cpp.

元関数名(C#): highgui_setTrackbarMin
元DLLエクスポート名: highgui_setTrackbarMin
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_setTrackbarMin(const char *trackbarName, const char *winName, int minVal)
{
    BEGIN_WRAP
    cv::setTrackbarMin(trackbarName, winName, minVal);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_highgui

%index
highgui_cvGetWindowHandle
[32/64bit] highgui_cvGetWindowHandle
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string name
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): highgui_cvGetWindowHandle
元DLLエクスポート名: highgui_cvGetWindowHandle
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_highgui.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) highgui_cvGetWindowHandle(const char* name, void **returnValue)
{
    BEGIN_WRAP
    *returnValue = cvGetWindowHandle(name);
    END_WRAP    
}

</pre>
}html
%group
NativeMethods_highgui

%index
imgcodecs_imread_NotWindows
[32/64bit] ファイルから画像を読み込みます。
%prm
p1,p2,p3
p1 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string fileName
p2 = int : int flags
p3 = var : out IntPtr returnValue
%inst
関数 imread は，指定されたファイルから画像を読み込み，それを返します．画像が読み込めない場合（ファイルが存在しない，不適切なパーミッション，サポートされていない，あるいは無効なフォーマットのため），この関数は空の行列（ Mat::data==NULL ）を返します．

JPEGファイル - *.jpeg, *.jpg, *.jpe (Noteセクションを参照)

JPEG 2000ファイル - *.jp2 (注意事項を参照)

ポータブルネットワークグラフィックス - *.png (注釈欄参照)

WebP - *.webp（注釈欄参照）

ポータブルイメージフォーマット - *.pbm, *.pgm, *.ppm *.pxm, *.pnm (常時サポート)

PFMファイル - *.pfm (Noteセクションを参照)

太陽ラスタ - *.sr, *.ras (常にサポートされています)

TIFFファイル - *.tiff, *.tif (Noteセクションを参照)

OpenEXR画像ファイル - *.exr (注釈欄参照)

Radiance HDR - *.hdr, *.pic (常時サポート)

GDALでサポートされているラスターおよびベクターの地理空間データ（注釈セクションを参照）注釈

本機能では、拡張子ではなく、画像の内容で画像の種類を判断します。

カラー画像の場合、デコードされた画像はB G Rの順にチャンネルが格納されます。

IMREAD_GRAYSCALE を使用した場合，コーデック内部のグレースケール変換が可能であれば，それが使用されます。結果は cvtColor() の出力と異なる場合があります。

Microsoft Windows* OSやMacOSX*では，OpenCVの画像に同梱されているコーデック（libjpeg, libpng, libtiff, libjasper）がデフォルトで利用されます．そのため，OpenCV は常に JPEG, PNG, TIFF を読み込むことができます．MacOSXでは，MacOSXのネイティブな画像リーダを利用するオプションもあります．しかし，現在のところ，MacOSXに組み込まれたカラーマネージメントのために，これらのネイティブ画像ローダは，異なるピクセル値の画像を与えることに注意してください．

Linux*，BSDフレーバー，その他のUnix系オープンソースOSでは，OpenCVはOSイメージに含まれるコーデックを探します．コーデックをサポートするために，関連するパッケージ（Debian* や Ubuntu* では，"libjpeg-dev" のような開発ファイルも忘れないでください）をインストールするか，CMake で OPENCV_BUILD_3RDPARTY_LIBS フラグをオンにしてください．

CMakeでWITH_GDALフラグをtrueに設定し、IMREAD_LOAD_GDALで画像をロードした場合、画像をデコードするためにGDALドライバが使用され、以下のフォーマットをサポートします。ラスター、ベクター。

画像ファイルにEXIF情報が埋め込まれている場合、EXIFの向きが考慮され、フラグIMREAD_IGNORE_ORIENTATIONまたはIMREAD_UNCHANGEDが渡される場合を除き、それに応じて画像が回転します。

PFM画像から浮動小数点値を保持するためには、IMREAD_UNCHANGEDフラグを使用する。

デフォルトでは、ピクセル数は2^30以下でなければなりません。システム変数OPENCV_IO_MAX_IMAGE_PIXELSEで設定できます。サンプル：fld_lines.cpp, modules/shape/samples/shape_example.cpp, samples/cpp/connected_components.cpp, samples/cpp/create_mask.cpp, samples/cpp/demhist.cpp, samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/pca.cpp, samples/cpp/squares.cpp, samples/cpp/stitching.cpp, samples/cpp/stitching_detailed.cpp, samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp、samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp、samples/cpp/warpPerspective_demo.cpp、samples/cpp/watershed.cpp、samples/dnn/colorization.cpp、samples/dnn/openpose.cpp、samples/tapi/hog.cpp、samples/tapi/squares.cppです。

元関数名(C#): imgcodecs_imread_NotWindows
元DLLエクスポート名: imgcodecs_imread
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_imgcodecs.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgcodecs_imread(const char *filename, int flags, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::imread(filename, flags);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgcodecs

%index
imgcodecs_imread_Windows
[32/64bit] ファイルから画像を読み込みます。
%prm
p1,p2,p3
p1 = str : [MarshalAs(StringUnmanagedTypeWindows)] string fileName
p2 = int : int flags
p3 = var : out IntPtr returnValue
%inst
関数 imread は，指定されたファイルから画像を読み込み，それを返します．画像が読み込めない場合（ファイルが存在しない，不適切なパーミッション，サポートされていない，あるいは無効なフォーマットのため），この関数は空の行列（ Mat::data==NULL ）を返します．

JPEGファイル - *.jpeg, *.jpg, *.jpe (Noteセクションを参照)

JPEG 2000ファイル - *.jp2 (注意事項を参照)

ポータブルネットワークグラフィックス - *.png (注釈欄参照)

WebP - *.webp（注釈欄参照）

ポータブルイメージフォーマット - *.pbm, *.pgm, *.ppm *.pxm, *.pnm (常時サポート)

PFMファイル - *.pfm (Noteセクションを参照)

太陽ラスタ - *.sr, *.ras (常にサポートされています)

TIFFファイル - *.tiff, *.tif (Noteセクションを参照)

OpenEXR画像ファイル - *.exr (注釈欄参照)

Radiance HDR - *.hdr, *.pic (常時サポート)

GDALでサポートされているラスターおよびベクターの地理空間データ（注釈セクションを参照）注釈

本機能では、拡張子ではなく、画像の内容で画像の種類を判断します。

カラー画像の場合、デコードされた画像はB G Rの順にチャンネルが格納されます。

IMREAD_GRAYSCALE を使用した場合，コーデック内部のグレースケール変換が可能であれば，それが使用されます。結果は cvtColor() の出力と異なる場合があります。

Microsoft Windows* OSやMacOSX*では，OpenCVの画像に同梱されているコーデック（libjpeg, libpng, libtiff, libjasper）がデフォルトで利用されます．そのため，OpenCV は常に JPEG, PNG, TIFF を読み込むことができます．MacOSXでは，MacOSXのネイティブな画像リーダを利用するオプションもあります．しかし，現在のところ，MacOSXに組み込まれたカラーマネージメントのために，これらのネイティブ画像ローダは，異なるピクセル値の画像を与えることに注意してください．

Linux*，BSDフレーバー，その他のUnix系オープンソースOSでは，OpenCVはOSイメージに含まれるコーデックを探します．コーデックをサポートするために，関連するパッケージ（Debian* や Ubuntu* では，"libjpeg-dev" のような開発ファイルも忘れないでください）をインストールするか，CMake で OPENCV_BUILD_3RDPARTY_LIBS フラグをオンにしてください．

CMakeでWITH_GDALフラグをtrueに設定し、IMREAD_LOAD_GDALで画像をロードした場合、画像をデコードするためにGDALドライバが使用され、以下のフォーマットをサポートします。ラスター、ベクター。

画像ファイルにEXIF情報が埋め込まれている場合、EXIFの向きが考慮され、フラグIMREAD_IGNORE_ORIENTATIONまたはIMREAD_UNCHANGEDが渡される場合を除き、それに応じて画像が回転します。

PFM画像から浮動小数点値を保持するためには、IMREAD_UNCHANGEDフラグを使用する。

デフォルトでは、ピクセル数は2^30以下でなければなりません。システム変数OPENCV_IO_MAX_IMAGE_PIXELSEで設定できます。サンプル：fld_lines.cpp, modules/shape/samples/shape_example.cpp, samples/cpp/connected_components.cpp, samples/cpp/create_mask.cpp, samples/cpp/demhist.cpp, samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/pca.cpp, samples/cpp/squares.cpp, samples/cpp/stitching.cpp, samples/cpp/stitching_detailed.cpp, samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp、samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp、samples/cpp/warpPerspective_demo.cpp、samples/cpp/watershed.cpp、samples/dnn/colorization.cpp、samples/dnn/openpose.cpp、samples/tapi/hog.cpp、samples/tapi/squares.cppです。

元関数名(C#): imgcodecs_imread_Windows
元DLLエクスポート名: imgcodecs_imread
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_imgcodecs.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgcodecs_imread(const char *filename, int flags, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::imread(filename, flags);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgcodecs

%index
imgcodecs_imreadmulti_NotWindows
[32/64bit] 複数ページの画像をファイルから読み込みます。
%prm
p1,p2,p3,p4
p1 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string fileName
p2 = sptr : IntPtr mats
p3 = int : int flags
p4 = var : out int returnValue
%inst
関数 imreadmulti は，複数ページにわたる画像を指定されたファイルから Mat オブジェクトのベクトルに読み込みます．

元関数名(C#): imgcodecs_imreadmulti_NotWindows
元DLLエクスポート名: imgcodecs_imreadmulti
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_imgcodecs.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgcodecs_imreadmulti(const char *filename, std::vector&amp;lt;cv::Mat&amp;gt; *mats, int flags, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::imreadmulti(filename, *mats, flags) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgcodecs

%index
imgcodecs_imreadmulti_Windows
[32/64bit] 複数ページの画像をファイルから読み込みます。
%prm
p1,p2,p3,p4
p1 = str : [MarshalAs(StringUnmanagedTypeWindows)] string fileName
p2 = sptr : IntPtr mats
p3 = int : int flags
p4 = var : out int returnValue
%inst
関数 imreadmulti は，複数ページにわたる画像を指定されたファイルから Mat オブジェクトのベクトルに読み込みます．

元関数名(C#): imgcodecs_imreadmulti_Windows
元DLLエクスポート名: imgcodecs_imreadmulti
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_imgcodecs.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgcodecs_imreadmulti(const char *filename, std::vector&amp;lt;cv::Mat&amp;gt; *mats, int flags, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::imreadmulti(filename, *mats, flags) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgcodecs

%index
imgcodecs_imwrite_NotWindows
[32/64bit] 画像を指定されたファイルに保存します．
%prm
p1,p2,p3,p4,p5
p1 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string fileName
p2 = sptr : IntPtr img
p3 = var : [In] int[] @params
p4 = int : int paramsLength
p5 = var : out int returnValue
%inst
関数 imwrite は，画像を指定されたファイルに保存します．画像フォーマットは，ファイル名の拡張子に基づいて選択されます（拡張子のリストについては cv::imread を参照してください）．一般に，この関数を用いて保存できるのは，8ビットのシングルチャンネルまたは3チャンネル（チャンネル順序は 'BGR' ）の画像のみですが，以下のような例外があります： 16ビット符号なし（CV_16U）の画像は，PNG, JPEG 2000, TIFF フォーマットの場合に保存できます．

32ビット浮動小数点（CV_32F）画像は，PFM, TIFF, OpenEXR, Radiance HDR 形式で保存できます．3チャンネル（CV_32FC3）TIFF 画像は，LogLuv ハイダイナミックレンジエンコーディング（1ピクセルあたり4バイト）で保存されます．

アルファチャンネル付きのPNG画像もこの機能を使って保存できます。これを行うには，8ビット（あるいは16ビット）の4チャンネル画像BGRAを作成し，アルファチャンネルを最後に置きます。完全に透明なピクセルは，アルファを 0 に，完全に不透明なピクセルは，アルファを 255/65535 に設定する必要があります（以下のコードサンプルを参照してください）．

複数の画像（Mat のベクトル）は，TIFF 形式で保存することができます（以下のコードサンプルを参照してください）．画像フォーマットがサポートされていない場合，画像は 8 ビット符号なし（CV_8U）に変換され，そのように保存されます．フォーマット，ビット深度，チャンネル順序が異なる場合は， Mat::convertTo や cv::cvtColor を用いて，保存前に変換してください．あるいは，汎用の FileStorage I/O 関数を利用して，画像を XML や YAML 形式で保存します．以下のサンプルでは，BGRA 画像の作成方法，カスタム圧縮パラメータの設定方法，PNG ファイルへの保存方法を示しています．以下のサンプルは，BGRA 画像を作成し，カスタム圧縮パラメータを設定して PNG ファイルに保存する方法と，複数の画像を 1 つの TIFF ファイルに保存する方法を示しています： #include <opencv2/imgcodecs.hpp>using namespace cv;using namespace std;static void paintAlphaMat(Mat &mat){ CV_Assert(mat.channels() == 4); for (int i = 0; i < mat.rows; ++i) { for (int j = 0; j < mat.cols; ++j) { Vec4b& bgra = mat.at<Vec4b>(i, j); bgra[0] = UCHAR_MAX; // 青 bgra[1] = saturate_cast<uchar>((float (mat.cols - j)) / ((float)mat.cols./ ((float)mat.cols) * UCHAR_MAX); // 緑 bgra[2] = saturate_cast<uchar>((float (mat.rows - i))/ ((float)mat.rows) * UCHAR_MAX); // 赤 bgra[3] = saturate_cast<uchar>(0.5 * (bgra[1] + bgra[2])); // α }。    }}int main(){ Mat mat(480, 640, CV_8UC4); // アルファチャンネルを持つ行列を作成 paintAlphaMat(mat); vector<int> compression_params; compression_params.push_back(IMWRITE_PNG_COMPRESSION); compression_params.push_back(9); bool result = false; try { result = imwrite("alpha.png", mat, compression_params); } catch (const cv::Exception& ex) { fprintf(stderr, "Exception converting image to PNG format: %s\n", ex.what()); } if (result) printf("Saved PNG file with alpha data.\\"); else printf("ERROR: Can't save PNG file.\\"); vector<Mat> imgs; imgs.push_back(mat); imgs.push_back(~mat); imgs.push_back(mat(Rect(0, 0, mat.cols / 2, mat.rows / 2))); imwrite("test.tiff", imgs); printf("Multiple files saved in test.tiff\n"); return result ?0 : 1;}fragmentExamples: samples/cpp/image_alignment.cpp, samples/cpp/stitching.cpp, samples/cpp/stitching_detailed.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/tapi/hog.cpp, samples/tapi/squares.cpp.

元関数名(C#): imgcodecs_imwrite_NotWindows
元DLLエクスポート名: imgcodecs_imwrite
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_imgcodecs.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgcodecs_imwrite(const char *filename, cv::Mat *img, int *params, int paramsLength, int *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;int&amp;gt; paramsVec;
    paramsVec.assign(params, params + paramsLength);
    *returnValue = cv::imwrite(filename, *img, paramsVec) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgcodecs

%index
imgcodecs_imwrite_Windows
[32/64bit] 画像を指定されたファイルに保存します．
%prm
p1,p2,p3,p4,p5
p1 = str : [MarshalAs(StringUnmanagedTypeWindows)] string fileName
p2 = sptr : IntPtr img
p3 = var : [In] int[] @params
p4 = int : int paramsLength
p5 = var : out int returnValue
%inst
関数 imwrite は，画像を指定されたファイルに保存します．画像フォーマットは，ファイル名の拡張子に基づいて選択されます（拡張子のリストについては cv::imread を参照してください）．一般に，この関数を用いて保存できるのは，8ビットのシングルチャンネルまたは3チャンネル（チャンネル順序は 'BGR' ）の画像のみですが，以下のような例外があります： 16ビット符号なし（CV_16U）の画像は，PNG, JPEG 2000, TIFF フォーマットの場合に保存できます．

32ビット浮動小数点（CV_32F）画像は，PFM, TIFF, OpenEXR, Radiance HDR 形式で保存できます．3チャンネル（CV_32FC3）TIFF 画像は，LogLuv ハイダイナミックレンジエンコーディング（1ピクセルあたり4バイト）で保存されます．

アルファチャンネル付きのPNG画像もこの機能を使って保存できます。これを行うには，8ビット（あるいは16ビット）の4チャンネル画像BGRAを作成し，アルファチャンネルを最後に置きます。完全に透明なピクセルは，アルファを 0 に，完全に不透明なピクセルは，アルファを 255/65535 に設定する必要があります（以下のコードサンプルを参照してください）．

複数の画像（Mat のベクトル）は，TIFF 形式で保存することができます（以下のコードサンプルを参照してください）．画像フォーマットがサポートされていない場合，画像は 8 ビット符号なし（CV_8U）に変換され，そのように保存されます．フォーマット，ビット深度，チャンネル順序が異なる場合は， Mat::convertTo や cv::cvtColor を用いて，保存前に変換してください．あるいは，汎用の FileStorage I/O 関数を利用して，画像を XML や YAML 形式で保存します．以下のサンプルでは，BGRA 画像の作成方法，カスタム圧縮パラメータの設定方法，PNG ファイルへの保存方法を示しています．以下のサンプルは，BGRA 画像を作成し，カスタム圧縮パラメータを設定して PNG ファイルに保存する方法と，複数の画像を 1 つの TIFF ファイルに保存する方法を示しています： #include <opencv2/imgcodecs.hpp>using namespace cv;using namespace std;static void paintAlphaMat(Mat &mat){ CV_Assert(mat.channels() == 4); for (int i = 0; i < mat.rows; ++i) { for (int j = 0; j < mat.cols; ++j) { Vec4b& bgra = mat.at<Vec4b>(i, j); bgra[0] = UCHAR_MAX; // 青 bgra[1] = saturate_cast<uchar>((float (mat.cols - j)) / ((float)mat.cols./ ((float)mat.cols) * UCHAR_MAX); // 緑 bgra[2] = saturate_cast<uchar>((float (mat.rows - i))/ ((float)mat.rows) * UCHAR_MAX); // 赤 bgra[3] = saturate_cast<uchar>(0.5 * (bgra[1] + bgra[2])); // α }。    }}int main(){ Mat mat(480, 640, CV_8UC4); // アルファチャンネルを持つ行列を作成 paintAlphaMat(mat); vector<int> compression_params; compression_params.push_back(IMWRITE_PNG_COMPRESSION); compression_params.push_back(9); bool result = false; try { result = imwrite("alpha.png", mat, compression_params); } catch (const cv::Exception& ex) { fprintf(stderr, "Exception converting image to PNG format: %s\n", ex.what()); } if (result) printf("Saved PNG file with alpha data.\\"); else printf("ERROR: Can't save PNG file.\\"); vector<Mat> imgs; imgs.push_back(mat); imgs.push_back(~mat); imgs.push_back(mat(Rect(0, 0, mat.cols / 2, mat.rows / 2))); imwrite("test.tiff", imgs); printf("Multiple files saved in test.tiff\n"); return result ?0 : 1;}fragmentExamples: samples/cpp/image_alignment.cpp, samples/cpp/stitching.cpp, samples/cpp/stitching_detailed.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/tapi/hog.cpp, samples/tapi/squares.cpp.

元関数名(C#): imgcodecs_imwrite_Windows
元DLLエクスポート名: imgcodecs_imwrite
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_imgcodecs.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgcodecs_imwrite(const char *filename, cv::Mat *img, int *params, int paramsLength, int *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;int&amp;gt; paramsVec;
    paramsVec.assign(params, params + paramsLength);
    *returnValue = cv::imwrite(filename, *img, paramsVec) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgcodecs

%index
imgcodecs_imwrite_multi_NotWindows
[32/64bit] 画像を指定されたファイルに保存します．
%prm
p1,p2,p3,p4,p5
p1 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string fileName
p2 = sptr : IntPtr img
p3 = var : [In] int[] @params
p4 = int : int paramsLength
p5 = var : out int returnValue
%inst
関数 imwrite は，画像を指定されたファイルに保存します．画像フォーマットは，ファイル名の拡張子に基づいて選択されます（拡張子のリストについては cv::imread を参照してください）．一般に，この関数を用いて保存できるのは，8ビットのシングルチャンネルまたは3チャンネル（チャンネル順序は 'BGR' ）の画像のみですが，以下のような例外があります： 16ビット符号なし（CV_16U）の画像は，PNG, JPEG 2000, TIFF フォーマットの場合に保存できます．

32ビット浮動小数点（CV_32F）画像は，PFM, TIFF, OpenEXR, Radiance HDR 形式で保存できます．3チャンネル（CV_32FC3）TIFF 画像は，LogLuv ハイダイナミックレンジエンコーディング（1ピクセルあたり4バイト）で保存されます．

アルファチャンネル付きのPNG画像もこの機能を使って保存できます。これを行うには，8ビット（あるいは16ビット）の4チャンネル画像BGRAを作成し，アルファチャンネルを最後に置きます。完全に透明なピクセルは，アルファを 0 に，完全に不透明なピクセルは，アルファを 255/65535 に設定する必要があります（以下のコードサンプルを参照してください）．

複数の画像（Mat のベクトル）は，TIFF 形式で保存することができます（以下のコードサンプルを参照してください）．画像フォーマットがサポートされていない場合，画像は 8 ビット符号なし（CV_8U）に変換され，そのように保存されます．フォーマット，ビット深度，チャンネル順序が異なる場合は， Mat::convertTo や cv::cvtColor を用いて，保存前に変換してください．あるいは，汎用の FileStorage I/O 関数を利用して，画像を XML や YAML 形式で保存します．以下のサンプルでは，BGRA 画像の作成方法，カスタム圧縮パラメータの設定方法，PNG ファイルへの保存方法を示しています．以下のサンプルは，BGRA 画像を作成し，カスタム圧縮パラメータを設定して PNG ファイルに保存する方法と，複数の画像を 1 つの TIFF ファイルに保存する方法を示しています： #include <opencv2/imgcodecs.hpp>using namespace cv;using namespace std;static void paintAlphaMat(Mat &mat){ CV_Assert(mat.channels() == 4); for (int i = 0; i < mat.rows; ++i) { for (int j = 0; j < mat.cols; ++j) { Vec4b& bgra = mat.at<Vec4b>(i, j); bgra[0] = UCHAR_MAX; // 青 bgra[1] = saturate_cast<uchar>((float (mat.cols - j)) / ((float)mat.cols./ ((float)mat.cols) * UCHAR_MAX); // 緑 bgra[2] = saturate_cast<uchar>((float (mat.rows - i))/ ((float)mat.rows) * UCHAR_MAX); // 赤 bgra[3] = saturate_cast<uchar>(0.5 * (bgra[1] + bgra[2])); // α }。    }}int main(){ Mat mat(480, 640, CV_8UC4); // アルファチャンネルを持つ行列を作成 paintAlphaMat(mat); vector<int> compression_params; compression_params.push_back(IMWRITE_PNG_COMPRESSION); compression_params.push_back(9); bool result = false; try { result = imwrite("alpha.png", mat, compression_params); } catch (const cv::Exception& ex) { fprintf(stderr, "Exception converting image to PNG format: %s\n", ex.what()); } if (result) printf("Saved PNG file with alpha data.\\"); else printf("ERROR: Can't save PNG file.\\"); vector<Mat> imgs; imgs.push_back(mat); imgs.push_back(~mat); imgs.push_back(mat(Rect(0, 0, mat.cols / 2, mat.rows / 2))); imwrite("test.tiff", imgs); printf("Multiple files saved in test.tiff\n"); return result ?0 : 1;}fragmentExamples: samples/cpp/image_alignment.cpp, samples/cpp/stitching.cpp, samples/cpp/stitching_detailed.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/tapi/hog.cpp, samples/tapi/squares.cpp.

元関数名(C#): imgcodecs_imwrite_multi_NotWindows
元DLLエクスポート名: imgcodecs_imwrite_multi
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_imgcodecs.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgcodecs_imwrite_multi(const char *filename, std::vector&amp;lt;cv::Mat&amp;gt; *img, int *params, int paramsLength, int *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;int&amp;gt; paramsVec;
    paramsVec.assign(params, params + paramsLength);
    *returnValue = cv::imwrite(filename, *img, paramsVec) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgcodecs

%index
imgcodecs_imwrite_multi_Windows
[32/64bit] 画像を指定されたファイルに保存します．
%prm
p1,p2,p3,p4,p5
p1 = str : [MarshalAs(StringUnmanagedTypeWindows)] string fileName
p2 = sptr : IntPtr img
p3 = var : [In] int[] @params
p4 = int : int paramsLength
p5 = var : out int returnValue
%inst
関数 imwrite は，画像を指定されたファイルに保存します．画像フォーマットは，ファイル名の拡張子に基づいて選択されます（拡張子のリストについては cv::imread を参照してください）．一般に，この関数を用いて保存できるのは，8ビットのシングルチャンネルまたは3チャンネル（チャンネル順序は 'BGR' ）の画像のみですが，以下のような例外があります： 16ビット符号なし（CV_16U）の画像は，PNG, JPEG 2000, TIFF フォーマットの場合に保存できます．

32ビット浮動小数点（CV_32F）画像は，PFM, TIFF, OpenEXR, Radiance HDR 形式で保存できます．3チャンネル（CV_32FC3）TIFF 画像は，LogLuv ハイダイナミックレンジエンコーディング（1ピクセルあたり4バイト）で保存されます．

アルファチャンネル付きのPNG画像もこの機能を使って保存できます。これを行うには，8ビット（あるいは16ビット）の4チャンネル画像BGRAを作成し，アルファチャンネルを最後に置きます。完全に透明なピクセルは，アルファを 0 に，完全に不透明なピクセルは，アルファを 255/65535 に設定する必要があります（以下のコードサンプルを参照してください）．

複数の画像（Mat のベクトル）は，TIFF 形式で保存することができます（以下のコードサンプルを参照してください）．画像フォーマットがサポートされていない場合，画像は 8 ビット符号なし（CV_8U）に変換され，そのように保存されます．フォーマット，ビット深度，チャンネル順序が異なる場合は， Mat::convertTo や cv::cvtColor を用いて，保存前に変換してください．あるいは，汎用の FileStorage I/O 関数を利用して，画像を XML や YAML 形式で保存します．以下のサンプルでは，BGRA 画像の作成方法，カスタム圧縮パラメータの設定方法，PNG ファイルへの保存方法を示しています．以下のサンプルは，BGRA 画像を作成し，カスタム圧縮パラメータを設定して PNG ファイルに保存する方法と，複数の画像を 1 つの TIFF ファイルに保存する方法を示しています： #include <opencv2/imgcodecs.hpp>using namespace cv;using namespace std;static void paintAlphaMat(Mat &mat){ CV_Assert(mat.channels() == 4); for (int i = 0; i < mat.rows; ++i) { for (int j = 0; j < mat.cols; ++j) { Vec4b& bgra = mat.at<Vec4b>(i, j); bgra[0] = UCHAR_MAX; // 青 bgra[1] = saturate_cast<uchar>((float (mat.cols - j)) / ((float)mat.cols./ ((float)mat.cols) * UCHAR_MAX); // 緑 bgra[2] = saturate_cast<uchar>((float (mat.rows - i))/ ((float)mat.rows) * UCHAR_MAX); // 赤 bgra[3] = saturate_cast<uchar>(0.5 * (bgra[1] + bgra[2])); // α }。    }}int main(){ Mat mat(480, 640, CV_8UC4); // アルファチャンネルを持つ行列を作成 paintAlphaMat(mat); vector<int> compression_params; compression_params.push_back(IMWRITE_PNG_COMPRESSION); compression_params.push_back(9); bool result = false; try { result = imwrite("alpha.png", mat, compression_params); } catch (const cv::Exception& ex) { fprintf(stderr, "Exception converting image to PNG format: %s\n", ex.what()); } if (result) printf("Saved PNG file with alpha data.\\"); else printf("ERROR: Can't save PNG file.\\"); vector<Mat> imgs; imgs.push_back(mat); imgs.push_back(~mat); imgs.push_back(mat(Rect(0, 0, mat.cols / 2, mat.rows / 2))); imwrite("test.tiff", imgs); printf("Multiple files saved in test.tiff\n"); return result ?0 : 1;}fragmentExamples: samples/cpp/image_alignment.cpp, samples/cpp/stitching.cpp, samples/cpp/stitching_detailed.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/tapi/hog.cpp, samples/tapi/squares.cpp.

元関数名(C#): imgcodecs_imwrite_multi_Windows
元DLLエクスポート名: imgcodecs_imwrite_multi
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_imgcodecs.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgcodecs_imwrite_multi(const char *filename, std::vector&amp;lt;cv::Mat&amp;gt; *img, int *params, int paramsLength, int *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;int&amp;gt; paramsVec;
    paramsVec.assign(params, params + paramsLength);
    *returnValue = cv::imwrite(filename, *img, paramsVec) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgcodecs

%index
imgcodecs_imdecode_Mat
[32/64bit] メモリ上のバッファから画像を読み込みます。
%prm
p1,p2,p3
p1 = sptr : IntPtr buf
p2 = int : int flags
p3 = var : out IntPtr returnValue
%inst
関数 imdecode は，メモリ上の指定されたバッファから画像を読み込みます．サポートされるフォーマットのリストとフラグの説明は， cv::imread を参照してください．注意カラー画像の場合，デコードされた画像は，B G R の順にチャンネルが格納されます．

元関数名(C#): imgcodecs_imdecode_Mat
元DLLエクスポート名: imgcodecs_imdecode_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_imgcodecs.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgcodecs_imdecode_Mat(cv::Mat *buf, int flags, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::imdecode(*buf, flags);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgcodecs

%index
imgcodecs_imdecode_vector
[32/64bit] メモリ上のバッファから画像を読み込みます。
%prm
p1,p2,p3,p4
p1 = var : byte* buf
p2 = int : int bufLength
p3 = int : int flags
p4 = var : out IntPtr returnValue
%inst
関数 imdecode は，メモリ上の指定されたバッファから画像を読み込みます．サポートされるフォーマットのリストとフラグの説明は， cv::imread を参照してください．注意カラー画像の場合，デコードされた画像は，B G R の順にチャンネルが格納されます．

元関数名(C#): imgcodecs_imdecode_vector
元DLLエクスポート名: imgcodecs_imdecode_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_imgcodecs.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgcodecs_imdecode_vector(uchar *buf, int bufLength, int flags, cv::Mat **returnValue)
{
    BEGIN_WRAP
    //const std::vector&amp;lt;uchar&amp;gt; bufVec(buf, buf + bufLength);
    const cv::Mat bufMat(1, bufLength, CV_8UC1, buf, cv::Mat::AUTO_STEP);
    const auto ret = cv::imdecode(bufMat, flags);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgcodecs

%index
imgcodecs_imdecode_InputArray
[32/64bit] メモリ上のバッファから画像を読み込みます。
%prm
p1,p2,p3
p1 = sptr : IntPtr buf
p2 = int : int flags
p3 = var : out IntPtr returnValue
%inst
関数 imdecode は，メモリ上の指定されたバッファから画像を読み込みます．サポートされるフォーマットのリストとフラグの説明は， cv::imread を参照してください．注意カラー画像の場合，デコードされた画像は，B G R の順にチャンネルが格納されます．

元関数名(C#): imgcodecs_imdecode_InputArray
元DLLエクスポート名: imgcodecs_imdecode_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_imgcodecs.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgcodecs_imdecode_InputArray(cv::_InputArray *buf, int flags, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::imdecode(*buf, flags);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgcodecs

%index
imgcodecs_imencode_vector
[32/64bit] 画像をメモリバッファにエンコードします．
%prm
p1,p2,p3,p4,p5,p6
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string ext
p2 = sptr : IntPtr img
p3 = sptr : IntPtr buf
p4 = var : [In] int[] @params
p5 = int : int paramsLength
p6 = var : out int returnValue
%inst
関数 imencode は，画像を圧縮し，その結果に合わせてリサイズされたメモリバッファに格納します．サポートされるフォーマットのリストとフラグの説明については， cv::imwrite を参照してください．

元関数名(C#): imgcodecs_imencode_vector
元DLLエクスポート名: imgcodecs_imencode_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_imgcodecs.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgcodecs_imencode_vector(
    const char *ext, cv::_InputArray *img,
    std::vector&amp;lt;uchar&amp;gt; *buf, int *params, int paramsLength, int *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;int&amp;gt; paramsVec;
    if (params != nullptr)
        paramsVec = std::vector&amp;lt;int&amp;gt;(params, params + paramsLength);
    *returnValue = cv::imencode(ext, *img, *buf, paramsVec) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgcodecs

%index
imgcodecs_haveImageReader_NotWindows
[32/64bit] 画像を指定されたファイルに保存します．
%prm
p1,p2
p1 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string fileName
p2 = var : out int returnValue
%inst
関数 imwrite は，画像を指定されたファイルに保存します．画像フォーマットは，ファイル名の拡張子に基づいて選択されます（拡張子のリストについては cv::imread を参照してください）．一般に，この関数を用いて保存できるのは，8ビットのシングルチャンネルまたは3チャンネル（チャンネル順序は 'BGR' ）の画像のみですが，以下のような例外があります： 16ビット符号なし（CV_16U）の画像は，PNG, JPEG 2000, TIFF フォーマットの場合に保存できます．

32ビット浮動小数点（CV_32F）画像は，PFM, TIFF, OpenEXR, Radiance HDR 形式で保存できます．3チャンネル（CV_32FC3）TIFF 画像は，LogLuv ハイダイナミックレンジエンコーディング（1ピクセルあたり4バイト）で保存されます．

アルファチャンネル付きのPNG画像もこの機能を使って保存できます。これを行うには，8ビット（あるいは16ビット）の4チャンネル画像BGRAを作成し，アルファチャンネルを最後に置きます。完全に透明なピクセルは，アルファを 0 に，完全に不透明なピクセルは，アルファを 255/65535 に設定する必要があります（以下のコードサンプルを参照してください）．

複数の画像（Mat のベクトル）は，TIFF 形式で保存することができます（以下のコードサンプルを参照してください）．画像フォーマットがサポートされていない場合，画像は 8 ビット符号なし（CV_8U）に変換され，そのように保存されます．フォーマット，ビット深度，チャンネル順序が異なる場合は， Mat::convertTo や cv::cvtColor を用いて，保存前に変換してください．あるいは，汎用の FileStorage I/O 関数を利用して，画像を XML や YAML 形式で保存します．以下のサンプルでは，BGRA 画像の作成方法，カスタム圧縮パラメータの設定方法，PNG ファイルへの保存方法を示しています．以下のサンプルは，BGRA 画像を作成し，カスタム圧縮パラメータを設定して PNG ファイルに保存する方法と，複数の画像を 1 つの TIFF ファイルに保存する方法を示しています： #include <opencv2/imgcodecs.hpp>using namespace cv;using namespace std;static void paintAlphaMat(Mat &mat){ CV_Assert(mat.channels() == 4); for (int i = 0; i < mat.rows; ++i) { for (int j = 0; j < mat.cols; ++j) { Vec4b& bgra = mat.at<Vec4b>(i, j); bgra[0] = UCHAR_MAX; // 青 bgra[1] = saturate_cast<uchar>((float (mat.cols - j)) / ((float)mat.cols./ ((float)mat.cols) * UCHAR_MAX); // 緑 bgra[2] = saturate_cast<uchar>((float (mat.rows - i))/ ((float)mat.rows) * UCHAR_MAX); // 赤 bgra[3] = saturate_cast<uchar>(0.5 * (bgra[1] + bgra[2])); // α }。    }}int main(){ Mat mat(480, 640, CV_8UC4); // アルファチャンネルを持つ行列を作成 paintAlphaMat(mat); vector<int> compression_params; compression_params.push_back(IMWRITE_PNG_COMPRESSION); compression_params.push_back(9); bool result = false; try { result = imwrite("alpha.png", mat, compression_params); } catch (const cv::Exception& ex) { fprintf(stderr, "Exception converting image to PNG format: %s\n", ex.what()); } if (result) printf("Saved PNG file with alpha data.\\"); else printf("ERROR: Can't save PNG file.\\"); vector<Mat> imgs; imgs.push_back(mat); imgs.push_back(~mat); imgs.push_back(mat(Rect(0, 0, mat.cols / 2, mat.rows / 2))); imwrite("test.tiff", imgs); printf("Multiple files saved in test.tiff\n"); return result ?0 : 1;}fragmentExamples: samples/cpp/image_alignment.cpp, samples/cpp/stitching.cpp, samples/cpp/stitching_detailed.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/tapi/hog.cpp, samples/tapi/squares.cpp.

元関数名(C#): imgcodecs_haveImageReader_NotWindows
元DLLエクスポート名: imgcodecs_imwrite
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_imgcodecs.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgcodecs_imwrite(const char *filename, cv::Mat *img, int *params, int paramsLength, int *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;int&amp;gt; paramsVec;
    paramsVec.assign(params, params + paramsLength);
    *returnValue = cv::imwrite(filename, *img, paramsVec) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgcodecs

%index
imgcodecs_haveImageReader_Windows
[32/64bit] 画像を指定されたファイルに保存します．
%prm
p1,p2
p1 = str : [MarshalAs(StringUnmanagedTypeWindows)] string fileName
p2 = var : out int returnValue
%inst
関数 imwrite は，画像を指定されたファイルに保存します．画像フォーマットは，ファイル名の拡張子に基づいて選択されます（拡張子のリストについては cv::imread を参照してください）．一般に，この関数を用いて保存できるのは，8ビットのシングルチャンネルまたは3チャンネル（チャンネル順序は 'BGR' ）の画像のみですが，以下のような例外があります： 16ビット符号なし（CV_16U）の画像は，PNG, JPEG 2000, TIFF フォーマットの場合に保存できます．

32ビット浮動小数点（CV_32F）画像は，PFM, TIFF, OpenEXR, Radiance HDR 形式で保存できます．3チャンネル（CV_32FC3）TIFF 画像は，LogLuv ハイダイナミックレンジエンコーディング（1ピクセルあたり4バイト）で保存されます．

アルファチャンネル付きのPNG画像もこの機能を使って保存できます。これを行うには，8ビット（あるいは16ビット）の4チャンネル画像BGRAを作成し，アルファチャンネルを最後に置きます。完全に透明なピクセルは，アルファを 0 に，完全に不透明なピクセルは，アルファを 255/65535 に設定する必要があります（以下のコードサンプルを参照してください）．

複数の画像（Mat のベクトル）は，TIFF 形式で保存することができます（以下のコードサンプルを参照してください）．画像フォーマットがサポートされていない場合，画像は 8 ビット符号なし（CV_8U）に変換され，そのように保存されます．フォーマット，ビット深度，チャンネル順序が異なる場合は， Mat::convertTo や cv::cvtColor を用いて，保存前に変換してください．あるいは，汎用の FileStorage I/O 関数を利用して，画像を XML や YAML 形式で保存します．以下のサンプルでは，BGRA 画像の作成方法，カスタム圧縮パラメータの設定方法，PNG ファイルへの保存方法を示しています．以下のサンプルは，BGRA 画像を作成し，カスタム圧縮パラメータを設定して PNG ファイルに保存する方法と，複数の画像を 1 つの TIFF ファイルに保存する方法を示しています： #include <opencv2/imgcodecs.hpp>using namespace cv;using namespace std;static void paintAlphaMat(Mat &mat){ CV_Assert(mat.channels() == 4); for (int i = 0; i < mat.rows; ++i) { for (int j = 0; j < mat.cols; ++j) { Vec4b& bgra = mat.at<Vec4b>(i, j); bgra[0] = UCHAR_MAX; // 青 bgra[1] = saturate_cast<uchar>((float (mat.cols - j)) / ((float)mat.cols./ ((float)mat.cols) * UCHAR_MAX); // 緑 bgra[2] = saturate_cast<uchar>((float (mat.rows - i))/ ((float)mat.rows) * UCHAR_MAX); // 赤 bgra[3] = saturate_cast<uchar>(0.5 * (bgra[1] + bgra[2])); // α }。    }}int main(){ Mat mat(480, 640, CV_8UC4); // アルファチャンネルを持つ行列を作成 paintAlphaMat(mat); vector<int> compression_params; compression_params.push_back(IMWRITE_PNG_COMPRESSION); compression_params.push_back(9); bool result = false; try { result = imwrite("alpha.png", mat, compression_params); } catch (const cv::Exception& ex) { fprintf(stderr, "Exception converting image to PNG format: %s\n", ex.what()); } if (result) printf("Saved PNG file with alpha data.\\"); else printf("ERROR: Can't save PNG file.\\"); vector<Mat> imgs; imgs.push_back(mat); imgs.push_back(~mat); imgs.push_back(mat(Rect(0, 0, mat.cols / 2, mat.rows / 2))); imwrite("test.tiff", imgs); printf("Multiple files saved in test.tiff\n"); return result ?0 : 1;}fragmentExamples: samples/cpp/image_alignment.cpp, samples/cpp/stitching.cpp, samples/cpp/stitching_detailed.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/tapi/hog.cpp, samples/tapi/squares.cpp.

元関数名(C#): imgcodecs_haveImageReader_Windows
元DLLエクスポート名: imgcodecs_imwrite
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_imgcodecs.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgcodecs_imwrite(const char *filename, cv::Mat *img, int *params, int paramsLength, int *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;int&amp;gt; paramsVec;
    paramsVec.assign(params, params + paramsLength);
    *returnValue = cv::imwrite(filename, *img, paramsVec) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgcodecs

%index
imgcodecs_haveImageWriter
[32/64bit] 指定された filename の画像が，OpenCV でエンコードできる場合に true を返します．
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string fileName
p2 = var : out int returnValue
%inst
元関数名(C#): imgcodecs_haveImageWriter
元DLLエクスポート名: imgcodecs_haveImageWriter
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_imgcodecs.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgcodecs_haveImageWriter(const char *filename, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::haveImageWriter(filename) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgcodecs

%index
img_hash_ImgHashBase_compute
[32/64bit] 入力画像のハッシュを計算します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr inputArr
p3 = sptr : IntPtr outputArr
%inst
元関数名(C#): img_hash_ImgHashBase_compute
元DLLエクスポート名: img_hash_ImgHashBase_compute
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_ImgHashBase_compute(cv::img_hash::ImgHashBase *obj, cv::_InputArray *inputArr, cv::_OutputArray *outputArr)
{
    BEGIN_WRAP
    obj-&amp;gt;compute(*inputArr, *outputArr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_ImgHashBase_compare
[32/64bit] inOneとinTwoのハッシュ値を比較します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr hashOne
p3 = sptr : IntPtr hashTwo
p4 = var : out double returnValue
%inst
元関数名(C#): img_hash_ImgHashBase_compare
元DLLエクスポート名: img_hash_ImgHashBase_compare
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_ImgHashBase_compare(cv::img_hash::ImgHashBase *obj, cv::_InputArray *hashOne, cv::_InputArray *hashTwo, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;compare(*hashOne, *hashTwo);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_AverageHash_create
[32/64bit] img_hash_AverageHash_create
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): img_hash_AverageHash_create
元DLLエクスポート名: img_hash_AverageHash_create
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_AverageHash_create(cv::Ptr&amp;lt;cv::img_hash::AverageHash&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::img_hash::AverageHash::create();
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_Ptr_AverageHash_delete
[32/64bit] cv::img_hash::AverageHash のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
入力画像の平均的なハッシュ値を計算します。

これは高速な画像ハッシュアルゴリズムですが、単純なケースでしか動作しません。詳しくは、[130]を参照してください。


元関数名(C#): img_hash_Ptr_AverageHash_delete
元DLLエクスポート名: img_hash_Ptr_AverageHash_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_Ptr_AverageHash_delete(cv::Ptr&amp;lt;cv::img_hash::AverageHash&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_Ptr_AverageHash_get
[32/64bit] cv::img_hash::AverageHash のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
入力画像の平均的なハッシュ値を計算します。

これは高速な画像ハッシュアルゴリズムですが、単純なケースでしか動作しません。詳しくは、[130]を参照してください。


元関数名(C#): img_hash_Ptr_AverageHash_get
元DLLエクスポート名: img_hash_Ptr_AverageHash_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_Ptr_AverageHash_get(cv::Ptr&amp;lt;cv::img_hash::AverageHash&amp;gt; *ptr, cv::img_hash::AverageHash **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_BlockMeanHash_create
[32/64bit] img_hash_BlockMeanHash_create
%prm
p1,p2
p1 = int : int mode
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): img_hash_BlockMeanHash_create
元DLLエクスポート名: img_hash_BlockMeanHash_create
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_BlockMeanHash_create(const int mode, cv::Ptr&amp;lt;cv::img_hash::BlockMeanHash&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::img_hash::BlockMeanHash::create(mode);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_Ptr_BlockMeanHash_delete
[32/64bit] cv::img_hash::BlockMeanHash のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
ブロック平均に基づく画像ハッシュ。

詳細は[289]を参照してください。


元関数名(C#): img_hash_Ptr_BlockMeanHash_delete
元DLLエクスポート名: img_hash_Ptr_BlockMeanHash_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_Ptr_BlockMeanHash_delete(cv::Ptr&amp;lt;cv::img_hash::BlockMeanHash&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_Ptr_BlockMeanHash_get
[32/64bit] cv::img_hash::BlockMeanHash のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
ブロック平均に基づく画像ハッシュ。

詳細は[289]を参照してください。


元関数名(C#): img_hash_Ptr_BlockMeanHash_get
元DLLエクスポート名: img_hash_Ptr_BlockMeanHash_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_Ptr_BlockMeanHash_get(cv::Ptr&amp;lt;cv::img_hash::BlockMeanHash&amp;gt; *ptr, cv::img_hash::BlockMeanHash **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_BlockMeanHash_setMode
[32/64bit] BlockMeanHashオブジェクトを作成します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int mode
%inst
元関数名(C#): img_hash_BlockMeanHash_setMode
元DLLエクスポート名: img_hash_BlockMeanHash_setMode
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_BlockMeanHash_setMode(cv::img_hash::BlockMeanHash *obj, const int mode)
{
    BEGIN_WRAP
    obj-&amp;gt;setMode(mode);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_BlockMeanHash_getMean
[32/64bit] img_hash_BlockMeanHash_getMean
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr outVec
%inst
元関数名(C#): img_hash_BlockMeanHash_getMean
元DLLエクスポート名: img_hash_BlockMeanHash_getMean
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_BlockMeanHash_getMean(cv::img_hash::BlockMeanHash *obj, std::vector&amp;lt;double&amp;gt; *outVec)
{
    BEGIN_WRAP
    const auto mean = obj-&amp;gt;getMean();
    outVec-&amp;gt;clear();
    outVec-&amp;gt;assign(mean.begin(), mean.end());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_ColorMomentHash_create
[32/64bit] img_hash_ColorMomentHash_create
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): img_hash_ColorMomentHash_create
元DLLエクスポート名: img_hash_ColorMomentHash_create
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_ColorMomentHash_create(cv::Ptr&amp;lt;cv::img_hash::ColorMomentHash&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::img_hash::ColorMomentHash::create();
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_Ptr_ColorMomentHash_delete
[32/64bit] cv::img_hash::ColorMomentHash のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
カラーモーメントに基づく画像ハッシュ。

詳しくは[238]を参照してください．


元関数名(C#): img_hash_Ptr_ColorMomentHash_delete
元DLLエクスポート名: img_hash_Ptr_ColorMomentHash_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_Ptr_ColorMomentHash_delete(cv::Ptr&amp;lt;cv::img_hash::ColorMomentHash&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_Ptr_ColorMomentHash_get
[32/64bit] cv::img_hash::ColorMomentHash のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
カラーモーメントに基づく画像ハッシュ。

詳しくは[238]を参照してください．


元関数名(C#): img_hash_Ptr_ColorMomentHash_get
元DLLエクスポート名: img_hash_Ptr_ColorMomentHash_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_Ptr_ColorMomentHash_get(cv::Ptr&amp;lt;cv::img_hash::ColorMomentHash&amp;gt; *ptr, cv::img_hash::ColorMomentHash **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_MarrHildrethHash_create
[32/64bit] img_hash_MarrHildrethHash_create
%prm
p1,p2,p3
p1 = float : float alpha
p2 = float : float scale
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): img_hash_MarrHildrethHash_create
元DLLエクスポート名: img_hash_MarrHildrethHash_create
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_MarrHildrethHash_create(const float alpha, const float scale, cv::Ptr&amp;lt;cv::img_hash::MarrHildrethHash&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::img_hash::MarrHildrethHash::create(alpha, scale);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_Ptr_MarrHildrethHash_delete
[32/64bit] cv::img_hash::MarrHildrethHash のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
Marr-Hildreth Operator Based Hash, 最も遅いですが，より識別性が高いです．

詳細は[289]を参照してください。


元関数名(C#): img_hash_Ptr_MarrHildrethHash_delete
元DLLエクスポート名: img_hash_Ptr_MarrHildrethHash_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_Ptr_MarrHildrethHash_delete(cv::Ptr&amp;lt;cv::img_hash::MarrHildrethHash&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_Ptr_MarrHildrethHash_get
[32/64bit] cv::img_hash::MarrHildrethHash のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
Marr-Hildreth Operator Based Hash, 最も遅いですが，より識別性が高いです．

詳細は[289]を参照してください。


元関数名(C#): img_hash_Ptr_MarrHildrethHash_get
元DLLエクスポート名: img_hash_Ptr_MarrHildrethHash_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_Ptr_MarrHildrethHash_get(cv::Ptr&amp;lt;cv::img_hash::MarrHildrethHash&amp;gt; *ptr, cv::img_hash::MarrHildrethHash **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_MarrHildrethHash_setKernelParam
[32/64bit] Mhカーネルのパラメータを設定します。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = float : float alpha
p3 = float : float scale
%inst
元関数名(C#): img_hash_MarrHildrethHash_setKernelParam
元DLLエクスポート名: img_hash_MarrHildrethHash_setKernelParam
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_MarrHildrethHash_setKernelParam(cv::img_hash::MarrHildrethHash *obj, const float alpha, const float scale)
{
    BEGIN_WRAP
    obj-&amp;gt;setKernelParam(alpha, scale);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_MarrHildrethHash_getAlpha
[32/64bit] 自己説明
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): img_hash_MarrHildrethHash_getAlpha
元DLLエクスポート名: img_hash_MarrHildrethHash_getAlpha
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_MarrHildrethHash_getAlpha(cv::img_hash::MarrHildrethHash *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getAlpha();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_MarrHildrethHash_getScale
[32/64bit] 自己説明
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): img_hash_MarrHildrethHash_getScale
元DLLエクスポート名: img_hash_MarrHildrethHash_getScale
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_MarrHildrethHash_getScale(cv::img_hash::MarrHildrethHash *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getScale();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_PHash_create
[32/64bit] img_hash_PHash_create
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): img_hash_PHash_create
元DLLエクスポート名: img_hash_PHash_create
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_PHash_create(cv::Ptr&amp;lt;cv::img_hash::PHash&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::img_hash::PHash::create();
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_Ptr_PHash_delete
[32/64bit] cv::img_hash::Phas のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst



元関数名(C#): img_hash_Ptr_PHash_delete
元DLLエクスポート名: img_hash_Ptr_PHash_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_Ptr_PHash_delete(cv::Ptr&amp;lt;cv::img_hash::PHash&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_Ptr_PHash_get
[32/64bit] cv::img_hash::Phas のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): img_hash_Ptr_PHash_get
元DLLエクスポート名: img_hash_Ptr_PHash_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_Ptr_PHash_get(cv::Ptr&amp;lt;cv::img_hash::PHash&amp;gt; *ptr, cv::img_hash::PHash **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_RadialVarianceHash_create
[32/64bit] img_hash_RadialVarianceHash_create
%prm
p1,p2,p3
p1 = double : double sigma
p2 = int : int numOfAngleLine
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): img_hash_RadialVarianceHash_create
元DLLエクスポート名: img_hash_RadialVarianceHash_create
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_RadialVarianceHash_create(const double sigma, const int numOfAngleLine, cv::Ptr&amp;lt;cv::img_hash::RadialVarianceHash&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::img_hash::RadialVarianceHash::create(sigma, numOfAngleLine);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_Ptr_RadialVarianceHash_delete
[32/64bit] cv::img_hash::RadialVarianceHash のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
ラドン変換に基づく画像ハッシュです．

詳しくは[238]を参照してください．


元関数名(C#): img_hash_Ptr_RadialVarianceHash_delete
元DLLエクスポート名: img_hash_Ptr_RadialVarianceHash_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_Ptr_RadialVarianceHash_delete(cv::Ptr&amp;lt;cv::img_hash::RadialVarianceHash&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_Ptr_RadialVarianceHash_get
[32/64bit] cv::img_hash::RadialVarianceHash のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
ラドン変換に基づく画像ハッシュです．

詳しくは[238]を参照してください．


元関数名(C#): img_hash_Ptr_RadialVarianceHash_get
元DLLエクスポート名: img_hash_Ptr_RadialVarianceHash_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_Ptr_RadialVarianceHash_get(cv::Ptr&amp;lt;cv::img_hash::RadialVarianceHash&amp;gt; *ptr, cv::img_hash::RadialVarianceHash **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_RadialVarianceHash_setNumOfAngleLine
[32/64bit] img_hash_RadialVarianceHash_setNumOfAngleLine
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): img_hash_RadialVarianceHash_setNumOfAngleLine
元DLLエクスポート名: img_hash_RadialVarianceHash_setNumOfAngleLine
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_RadialVarianceHash_setNumOfAngleLine(cv::img_hash::RadialVarianceHash *obj, const int value)
{
    BEGIN_WRAP
    obj-&amp;gt;setNumOfAngleLine(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_RadialVarianceHash_setSigma
[32/64bit] img_hash_RadialVarianceHash_setSigma
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double value
%inst
元関数名(C#): img_hash_RadialVarianceHash_setSigma
元DLLエクスポート名: img_hash_RadialVarianceHash_setSigma
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_RadialVarianceHash_setSigma(cv::img_hash::RadialVarianceHash *obj, const double value)
{
    BEGIN_WRAP
    obj-&amp;gt;setSigma(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_RadialVarianceHash_getNumOfAngleLine
[32/64bit] img_hash_RadialVarianceHash_getNumOfAngleLine
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): img_hash_RadialVarianceHash_getNumOfAngleLine
元DLLエクスポート名: img_hash_RadialVarianceHash_getNumOfAngleLine
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_RadialVarianceHash_getNumOfAngleLine(cv::img_hash::RadialVarianceHash *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getNumOfAngleLine();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
img_hash_RadialVarianceHash_getSigma
[32/64bit] img_hash_RadialVarianceHash_getSigma
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): img_hash_RadialVarianceHash_getSigma
元DLLエクスポート名: img_hash_RadialVarianceHash_getSigma
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_img_hash.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) img_hash_RadialVarianceHash_getSigma(cv::img_hash::RadialVarianceHash *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getSigma();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_img_hash

%index
line_descriptor_LSDDetector_new1
[32/64bit] cv::line_descriptor::LSDDetector のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst



元関数名(C#): line_descriptor_LSDDetector_new1
元DLLエクスポート名: line_descriptor_LSDDetector_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_line_descriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) line_descriptor_LSDDetector_new1(
    cv::line_descriptor::LSDDetector** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::line_descriptor::LSDDetector;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_line_descriptor

%index
line_descriptor_LSDDetector_new2
[32/64bit] cv::line_descriptor::LSDDetector のインスタンスを生成します
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = double : double scale
p2 = double : double sigmaScale
p3 = double : double quant
p4 = double : double angTh
p5 = double : double logEps
p6 = double : double densityTh
p7 = int : int nBins
p8 = var : out IntPtr returnValue
%inst



元関数名(C#): line_descriptor_LSDDetector_new2
元DLLエクスポート名: line_descriptor_LSDDetector_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_line_descriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) line_descriptor_LSDDetector_new2(
    const double scale,
    const double sigma_scale,
    const double quant,
    const double ang_th,
    const double log_eps,
    const double density_th,
    const int n_bins,
    cv::line_descriptor::LSDDetector** returnValue)
{
    BEGIN_WRAP
    cv::line_descriptor::LSDParam param;
    param.scale = scale;
    param.sigma_scale = sigma_scale;
    param.quant = quant;
    param.ang_th = ang_th;
    param.log_eps = log_eps;
    param.density_th = density_th;
    param.n_bins = n_bins;
    *returnValue = new cv::line_descriptor::LSDDetector(param);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_line_descriptor

%index
line_descriptor_LSDDetector_delete
[32/64bit] cv::line_descriptor::LSDDetector のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): line_descriptor_LSDDetector_delete
元DLLエクスポート名: line_descriptor_LSDDetector_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_line_descriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) line_descriptor_LSDDetector_delete(cv::line_descriptor::LSDDetector* obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_line_descriptor

%index
line_descriptor_LSDDetector_detect1
[32/64bit] 画像内の線を検出します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = sptr : IntPtr keypoints
p4 = int : int scale
p5 = int : int numOctaves
p6 = sptr : IntPtr mask
%inst
元関数名(C#): line_descriptor_LSDDetector_detect1
元DLLエクスポート名: line_descriptor_LSDDetector_detect1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_line_descriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) line_descriptor_LSDDetector_detect1(
    cv::line_descriptor::LSDDetector* obj,
    cv::Mat* image, std::vector&amp;lt;cv::line_descriptor::KeyLine&amp;gt; *keypoints, int scale, int numOctaves, cv::Mat* mask)
{
    BEGIN_WRAP
    obj-&amp;gt;detect(*image, *keypoints, scale, numOctaves, entity(mask));    
    END_WRAP
}

</pre>
}html
%group
NativeMethods_line_descriptor

%index
line_descriptor_LSDDetector_detect2
[32/64bit] 画像内の線を検出します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr[] images
p3 = int : int imagesSize
p4 = sptr : IntPtr keyLines
p5 = int : int scale
p6 = int : int numOctaves
p7 = sptr : IntPtr[] masks
p8 = int : int masksSize
%inst
元関数名(C#): line_descriptor_LSDDetector_detect2
元DLLエクスポート名: line_descriptor_LSDDetector_detect2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_line_descriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) line_descriptor_LSDDetector_detect2(
    cv::line_descriptor::LSDDetector* obj,
    cv::Mat **images, int32_t imagesSize,
    std::vector&amp;lt;std::vector&amp;lt;cv::line_descriptor::KeyLine&amp;gt; &amp;gt; *keylines, int scale, int numOctaves,
    cv::Mat** masks, int32_t masksSize)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; imagesVec(imagesSize);
    std::vector&amp;lt;cv::Mat&amp;gt; masksVec(masksSize);
    for (int i = 0; i &amp;lt; imagesSize; i++)
    {
        imagesVec[i] = *images[i];
    }
    for (int i = 0; i &amp;lt; masksSize; i++)
    {
        masksVec[i] = *masks[i];
    }
    
    obj-&amp;gt;detect(imagesVec, *keylines, scale, numOctaves, masksVec);

    END_WRAP
}

</pre>
}html
%group
NativeMethods_line_descriptor

%index
optflow_motempl_updateMotionHistory
[32/64bit] シルエットが動くことで動体視力を更新します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr silhouette
p2 = sptr : IntPtr mhi
p3 = double : double timestamp
p4 = double : double duration
%inst
この関数は，次のように動作履歴画像を更新します．(x,y)= \\{timestamp}}{if ?(\\{silhouette}(x,y) = 0\)}{0}{if ?(\{silhouette}(x,y) = 0\)and ?(\{mhi}) < (??-??-?)< (??? -? ???) }{\\}(x,y)}{otherwise}]つまり、動きが発生したMHIピクセルは、現在のタイムスタンプに設定され、前回ずっと前に動きが発生したピクセルはクリアされます。この関数は、calcMotionGradient、calcGlobalOrientationとともに、[53]や[32]で述べられているモーションテンプレート技術を実装しています。

元関数名(C#): optflow_motempl_updateMotionHistory
元DLLエクスポート名: optflow_motempl_updateMotionHistory
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_optflow.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) optflow_motempl_updateMotionHistory(
    cv::_InputArray *silhouette, cv::_InputOutputArray *mhi,
    double timestamp, double duration)
{
    BEGIN_WRAP
    cv::motempl::updateMotionHistory(*silhouette, *mhi, timestamp, duration);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_optflow

%index
optflow_motempl_calcMotionGradient
[32/64bit] モーションヒストリー画像のグラデーションオリエンテーションを計算します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr mhi
p2 = sptr : IntPtr mask
p3 = sptr : IntPtr orientation
p4 = double : double delta1
p5 = double : double delta2
p6 = int : int apertureSize
%inst
この関数は，各ピクセル ?((x, y)?)を用いて，グラデーションの方向性を計算します：?((x, y)?)????? )(x,y)= \frac{d\texttt{mhi}/dy}{d\texttt{mhi}/dx}}\]実際には，fastAtan2 と phase が利用され，計算される角度は度単位で，0 〜 360 の範囲をカバーします．また，計算された角度が有効なピクセルを示すために，マスクが塗りつぶされています．

(Python) モーションテンプレート法の実行例は、opencv_source_code/samples/python2/motempl.py にあります。

元関数名(C#): optflow_motempl_calcMotionGradient
元DLLエクスポート名: optflow_motempl_calcMotionGradient
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_optflow.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) optflow_motempl_calcMotionGradient(
    cv::_InputArray *mhi, cv::_OutputArray *mask, cv::_OutputArray *orientation,
    double delta1, double delta2, int apertureSize)
{
    BEGIN_WRAP
    cv::motempl::calcMotionGradient(*mhi, *mask, *orientation, delta1, delta2, apertureSize);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_optflow

%index
optflow_motempl_calcGlobalOrientation
[32/64bit] 選択された領域のグローバルモーションオリエンテーションを計算します。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr orientation
p2 = sptr : IntPtr mask
p3 = sptr : IntPtr mhi
p4 = double : double timestamp
p5 = double : double duration
p6 = var : out double returnValue
%inst
この関数は、選択された領域における平均的な動きの方向を計算し、0 度から 360 度の間の角度を返します。この平均方向は，mhi に記録されている，最近の動きの重みが大きく，過去に発生した動きの重みが小さい，重み付けされた方向ヒストグラムから計算されます．

元関数名(C#): optflow_motempl_calcGlobalOrientation
元DLLエクスポート名: optflow_motempl_calcGlobalOrientation
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_optflow.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) optflow_motempl_calcGlobalOrientation(
    cv::_InputArray *orientation, cv::_InputArray *mask,
    cv::_InputArray *mhi, double timestamp, double duration, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::motempl::calcGlobalOrientation(*orientation, *mask, *mhi, timestamp, duration);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_optflow

%index
optflow_motempl_segmentMotion
[32/64bit] モーションヒストリー画像を、独立した別々の動作（例えば、左手、右手）に対応するいくつかの部分に分割します。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr mhi
p2 = sptr : IntPtr segmask
p3 = sptr : IntPtr boundingRects
p4 = double : double timestamp
p5 = double : double segThresh
%inst
この関数は，すべてのモーションセグメントを検出し，segmask に個別の値 (1,2,...) でマークします．また，モーションに接続されたコンポーネントのROIを含むベクトルを計算します．その後，calcGlobalOrientation を用いて，特定のコンポーネントの抽出されたマスクを用いて，各コンポーネントの動きの方向を計算します．

元関数名(C#): optflow_motempl_segmentMotion
元DLLエクスポート名: optflow_motempl_segmentMotion
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_optflow.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) optflow_motempl_segmentMotion(
    cv::_InputArray *mhi, cv::_OutputArray *segmask,
    std::vector&amp;lt;cv::Rect&amp;gt; *boundingRects,
    double timestamp, double segThresh)
{
    BEGIN_WRAP
    cv::motempl::segmentMotion(*mhi, *segmask, *boundingRects, timestamp, segThresh);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_optflow

%index
optflow_calcOpticalFlowSF1
[32/64bit] SimpleFlow "アルゴリズムを用いて、オプティカルフローを計算します。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr from
p2 = sptr : IntPtr to
p3 = sptr : IntPtr flow
p4 = int : int layers
p5 = int : int averagingBlockSize
p6 = int : int maxFlow
%inst
239]を参照してください。そして、プロジェクトのサイト - http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/.Note

simpleFlowアルゴリズムを用いた例は、samples/simpleflow_demo.cppにあります。

元関数名(C#): optflow_calcOpticalFlowSF1
元DLLエクスポート名: optflow_calcOpticalFlowSF1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_optflow.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) optflow_calcOpticalFlowSF1(
    cv::_InputArray *from,
    cv::_InputArray *to,
    cv::_OutputArray *flow,
    int layers,
    int averagingBlockSize,
    int maxFlow)
{
    BEGIN_WRAP
    cv::optflow::calcOpticalFlowSF(*from, *to, *flow, layers, averagingBlockSize, maxFlow);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_optflow

%index
optflow_calcOpticalFlowSF2
[32/64bit] SimpleFlow "アルゴリズムを用いて、オプティカルフローを計算します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16
p1 = sptr : IntPtr from
p2 = sptr : IntPtr to
p3 = sptr : IntPtr flow
p4 = int : int layers
p5 = int : int averagingBlockSize
p6 = int : int maxFlow
p7 = double : double sigmaDist
p8 = double : double sigmaColor
p9 = int : int postprocessWindow
p10 = double : double sigmaDistFix
p11 = double : double sigmaColorFix
p12 = double : double occThr
p13 = int : int upscaleAveragingRadius
p14 = double : double upscaleSigmaDist
p15 = double : double upscaleSigmaColor
p16 = double : double speedUpThr
%inst
239]を参照してください。そして、プロジェクトのサイト - http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/.Note

simpleFlowアルゴリズムを用いた例は、samples/simpleflow_demo.cppにあります。

元関数名(C#): optflow_calcOpticalFlowSF2
元DLLエクスポート名: optflow_calcOpticalFlowSF2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_optflow.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) optflow_calcOpticalFlowSF2(
    cv::_InputArray *from,
    cv::_InputArray *to,
    cv::_OutputArray *flow,
    int layers,
    int averagingBlockSize,
    int maxFlow,
    double sigmaDist,
    double sigmaColor,
    int postprocessWindow,
    double sigmaDistFix,
    double sigmaColorFix,
    double occThr,
    int upscaleAveragingRadius,
    double upscaleSigmaDist,
    double upscaleSigmaColor,
    double speedUpThr)
{
    BEGIN_WRAP
    cv::optflow::calcOpticalFlowSF(*from, *to, *flow, layers, averagingBlockSize, maxFlow,
        sigmaDist, sigmaColor, postprocessWindow, sigmaDistFix, sigmaColorFix,
        occThr, upscaleAveragingRadius, upscaleSigmaDist, upscaleSigmaColor, speedUpThr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_optflow

%index
optflow_calcOpticalFlowSparseToDense
[32/64bit] PyrLK スパースマッチ補間に基づく高速高密度オプティカルフロー．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr from
p2 = sptr : IntPtr to
p3 = sptr : IntPtr flow
p4 = int : int gridStep
p5 = int : int k
p6 = float : float sigma
p7 = int : int usePostProc
p8 = float : float fgsLambda
p9 = float : float fgsSigma
%inst
元関数名(C#): optflow_calcOpticalFlowSparseToDense
元DLLエクスポート名: optflow_calcOpticalFlowSparseToDense
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_optflow.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) optflow_calcOpticalFlowSparseToDense(
    cv::_InputArray *from,  cv::_InputArray *to,  cv::_OutputArray *flow,
    int grid_step, int k, float sigma, int use_post_proc, float fgs_lambda, float fgs_sigma )
{
    BEGIN_WRAP
    cv::optflow::calcOpticalFlowSparseToDense(
        *from, *to, *flow, 
        grid_step, k, sigma, use_post_proc != 0, fgs_lambda, fgs_sigma);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_optflow

%index
quality_QualityBase_compute
[32/64bit] quality_QualityBase_compute
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr img
p3 = var : out Scalar returnValue
%inst
元関数名(C#): quality_QualityBase_compute
元DLLエクスポート名: quality_QualityBase_compute
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_QualityBase_compute(cv::quality::QualityBase *obj, cv::_InputArray *img, MyCvScalar *returnValue)
{
    BEGIN_WRAP
    const auto ret = obj-&amp;gt;compute(*img);
    *returnValue = c(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_QualityBase_getQualityMap
[32/64bit] アルゴリズムがサポートしていれば、計算中に生成された出力品質マップを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr dst
%inst
元関数名(C#): quality_QualityBase_getQualityMap
元DLLエクスポート名: quality_QualityBase_getQualityMap
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_QualityBase_getQualityMap(cv::quality::QualityBase *obj, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    obj-&amp;gt;getQualityMap(*dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_QualityBase_clear
[32/64bit] Algorithm::clear() を実装しています．
%prm
p1
p1 = sptr : IntPtr obj
%inst
cv::Algorithm.Reimplemented from cv::quality::QualityPSNR, cv::quality::QualityGMSD, cv::quality::QualitySSIM, および cv::quality::QualityMSE.

元関数名(C#): quality_QualityBase_clear
元DLLエクスポート名: quality_QualityBase_clear
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_QualityBase_clear(cv::quality::QualityBase *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;clear();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_QualityBase_empty
[32/64bit] Algorithm::empty() を実装しています．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
cv::Algorithm.Reimplemented from cv::quality::QualityPSNR, cv::quality::QualityGMSD, cv::quality::QualitySSIM, および cv::quality::QualityMSE.

元関数名(C#): quality_QualityBase_empty
元DLLエクスポート名: quality_QualityBase_empty
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_QualityBase_empty(cv::quality::QualityBase *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;empty() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_createQualityPSNR
[32/64bit] 品質を計算するオブジェクトを作成します．
%prm
p1,p2,p3
p1 = sptr : IntPtr @ref
p2 = double : double maxPixelValue
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): quality_createQualityPSNR
元DLLエクスポート名: quality_createQualityPSNR
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_createQualityPSNR(
    cv::_InputArray *ref, double maxPixelValue, cv::Ptr&amp;lt;cv::quality::QualityPSNR&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::quality::QualityPSNR::create(*ref, maxPixelValue);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_Ptr_QualityPSNR_delete
[32/64bit] cv::quality::QualityPSNR のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
full reference peak signal to noise ratio (PSNR) algorithm https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio.


元関数名(C#): quality_Ptr_QualityPSNR_delete
元DLLエクスポート名: quality_Ptr_QualityPSNR_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_Ptr_QualityPSNR_delete(cv::Ptr&amp;lt;cv::quality::QualityPSNR&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_QualityPSNR_staticCompute
[32/64bit] quality_QualityPSNR_staticCompute
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr @ref
p2 = sptr : IntPtr cmp
p3 = sptr : IntPtr qualityMap
p4 = double : double maxPixelValue
p5 = var : out Scalar returnValue
%inst
元関数名(C#): quality_QualityPSNR_staticCompute
元DLLエクスポート名: quality_QualityPSNR_staticCompute
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_QualityPSNR_staticCompute(
    cv::_InputArray *ref, cv::_InputArray *cmp, cv::_OutputArray *qualityMap, double maxPixelValue, MyCvScalar *returnValue)
{
    BEGIN_WRAP
    cv::Scalar ret;
    if (qualityMap == nullptr)
        ret = cv::quality::QualityPSNR::compute(*ref, *cmp, cv::noArray(), maxPixelValue);
    else
        ret = cv::quality::QualityPSNR::compute(*ref, *cmp, *qualityMap, maxPixelValue);
    *returnValue = c(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_QualityPSNR_getMaxPixelValue
[32/64bit] PSNRの計算に用いる最大ピクセル値を返す
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): quality_QualityPSNR_getMaxPixelValue
元DLLエクスポート名: quality_QualityPSNR_getMaxPixelValue
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_QualityPSNR_getMaxPixelValue(cv::quality::QualityPSNR *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getMaxPixelValue();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_QualityPSNR_setMaxPixelValue
[32/64bit] PSNRの計算に用いる最大ピクセル値を設定します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): quality_QualityPSNR_setMaxPixelValue
元DLLエクスポート名: quality_QualityPSNR_setMaxPixelValue
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_QualityPSNR_setMaxPixelValue(cv::quality::QualityPSNR *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setMaxPixelValue(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_Ptr_QualityPSNR_get
[32/64bit] cv::quality::QualityPSNR のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
full reference peak signal to noise ratio (PSNR) algorithm https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio.


元関数名(C#): quality_Ptr_QualityPSNR_get
元DLLエクスポート名: quality_Ptr_QualityPSNR_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_Ptr_QualityPSNR_get(
    cv::Ptr&amp;lt;cv::quality::QualityPSNR&amp;gt;* ptr, cv::quality::QualityPSNR **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_createQualitySSIM
[32/64bit] 品質を計算するオブジェクトを作成します．
%prm
p1,p2
p1 = sptr : IntPtr @ref
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): quality_createQualitySSIM
元DLLエクスポート名: quality_createQualitySSIM
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_createQualitySSIM(cv::_InputArray* ref, cv::Ptr&amp;lt;cv::quality::QualitySSIM&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::quality::QualitySSIM::create(*ref);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_Ptr_QualitySSIM_delete
[32/64bit] cv::quality::QualitySSIM のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
完全参照構造類似性アルゴリズム https://en.wikipedia.org/wiki/Structural_similarity.


元関数名(C#): quality_Ptr_QualitySSIM_delete
元DLLエクスポート名: quality_Ptr_QualitySSIM_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_Ptr_QualitySSIM_delete(cv::Ptr&amp;lt;cv::quality::QualitySSIM&amp;gt;* obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_Ptr_QualitySSIM_get
[32/64bit] cv::quality::QualitySSIM のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
完全参照構造類似性アルゴリズム https://en.wikipedia.org/wiki/Structural_similarity.


元関数名(C#): quality_Ptr_QualitySSIM_get
元DLLエクスポート名: quality_Ptr_QualitySSIM_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_Ptr_QualitySSIM_get(
    cv::Ptr&amp;lt;cv::quality::QualitySSIM&amp;gt;* ptr, cv::quality::QualitySSIM **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_QualitySSIM_staticCompute
[32/64bit] quality_QualitySSIM_staticCompute
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr @ref
p2 = sptr : IntPtr cmp
p3 = sptr : IntPtr qualityMap
p4 = var : out Scalar returnValue
%inst
元関数名(C#): quality_QualitySSIM_staticCompute
元DLLエクスポート名: quality_QualitySSIM_staticCompute
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_QualitySSIM_staticCompute(
    cv::_InputArray* ref, cv::_InputArray* cmp, cv::_OutputArray* qualityMap, MyCvScalar *returnValue)
{
    BEGIN_WRAP
    cv::Scalar ret;
    if (qualityMap == nullptr)
        ret = cv::quality::QualitySSIM::compute(*ref, *cmp, cv::noArray());
    else
        ret = cv::quality::QualitySSIM::compute(*ref, *cmp, *qualityMap);
    *returnValue = c(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_createQualityGMSD
[32/64bit] 画質を計算するオブジェクトを作成します．
%prm
p1,p2
p1 = sptr : IntPtr @ref
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): quality_createQualityGMSD
元DLLエクスポート名: quality_createQualityGMSD
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_createQualityGMSD(cv::_InputArray* ref, cv::Ptr&amp;lt;cv::quality::QualityGMSD&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::quality::QualityGMSD::create(*ref);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_Ptr_QualityGMSD_delete
[32/64bit] cv::quality::QualityGMSD のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
完全参照GMSDアルゴリズム http://www4.comp.polyu.edu.hk/~cslzhang/IQA/GMSD/GMSD.htm.


元関数名(C#): quality_Ptr_QualityGMSD_delete
元DLLエクスポート名: quality_Ptr_QualityGMSD_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_Ptr_QualityGMSD_delete(cv::Ptr&amp;lt;cv::quality::QualityGMSD&amp;gt;* obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_Ptr_QualityGMSD_get
[32/64bit] cv::quality::QualityGMSD のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
完全参照GMSDアルゴリズム http://www4.comp.polyu.edu.hk/~cslzhang/IQA/GMSD/GMSD.htm.


元関数名(C#): quality_Ptr_QualityGMSD_get
元DLLエクスポート名: quality_Ptr_QualityGMSD_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_Ptr_QualityGMSD_get(
    cv::Ptr&amp;lt;cv::quality::QualityGMSD&amp;gt;* ptr, cv::quality::QualityGMSD **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_QualityGMSD_staticCompute
[32/64bit] quality_QualityGMSD_staticCompute
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr @ref
p2 = sptr : IntPtr cmp
p3 = sptr : IntPtr qualityMap
p4 = var : out Scalar returnValue
%inst
元関数名(C#): quality_QualityGMSD_staticCompute
元DLLエクスポート名: quality_QualityGMSD_staticCompute
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_QualityGMSD_staticCompute(
    cv::_InputArray* ref, cv::_InputArray* cmp, cv::_OutputArray* qualityMap, MyCvScalar *returnValue)
{
    BEGIN_WRAP
    cv::Scalar ret;
    if (qualityMap == nullptr)
        ret = cv::quality::QualityGMSD::compute(*ref, *cmp, cv::noArray());
    else
        ret = cv::quality::QualityGMSD::compute(*ref, *cmp, *qualityMap);
    *returnValue = c(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_createQualityMSE
[32/64bit] 品質を計算するオブジェクトを作成します．
%prm
p1,p2
p1 = sptr : IntPtr @ref
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): quality_createQualityMSE
元DLLエクスポート名: quality_createQualityMSE
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_createQualityMSE(cv::_InputArray* ref, cv::Ptr&amp;lt;cv::quality::QualityMSE&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::quality::QualityMSE::create(*ref);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_Ptr_QualityMSE_delete
[32/64bit] cv::quality::QualityMSE のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
Full reference mean square error algorithm https://en.wikipedia.org/wiki/Mean_squared_error.


元関数名(C#): quality_Ptr_QualityMSE_delete
元DLLエクスポート名: quality_Ptr_QualityMSE_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_Ptr_QualityMSE_delete(cv::Ptr&amp;lt;cv::quality::QualityMSE&amp;gt;* obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_Ptr_QualityMSE_get
[32/64bit] cv::quality::QualityMSE のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
Full reference mean square error algorithm https://en.wikipedia.org/wiki/Mean_squared_error.


元関数名(C#): quality_Ptr_QualityMSE_get
元DLLエクスポート名: quality_Ptr_QualityMSE_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_Ptr_QualityMSE_get(
    cv::Ptr&amp;lt;cv::quality::QualityMSE&amp;gt;* ptr, cv::quality::QualityMSE **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_QualityMSE_staticCompute
[32/64bit] quality_QualityMSE_staticCompute
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr @ref
p2 = sptr : IntPtr cmp
p3 = sptr : IntPtr qualityMap
p4 = var : out Scalar returnValue
%inst
元関数名(C#): quality_QualityMSE_staticCompute
元DLLエクスポート名: quality_QualityMSE_staticCompute
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_QualityMSE_staticCompute(
    cv::_InputArray* ref, cv::_InputArray* cmp, cv::_OutputArray* qualityMap, MyCvScalar *returnValue)
{
    BEGIN_WRAP
    cv::Scalar ret;
    if (qualityMap == nullptr)
        ret = cv::quality::QualityMSE::compute(*ref, *cmp, cv::noArray());
    else
        ret = cv::quality::QualityMSE::compute(*ref, *cmp, *qualityMap);
    *returnValue = c(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_createQualityBRISQUE1
[32/64bit] 品質を計算するオブジェクトを作成します．
%prm
p1,p2,p3
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string modelFilePath
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string rangeFilePath
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): quality_createQualityBRISQUE1
元DLLエクスポート名: quality_createQualityBRISQUE1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_createQualityBRISQUE1(
    const char *modelFilePath, const char *rangeFilePath, cv::Ptr&amp;lt;cv::quality::QualityBRISQUE&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::quality::QualityBRISQUE::create(modelFilePath, rangeFilePath);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_createQualityBRISQUE2
[32/64bit] 品質を計算するオブジェクトを作成します．
%prm
p1,p2,p3
p1 = sptr : IntPtr model
p2 = sptr : IntPtr range
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): quality_createQualityBRISQUE2
元DLLエクスポート名: quality_createQualityBRISQUE2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_createQualityBRISQUE2(
    cv::ml::SVM *model, cv::Mat *range, cv::Ptr&amp;lt;cv::quality::QualityBRISQUE&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::quality::QualityBRISQUE::create(model, *range);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_Ptr_QualityBRISQUE_delete
[32/64bit] cv::quality::QualityBRISQUE のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
BRISQUE (Blind/Referenceless Image Spatial Quality Evaluator) は，NR-IQA (No Reference Image Quality Assessment) アルゴリズムの一つです．

BRISQUEは、Natural Scene Statistics (https://en.wikipedia.org/wiki/Scene_statistics)を抽出し、特徴ベクトルを計算することでスコアを算出します。オリジナルの論文はMittal et al.[174]、オリジナルの実装は[173]を参照してください。

学習済みのモデルは，/samples/ ディレクトリに用意されており，オリジナルの実装と同様に LIVE-R2 データベース [114] で学習されています．TID2008データベース[180]に対して評価したところ，オリジナルの実装ではSROCCが-0.8354であったのに対し，SROCCは-0.8424となりました．BRISQUE LIVE-R2トレーナーとTID2008評価器のC++コードも/samples/ディレクトリにあります。


元関数名(C#): quality_Ptr_QualityBRISQUE_delete
元DLLエクスポート名: quality_Ptr_QualityBRISQUE_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_Ptr_QualityBRISQUE_delete(cv::Ptr&amp;lt;cv::quality::QualityBRISQUE&amp;gt;* obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_Ptr_QualityBRISQUE_get
[32/64bit] cv::quality::QualityBRISQUE のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
BRISQUE (Blind/Referenceless Image Spatial Quality Evaluator) は，NR-IQA (No Reference Image Quality Assessment) アルゴリズムの一つです．

BRISQUEは、Natural Scene Statistics (https://en.wikipedia.org/wiki/Scene_statistics)を抽出し、特徴ベクトルを計算することでスコアを算出します。オリジナルの論文はMittal et al.[174]、オリジナルの実装は[173]を参照してください。

学習済みのモデルは，/samples/ ディレクトリに用意されており，オリジナルの実装と同様に LIVE-R2 データベース [114] で学習されています．TID2008データベース[180]に対して評価したところ，オリジナルの実装ではSROCCが-0.8354であったのに対し，SROCCは-0.8424となりました．BRISQUE LIVE-R2トレーナーとTID2008評価器のC++コードも/samples/ディレクトリにあります。


元関数名(C#): quality_Ptr_QualityBRISQUE_get
元DLLエクスポート名: quality_Ptr_QualityBRISQUE_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_Ptr_QualityBRISQUE_get(
    cv::Ptr&amp;lt;cv::quality::QualityBRISQUE&amp;gt;* ptr, cv::quality::QualityBRISQUE **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_QualityBRISQUE_staticCompute
[32/64bit] quality_QualityBRISQUE_staticCompute
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr @ref
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string modelFilePath
p3 = str : [MarshalAs(UnmanagedType.LPStr)] string rangeFilePath
p4 = var : out Scalar returnValue
%inst
元関数名(C#): quality_QualityBRISQUE_staticCompute
元DLLエクスポート名: quality_QualityBRISQUE_staticCompute
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_QualityBRISQUE_staticCompute(
    cv::_InputArray* ref, const char* modelFilePath, const char* rangeFilePath, MyCvScalar *returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::quality::QualityBRISQUE::compute(*ref, modelFilePath, rangeFilePath);
    *returnValue = c(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
quality_QualityBRISQUE_computeFeatures
[32/64bit] BRISQUEアルゴリズムで使用する画像特徴量の静的な計算方法
%prm
p1,p2
p1 = sptr : IntPtr img
p2 = sptr : IntPtr features
%inst
元関数名(C#): quality_QualityBRISQUE_computeFeatures
元DLLエクスポート名: quality_QualityBRISQUE_computeFeatures
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_quality.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) quality_QualityBRISQUE_computeFeatures(
    cv::_InputArray* img, cv::_OutputArray *features)
{
    BEGIN_WRAP
    cv::quality::QualityBRISQUE::computeFeatures(*img, *features);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_quality

%index
string_new1
[32/64bit] std::string のインスタンスを生成します
%prm

%inst



元関数名(C#): string_new1
元DLLエクスポート名: string_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdstring.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::string*) string_new1()
{
    return new std::string;
}

</pre>
}html
%group
NativeMethods_stdstring

%index
string_new2
[32/64bit] std::string のインスタンスを生成します
%prm
p1
p1 = var : [MarshalAs(UnmanagedType.LPArray)] byte[] str
%inst



元関数名(C#): string_new2
元DLLエクスポート名: string_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdstring.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::string*) string_new2(const char *str)
{
    return new std::string(str);
}

</pre>
}html
%group
NativeMethods_stdstring

%index
string_delete
[32/64bit] std::string のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr s
%inst



元関数名(C#): string_delete
元DLLエクスポート名: string_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdstring.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) string_delete(std::string *s)
{
    delete s;
}

</pre>
}html
%group
NativeMethods_stdstring

%index
string_c_str
[32/64bit] string_c_str
%prm
p1
p1 = sptr : IntPtr s
%inst
元関数名(C#): string_c_str
元DLLエクスポート名: string_c_str
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdstring.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(const char*) string_c_str(std::string *s)
{
    return s-&amp;gt;c_str();
}

</pre>
}html
%group
NativeMethods_stdstring

%index
string_size
[32/64bit] string_size
%prm
p1
p1 = sptr : IntPtr s
%inst
元関数名(C#): string_size
元DLLエクスポート名: string_size
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdstring.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) string_size(std::string *s)
{
    return s-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdstring

%index
vector_uchar_new1
[32/64bit] std::vector<std::vector<uchar>> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_uchar_new1
元DLLエクスポート名: vector_uchar_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;std::vector&amp;lt;uchar&amp;gt; &amp;gt;*) vector_vector_uchar_new1()
{
    return new std::vector&amp;lt;std::vector&amp;lt;uchar&amp;gt; &amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_uchar_new2
[32/64bit] std::vector<uchar>() のインスタンスを生成します
%prm
p1
p1 = sptr : nuint size
%inst



元関数名(C#): vector_uchar_new2
元DLLエクスポート名: vector_uchar_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;uchar&amp;gt;*) vector_uchar_new2(size_t size)
{
    return new std::vector&amp;lt;uchar&amp;gt;(size);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_uchar_new3
[32/64bit] new std::vector<uchar>() のインスタンスを生成します
%prm
p1,p2
p1 = var : [In] byte[] data
p2 = sptr : nuint dataLength
%inst



元関数名(C#): vector_uchar_new3
元DLLエクスポート名: vector_uchar_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;uchar&amp;gt;*) vector_uchar_new3(uchar* data, size_t dataLength)
{
    return new std::vector&amp;lt;uchar&amp;gt;(data, data + dataLength);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_uchar_getSize
[32/64bit] vector_uchar_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_uchar_getSize
元DLLエクスポート名: vector_uchar_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_vector_uchar_getSize1(std::vector&amp;lt;std::vector&amp;lt;uchar&amp;gt; &amp;gt;* vec)
{
    return vec-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_uchar_getPointer
[32/64bit] std::vector<uchar> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_uchar_getPointer
元DLLエクスポート名: vector_uchar_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(uchar*) vector_uchar_getPointer(std::vector&amp;lt;uchar&amp;gt;* vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_uchar_copy
[32/64bit] std::vector<std::vector<uchar>> をメモリコピーします
%prm
p1,p2
p1 = sptr : IntPtr vector
p2 = sptr : IntPtr dst
%inst



元関数名(C#): vector_uchar_copy
元DLLエクスポート名: vector_uchar_copy
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_uchar_copy(std::vector&amp;lt;std::vector&amp;lt;uchar&amp;gt; &amp;gt;* vec, uchar** dst)
{
    for (size_t i = 0; i &amp;lt; vec-&amp;gt;size(); i++)
    {
        auto&amp; elem = vec-&amp;gt;at(i);
        void* src = &amp;elem[0];
        const auto length = sizeof(int) * elem.size();
        memcpy(dst[i], src, length);
    }
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_uchar_delete
[32/64bit] std::vector<std::vector<uchar>> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_uchar_delete
元DLLエクスポート名: vector_uchar_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_uchar_delete(std::vector&amp;lt;std::vector&amp;lt;uchar&amp;gt; &amp;gt;* vec)
{
    delete vec;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_int32_new1
[32/64bit] std::vector<int> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_int32_new1
元DLLエクスポート名: vector_int32_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;int&amp;gt;*) vector_int32_new1()
{
    return new std::vector&amp;lt;int&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_int32_new2
[32/64bit] std::vector<int> のインスタンスを生成します
%prm
p1
p1 = sptr : nuint size
%inst



元関数名(C#): vector_int32_new2
元DLLエクスポート名: vector_int32_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;int&amp;gt;*) vector_int32_new2(size_t size)
{
    return new std::vector&amp;lt;int&amp;gt;(size);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_int32_new3
[32/64bit] std::vector<int> のインスタンスを生成します
%prm
p1,p2
p1 = var : [In] int[] data
p2 = sptr : nuint dataLength
%inst



元関数名(C#): vector_int32_new3
元DLLエクスポート名: vector_int32_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;int&amp;gt;*) vector_int32_new3(int* data, size_t dataLength)
{
    return new std::vector&amp;lt;int&amp;gt;(data, data + dataLength);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_int32_getSize
[32/64bit] vector_int32_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_int32_getSize
元DLLエクスポート名: vector_int32_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_int32_getSize(std::vector&amp;lt;int&amp;gt;* vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_int32_getPointer
[32/64bit] std::vector<int> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_int32_getPointer
元DLLエクスポート名: vector_int32_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(int*) vector_int32_getPointer(std::vector&amp;lt;int&amp;gt;* vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_int32_delete
[32/64bit] std::vector<int> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_int32_delete
元DLLエクスポート名: vector_int32_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_int32_delete(std::vector&amp;lt;int&amp;gt;* vector)
{
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_float_new1
[32/64bit] std::vector<float> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_float_new1
元DLLエクスポート名: vector_float_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;float&amp;gt;*) vector_float_new1()
{
    return new std::vector&amp;lt;float&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_float_new2
[32/64bit] std::vector<float> のインスタンスを生成します
%prm
p1
p1 = sptr : nuint size
%inst



元関数名(C#): vector_float_new2
元DLLエクスポート名: vector_float_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;float&amp;gt;*) vector_float_new2(size_t size)
{
    return new std::vector&amp;lt;float&amp;gt;(size);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_float_new3
[32/64bit] std::vector<float> のインスタンスを生成します
%prm
p1,p2
p1 = var : [In] float[] data
p2 = sptr : nuint dataLength
%inst



元関数名(C#): vector_float_new3
元DLLエクスポート名: vector_float_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;float&amp;gt;*) vector_float_new3(float* data, size_t dataLength)
{
    return new std::vector&amp;lt;float&amp;gt;(data, data + dataLength);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_float_getSize
[32/64bit] vector_float_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_float_getSize
元DLLエクスポート名: vector_float_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_float_getSize(std::vector&amp;lt;float&amp;gt;* vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_float_getPointer
[32/64bit] std::vector<float> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_float_getPointer
元DLLエクスポート名: vector_float_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(float*) vector_float_getPointer(std::vector&amp;lt;float&amp;gt;* vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_float_delete
[32/64bit] std::vector<float> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_float_delete
元DLLエクスポート名: vector_float_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_float_delete(std::vector&amp;lt;float&amp;gt;* vector)
{
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_double_new1
[32/64bit] std::vector<std::vector<double>> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_double_new1
元DLLエクスポート名: vector_double_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;std::vector&amp;lt;double&amp;gt; &amp;gt;*) vector_vector_double_new1()
{
    return new std::vector&amp;lt;std::vector&amp;lt;double&amp;gt; &amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_double_new2
[32/64bit] std::vector<std::vector<double>> のインスタンスを生成します
%prm
p1
p1 = sptr : nuint size
%inst



元関数名(C#): vector_double_new2
元DLLエクスポート名: vector_double_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;double&amp;gt;*) vector_double_new2(size_t size)
{
    return new std::vector&amp;lt;double&amp;gt;(size);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_double_new3
[32/64bit] std::vector<std::vector<double>> のインスタンスを生成します
%prm
p1,p2
p1 = var : [In] double[] data
p2 = sptr : nuint dataLength
%inst



元関数名(C#): vector_double_new3
元DLLエクスポート名: vector_double_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;double&amp;gt;*) vector_double_new3(double* data, size_t dataLength)
{
    return new std::vector&amp;lt;double&amp;gt;(data, data + dataLength);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_double_getSize
[32/64bit] vector_double_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_double_getSize
元DLLエクスポート名: vector_double_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_vector_double_getSize1(std::vector&amp;lt;std::vector&amp;lt;double&amp;gt; &amp;gt;* vec)
{
    return vec-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_double_getPointer
[32/64bit] std::vector<std::vector<double>> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_double_getPointer
元DLLエクスポート名: vector_double_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(double*) vector_double_getPointer(std::vector&amp;lt;double&amp;gt;* vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_double_delete
[32/64bit] std::vector<std::vector<double>> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_double_delete
元DLLエクスポート名: vector_double_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_double_delete(std::vector&amp;lt;std::vector&amp;lt;double&amp;gt; &amp;gt;* vec)
{
    delete vec;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec2f_new1
[32/64bit] std::vector<cv::Vec2f> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_Vec2f_new1
元DLLエクスポート名: vector_Vec2f_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Vec2f&amp;gt;*) vector_Vec2f_new1()
{
    return new std::vector&amp;lt;cv::Vec2f&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec2f_getSize
[32/64bit] vector_Vec2f_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_Vec2f_getSize
元DLLエクスポート名: vector_Vec2f_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_Vec2f_getSize(std::vector&amp;lt;cv::Vec2f&amp;gt;* vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec2f_getPointer
[32/64bit] std::vector<cv::Vec2f> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Vec2f_getPointer
元DLLエクスポート名: vector_Vec2f_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::Vec2f*) vector_Vec2f_getPointer(std::vector&amp;lt;cv::Vec2f&amp;gt;* vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec2f_delete
[32/64bit] std::vector<cv::Vec2f> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Vec2f_delete
元DLLエクスポート名: vector_Vec2f_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_Vec2f_delete(std::vector&amp;lt;cv::Vec2f&amp;gt;* vector)
{
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec3f_new1
[32/64bit] std::vector<cv::Vec3f> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_Vec3f_new1
元DLLエクスポート名: vector_Vec3f_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Vec3f&amp;gt;*) vector_Vec3f_new1()
{
    return new std::vector&amp;lt;cv::Vec3f&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec3f_getSize
[32/64bit] vector_Vec3f_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_Vec3f_getSize
元DLLエクスポート名: vector_Vec3f_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_Vec3f_getSize(std::vector&amp;lt;cv::Vec3f&amp;gt;* vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec3f_getPointer
[32/64bit] std::vector<cv::Vec3f> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Vec3f_getPointer
元DLLエクスポート名: vector_Vec3f_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::Vec3f*) vector_Vec3f_getPointer(std::vector&amp;lt;cv::Vec3f&amp;gt;* vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec3f_delete
[32/64bit] std::vector<cv::Vec3f> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Vec3f_delete
元DLLエクスポート名: vector_Vec3f_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_Vec3f_delete(std::vector&amp;lt;cv::Vec3f&amp;gt;* vector)
{
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec4f_new1
[32/64bit] std::vector<cv::Vec4f> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_Vec4f_new1
元DLLエクスポート名: vector_Vec4f_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Vec4f&amp;gt;*) vector_Vec4f_new1()
{
    return new std::vector&amp;lt;cv::Vec4f&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec4f_new3
[32/64bit] std::vector<cv::Vec4f> のインスタンスを生成します
%prm
p1,p2
p1 = var : [In] Vec4f[] data
p2 = sptr : nuint dataLength
%inst



元関数名(C#): vector_Vec4f_new3
元DLLエクスポート名: vector_Vec4f_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Vec4f&amp;gt;*) vector_Vec4f_new3(cv::Vec4f* data, size_t dataLength)
{
    return new std::vector&amp;lt;cv::Vec4f&amp;gt;(data, data + dataLength);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec4f_getSize
[32/64bit] vector_Vec4f_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_Vec4f_getSize
元DLLエクスポート名: vector_Vec4f_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_Vec4f_getSize(std::vector&amp;lt;cv::Vec4f&amp;gt;* vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec4f_getPointer
[32/64bit] std::vector<cv::Vec4f> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Vec4f_getPointer
元DLLエクスポート名: vector_Vec4f_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::Vec4f*) vector_Vec4f_getPointer(std::vector&amp;lt;cv::Vec4f&amp;gt;* vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec4f_delete
[32/64bit] std::vector<cv::Vec4f> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Vec4f_delete
元DLLエクスポート名: vector_Vec4f_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_Vec4f_delete(std::vector&amp;lt;cv::Vec4f&amp;gt;* vector)
{
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec4i_new1
[32/64bit] std::vector<cv::Vec4i> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_Vec4i_new1
元DLLエクスポート名: vector_Vec4i_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Vec4i&amp;gt;*) vector_Vec4i_new1()
{
    return new std::vector&amp;lt;cv::Vec4i&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec4i_new3
[32/64bit] std::vector<cv::Vec4i> のインスタンスを生成します
%prm
p1,p2
p1 = var : [In] Vec4i[] data
p2 = sptr : nuint dataLength
%inst



元関数名(C#): vector_Vec4i_new3
元DLLエクスポート名: vector_Vec4i_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Vec4i&amp;gt;*) vector_Vec4i_new3(cv::Vec4i* data, size_t dataLength)
{
    return new std::vector&amp;lt;cv::Vec4i&amp;gt;(data, data + dataLength);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec4i_getSize
[32/64bit] vector_Vec4i_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_Vec4i_getSize
元DLLエクスポート名: vector_Vec4i_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_Vec4i_getSize(std::vector&amp;lt;cv::Vec4i&amp;gt;* vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec4i_getPointer
[32/64bit] std::vector<cv::Vec4i> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Vec4i_getPointer
元DLLエクスポート名: vector_Vec4i_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::Vec4i*) vector_Vec4i_getPointer(std::vector&amp;lt;cv::Vec4i&amp;gt;* vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec4i_delete
[32/64bit] std::vector<cv::Vec4i> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Vec4i_delete
元DLLエクスポート名: vector_Vec4i_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_Vec4i_delete(std::vector&amp;lt;cv::Vec4i&amp;gt;* vector)
{
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec6f_new1
[32/64bit] std::vector<cv::Vec6f> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_Vec6f_new1
元DLLエクスポート名: vector_Vec6f_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Vec6f&amp;gt;*) vector_Vec6f_new1()
{
    return new std::vector&amp;lt;cv::Vec6f&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec6f_getSize
[32/64bit] vector_Vec6f_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_Vec6f_getSize
元DLLエクスポート名: vector_Vec6f_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_Vec6f_getSize(std::vector&amp;lt;cv::Vec6f&amp;gt;* vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec6f_getPointer
[32/64bit] std::vector<cv::Vec6f> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Vec6f_getPointer
元DLLエクスポート名: vector_Vec6f_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::Vec6f*) vector_Vec6f_getPointer(std::vector&amp;lt;cv::Vec6f&amp;gt;* vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Vec6f_delete
[32/64bit] std::vector<cv::Vec6f> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Vec6f_delete
元DLLエクスポート名: vector_Vec6f_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_Vec6f_delete(std::vector&amp;lt;cv::Vec6f&amp;gt;* vector)
{
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point2i_new1
[32/64bit] std::vector<cv::Point> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_Point2i_new1
元DLLエクスポート名: vector_Point2i_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Point&amp;gt;*) vector_Point2i_new1()
{
    return new std::vector&amp;lt;cv::Point&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point2i_new2
[32/64bit] std::vector<cv::Point> のインスタンスを生成します
%prm
p1
p1 = sptr : nuint size
%inst



元関数名(C#): vector_Point2i_new2
元DLLエクスポート名: vector_Point2i_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Point&amp;gt;*) vector_Point2i_new2(size_t size)
{
    return new std::vector&amp;lt;cv::Point&amp;gt;(size);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point2i_new3
[32/64bit] std::vector<cv::Point> のインスタンスを生成します
%prm
p1,p2
p1 = var : [In] Point[] data
p2 = sptr : nuint dataLength
%inst



元関数名(C#): vector_Point2i_new3
元DLLエクスポート名: vector_Point2i_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Point&amp;gt;*) vector_Point2i_new3(cv::Point* data, size_t dataLength)
{
    return new std::vector&amp;lt;cv::Point&amp;gt;(data, data + dataLength);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point2i_getSize
[32/64bit] vector_Point2i_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_Point2i_getSize
元DLLエクスポート名: vector_Point2i_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_Point2i_getSize(std::vector&amp;lt;cv::Point&amp;gt;* vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point2i_getPointer
[32/64bit] std::vector<cv::Point> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Point2i_getPointer
元DLLエクスポート名: vector_Point2i_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::Point*) vector_Point2i_getPointer(std::vector&amp;lt;cv::Point&amp;gt;* vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point2i_delete
[32/64bit] std::vector<cv::Point> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Point2i_delete
元DLLエクスポート名: vector_Point2i_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_Point2i_delete(std::vector&amp;lt;cv::Point&amp;gt;* vector)
{
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point2f_new1
[32/64bit] std::vector<cv::Point2f> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_Point2f_new1
元DLLエクスポート名: vector_Point2f_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Point2f&amp;gt;*) vector_Point2f_new1()
{
    return new std::vector&amp;lt;cv::Point2f&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point2f_new2
[32/64bit] std::vector<cv::Point2f> のインスタンスを生成します
%prm
p1
p1 = sptr : nuint size
%inst



元関数名(C#): vector_Point2f_new2
元DLLエクスポート名: vector_Point2f_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Point2f&amp;gt;*) vector_Point2f_new2(size_t size)
{
    return new std::vector&amp;lt;cv::Point2f&amp;gt;(size);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point2f_new3
[32/64bit] std::vector<cv::Point2f> のインスタンスを生成します
%prm
p1,p2
p1 = var : [In] Point2f[] data
p2 = sptr : nuint dataLength
%inst



元関数名(C#): vector_Point2f_new3
元DLLエクスポート名: vector_Point2f_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Point2f&amp;gt;*) vector_Point2f_new3(cv::Point2f* data, size_t dataLength)
{
    return new std::vector&amp;lt;cv::Point2f&amp;gt;(data, data + dataLength);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point2f_getSize
[32/64bit] vector_Point2f_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_Point2f_getSize
元DLLエクスポート名: vector_Point2f_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_Point2f_getSize(std::vector&amp;lt;cv::Point2f&amp;gt;* vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point2f_getPointer
[32/64bit] std::vector<cv::Point2f> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Point2f_getPointer
元DLLエクスポート名: vector_Point2f_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::Point2f*) vector_Point2f_getPointer(std::vector&amp;lt;cv::Point2f&amp;gt;* vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point2f_delete
[32/64bit] std::vector<cv::Point2f> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Point2f_delete
元DLLエクスポート名: vector_Point2f_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_Point2f_delete(std::vector&amp;lt;cv::Point2f&amp;gt;* vector)
{
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point2d_new1
[32/64bit] std::vector<cv::Point2d> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_Point2d_new1
元DLLエクスポート名: vector_Point2d_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Point2d&amp;gt;*) vector_Point2d_new1()
{
    return new std::vector&amp;lt;cv::Point2d&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point2d_getSize
[32/64bit] vector_Point2d_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_Point2d_getSize
元DLLエクスポート名: vector_Point2d_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_Point2d_getSize(std::vector&amp;lt;cv::Point2d&amp;gt;* vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point2d_getPointer
[32/64bit] std::vector<cv::Point2d> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Point2d_getPointer
元DLLエクスポート名: vector_Point2d_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::Point2d*) vector_Point2d_getPointer(std::vector&amp;lt;cv::Point2d&amp;gt;* vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point2d_delete
[32/64bit] std::vector<cv::Point2d> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Point2d_delete
元DLLエクスポート名: vector_Point2d_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_Point2d_delete(std::vector&amp;lt;cv::Point2d&amp;gt;* vector)
{
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point3f_new1
[32/64bit] std::vector<cv::Point3f> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_Point3f_new1
元DLLエクスポート名: vector_Point3f_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Point3f&amp;gt;*) vector_Point3f_new1()
{
    return new std::vector&amp;lt;cv::Point3f&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point3f_new2
[32/64bit] std::vector<cv::Point3f> のインスタンスを生成します
%prm
p1
p1 = sptr : nuint size
%inst



元関数名(C#): vector_Point3f_new2
元DLLエクスポート名: vector_Point3f_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Point3f&amp;gt;*) vector_Point3f_new2(size_t size)
{
    return new std::vector&amp;lt;cv::Point3f&amp;gt;(size);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point3f_new3
[32/64bit] std::vector<cv::Point3f> のインスタンスを生成します
%prm
p1,p2
p1 = var : [In] Point3f[] data
p2 = sptr : nuint dataLength
%inst



元関数名(C#): vector_Point3f_new3
元DLLエクスポート名: vector_Point3f_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Point3f&amp;gt;*) vector_Point3f_new3(cv::Point3f* data, size_t dataLength)
{
    return new std::vector&amp;lt;cv::Point3f&amp;gt;(data, data + dataLength);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point3f_getSize
[32/64bit] vector_Point3f_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_Point3f_getSize
元DLLエクスポート名: vector_Point3f_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_Point3f_getSize(std::vector&amp;lt;cv::Point3f&amp;gt;* vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point3f_getPointer
[32/64bit] std::vector<cv::Point3f> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Point3f_getPointer
元DLLエクスポート名: vector_Point3f_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::Point3f*) vector_Point3f_getPointer(std::vector&amp;lt;cv::Point3f&amp;gt;* vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Point3f_delete
[32/64bit] std::vector<cv::Point3f> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Point3f_delete
元DLLエクスポート名: vector_Point3f_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_Point3f_delete(std::vector&amp;lt;cv::Point3f&amp;gt;* vector)
{
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Rect_new1
[32/64bit] new std::vector<cv::Rect> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_Rect_new1
元DLLエクスポート名: vector_Rect_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Rect&amp;gt;*) vector_Rect_new1()
{
    return new std::vector&amp;lt;cv::Rect&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Rect_new2
[32/64bit] new std::vector<cv::Rect> のインスタンスを生成します
%prm
p1
p1 = sptr : nuint size
%inst



元関数名(C#): vector_Rect_new2
元DLLエクスポート名: vector_Rect_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Rect&amp;gt;*) vector_Rect_new2(size_t size)
{
    return new std::vector&amp;lt;cv::Rect&amp;gt;(size);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Rect_new3
[32/64bit] new std::vector<cv::Rect> のインスタンスを生成します
%prm
p1,p2
p1 = var : [In] Rect[] data
p2 = sptr : nuint dataLength
%inst



元関数名(C#): vector_Rect_new3
元DLLエクスポート名: vector_Rect_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Rect&amp;gt;*) vector_Rect_new3(cv::Rect* data, size_t dataLength)
{
    return new std::vector&amp;lt;cv::Rect&amp;gt;(data, data + dataLength);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Rect_getSize
[32/64bit] vector_Rect_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_Rect_getSize
元DLLエクスポート名: vector_Rect_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_Rect_getSize(std::vector&amp;lt;cv::Rect&amp;gt;* vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Rect_getPointer
[32/64bit] new std::vector<cv::Rect> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Rect_getPointer
元DLLエクスポート名: vector_Rect_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::Rect*) vector_Rect_getPointer(std::vector&amp;lt;cv::Rect&amp;gt; *vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Rect_delete
[32/64bit] new std::vector<cv::Rect> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Rect_delete
元DLLエクスポート名: vector_Rect_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_Rect_delete(std::vector&amp;lt;cv::Rect&amp;gt; *vector)
{    
    //vector-&amp;gt;~vector();
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Rect2d_new1
[32/64bit] std::vector<cv::Rect2d> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_Rect2d_new1
元DLLエクスポート名: vector_Rect2d_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Rect2d&amp;gt;*) vector_Rect2d_new1()
{
    return new std::vector&amp;lt;cv::Rect2d&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Rect2d_new2
[32/64bit] std::vector<cv::Rect2d> のインスタンスを生成します
%prm
p1
p1 = sptr : nuint size
%inst



元関数名(C#): vector_Rect2d_new2
元DLLエクスポート名: vector_Rect2d_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Rect2d&amp;gt;*) vector_Rect2d_new2(size_t size)
{
    return new std::vector&amp;lt;cv::Rect2d&amp;gt;(size);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Rect2d_new3
[32/64bit] std::vector<cv::Rect2d> のインスタンスを生成します
%prm
p1,p2
p1 = var : [In] Rect2d[] data
p2 = sptr : nuint dataLength
%inst



元関数名(C#): vector_Rect2d_new3
元DLLエクスポート名: vector_Rect2d_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Rect2d&amp;gt;*) vector_Rect2d_new3(cv::Rect2d* data, size_t dataLength)
{
    return new std::vector&amp;lt;cv::Rect2d&amp;gt;(data, data + dataLength);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Rect2d_getSize
[32/64bit] vector_Rect2d_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_Rect2d_getSize
元DLLエクスポート名: vector_Rect2d_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_Rect2d_getSize(std::vector&amp;lt;cv::Rect2d&amp;gt;* vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Rect2d_getPointer
[32/64bit] std::vector<cv::Rect2d> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Rect2d_getPointer
元DLLエクスポート名: vector_Rect2d_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::Rect2d*) vector_Rect2d_getPointer(std::vector&amp;lt;cv::Rect2d&amp;gt; *vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Rect2d_delete
[32/64bit] std::vector<cv::Rect2d> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Rect2d_delete
元DLLエクスポート名: vector_Rect2d_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_Rect2d_delete(std::vector&amp;lt;cv::Rect2d&amp;gt; *vector)
{
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_RotatedRect_new1
[32/64bit] std::vector<cv::RotatedRect> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_RotatedRect_new1
元DLLエクスポート名: vector_RotatedRect_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::RotatedRect&amp;gt;*) vector_RotatedRect_new1()
{
    return new std::vector&amp;lt;cv::RotatedRect&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_RotatedRect_new2
[32/64bit] std::vector<cv::RotatedRect> のインスタンスを生成します
%prm
p1
p1 = sptr : nuint size
%inst



元関数名(C#): vector_RotatedRect_new2
元DLLエクスポート名: vector_RotatedRect_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::RotatedRect&amp;gt;*) vector_RotatedRect_new2(size_t size)
{
    return new std::vector&amp;lt;cv::RotatedRect&amp;gt;(size);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_RotatedRect_new3
[32/64bit] std::vector<cv::RotatedRect> のインスタンスを生成します
%prm
p1,p2
p1 = var : [In] RotatedRect[] data
p2 = sptr : nuint dataLength
%inst



元関数名(C#): vector_RotatedRect_new3
元DLLエクスポート名: vector_RotatedRect_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::RotatedRect&amp;gt;*) vector_RotatedRect_new3(cv::RotatedRect* data, size_t dataLength)
{
    return new std::vector&amp;lt;cv::RotatedRect&amp;gt;(data, data + dataLength);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_RotatedRect_getSize
[32/64bit] vector_RotatedRect_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_RotatedRect_getSize
元DLLエクスポート名: vector_RotatedRect_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_RotatedRect_getSize(std::vector&amp;lt;cv::RotatedRect&amp;gt;* vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_RotatedRect_getPointer
[32/64bit] std::vector<cv::RotatedRect> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_RotatedRect_getPointer
元DLLエクスポート名: vector_RotatedRect_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::RotatedRect*) vector_RotatedRect_getPointer(std::vector&amp;lt;cv::RotatedRect&amp;gt; *vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_RotatedRect_delete
[32/64bit] std::vector<cv::RotatedRect> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_RotatedRect_delete
元DLLエクスポート名: vector_RotatedRect_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_RotatedRect_delete(std::vector&amp;lt;cv::RotatedRect&amp;gt; *vector)
{
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_KeyPoint_new1
[32/64bit] std::vector<cv::KeyPoint> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_KeyPoint_new1
元DLLエクスポート名: vector_KeyPoint_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::KeyPoint&amp;gt;*) vector_KeyPoint_new1()
{
    return new std::vector&amp;lt;cv::KeyPoint&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_KeyPoint_new2
[32/64bit] std::vector<cv::KeyPoint> のインスタンスを生成します
%prm
p1
p1 = sptr : nuint size
%inst



元関数名(C#): vector_KeyPoint_new2
元DLLエクスポート名: vector_KeyPoint_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::KeyPoint&amp;gt;*) vector_KeyPoint_new2(size_t size)
{
    return new std::vector&amp;lt;cv::KeyPoint&amp;gt;(size);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_KeyPoint_new3
[32/64bit] std::vector<cv::KeyPoint> のインスタンスを生成します
%prm
p1,p2
p1 = var : [In]KeyPoint[] data
p2 = sptr : nuint dataLength
%inst



元関数名(C#): vector_KeyPoint_new3
元DLLエクスポート名: vector_KeyPoint_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::KeyPoint&amp;gt;*) vector_KeyPoint_new3(cv::KeyPoint *data, size_t dataLength)
{
    return new std::vector&amp;lt;cv::KeyPoint&amp;gt;(data, data + dataLength);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_KeyPoint_getSize
[32/64bit] vector_KeyPoint_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_KeyPoint_getSize
元DLLエクスポート名: vector_KeyPoint_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_KeyPoint_getSize(std::vector&amp;lt;cv::KeyPoint&amp;gt;* vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_KeyPoint_getPointer
[32/64bit] std::vector<cv::KeyPoint> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_KeyPoint_getPointer
元DLLエクスポート名: vector_KeyPoint_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::KeyPoint*) vector_KeyPoint_getPointer(std::vector&amp;lt;cv::KeyPoint&amp;gt;* vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_KeyPoint_delete
[32/64bit] std::vector<cv::KeyPoint> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_KeyPoint_delete
元DLLエクスポート名: vector_KeyPoint_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_KeyPoint_delete(std::vector&amp;lt;cv::KeyPoint&amp;gt;* vector)
{    
    //vector-&amp;gt;~vector();
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_DMatch_new1
[32/64bit] std::vector<cv::DMatch> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_DMatch_new1
元DLLエクスポート名: vector_DMatch_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::DMatch&amp;gt;*) vector_DMatch_new1()
{
    return new std::vector&amp;lt;cv::DMatch&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_DMatch_new2
[32/64bit] std::vector<cv::DMatch> のインスタンスを生成します
%prm
p1
p1 = sptr : nuint size
%inst



元関数名(C#): vector_DMatch_new2
元DLLエクスポート名: vector_DMatch_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::DMatch&amp;gt;*) vector_DMatch_new2(size_t size)
{
    return new std::vector&amp;lt;cv::DMatch&amp;gt;(size);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_DMatch_new3
[32/64bit] std::vector<cv::DMatch> のインスタンスを生成します
%prm
p1,p2
p1 = var : [In] DMatch[] data
p2 = sptr : nuint dataLength
%inst



元関数名(C#): vector_DMatch_new3
元DLLエクスポート名: vector_DMatch_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::DMatch&amp;gt;*) vector_DMatch_new3(cv::DMatch *data, size_t dataLength)
{
    return new std::vector&amp;lt;cv::DMatch&amp;gt;(data, data + dataLength);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_DMatch_getSize
[32/64bit] vector_DMatch_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_DMatch_getSize
元DLLエクスポート名: vector_DMatch_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_DMatch_getSize(std::vector&amp;lt;cv::DMatch&amp;gt;* vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_DMatch_getPointer
[32/64bit] std::vector<cv::DMatch> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_DMatch_getPointer
元DLLエクスポート名: vector_DMatch_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::DMatch*) vector_DMatch_getPointer(std::vector&amp;lt;cv::DMatch&amp;gt;* vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_DMatch_delete
[32/64bit] std::vector<cv::DMatch> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_DMatch_delete
元DLLエクスポート名: vector_DMatch_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_DMatch_delete(std::vector&amp;lt;cv::DMatch&amp;gt;* vector)
{
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Mat_new1
[32/64bit] std::vector<cv::Mat> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_Mat_new1
元DLLエクスポート名: vector_Mat_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Mat&amp;gt;*) vector_Mat_new1()
{
    return new std::vector&amp;lt;cv::Mat&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Mat_new2
[32/64bit] std::vector<cv::Mat> のインスタンスを生成します
%prm
p1
p1 = int : uint size
%inst



元関数名(C#): vector_Mat_new2
元DLLエクスポート名: vector_Mat_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Mat&amp;gt;*) vector_Mat_new2(uint32_t size)
{
    return new std::vector&amp;lt;cv::Mat&amp;gt;(size);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Mat_new3
[32/64bit] std::vector<cv::Mat> のインスタンスを生成します
%prm
p1,p2
p1 = sptr : IntPtr[] data
p2 = int : uint dataLength
%inst



元関数名(C#): vector_Mat_new3
元DLLエクスポート名: vector_Mat_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::Mat&amp;gt;*) vector_Mat_new3(cv::Mat **data, uint32_t dataLength)
{
    auto *vec = new std::vector&amp;lt;cv::Mat&amp;gt;(dataLength);
    for (size_t i = 0; i &amp;lt; dataLength; i++)
    {
        (*vec)[i] = *(data[i]);
    }
    return vec;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Mat_getSize
[32/64bit] vector_Mat_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_Mat_getSize
元DLLエクスポート名: vector_Mat_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_Mat_getSize(std::vector&amp;lt;cv::Mat&amp;gt;* vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Mat_getPointer
[32/64bit] std::vector<cv::Mat> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Mat_getPointer
元DLLエクスポート名: vector_Mat_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::Mat*) vector_Mat_getPointer(std::vector&amp;lt;cv::Mat&amp;gt;* vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Mat_delete
[32/64bit] std::vector<cv::Mat> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_Mat_delete
元DLLエクスポート名: vector_Mat_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_Mat_delete(std::vector&amp;lt;cv::Mat&amp;gt;* vector)
{
    //vector-&amp;gt;~vector();
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_Mat_assignToArray
[32/64bit] vector_Mat_assignToArray
%prm
p1,p2
p1 = sptr : IntPtr vector
p2 = sptr : [MarshalAs(UnmanagedType.LPArray)] IntPtr[] arr
%inst
元関数名(C#): vector_Mat_assignToArray
元DLLエクスポート名: vector_Mat_assignToArray
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_Mat_assignToArray(std::vector&amp;lt;cv::Mat&amp;gt;* vector, cv::Mat** arr)
{
    for (size_t i = 0; i &amp;lt; vector-&amp;gt;size(); i++)
    {
        (vector-&amp;gt;at(i)).assignTo(*(arr[i]));
    }
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_DTrees_Node_new1
[32/64bit] std::vector<cv::ml::DTrees::Node> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_DTrees_Node_new1
元DLLエクスポート名: vector_DTrees_Node_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::ml::DTrees::Node&amp;gt;*) vector_DTrees_Node_new1()
{
    return new std::vector&amp;lt;cv::ml::DTrees::Node&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_DTrees_Node_getSize
[32/64bit] vector_DTrees_Node_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_DTrees_Node_getSize
元DLLエクスポート名: vector_DTrees_Node_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_DTrees_Node_getSize(std::vector&amp;lt;cv::ml::DTrees::Node&amp;gt; *vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_DTrees_Node_getPointer
[32/64bit] std::vector<cv::ml::DTrees::Node> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_DTrees_Node_getPointer
元DLLエクスポート名: vector_DTrees_Node_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::ml::DTrees::Node*) vector_DTrees_Node_getPointer(std::vector&amp;lt;cv::ml::DTrees::Node&amp;gt; *vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_DTrees_Node_delete
[32/64bit] std::vector<cv::ml::DTrees::Node> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_DTrees_Node_delete
元DLLエクスポート名: vector_DTrees_Node_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_DTrees_Node_delete(std::vector&amp;lt;cv::ml::DTrees::Node&amp;gt; *vector)
{
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_DTrees_Split_new1
[32/64bit] std::vector<cv::ml::DTrees::Split> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_DTrees_Split_new1
元DLLエクスポート名: vector_DTrees_Split_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::ml::DTrees::Split&amp;gt;*) vector_DTrees_Split_new1()
{
    return new std::vector&amp;lt;cv::ml::DTrees::Split&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_DTrees_Split_getSize
[32/64bit] vector_DTrees_Split_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_DTrees_Split_getSize
元DLLエクスポート名: vector_DTrees_Split_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_DTrees_Split_getSize(std::vector&amp;lt;cv::ml::DTrees::Split&amp;gt; *vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_DTrees_Split_getPointer
[32/64bit] std::vector<cv::ml::DTrees::Split> のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_DTrees_Split_getPointer
元DLLエクスポート名: vector_DTrees_Split_getPointer
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::ml::DTrees::Split*) vector_DTrees_Split_getPointer(std::vector&amp;lt;cv::ml::DTrees::Split&amp;gt; *vector)
{
    return &amp;(vector-&amp;gt;at(0));
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_DTrees_Split_delete
[32/64bit] std::vector<cv::ml::DTrees::Split> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_DTrees_Split_delete
元DLLエクスポート名: vector_DTrees_Split_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_DTrees_Split_delete(std::vector&amp;lt;cv::ml::DTrees::Split&amp;gt; *vector)
{
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_ImageFeatures_new1
[32/64bit] std::vector<cv::detail::ImageFeatures> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_ImageFeatures_new1
元DLLエクスポート名: vector_ImageFeatures_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;cv::detail::ImageFeatures&amp;gt;*) vector_ImageFeatures_new1()
{
    return new std::vector&amp;lt;cv::detail::ImageFeatures&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_ImageFeatures_getSize
[32/64bit] vector_ImageFeatures_getSize
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_ImageFeatures_getSize
元DLLエクスポート名: vector_ImageFeatures_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_ImageFeatures_getSize(
    std::vector&amp;lt;cv::detail::ImageFeatures&amp;gt;* vector)
{
    return vector-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_ImageFeatures_getKeypointsSize
[32/64bit] vector_ImageFeatures_getKeypointsSize
%prm
p1,p2
p1 = sptr : IntPtr vector
p2 = var : [Out] nuint[] dst
%inst
元関数名(C#): vector_ImageFeatures_getKeypointsSize
元DLLエクスポート名: vector_ImageFeatures_getKeypointsSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_ImageFeatures_getKeypointsSize(
    std::vector&amp;lt;cv::detail::ImageFeatures&amp;gt;* vector, size_t *dst)
{
    for (size_t i = 0; i &amp;lt; vector-&amp;gt;size(); i++) 
    {
        dst[i] = vector-&amp;gt;at(i).keypoints.size();
    }
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_ImageFeatures_getElements
[32/64bit] vector_ImageFeatures_getElements
%prm
p1,p2
p1 = sptr : IntPtr vector
p2 = var : [Out] WImageFeatures[] dst
%inst
元関数名(C#): vector_ImageFeatures_getElements
元DLLエクスポート名: vector_ImageFeatures_getElements
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_ImageFeatures_getElements(
    std::vector&amp;lt;cv::detail::ImageFeatures&amp;gt;* vector, detail_ImageFeatures* dstArray)
{
    for (size_t i = 0; i &amp;lt; vector-&amp;gt;size(); i++)
    {
        const auto &amp;src = vector-&amp;gt;at(i);
        auto &amp;dst = dstArray[i];
        dst.img_idx = src.img_idx;
        dst.img_size = c(src.img_size);
        //std::memcpy(dst.keypoints, &amp;src.keypoints[0], sizeof(cv::KeyPoint)*src.keypoints.size());
        std::copy(src.keypoints.begin(), src.keypoints.end(), std::back_inserter(*dst.keypoints));
        src.descriptors.copyTo(*dst.descriptors);
    }
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_ImageFeatures_delete
[32/64bit] std::vector<cv::detail::ImageFeatures> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_ImageFeatures_delete
元DLLエクスポート名: vector_ImageFeatures_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_ImageFeatures_delete(std::vector&amp;lt;cv::detail::ImageFeatures&amp;gt;* vector)
{
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_uchar_new1
[32/64bit] std::vector<std::vector<uchar>> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_vector_uchar_new1
元DLLエクスポート名: vector_vector_uchar_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;std::vector&amp;lt;uchar&amp;gt; &amp;gt;*) vector_vector_uchar_new1()
{
    return new std::vector&amp;lt;std::vector&amp;lt;uchar&amp;gt; &amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_uchar_getSize1
[32/64bit] vector_vector_uchar_getSize1
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_vector_uchar_getSize1
元DLLエクスポート名: vector_vector_uchar_getSize1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_vector_uchar_getSize1(std::vector&amp;lt;std::vector&amp;lt;uchar&amp;gt; &amp;gt;* vec)
{
    return vec-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_uchar_getSize2
[32/64bit] vector_vector_uchar_getSize2
%prm
p1,p2
p1 = sptr : IntPtr vector
p2 = var : [In, Out] nuint[] size
%inst
元関数名(C#): vector_vector_uchar_getSize2
元DLLエクスポート名: vector_vector_uchar_getSize2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_uchar_getSize2(std::vector&amp;lt;std::vector&amp;lt;uchar&amp;gt; &amp;gt;* vec, size_t* sizes)
{
    for (size_t i = 0; i &amp;lt; vec-&amp;gt;size(); i++)
    {
        sizes[i] = vec-&amp;gt;at(i).size();
    }
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_uchar_copy
[32/64bit] std::vector<std::vector<uchar>> をメモリコピーします
%prm
p1,p2
p1 = sptr : IntPtr vec
p2 = sptr : IntPtr[] dst
%inst



元関数名(C#): vector_vector_uchar_copy
元DLLエクスポート名: vector_vector_uchar_copy
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_uchar_copy(std::vector&amp;lt;std::vector&amp;lt;uchar&amp;gt; &amp;gt;* vec, uchar** dst)
{
    for (size_t i = 0; i &amp;lt; vec-&amp;gt;size(); i++)
    {
        auto&amp; elem = vec-&amp;gt;at(i);
        void* src = &amp;elem[0];
        const auto length = sizeof(int) * elem.size();
        memcpy(dst[i], src, length);
    }
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_uchar_delete
[32/64bit] std::vector<std::vector<uchar>> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_vector_uchar_delete
元DLLエクスポート名: vector_vector_uchar_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_uchar_delete(std::vector&amp;lt;std::vector&amp;lt;uchar&amp;gt; &amp;gt;* vec)
{
    delete vec;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_int_new1
[32/64bit] std::vector<std::vector<int>> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_vector_int_new1
元DLLエクスポート名: vector_vector_int_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt;*) vector_vector_int_new1()
{
    return new std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_int_getSize1
[32/64bit] vector_vector_int_getSize1
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_vector_int_getSize1
元DLLエクスポート名: vector_vector_int_getSize1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_vector_int_getSize1(std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt;* vec)
{
    return vec-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_int_getSize2
[32/64bit] vector_vector_int_getSize2
%prm
p1,p2
p1 = sptr : IntPtr vector
p2 = var : [In, Out] nuint[] size
%inst
元関数名(C#): vector_vector_int_getSize2
元DLLエクスポート名: vector_vector_int_getSize2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_int_getSize2(std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt;* vec, size_t* sizes)
{
    for (size_t i = 0; i &amp;lt; vec-&amp;gt;size(); i++)
    {
        sizes[i] = vec-&amp;gt;at(i).size();
    }
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_int_copy
[32/64bit] std::vector<std::vector<int>> をメモリコピーします
%prm
p1,p2
p1 = sptr : IntPtr vec
p2 = sptr : IntPtr[] dst
%inst



元関数名(C#): vector_vector_int_copy
元DLLエクスポート名: vector_vector_int_copy
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_int_copy(std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt;* vec, int** dst)
{
    for (size_t i = 0; i &amp;lt; vec-&amp;gt;size(); i++)
    {
        auto&amp; elem = vec-&amp;gt;at(i);
        void* src = &amp;elem[0];
        const auto length = sizeof(int) * elem.size();
        memcpy(dst[i], src, length);
    }
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_int_delete
[32/64bit] std::vector<std::vector<int>> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_vector_int_delete
元DLLエクスポート名: vector_vector_int_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_int_delete(std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt;* vec)
{
    delete vec;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_double_new1
[32/64bit] std::vector<std::vector<double>> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_vector_double_new1
元DLLエクスポート名: vector_vector_double_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;std::vector&amp;lt;double&amp;gt; &amp;gt;*) vector_vector_double_new1()
{
    return new std::vector&amp;lt;std::vector&amp;lt;double&amp;gt; &amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_double_getSize1
[32/64bit] vector_vector_double_getSize1
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_vector_double_getSize1
元DLLエクスポート名: vector_vector_double_getSize1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_vector_double_getSize1(std::vector&amp;lt;std::vector&amp;lt;double&amp;gt; &amp;gt;* vec)
{
    return vec-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_double_getSize2
[32/64bit] vector_vector_double_getSize2
%prm
p1,p2
p1 = sptr : IntPtr vector
p2 = var : [In, Out] nuint[] size
%inst
元関数名(C#): vector_vector_double_getSize2
元DLLエクスポート名: vector_vector_double_getSize2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_double_getSize2(std::vector&amp;lt;std::vector&amp;lt;double&amp;gt; &amp;gt;* vec, size_t* sizes)
{
    for (size_t i = 0; i &amp;lt; vec-&amp;gt;size(); i++)
    {
        sizes[i] = vec-&amp;gt;at(i).size();
    }
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_double_copy
[32/64bit] std::vector<std::vector<double>> をメモリコピーします
%prm
p1,p2
p1 = sptr : IntPtr vec
p2 = sptr : IntPtr[] dst
%inst



元関数名(C#): vector_vector_double_copy
元DLLエクスポート名: vector_vector_double_copy
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_double_copy(std::vector&amp;lt;std::vector&amp;lt;double&amp;gt; &amp;gt;* vec, double** dst)
{
    for (size_t i = 0; i &amp;lt; vec-&amp;gt;size(); i++)
    {
        std::vector&amp;lt;double&amp;gt;&amp; elem = vec-&amp;gt;at(i);
        void* src = &amp;elem[0];
        const size_t length = sizeof(double) * elem.size();
        memcpy(dst[i], src, length);
    }
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_double_delete
[32/64bit] std::vector<std::vector<double>> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_vector_double_delete
元DLLエクスポート名: vector_vector_double_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_double_delete(std::vector&amp;lt;std::vector&amp;lt;double&amp;gt; &amp;gt;* vec)
{
    delete vec;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_KeyPoint_new1
[32/64bit] std::vector<std::vector<cv::KeyPoint>> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_vector_KeyPoint_new1
元DLLエクスポート名: vector_vector_KeyPoint_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;std::vector&amp;lt;cv::KeyPoint&amp;gt; &amp;gt;*) vector_vector_KeyPoint_new1()
{
    return new std::vector&amp;lt;std::vector&amp;lt;cv::KeyPoint&amp;gt; &amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_KeyPoint_new3
[32/64bit] std::vector<std::vector<cv::KeyPoint>> のインスタンスを生成します
%prm
p1,p2,p3
p1 = sptr : IntPtr[] values
p2 = int : int size1
p3 = var : int[] size2
%inst



元関数名(C#): vector_vector_KeyPoint_new3
元DLLエクスポート名: vector_vector_KeyPoint_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;std::vector&amp;lt;cv::KeyPoint&amp;gt; &amp;gt;*) vector_vector_KeyPoint_new3(
    cv::KeyPoint** values, int size1, int* size2)
{
    std::vector&amp;lt;std::vector&amp;lt;cv::KeyPoint&amp;gt; &amp;gt;* vec = new std::vector&amp;lt;std::vector&amp;lt;cv::KeyPoint&amp;gt; &amp;gt;(size1);
    for (int i = 0; i &amp;lt; size1; i++)
    {
        vec-&amp;gt;at(i) = std::vector&amp;lt;cv::KeyPoint&amp;gt;(values[i], values[i] + size2[i]);
    }
    return vec;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_KeyPoint_getSize1
[32/64bit] vector_vector_KeyPoint_getSize1
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_vector_KeyPoint_getSize1
元DLLエクスポート名: vector_vector_KeyPoint_getSize1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_vector_KeyPoint_getSize1(std::vector&amp;lt;std::vector&amp;lt;cv::KeyPoint&amp;gt; &amp;gt;* vec)
{
    return vec-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_KeyPoint_getSize2
[32/64bit] vector_vector_KeyPoint_getSize2
%prm
p1,p2
p1 = sptr : IntPtr vector
p2 = var : [In, Out] nuint[] size
%inst
元関数名(C#): vector_vector_KeyPoint_getSize2
元DLLエクスポート名: vector_vector_KeyPoint_getSize2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_KeyPoint_getSize2(std::vector&amp;lt;std::vector&amp;lt;cv::KeyPoint&amp;gt; &amp;gt;* vec, size_t* sizes)
{
    for (size_t i = 0; i &amp;lt; vec-&amp;gt;size(); i++)
    {
        sizes[i] = vec-&amp;gt;at(i).size();
    }
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_KeyPoint_copy
[32/64bit] std::vector<std::vector<cv::KeyPoint>> をメモリコピーします
%prm
p1,p2
p1 = sptr : IntPtr vec
p2 = sptr : IntPtr[] dst
%inst



元関数名(C#): vector_vector_KeyPoint_copy
元DLLエクスポート名: vector_vector_KeyPoint_copy
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_KeyPoint_copy(std::vector&amp;lt;std::vector&amp;lt;cv::KeyPoint&amp;gt; &amp;gt;* vec, cv::KeyPoint** dst)
{
    copyFromVectorToArray(vec, dst);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_KeyPoint_delete
[32/64bit] std::vector<std::vector<cv::KeyPoint>> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_vector_KeyPoint_delete
元DLLエクスポート名: vector_vector_KeyPoint_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_KeyPoint_delete(std::vector&amp;lt;std::vector&amp;lt;cv::KeyPoint&amp;gt; &amp;gt;* vec)
{
    delete vec;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_DMatch_new1
[32/64bit] std::vector<std::vector<cv::DMatch>> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_vector_DMatch_new1
元DLLエクスポート名: vector_vector_DMatch_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;std::vector&amp;lt;cv::DMatch&amp;gt; &amp;gt;*) vector_vector_DMatch_new1()
{
    return new std::vector&amp;lt;std::vector&amp;lt;cv::DMatch&amp;gt; &amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_DMatch_getSize1
[32/64bit] vector_vector_DMatch_getSize1
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_vector_DMatch_getSize1
元DLLエクスポート名: vector_vector_DMatch_getSize1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_vector_DMatch_getSize1(std::vector&amp;lt;std::vector&amp;lt;cv::DMatch&amp;gt; &amp;gt;* vec)
{
    return vec-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_DMatch_getSize2
[32/64bit] vector_vector_DMatch_getSize2
%prm
p1,p2
p1 = sptr : IntPtr vector
p2 = var : [In, Out] nuint[] size
%inst
元関数名(C#): vector_vector_DMatch_getSize2
元DLLエクスポート名: vector_vector_DMatch_getSize2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_DMatch_getSize2(std::vector&amp;lt;std::vector&amp;lt;cv::DMatch&amp;gt; &amp;gt;* vec, size_t* sizes)
{
    for (size_t i = 0; i &amp;lt; vec-&amp;gt;size(); i++)
    {
        sizes[i] = vec-&amp;gt;at(i).size();
    }
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_DMatch_copy
[32/64bit] std::vector<std::vector<cv::DMatch>> をメモリコピーします
%prm
p1,p2
p1 = sptr : IntPtr vec
p2 = sptr : IntPtr[] dst
%inst



元関数名(C#): vector_vector_DMatch_copy
元DLLエクスポート名: vector_vector_DMatch_copy
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_DMatch_copy(std::vector&amp;lt;std::vector&amp;lt;cv::DMatch&amp;gt; &amp;gt;* vec, cv::DMatch** dst)
{
    copyFromVectorToArray(vec, dst);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_DMatch_delete
[32/64bit] std::vector<std::vector<cv::DMatch>> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_vector_DMatch_delete
元DLLエクスポート名: vector_vector_DMatch_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_DMatch_delete(std::vector&amp;lt;std::vector&amp;lt;cv::DMatch&amp;gt; &amp;gt;* vec)
{
    delete vec;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_Point_new1
[32/64bit] std::vector<std::vector<cv::Point>> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_vector_Point_new1
元DLLエクスポート名: vector_vector_Point_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt; &amp;gt;*) vector_vector_Point_new1()
{
    return new std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt; &amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_Point_new2
[32/64bit] std::vector<std::vector<cv::Point>> のインスタンスを生成します
%prm
p1
p1 = sptr : nuint size
%inst



元関数名(C#): vector_vector_Point_new2
元DLLエクスポート名: vector_vector_Point_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt; &amp;gt;*) vector_vector_Point_new2(size_t size)
{
    return new std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt; &amp;gt;(size);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_Point_getSize1
[32/64bit] vector_vector_Point_getSize1
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_vector_Point_getSize1
元DLLエクスポート名: vector_vector_Point_getSize1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_vector_Point_getSize1(std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt; &amp;gt;* vec)
{
    return vec-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_Point_getSize2
[32/64bit] vector_vector_Point_getSize2
%prm
p1,p2
p1 = sptr : IntPtr vector
p2 = var : [In, Out] nuint[] size
%inst
元関数名(C#): vector_vector_Point_getSize2
元DLLエクスポート名: vector_vector_Point_getSize2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_Point_getSize2(std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt; &amp;gt;* vec, size_t* sizes)
{
    for (size_t i = 0; i &amp;lt; vec-&amp;gt;size(); i++)
    {
        sizes[i] = vec-&amp;gt;at(i).size();
    }
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_Point_copy
[32/64bit] std::vector<std::vector<cv::Point>> をメモリコピーします
%prm
p1,p2
p1 = sptr : IntPtr vec
p2 = sptr : IntPtr[] dst
%inst



元関数名(C#): vector_vector_Point_copy
元DLLエクスポート名: vector_vector_Point_copy
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_Point_copy(std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt; &amp;gt;* vec, cv::Point** dst)
{
    copyFromVectorToArray(vec, dst);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_Point_delete
[32/64bit] std::vector<std::vector<cv::Point>> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_vector_Point_delete
元DLLエクスポート名: vector_vector_Point_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_Point_delete(std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt; &amp;gt;* vec)
{
    delete vec;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_Point2f_new1
[32/64bit] std::vector<std::vector<cv::Point2f>> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_vector_Point2f_new1
元DLLエクスポート名: vector_vector_Point2f_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt;*) vector_vector_Point2f_new1()
{
    return new std::vector&amp;lt;std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_Point2f_getSize1
[32/64bit] vector_vector_Point2f_getSize1
%prm
p1
p1 = sptr : IntPtr vector
%inst
元関数名(C#): vector_vector_Point2f_getSize1
元DLLエクスポート名: vector_vector_Point2f_getSize1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_vector_Point2f_getSize1(std::vector&amp;lt;std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt;* vec)
{
    return vec-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_Point2f_getSize2
[32/64bit] vector_vector_Point2f_getSize2
%prm
p1,p2
p1 = sptr : IntPtr vector
p2 = var : [In, Out] nuint[] size
%inst
元関数名(C#): vector_vector_Point2f_getSize2
元DLLエクスポート名: vector_vector_Point2f_getSize2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_Point2f_getSize2(std::vector&amp;lt;std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt;* vec, size_t* sizes)
{
    for (size_t i = 0; i &amp;lt; vec-&amp;gt;size(); i++)
    {
        sizes[i] = vec-&amp;gt;at(i).size();
    }
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_Point2f_copy
[32/64bit] std::vector<std::vector<cv::Point2f>> をメモリコピーします
%prm
p1,p2
p1 = sptr : IntPtr vec
p2 = sptr : IntPtr[] dst
%inst



元関数名(C#): vector_vector_Point2f_copy
元DLLエクスポート名: vector_vector_Point2f_copy
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_Point2f_copy(std::vector&amp;lt;std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt;* vec, cv::Point2f** dst)
{
    copyFromVectorToArray(vec, dst);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_vector_Point2f_delete
[32/64bit] std::vector<std::vector<cv::Point2f>> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_vector_Point2f_delete
元DLLエクスポート名: vector_vector_Point2f_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_vector_Point2f_delete(std::vector&amp;lt;std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt;* vec)
{
    delete vec;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_string_new1
[32/64bit] std::vector<std::string> のインスタンスを生成します
%prm

%inst



元関数名(C#): vector_string_new1
元DLLエクスポート名: vector_string_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;std::string&amp;gt;*) vector_string_new1()
{
    return new std::vector&amp;lt;std::string&amp;gt;;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_string_new2
[32/64bit] std::vector<std::string> のインスタンスを生成します
%prm
p1
p1 = sptr : nuint size
%inst



元関数名(C#): vector_string_new2
元DLLエクスポート名: vector_string_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(std::vector&amp;lt;std::string&amp;gt;*) vector_string_new2(size_t size)
{
    return new std::vector&amp;lt;std::string&amp;gt;(size);
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_string_getSize
[32/64bit] vector_string_getSize
%prm
p1
p1 = sptr : IntPtr vec
%inst
元関数名(C#): vector_string_getSize
元DLLエクスポート名: vector_string_getSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(size_t) vector_string_getSize(std::vector&amp;lt;std::string&amp;gt;* vec)
{
    return vec-&amp;gt;size();
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_string_getElements
[32/64bit] vector_string_getElements
%prm
p1,p2,p3
p1 = sptr : IntPtr vector
p2 = sptr : [MarshalAs(UnmanagedType.LPArray)] IntPtr[] cStringPointers
p3 = var : [MarshalAs(UnmanagedType.LPArray)] int[] stringLengths
%inst
元関数名(C#): vector_string_getElements
元DLLエクスポート名: vector_string_getElements
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_string_getElements(std::vector&amp;lt;std::string&amp;gt;* vector, const char** cStringPointers, int32_t* stringLengths)
{
    for (size_t i = 0; i &amp;lt; vector-&amp;gt;size(); i++)
    {
        const auto&amp; elem = vector-&amp;gt;at(i);
        cStringPointers[i] = elem.c_str();
        stringLengths[i] = static_cast&amp;lt;int32_t&amp;gt;(elem.size());
    }
}

</pre>
}html
%group
NativeMethods_stdvector

%index
vector_string_delete
[32/64bit] std::vector<std::string> のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr vector
%inst



元関数名(C#): vector_string_delete
元DLLエクスポート名: vector_string_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_stdvector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) vector_string_delete(std::vector&amp;lt;std::string&amp;gt;* vector)
{
    delete vector;
}

</pre>
}html
%group
NativeMethods_stdvector

%index
videoio_VideoCapture_new1
[32/64bit] cv::VideoCapture のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst
ビデオファイル，画像シーケンス，カメラからビデオをキャプチャするためのクラス．

このクラスは，カメラからビデオをキャプチャしたり，ビデオファイルや画像シーケンスを読み込んだりするための C++ API を提供します．


元関数名(C#): videoio_VideoCapture_new1
元DLLエクスポート名: videoio_VideoCapture_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_new1(cv::VideoCapture **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::VideoCapture;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_new2
[32/64bit] cv::VideoCapture のインスタンスを生成します
%prm
p1,p2,p3
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
p2 = int : int apiPreference
p3 = var : out IntPtr returnValue
%inst
ビデオファイル，画像シーケンス，カメラからビデオをキャプチャするためのクラス．

このクラスは，カメラからビデオをキャプチャしたり，ビデオファイルや画像シーケンスを読み込んだりするための C++ API を提供します．


元関数名(C#): videoio_VideoCapture_new2
元DLLエクスポート名: videoio_VideoCapture_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_new2(const char *filename, int apiPreference, cv::VideoCapture **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::VideoCapture(filename, apiPreference);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_new3
[32/64bit] cv::VideoCapture のインスタンスを生成します
%prm
p1,p2,p3
p1 = int : int device
p2 = int : int apiPreference
p3 = var : out IntPtr returnValue
%inst
ビデオファイル，画像シーケンス，カメラからビデオをキャプチャするためのクラス．

このクラスは，カメラからビデオをキャプチャしたり，ビデオファイルや画像シーケンスを読み込んだりするための C++ API を提供します．


元関数名(C#): videoio_VideoCapture_new3
元DLLエクスポート名: videoio_VideoCapture_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_new3(int device, int apiPreference, cv::VideoCapture **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::VideoCapture(device, apiPreference);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_new4
[32/64bit] cv::VideoCapture のインスタンスを生成します
%prm
p1,p2,p3,p4,p5
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
p2 = int : int apiPreference
p3 = var : [In] int[] @params
p4 = int : int paramsLength
p5 = var : out IntPtr returnValue
%inst
ビデオファイル，画像シーケンス，カメラからビデオをキャプチャするためのクラス．

このクラスは，カメラからビデオをキャプチャしたり，ビデオファイルや画像シーケンスを読み込んだりするための C++ API を提供します．


元関数名(C#): videoio_VideoCapture_new4
元DLLエクスポート名: videoio_VideoCapture_new4
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_new4(const char* filename, int apiPreference, int* params, int paramsLength, cv::VideoCapture** returnValue)
{
    BEGIN_WRAP
        std::vector&amp;lt;int&amp;gt; paramsVec;
        paramsVec.assign(params, params + paramsLength);
        * returnValue = new cv::VideoCapture(filename, apiPreference, paramsVec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_new5
[32/64bit] cv::VideoCapture のインスタンスを生成します
%prm
p1,p2,p3,p4,p5
p1 = int : int device
p2 = int : int apiPreference
p3 = var : [In] int[] @params
p4 = int : int paramsLength
p5 = var : out IntPtr returnValue
%inst
ビデオファイル，画像シーケンス，カメラからビデオをキャプチャするためのクラス．

このクラスは，カメラからビデオをキャプチャしたり，ビデオファイルや画像シーケンスを読み込んだりするための C++ API を提供します．


元関数名(C#): videoio_VideoCapture_new5
元DLLエクスポート名: videoio_VideoCapture_new5
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_new5(int device, int apiPreference, int* params, int paramsLength, cv::VideoCapture** returnValue)
{
    BEGIN_WRAP
        std::vector&amp;lt;int&amp;gt; paramsVec;
        paramsVec.assign(params, params + paramsLength);
        * returnValue = new cv::VideoCapture(device, apiPreference, paramsVec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_delete
[32/64bit] cv::VideoCapture のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
ビデオファイル，画像シーケンス，カメラからビデオをキャプチャするためのクラス．

このクラスは，カメラからビデオをキャプチャしたり，ビデオファイルや画像シーケンスを読み込んだりするための C++ API を提供します．

このクラスは，以下のように利用されます．#include <opencv2/core.hpp>#include <opencv2/videoio.hpp>#include <opencv2/highgui.hpp>#include <iostream>#include <stdio.h>using namespace cv;using namespace std;int main(int, char**){ Mat frame; //--- INITIALIZE VIDEOCAPTURE VideoCapture cap; // デフォルトの API を用いて，デフォルトのカメラをオープンします // cap.open(0); // OR 事前使用: 任意の API バックエンドを選択する int deviceID = 0; // 0 = デフォルトカメラを開く int apiID = cv::CAP_ANY; // 0 = デフォルト API を自動検出する // 選択されたカメラを，選択された API を用いて開く cap.open(deviceID, apiID); // 成功したかどうかをチェックする if (!cap.isOpened()) { cerr << "ERROR!Unable to open camera\n"; return -1; }。    //--- GRAB AND WRITE LOOP cout << "Start grabbing" << endl << "Press any key to terminate" << endl; for (;;) { // カメラからの新しいフレームを待ち、'frame'に格納 cap.read(frame); // 成功したかどうかをチェック if (frame.empty()) { cerr << "ERROR! blank frame grabbed\n"; break; }。        imshow("Live", frame); if (waitKey(5) >= 0) break; } // ライブを表示し、画像を表示するのに十分なタイムアウト時間でキーを待ちます。    // カメラは，VideoCaptureのデストラクタで自動的に初期化されます return 0;}注：C言語のAPIでは，VideoCaptureの代わりにブラックボックス構造のCvCaptureが利用されます．





(C++）VideoCapture インターフェースを利用した基本的なサンプルは，OPENCV_SOURCE_CODE/samples/cpp/videocapture_starter.cpp にあります．

(Python) VideoCapture インターフェースを使用した基本的なサンプルは，OPENCV_SOURCE_CODE/samples/python/video.py にあります．

(Python) マルチスレッドビデオ処理のサンプルは、OPENCV_SOURCE_CODE/samples/python/video_threaded.py にあります。

(Python) Video4Linux2 バックエンドの一部の機能を紹介する VideoCapture サンプル OPENCV_SOURCE_CODE/samples/python/video_v4l2.py





サンプル： samples/cpp/camshiftdemo.cpp, samples/cpp/facedetect.cpp, samples/cpp/laplace.cpp, samples/cpp/lkdemo.cpp, samples/cpp/peopledetect.cpp, samples/cpp/polar_transforms.cpp, samples/cpp/segment_objects.cpp, samples/cpp/train_HOG.cpp、samples/cpp/tutorial_code/videoio/video-write/video-write.cpp、samples/cpp/videowriter_basic.cpp、samples/dnn/classification.cpp、samples/dnn/object_detection.cpp、samples/dnn/segmentation.cpp、samples/dnn/text_detection.cpp、samples/tapi/hog.cppです。


元関数名(C#): videoio_VideoCapture_delete
元DLLエクスポート名: videoio_VideoCapture_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_delete(cv::VideoCapture *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_open1
[32/64bit] ビデオファイルやキャプチャーデバイス、ビデオキャプチャー用のIPビデオストリームを開く。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
p3 = int : int apiPreference
p4 = var : out int returnValue
%inst
これはオーバーロードされたメンバー関数で、利便性のために提供されています。パラメータはコンストラクタと同じです。 VideoCapture(const String& filename, int apiPreference = CAP_ANY)このメソッドは、最初にVideoCapture::releaseを呼び出して、すでに開いているファイルやカメラを閉じます。cpp、samples/cpp/laplace.cpp、samples/cpp/lkdemo.cpp、samples/cpp/peopledetect.cpp、samples/cpp/polar_transforms.cpp、samples/cpp/segment_objects.cpp、samples/cpp/train_HOG.cpp、samples/dnn/classification.cpp、samples/dnn/object_detection.cpp、samples/dnn/segmentation.cpp、samples/dnn/text_detection.cpp、およびsamples/tapi/hog.cpp。

元関数名(C#): videoio_VideoCapture_open1
元DLLエクスポート名: videoio_VideoCapture_open1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_open1(cv::VideoCapture *obj, const char *filename, int apiPreference, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;open(filename, apiPreference) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_open2
[32/64bit] ビデオファイルやキャプチャーデバイス、ビデオキャプチャー用のIPビデオストリームを開く。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = int : int device
p3 = int : int apiPreference
p4 = var : out int returnValue
%inst
これはオーバーロードされたメンバー関数で、利便性のために提供されています。パラメータはコンストラクタと同じです。 VideoCapture(const String& filename, int apiPreference = CAP_ANY)このメソッドは、最初にVideoCapture::releaseを呼び出して、すでに開いているファイルやカメラを閉じます。cpp、samples/cpp/laplace.cpp、samples/cpp/lkdemo.cpp、samples/cpp/peopledetect.cpp、samples/cpp/polar_transforms.cpp、samples/cpp/segment_objects.cpp、samples/cpp/train_HOG.cpp、samples/dnn/classification.cpp、samples/dnn/object_detection.cpp、samples/dnn/segmentation.cpp、samples/dnn/text_detection.cpp、およびsamples/tapi/hog.cpp。

元関数名(C#): videoio_VideoCapture_open2
元DLLエクスポート名: videoio_VideoCapture_open2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_open2(cv::VideoCapture *obj, int device, int apiPreference, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;open(device, apiPreference) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_isOpened
[32/64bit] ビデオキャプチャーがすでに初期化されている場合は、trueを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
例: samples/cpp/camshiftdemo.cpp、samples/cpp/facedetect.cpp、samples/cpp/laplace.cpp、samples/cpp/lkdemo.cpp、samples/cpp/peopledetect.cpp、samples/cpp/polar_transforms.cpp、samples/cpp/segment_objects.cpp、samples/cpp/train_HOG.cpp、samples/cpp/tutorial_code/videoio/video-writ/video-writ.cpp、samples/cpp/videowriter_basic.cpp、samples/tapi/hog.cpp。

元関数名(C#): videoio_VideoCapture_isOpened
元DLLエクスポート名: videoio_VideoCapture_isOpened
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_isOpened(cv::VideoCapture *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;isOpened() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_release
[32/64bit] ビデオファイルまたはキャプチャーデバイスを閉じます。
%prm
p1
p1 = sptr : IntPtr obj
%inst
このメソッドは、後続の VideoCapture::open や VideoCapture destructor から自動的に呼び出されます。また、この C 関数は、メモリを解放し、*capture ポインタをクリアします。

元関数名(C#): videoio_VideoCapture_release
元DLLエクスポート名: videoio_VideoCapture_release
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_release(cv::VideoCapture *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;release();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_grab
[32/64bit] ビデオファイルまたはキャプチャーデバイスから次のフレームを取得します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
このメソッド／関数は，ビデオファイルまたはカメラから次のフレームを取得し，成功した場合は true（0 以外）を返します。この関数の主な用途は，マルチカメラ環境で，特にカメラがハードウェア同期を行っていない場合です。つまり，各カメラに対して VideoCapture::grab() を呼び出し，その後，より低速なメソッドである VideoCapture::retrieve() を呼び出して，各カメラからフレームをデコードして取得するのです．また、接続されているカメラがマルチヘッドの場合（ステレオカメラやKinectデバイスなど）は、最初にVideoCapture::grab()を呼び出し、その後VideoCapture::retrieve()をチャンネルパラメータの値を変えて複数回呼び出すのが正しいデータ取得方法です。

元関数名(C#): videoio_VideoCapture_grab
元DLLエクスポート名: videoio_VideoCapture_grab
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_grab(cv::VideoCapture *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;grab() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_retrieve_OutputArray
[32/64bit] 掴んだビデオフレームをデコードして返します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = int : int flag
p4 = var : out int returnValue
%inst
このメソッドはグラブされたばかりのフレームをデコードして返します。フレームが取得されなかった場合（カメラが切断された，あるいは，ビデオファイルにフレームが存在しない），このメソッドは false を返し，この関数は空の画像を返します（ cv::Mat の場合は， Mat::empty() でテストしてください）．この画像を変更したり，解放したりすることはできません．cvCloneImage を使ってフレームをコピーし，そのコピーに対して好きなことを行うことができます．

元関数名(C#): videoio_VideoCapture_retrieve_OutputArray
元DLLエクスポート名: videoio_VideoCapture_retrieve_OutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_retrieve_OutputArray(cv::VideoCapture *obj, cv::_OutputArray *image, int flag, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;retrieve(*image, flag) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_retrieve_Mat
[32/64bit] 掴んだビデオフレームをデコードして返します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = int : int flag
p4 = var : out int returnValue
%inst
このメソッドはグラブされたばかりのフレームをデコードして返します。フレームが取得されなかった場合（カメラが切断された，あるいは，ビデオファイルにフレームが存在しない），このメソッドは false を返し，この関数は空の画像を返します（ cv::Mat の場合は， Mat::empty() でテストしてください）．この画像を変更したり，解放したりすることはできません．cvCloneImage を使ってフレームをコピーし，そのコピーに対して好きなことを行うことができます．

元関数名(C#): videoio_VideoCapture_retrieve_Mat
元DLLエクスポート名: videoio_VideoCapture_retrieve_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_retrieve_Mat(cv::VideoCapture *obj, cv::Mat *image, int flag, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;retrieve(*image, flag) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_operatorRightShift_Mat
[32/64bit] videoio_VideoCapture_operatorRightShift_Mat
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
%inst
元関数名(C#): videoio_VideoCapture_operatorRightShift_Mat
元DLLエクスポート名: videoio_VideoCapture_operatorRightShift_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_operatorRightShift_Mat(cv::VideoCapture *obj, cv::Mat *image)
{
    BEGIN_WRAP
    (*obj) &amp;gt;&amp;gt; (*image);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_read_OutputArray
[32/64bit] 次のビデオフレームを取得，デコードして返します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = var : out int returnValue
%inst
このメソッド/関数は， VideoCapture::grab() と VideoCapture::retrieve() を1つの呼び出しにまとめたものです．これは、ビデオファイルを読み込んだり、デコードからデータをキャプチャしたりする際に最も便利な方法であり、グラブされたばかりのフレームを返します。フレームが取得されなかった場合（カメラが切断された，あるいは，ビデオファイルにフレームが存在しない），このメソッドは false を返し，この関数は空の画像を返します（ cv::Mat の場合は， Mat::empty() でテストしてください）．この画像を変更したり，解放したりすることはできません．cvCloneImage を使ってフレームをコピーし，そのコピーに対して好きなことを行うことができます．例： samples/cpp/videowriter_basic.cpp.

元関数名(C#): videoio_VideoCapture_read_OutputArray
元DLLエクスポート名: videoio_VideoCapture_read_OutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_read_OutputArray(cv::VideoCapture *obj, cv::_OutputArray *image, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;read(*image) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_read_Mat
[32/64bit] 次のビデオフレームを取得，デコードして返します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = var : out int returnValue
%inst
このメソッド/関数は， VideoCapture::grab() と VideoCapture::retrieve() を1つの呼び出しにまとめたものです．これは、ビデオファイルを読み込んだり、デコードからデータをキャプチャしたりする際に最も便利な方法であり、グラブされたばかりのフレームを返します。フレームが取得されなかった場合（カメラが切断された，あるいは，ビデオファイルにフレームが存在しない），このメソッドは false を返し，この関数は空の画像を返します（ cv::Mat の場合は， Mat::empty() でテストしてください）．この画像を変更したり，解放したりすることはできません．cvCloneImage を使ってフレームをコピーし，そのコピーに対して好きなことを行うことができます．例： samples/cpp/videowriter_basic.cpp.

元関数名(C#): videoio_VideoCapture_read_Mat
元DLLエクスポート名: videoio_VideoCapture_read_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_read_Mat(cv::VideoCapture *obj, cv::Mat *image, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;read(*image) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_set
[32/64bit] VideoCapture のプロパティを設定します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = int : int propId
p3 = double : double value
p4 = var : out int returnValue
%inst
注意： true を返したとしても，そのプロパティの値がキャプチャデバイスに受け入れられたかどうかは保証されません．VideoCapture::get()の注記を参照してください。 サンプル: samples/cpp/laplace.cpp.

元関数名(C#): videoio_VideoCapture_set
元DLLエクスポート名: videoio_VideoCapture_set
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_set(cv::VideoCapture *obj, int propId, double value, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;set(propId, value) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_get
[32/64bit] 指定した VideoCapture プロパティを返します。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = int : int propId
p3 = var : out double returnValue
%inst
注意：プロパティの読み書きには多くのレイヤーが関わっています。予期せぬ結果が発生する可能性がありますので、ご注意ください。VideoCapture -> API Backend -> Operating System -> Device Driver -> Device Hardware 返された値は、デバイスで実際に使用されているものとは異なる可能性があり、また、デバイス依存のルール（例：ステップまたはパーセンテージ）を使用してエンコードされている可能性があります。有効な動作は、デバイスドライバーとAPIバックエンドに依存します。サンプル：samples/cpp/laplace.cpp、samples/cpp/tutorial_code/videoio/video-write/video-writ.cpp。

元関数名(C#): videoio_VideoCapture_get
元DLLエクスポート名: videoio_VideoCapture_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_get(cv::VideoCapture *obj, int propId, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get(propId);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_getBackendName
[32/64bit] 使用したバックエンドのAPI名を返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr returnValue
%inst
NoteStreamをオープンします。

元関数名(C#): videoio_VideoCapture_getBackendName
元DLLエクスポート名: videoio_VideoCapture_getBackendName
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_getBackendName(cv::VideoCapture *obj, std::string *returnValue)
{
    BEGIN_WRAP
    returnValue-&amp;gt;assign(obj-&amp;gt;getBackendName());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_setExceptionMode
[32/64bit] 例外モードを切り替えます。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int enable
%inst
メソッドは、成功しなかった場合、エラーコードを返す代わりに例外を発生させます。

元関数名(C#): videoio_VideoCapture_setExceptionMode
元DLLエクスポート名: videoio_VideoCapture_setExceptionMode
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_setExceptionMode(cv::VideoCapture *obj, int enable)
{
    BEGIN_WRAP
    obj-&amp;gt;setExceptionMode(enable != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_getExceptionMode
[32/64bit] 例外モードがアクティブかどうかを問い合わせる
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): videoio_VideoCapture_getExceptionMode
元DLLエクスポート名: videoio_VideoCapture_getExceptionMode
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_getExceptionMode(cv::VideoCapture *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getExceptionMode() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoCapture_waitAny
[32/64bit] VideoCaptureからの準備完了フレームを待ちます。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr[] streams
p2 = sptr : nuint streamsSize
p3 = sptr : IntPtr readyIndex
p4 = ARGS_LONG : long timeoutNs
p5 = var : out int returnValue
%inst
例外処理

  

    ストリームエラー（.isOpened()をチェックして、不正なストリームを除外する）またはVideoCaptureタイプがサポートされていない場合は、Exceptionが発生しますこの関数の主な用途は、マルチカメラ環境です。このメソッドは、カメラの準備ができていれば、レディステートベクトルを満たし、ビデオフレームを取得します。この呼び出しの後、VideoCapture::retrieve()を使用して、フレームデータをデコードして取得します。

元関数名(C#): videoio_VideoCapture_waitAny
元DLLエクスポート名: videoio_VideoCapture_waitAny
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoCapture_waitAny(
    cv::VideoCapture** streams, const size_t streamsSize,
    std::vector&amp;lt;int&amp;gt; *readyIndex, const int64 timeoutNs, int *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::VideoCapture&amp;gt; streamsVec(streamsSize);
    for (size_t i = 0; i &amp;lt; streamsSize; i++)
        streamsVec[i] = *streams[i];

    *returnValue = cv::VideoCapture::waitAny(streamsVec, *readyIndex, timeoutNs) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoWriter_new1
[32/64bit] cv::VideoWriter のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst
ビデオライタークラス。

このクラスは，ビデオファイルやイメージシーケンスを書き込むための C++ API を提供します。


元関数名(C#): videoio_VideoWriter_new1
元DLLエクスポート名: videoio_VideoWriter_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoWriter_new1(cv::VideoWriter **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::VideoWriter;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoWriter_new2
[32/64bit] cv::VideoWriter のインスタンスを生成します
%prm
p1,p2,p3,p4,p5,p6
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
p2 = int : int fourcc
p3 = double : double fps
p4 = ARGS_SIZE : Size frameSize
p5 = int : int isColor
p6 = var : out IntPtr returnValue
%inst
ビデオライタークラス。

このクラスは，ビデオファイルやイメージシーケンスを書き込むための C++ API を提供します。


元関数名(C#): videoio_VideoWriter_new2
元DLLエクスポート名: videoio_VideoWriter_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoWriter_new2(
    const char *filename, 
    int fourcc, double fps,
    MyCvSize frameSize, int isColor, 
    cv::VideoWriter **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::VideoWriter(filename, fourcc, fps, cpp(frameSize), isColor != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoWriter_new3
[32/64bit] cv::VideoWriter のインスタンスを生成します
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
p2 = int : int apiPreference
p3 = int : int fourcc
p4 = double : double fps
p5 = ARGS_SIZE : Size frameSize
p6 = int : int isColor
p7 = var : out IntPtr returnValue
%inst
ビデオライタークラス。

このクラスは，ビデオファイルやイメージシーケンスを書き込むための C++ API を提供します。


元関数名(C#): videoio_VideoWriter_new3
元DLLエクスポート名: videoio_VideoWriter_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoWriter_new3(
    const char *filename, int apiPreference, 
    int fourcc, double fps,
    MyCvSize frameSize, int isColor, 
    cv::VideoWriter **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::VideoWriter(filename, apiPreference, fourcc, fps, cpp(frameSize), isColor != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoWriter_new4
[32/64bit] cv::VideoWriter のインスタンスを生成します
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
p2 = int : int fourcc
p3 = double : double fps
p4 = ARGS_SIZE : Size frameSize
p5 = var : [In] int[] @params
p6 = int : int paramsLength
p7 = var : out IntPtr returnValue
%inst
ビデオライタークラス。

このクラスは，ビデオファイルやイメージシーケンスを書き込むための C++ API を提供します。


元関数名(C#): videoio_VideoWriter_new4
元DLLエクスポート名: videoio_VideoWriter_new4
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoWriter_new4(
    const char* filename,
    int fourcc, double fps,
    MyCvSize frameSize, int* params, int paramsLength,
    cv::VideoWriter** returnValue)
{
    BEGIN_WRAP
        std::vector&amp;lt;int&amp;gt; paramsVec;
        paramsVec.assign(params, params + paramsLength);
        * returnValue = new cv::VideoWriter(filename, fourcc, fps, cpp(frameSize), paramsVec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoWriter_new5
[32/64bit] cv::VideoWriter のインスタンスを生成します
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
p2 = int : int apiPreference
p3 = int : int fourcc
p4 = double : double fps
p5 = ARGS_SIZE : Size frameSize
p6 = var : [In] int[] @params
p7 = int : int paramsLength
p8 = var : out IntPtr returnValue
%inst
ビデオライタークラス。

このクラスは，ビデオファイルやイメージシーケンスを書き込むための C++ API を提供します。


元関数名(C#): videoio_VideoWriter_new5
元DLLエクスポート名: videoio_VideoWriter_new5
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoWriter_new5(
    const char* filename, int apiPreference,
    int fourcc, double fps,
    MyCvSize frameSize, int* params, int paramsLength,
    cv::VideoWriter** returnValue)
{
    BEGIN_WRAP
        std::vector&amp;lt;int&amp;gt; paramsVec;
        paramsVec.assign(params, params + paramsLength);
        * returnValue = new cv::VideoWriter(filename, apiPreference, fourcc, fps, cpp(frameSize), paramsVec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoWriter_delete
[32/64bit] cv::VideoWriter のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
ビデオライタークラス。

このクラスは，ビデオファイルやイメージシーケンスを書き込むための C++ API を提供します。

sample/cpp/tutorial_code/videoio/video-write/video-write.cpp、samples/cpp/videowriter_basic.cpp、samples/tapi/hog.cppがその例です。


元関数名(C#): videoio_VideoWriter_delete
元DLLエクスポート名: videoio_VideoWriter_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoWriter_delete(cv::VideoWriter *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoWriter_open1
[32/64bit] ビデオライターを初期化または再初期化します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
p3 = int : int fourcc
p4 = double : double fps
p5 = ARGS_SIZE : Size frameSize
p6 = int : int isColor
p7 = var : out int returnValue
%inst
このメソッドは、ビデオライターを開きます。パラメータは、コンストラクタ VideoWriter::VideoWriter と同じです。このメソッドは、最初に VideoWriter::release を呼び出して、すでに開かれているファイルを閉じます。サンプル: samples/cpp/tutorial_code/videoio/video-writ/video-writ.cpp, samples/cpp/videowriter_basic.cpp, samples/tapi/hog.cpp.

元関数名(C#): videoio_VideoWriter_open1
元DLLエクスポート名: videoio_VideoWriter_open1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoWriter_open1(
    cv::VideoWriter *obj, const char *filename, 
    int fourcc, double fps,
    MyCvSize frameSize, int isColor, 
    int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;open(filename, fourcc, fps, cpp(frameSize), isColor != 0) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoWriter_open2
[32/64bit] ビデオライターを初期化または再初期化します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
p3 = int : int apiPreference
p4 = int : int fourcc
p5 = double : double fps
p6 = ARGS_SIZE : Size frameSize
p7 = int : int isColor
p8 = var : out int returnValue
%inst
このメソッドは、ビデオライターを開きます。パラメータは、コンストラクタ VideoWriter::VideoWriter と同じです。このメソッドは、最初に VideoWriter::release を呼び出して、すでに開かれているファイルを閉じます。サンプル: samples/cpp/tutorial_code/videoio/video-writ/video-writ.cpp, samples/cpp/videowriter_basic.cpp, samples/tapi/hog.cpp.

元関数名(C#): videoio_VideoWriter_open2
元DLLエクスポート名: videoio_VideoWriter_open2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoWriter_open2(
    cv::VideoWriter *obj, const char *filename, int apiPreference, 
    int fourcc, double fps,
    MyCvSize frameSize, int isColor, 
    int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;open(filename, apiPreference, fourcc, fps, cpp(frameSize), isColor != 0) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoWriter_isOpened
[32/64bit] ビデオライターの初期化に成功した場合は、trueを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
例：samples/cpp/videowriter_basic.cpp、samples/tapi/hog.cpp。

元関数名(C#): videoio_VideoWriter_isOpened
元DLLエクスポート名: videoio_VideoWriter_isOpened
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoWriter_isOpened(cv::VideoWriter *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;isOpened() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoWriter_release
[32/64bit] ビデオライターを閉じます。
%prm
p1
p1 = sptr : IntPtr obj
%inst
このメソッドは、後続の VideoWriter::open や VideoWriter のデストラクタから自動的に呼び出されます。

元関数名(C#): videoio_VideoWriter_release
元DLLエクスポート名: videoio_VideoWriter_release
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoWriter_release(cv::VideoWriter *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;release();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoWriter_write
[32/64bit] 次のビデオフレームを書き込みます。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
%inst
関数/メソッドは指定された画像をビデオファイルに書き込みます。ビデオファイルのサイズは、ビデオライターを開くときに指定したサイズと同じである必要があります。

元関数名(C#): videoio_VideoWriter_write
元DLLエクスポート名: videoio_VideoWriter_write
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoWriter_write(cv::VideoWriter *obj, cv::_InputArray *image)
{
    BEGIN_WRAP
    obj-&amp;gt;write(*image);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoWriter_set
[32/64bit] VideoWriter のプロパティを設定します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = int : int propId
p3 = double : double value
p4 = var : out int returnValue
%inst
元関数名(C#): videoio_VideoWriter_set
元DLLエクスポート名: videoio_VideoWriter_set
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoWriter_set(cv::VideoWriter *obj, int propId, double value, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;set(propId, value) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoWriter_get
[32/64bit] 指定された VideoWriter のプロパティを返します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = int : int propId
p3 = var : out double returnValue
%inst
元関数名(C#): videoio_VideoWriter_get
元DLLエクスポート名: videoio_VideoWriter_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoWriter_get(cv::VideoWriter *obj, int propId, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get(propId);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoWriter_fourcc
[32/64bit] 4文字をfourccコードに連結します。
%prm
p1,p2,p3,p4,p5
p1 = int : sbyte c1
p2 = int : sbyte c2
p3 = int : sbyte c3
p4 = int : sbyte c4
p5 = var : out int returnValue
%inst
VideoWriter::VideoWriter または VideoWriter::open のコンストラクタで使用するコーデックの fourcc コードを構築します。例: samples/cpp/videowriter_basic.cpp.

元関数名(C#): videoio_VideoWriter_fourcc
元DLLエクスポート名: videoio_VideoWriter_fourcc
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoWriter_fourcc(char c1, char c2, char c3, char c4, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::VideoWriter::fourcc(c1, c2, c3, c4);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
videoio_VideoWriter_getBackendName
[32/64bit] 使用したバックエンドのAPI名を返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr returnValue
%inst
NoteStreamをオープンします。

元関数名(C#): videoio_VideoWriter_getBackendName
元DLLエクスポート名: videoio_VideoWriter_getBackendName
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_videoio.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) videoio_VideoWriter_getBackendName(cv::VideoWriter *obj, std::string *returnValue)
{
    BEGIN_WRAP
    returnValue-&amp;gt;assign(obj-&amp;gt;getBackendName());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_videoio

%index
xfeatures2d_BriefDescriptorExtractor_create
[32/64bit] xfeatures2d_BriefDescriptorExtractor_create
%prm
p1,p2
p1 = int : int bytes
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): xfeatures2d_BriefDescriptorExtractor_create
元DLLエクスポート名: xfeatures2d_BriefDescriptorExtractor_create
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_BriefDescriptorExtractor_create(
    int bytes, cv::Ptr&amp;lt;cv::xfeatures2d::BriefDescriptorExtractor&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::xfeatures2d::BriefDescriptorExtractor::create(bytes);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_Ptr_BriefDescriptorExtractor_delete
[32/64bit] cv::xfeatures2d::BriefDescriptorExtractor のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
40]に記載されている BRIEF 記述子を計算するクラスです。

パラメータ

  

    bytes ディスクリプタの長さをバイト単位で指定します，有効な値は有効な値は，16，32（デフォルト），64です．

    use_orientations sample pattern using keypoints orientation，デフォルトでは無効です．

  

  


元関数名(C#): xfeatures2d_Ptr_BriefDescriptorExtractor_delete
元DLLエクスポート名: xfeatures2d_Ptr_BriefDescriptorExtractor_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_Ptr_BriefDescriptorExtractor_delete(
    cv::Ptr&amp;lt;cv::xfeatures2d::BriefDescriptorExtractor&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_BriefDescriptorExtractor_read
[32/64bit] xfeatures2d_BriefDescriptorExtractor_read
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr fn
%inst
元関数名(C#): xfeatures2d_BriefDescriptorExtractor_read
元DLLエクスポート名: xfeatures2d_BriefDescriptorExtractor_read
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_BriefDescriptorExtractor_read(
    cv::Ptr&amp;lt;cv::xfeatures2d::BriefDescriptorExtractor&amp;gt; *obj, cv::FileNode *fn)
{
    BEGIN_WRAP
    obj-&amp;gt;get()-&amp;gt;read(*fn);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_BriefDescriptorExtractor_write
[32/64bit] xfeatures2d_BriefDescriptorExtractor_write
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr fs
%inst
元関数名(C#): xfeatures2d_BriefDescriptorExtractor_write
元DLLエクスポート名: xfeatures2d_BriefDescriptorExtractor_write
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_BriefDescriptorExtractor_write(
    cv::Ptr&amp;lt;cv::xfeatures2d::BriefDescriptorExtractor&amp;gt; *obj, cv::FileStorage *fs)
{
    BEGIN_WRAP
    obj-&amp;gt;get()-&amp;gt;write(*fs);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_BriefDescriptorExtractor_descriptorSize
[32/64bit] xfeatures2d_BriefDescriptorExtractor_descriptorSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): xfeatures2d_BriefDescriptorExtractor_descriptorSize
元DLLエクスポート名: xfeatures2d_BriefDescriptorExtractor_descriptorSize
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_BriefDescriptorExtractor_descriptorSize(
    cv::Ptr&amp;lt;cv::xfeatures2d::BriefDescriptorExtractor&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get()-&amp;gt;descriptorSize();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_BriefDescriptorExtractor_descriptorType
[32/64bit] xfeatures2d_BriefDescriptorExtractor_descriptorType
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): xfeatures2d_BriefDescriptorExtractor_descriptorType
元DLLエクスポート名: xfeatures2d_BriefDescriptorExtractor_descriptorType
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_BriefDescriptorExtractor_descriptorType(
    cv::Ptr&amp;lt;cv::xfeatures2d::BriefDescriptorExtractor&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get()-&amp;gt;descriptorType();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_Ptr_BriefDescriptorExtractor_get
[32/64bit] cv::xfeatures2d::BriefDescriptorExtractor のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
40]に記載されている BRIEF 記述子を計算するクラスです。

パラメータ

  

    bytes ディスクリプタの長さをバイト単位で指定します，有効な値は有効な値は，16，32（デフォルト），64です．

    use_orientations sample pattern using keypoints orientation，デフォルトでは無効です．

  

  


元関数名(C#): xfeatures2d_Ptr_BriefDescriptorExtractor_get
元DLLエクスポート名: xfeatures2d_Ptr_BriefDescriptorExtractor_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_Ptr_BriefDescriptorExtractor_get(
    cv::Ptr&amp;lt;cv::xfeatures2d::BriefDescriptorExtractor&amp;gt;* ptr, cv::xfeatures2d::BriefDescriptorExtractor **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_FREAK_create
[32/64bit] xfeatures2d_FREAK_create
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = int : int orientationNormalized
p2 = int : int scaleNormalized
p3 = float : float patternScale
p4 = int : int nOctaves
p5 = var : int[]? selectedPairs
p6 = int : int selectedPairsLength
p7 = var : out IntPtr returnValue
%inst
元関数名(C#): xfeatures2d_FREAK_create
元DLLエクスポート名: xfeatures2d_FREAK_create
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_FREAK_create(
    int orientationNormalized, int scaleNormalized, float patternScale, int nOctaves,
    int *selectedPairs, int selectedPairsLength, 
    cv::Ptr&amp;lt;cv::xfeatures2d::FREAK&amp;gt; **returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;int&amp;gt; selectedPairsVec;
    if (selectedPairs != nullptr)
        selectedPairsVec = std::vector&amp;lt;int&amp;gt;(selectedPairs, selectedPairs + selectedPairsLength);
    const auto ptr = cv::xfeatures2d::FREAK::create(
        orientationNormalized != 0, scaleNormalized != 0, patternScale, nOctaves, selectedPairsVec);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_Ptr_FREAK_delete
[32/64bit] cv::xfeatures2d::FREAK のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
FREAK (Fast Retina Keypoint) キーポイントディスクリプタを実装したクラスで，[8]で述べられています．

このアルゴリズムは，人間の視覚システム，より正確には網膜にインスパイアされた新しいキーポイント記述子を提案しており，Fast Retina Key-point (FREAK)と呼ばれています．FREAKは、網膜のサンプリングパターン上で画像の強度を効率的に比較することで、2値文字列のカスケードを計算します。FREAKは、一般的に、SIFT、SURF、BRISKよりも、メモリ負荷が低く、計算が速く、また、ロバスト性に優れています。また、SIFTやSURF、BRISKに比べてロバスト性が高く、既存のキーポイントに代わる競争力のあるキーポイントとして、特に組込み用途に有効です。

備考

FREAK 記述子の使用方法の例は、opencv_source_code/samples/cpp/freak_demo.cpp にあります。


元関数名(C#): xfeatures2d_Ptr_FREAK_delete
元DLLエクスポート名: xfeatures2d_Ptr_FREAK_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_Ptr_FREAK_delete(cv::Ptr&amp;lt;cv::xfeatures2d::FREAK&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_Ptr_FREAK_get
[32/64bit] cv::xfeatures2d::FREAK のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
FREAK (Fast Retina Keypoint) キーポイントディスクリプタを実装したクラスで，[8]で述べられています．

このアルゴリズムは，人間の視覚システム，より正確には網膜にインスパイアされた新しいキーポイント記述子を提案しており，Fast Retina Key-point (FREAK)と呼ばれています．FREAKは、網膜のサンプリングパターン上で画像の強度を効率的に比較することで、2値文字列のカスケードを計算します。FREAKは、一般的に、SIFT、SURF、BRISKよりも、メモリ負荷が低く、計算が速く、また、ロバスト性に優れています。また、SIFTやSURF、BRISKに比べてロバスト性が高く、既存のキーポイントに代わる競争力のあるキーポイントとして、特に組込み用途に有効です。

備考

FREAK 記述子の使用方法の例は、opencv_source_code/samples/cpp/freak_demo.cpp にあります。


元関数名(C#): xfeatures2d_Ptr_FREAK_get
元DLLエクスポート名: xfeatures2d_Ptr_FREAK_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_Ptr_FREAK_get(cv::Ptr&amp;lt;cv::xfeatures2d::FREAK&amp;gt; *ptr, cv::xfeatures2d::FREAK **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_StarDetector_create
[32/64bit] フルコンストラクタ
%prm
p1,p2,p3,p4,p5,p6
p1 = int : int maxSize
p2 = int : int responseThreshold
p3 = int : int lineThresholdProjected
p4 = int : int lineThresholdBinarized
p5 = int : int suppressNonmaxSize
p6 = var : out IntPtr returnValue
%inst
元関数名(C#): xfeatures2d_StarDetector_create
元DLLエクスポート名: xfeatures2d_StarDetector_create
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_StarDetector_create(
    int maxSize, int responseThreshold,
    int lineThresholdProjected, int lineThresholdBinarized, int suppressNonmaxSize, 
    cv::Ptr&amp;lt;cv::xfeatures2d::StarDetector&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::xfeatures2d::StarDetector::create(
        maxSize, responseThreshold, lineThresholdProjected, lineThresholdBinarized, suppressNonmaxSize);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_Ptr_StarDetector_delete
[32/64bit] cv::xfeatures2d::StarDetector のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
このクラスは，[2]で紹介されたキーポイント検出器（StarDetectorの同義語）を実装しています．


元関数名(C#): xfeatures2d_Ptr_StarDetector_delete
元DLLエクスポート名: xfeatures2d_Ptr_StarDetector_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_Ptr_StarDetector_delete(cv::Ptr&amp;lt;cv::xfeatures2d::StarDetector&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_Ptr_StarDetector_get
[32/64bit] cv::xfeatures2d::StarDetector のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
このクラスは，[2]で紹介されたキーポイント検出器（StarDetectorの同義語）を実装しています．


元関数名(C#): xfeatures2d_Ptr_StarDetector_get
元DLLエクスポート名: xfeatures2d_Ptr_StarDetector_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_Ptr_StarDetector_get(cv::Ptr&amp;lt;cv::xfeatures2d::StarDetector&amp;gt; *ptr, cv::xfeatures2d::StarDetector **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_LUCID_create
[32/64bit] xfeatures2d_LUCID_create
%prm
p1,p2,p3
p1 = int : int lucidKernel
p2 = int : int blurKernel
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): xfeatures2d_LUCID_create
元DLLエクスポート名: xfeatures2d_LUCID_create
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_LUCID_create(const int lucid_kernel, const int blur_kernel, cv::Ptr&amp;lt;cv::xfeatures2d::LUCID&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::xfeatures2d::LUCID::create(lucid_kernel, blur_kernel);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_Ptr_LUCID_delete
[32/64bit] cv::xfeatures2d::LUCID のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
295]で述べられている，局所的に一様な比較画像記述子を実装したクラス．

SURFやBRIEFなどと同程度のロバスト性を持ちながら，非常に高速に計算できる画像記述子です．

注：入力としてカラー画像が必要です。


元関数名(C#): xfeatures2d_Ptr_LUCID_delete
元DLLエクスポート名: xfeatures2d_Ptr_LUCID_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_Ptr_LUCID_delete(cv::Ptr&amp;lt;cv::xfeatures2d::LUCID&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_Ptr_LUCID_get
[32/64bit] cv::xfeatures2d::LUCID のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
295]で述べられている，局所的に一様な比較画像記述子を実装したクラス．

SURFやBRIEFなどと同程度のロバスト性を持ちながら，非常に高速に計算できる画像記述子です．

注：入力としてカラー画像が必要です。


元関数名(C#): xfeatures2d_Ptr_LUCID_get
元DLLエクスポート名: xfeatures2d_Ptr_LUCID_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_Ptr_LUCID_get(cv::Ptr&amp;lt;cv::xfeatures2d::LUCID&amp;gt; *ptr, cv::xfeatures2d::LUCID **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_LATCH_create
[32/64bit] xfeatures2d_LATCH_create
%prm
p1,p2,p3,p4,p5
p1 = int : int bytes
p2 = int : int rotationInvariance
p3 = int : int halfSsdSize
p4 = double : double sigma
p5 = var : out IntPtr returnValue
%inst
元関数名(C#): xfeatures2d_LATCH_create
元DLLエクスポート名: xfeatures2d_LATCH_create
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_LATCH_create(
    int bytes, int rotationInvariance, int half_ssd_size, double sigma, 
    cv::Ptr&amp;lt;cv::xfeatures2d::LATCH&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::xfeatures2d::LATCH::create(bytes, rotationInvariance != 0, half_ssd_size, sigma);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_Ptr_LATCH_delete
[32/64bit] cv::xfeatures2d::LATCH のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
latch LATCH ディスクリプタを計算するクラス．このコードが役に立ったら，あなたの作品に次の論文への参照を加えてください。Gil Levi and Tal Hassner, "LATCH:Learned Arrangements of Three Patch Codes", arXiv preprint arXiv:1501.03719, 15 Jan.2015

LATCHは、画像パッチのトリプレットの学習された比較に基づく、バイナリ記述子です。

bytesは記述子のサイズで，64，32，16，8，4，2，1のいずれかです． rotationInvariance - 記述子が方向の変化に対応するかどうかを指定します． half_ssd_size - ミニパッチのサイズの半分のサイズです．例えば，サイズが7x7xのパッチのトリプレットを比較したい場合，half_ssd_sizeは(7-1)/2 = 3となります． sigma - ソース画像をガウスブラーで平滑化するためのシグマ値です．sigma値が0の場合，ソース画像はスムージングされずに利用されます．

注意：このディスクリプタは，任意のキーポイント抽出器と組み合わせることができます．唯一の要求は，set rotationInvariance = True を使った場合には，パッチの向き（度数）を推定する抽出器を使わなければならないということです．このような抽出器の例としては、ORBやSIFTがあります。

注：完全な例は、/samples/cpp/tutorial_code/xfeatures2D/latch_match.cppにあります。


元関数名(C#): xfeatures2d_Ptr_LATCH_delete
元DLLエクスポート名: xfeatures2d_Ptr_LATCH_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_Ptr_LATCH_delete(cv::Ptr&amp;lt;cv::xfeatures2d::LATCH&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_Ptr_LATCH_get
[32/64bit] cv::xfeatures2d::LATCH のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
latch LATCH ディスクリプタを計算するクラス．このコードが役に立ったら，あなたの作品に次の論文への参照を加えてください。Gil Levi and Tal Hassner, "LATCH:Learned Arrangements of Three Patch Codes", arXiv preprint arXiv:1501.03719, 15 Jan.2015

LATCHは、画像パッチのトリプレットの学習された比較に基づく、バイナリ記述子です。

bytesは記述子のサイズで，64，32，16，8，4，2，1のいずれかです． rotationInvariance - 記述子が方向の変化に対応するかどうかを指定します． half_ssd_size - ミニパッチのサイズの半分のサイズです．例えば，サイズが7x7xのパッチのトリプレットを比較したい場合，half_ssd_sizeは(7-1)/2 = 3となります． sigma - ソース画像をガウスブラーで平滑化するためのシグマ値です．sigma値が0の場合，ソース画像はスムージングされずに利用されます．

注意：このディスクリプタは，任意のキーポイント抽出器と組み合わせることができます．唯一の要求は，set rotationInvariance = True を使った場合には，パッチの向き（度数）を推定する抽出器を使わなければならないということです．このような抽出器の例としては、ORBやSIFTがあります。

注：完全な例は、/samples/cpp/tutorial_code/xfeatures2D/latch_match.cppにあります。


元関数名(C#): xfeatures2d_Ptr_LATCH_get
元DLLエクスポート名: xfeatures2d_Ptr_LATCH_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_Ptr_LATCH_get(cv::Ptr&amp;lt;cv::xfeatures2d::LATCH&amp;gt; *ptr, cv::xfeatures2d::LATCH **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_SURF_create
[32/64bit] xfeatures2d_SURF_create
%prm
p1,p2,p3,p4,p5,p6
p1 = double : double hessianThreshold
p2 = int : int nOctaves
p3 = int : int nOctaveLayers
p4 = int : int extended
p5 = int : int upright
p6 = var : out IntPtr returnValue
%inst
元関数名(C#): xfeatures2d_SURF_create
元DLLエクスポート名: xfeatures2d_SURF_create
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_SURF_create(
    double hessianThreshold, int nOctaves,
    int nOctaveLayers, int extended, int upright, 
    cv::Ptr&amp;lt;cv::xfeatures2d::SURF&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::xfeatures2d::SURF::create(
        hessianThreshold, nOctaves, nOctaveLayers, extended != 0, upright != 0);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_Ptr_SURF_delete
[32/64bit] cv::xfeatures2d::SURF のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
画像からSpeeded Up Robust Featuresを抽出するクラス [16] ．

アルゴリズムのパラメータです．

メンバー int extended

0 は，基本記述子（各64要素）を計算することを意味します．

1 は，拡張ディスクリプタ（各128要素）を計算することを意味します．





メンバー int upright

0 は，検出器が各特徴の向きを計算することを意味します．

1 は，向きの計算を行わないことを意味します（この方が，はるかに高速です）．例えば，ステレオペアの画像をマッチングさせたり，画像のスティッチングを行ったりする場合，マッチングした特徴の角度が非常に似ている可能性があり，upright=1を設定することで，特徴の抽出を高速化することができます．





member double hessianThreshold キーポイント検出器のしきい値。hessianThresholdよりも大きいヘシアンを持つ特徴のみが、検出器によって保持されます。したがって，この値が大きくなるほど，得られるキーポイントは少なくなります．初期値としては，画像のコントラストにもよりますが，300から500程度が良いでしょう。

member int nOctaves 検出器が利用するガウシアンピラミッドのオクターブ数を指定します。デフォルトでは，4に設定されています．非常に大きな特徴を得たい場合は，より大きな値を使用してください．小さな特徴を得るためには、この値を小さくしてください。

member int nOctaveLayers ガウシアンピラミッドの各オクターブ内の画像の数。デフォルトでは、2に設定されています。参考

SURF 特徴検出器を用いた例は， opencv_source_code/samples/cpp/generic_descriptor_match.cpp にあります．

SURF 特徴検出器，抽出器，マッチャーを用いた別の例は， opencv_source_code/samples/cpp/matcher_simple.cpp にあります．


元関数名(C#): xfeatures2d_Ptr_SURF_delete
元DLLエクスポート名: xfeatures2d_Ptr_SURF_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_Ptr_SURF_delete(cv::Ptr&amp;lt;cv::xfeatures2d::SURF&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_Ptr_SURF_get
[32/64bit] cv::xfeatures2d::SURF のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
画像からSpeeded Up Robust Featuresを抽出するクラス [16] ．

アルゴリズムのパラメータです．

メンバー int extended

0 は，基本記述子（各64要素）を計算することを意味します．

1 は，拡張ディスクリプタ（各128要素）を計算することを意味します．





メンバー int upright

0 は，検出器が各特徴の向きを計算することを意味します．

1 は，向きの計算を行わないことを意味します（この方が，はるかに高速です）．例えば，ステレオペアの画像をマッチングさせたり，画像のスティッチングを行ったりする場合，マッチングした特徴の角度が非常に似ている可能性があり，upright=1を設定することで，特徴の抽出を高速化することができます．





member double hessianThreshold キーポイント検出器のしきい値。hessianThresholdよりも大きいヘシアンを持つ特徴のみが、検出器によって保持されます。したがって，この値が大きくなるほど，得られるキーポイントは少なくなります．初期値としては，画像のコントラストにもよりますが，300から500程度が良いでしょう。

member int nOctaves 検出器が利用するガウシアンピラミッドのオクターブ数を指定します。デフォルトでは，4に設定されています．非常に大きな特徴を得たい場合は，より大きな値を使用してください．小さな特徴を得るためには、この値を小さくしてください。

member int nOctaveLayers ガウシアンピラミッドの各オクターブ内の画像の数。デフォルトでは、2に設定されています。参考

SURF 特徴検出器を用いた例は， opencv_source_code/samples/cpp/generic_descriptor_match.cpp にあります．

SURF 特徴検出器，抽出器，マッチャーを用いた別の例は， opencv_source_code/samples/cpp/matcher_simple.cpp にあります．


元関数名(C#): xfeatures2d_Ptr_SURF_get
元DLLエクスポート名: xfeatures2d_Ptr_SURF_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_Ptr_SURF_get(cv::Ptr&amp;lt;cv::xfeatures2d::SURF&amp;gt; *ptr, cv::xfeatures2d::SURF **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_SURF_getHessianThreshold
[32/64bit] xfeatures2d_SURF_getHessianThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): xfeatures2d_SURF_getHessianThreshold
元DLLエクスポート名: xfeatures2d_SURF_getHessianThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_SURF_getHessianThreshold(cv::xfeatures2d::SURF *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getHessianThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_SURF_getNOctaves
[32/64bit] xfeatures2d_SURF_getNOctaves
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): xfeatures2d_SURF_getNOctaves
元DLLエクスポート名: xfeatures2d_SURF_getNOctaves
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_SURF_getNOctaves(cv::xfeatures2d::SURF *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getNOctaves();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_SURF_getNOctaveLayers
[32/64bit] xfeatures2d_SURF_getNOctaveLayers
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): xfeatures2d_SURF_getNOctaveLayers
元DLLエクスポート名: xfeatures2d_SURF_getNOctaveLayers
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_SURF_getNOctaveLayers(cv::xfeatures2d::SURF *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getNOctaveLayers();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_SURF_getExtended
[32/64bit] xfeatures2d_SURF_getExtended
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): xfeatures2d_SURF_getExtended
元DLLエクスポート名: xfeatures2d_SURF_getExtended
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_SURF_getExtended(cv::xfeatures2d::SURF *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getExtended() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_SURF_getUpright
[32/64bit] xfeatures2d_SURF_getUpright
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): xfeatures2d_SURF_getUpright
元DLLエクスポート名: xfeatures2d_SURF_getUpright
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_SURF_getUpright(cv::xfeatures2d::SURF *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getUpright() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_SURF_setHessianThreshold
[32/64bit] xfeatures2d_SURF_setHessianThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double value
%inst
元関数名(C#): xfeatures2d_SURF_setHessianThreshold
元DLLエクスポート名: xfeatures2d_SURF_setHessianThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_SURF_setHessianThreshold(cv::xfeatures2d::SURF *obj, double value)
{
    BEGIN_WRAP
    obj-&amp;gt;setHessianThreshold(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_SURF_setNOctaves
[32/64bit] xfeatures2d_SURF_setNOctaves
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): xfeatures2d_SURF_setNOctaves
元DLLエクスポート名: xfeatures2d_SURF_setNOctaves
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_SURF_setNOctaves(cv::xfeatures2d::SURF *obj, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;setNOctaves(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_SURF_setNOctaveLayers
[32/64bit] xfeatures2d_SURF_setNOctaveLayers
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): xfeatures2d_SURF_setNOctaveLayers
元DLLエクスポート名: xfeatures2d_SURF_setNOctaveLayers
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_SURF_setNOctaveLayers(cv::xfeatures2d::SURF *obj, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;setNOctaveLayers(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_SURF_setExtended
[32/64bit] xfeatures2d_SURF_setExtended
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): xfeatures2d_SURF_setExtended
元DLLエクスポート名: xfeatures2d_SURF_setExtended
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_SURF_setExtended(cv::xfeatures2d::SURF *obj, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;setExtended(value != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xfeatures2d_SURF_setUpright
[32/64bit] xfeatures2d_SURF_setUpright
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): xfeatures2d_SURF_setUpright
元DLLエクスポート名: xfeatures2d_SURF_setUpright
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xfeatures2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xfeatures2d_SURF_setUpright(cv::xfeatures2d::SURF *obj, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;setUpright(value != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xfeatures2d

%index
xphoto_bm3dDenoising1
[32/64bit] Block-Matching and 3D-filtering algorithm http://www.cs.tut.fi/~foi/GCF-BM3D/BM3D_TIP_2007.pdf を用いて，いくつかの計算上の最適化を行いながら，画像のノイズ除去を行います．ノイズは，ガウスホワイトノイズであることが期待されます．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dstStep1
p3 = sptr : IntPtr dstStep2
p4 = float : float h
p5 = int : int templateWindowSize
p6 = int : int searchWindowSize
p7 = int : int blockMatchingStep1
p8 = int : int blockMatchingStep2
p9 = int : int groupSize
p10 = int : int slidingStep
p11 = float : float beta
p12 = int : int normType
p13 = int : int step
p14 = int : int transformType
%inst
この関数は，グレースケール画像に適用されることを想定しています．この関数の高度な利用法として，異なる色空間を持つカラー画像を手動でノイズ除去することが挙げられます．

元関数名(C#): xphoto_bm3dDenoising1
元DLLエクスポート名: xphoto_bm3dDenoising1
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_bm3dDenoising1(
    cv::_InputArray *src,
    cv::_InputOutputArray *dstStep1,
    cv::_OutputArray *dstStep2,
    float h,
    int templateWindowSize,
    int searchWindowSize,
    int blockMatchingStep1,
    int blockMatchingStep2,
    int groupSize,
    int slidingStep,
    float beta,
    int normType,
    int step,
    int transformType)
{
    BEGIN_WRAP
    cv::xphoto::bm3dDenoising(
        *src, *dstStep1, *dstStep2, h, templateWindowSize, searchWindowSize, blockMatchingStep1, blockMatchingStep2, 
        groupSize, slidingStep, beta, normType, step, transformType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_bm3dDenoising2
[32/64bit] Block-Matching and 3D-filtering algorithm http://www.cs.tut.fi/~foi/GCF-BM3D/BM3D_TIP_2007.pdf を用いて，いくつかの計算上の最適化を行いながら，画像のノイズ除去を行います．ノイズは，ガウスホワイトノイズであることが期待されます．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = float : float h
p4 = int : int templateWindowSize
p5 = int : int searchWindowSize
p6 = int : int blockMatchingStep1
p7 = int : int blockMatchingStep2
p8 = int : int groupSize
p9 = int : int slidingStep
p10 = float : float beta
p11 = int : int normType
p12 = int : int step
p13 = int : int transformType
%inst
この関数は，グレースケール画像に適用されることを想定しています．この関数の高度な利用法として，異なる色空間を持つカラー画像を手動でノイズ除去することが挙げられます．

元関数名(C#): xphoto_bm3dDenoising2
元DLLエクスポート名: xphoto_bm3dDenoising2
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_bm3dDenoising2(
    cv::_InputArray *src,
    cv::_OutputArray *dst,
    float h,
    int templateWindowSize,
    int searchWindowSize,
    int blockMatchingStep1,
    int blockMatchingStep2,
    int groupSize,
    int slidingStep,
    float beta,
    int normType,
    int step,
    int transformType)
{
    BEGIN_WRAP
    cv::xphoto::bm3dDenoising(
        *src, *dst, h, templateWindowSize, searchWindowSize, blockMatchingStep1, blockMatchingStep2, 
        groupSize, slidingStep, beta, normType, step, transformType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_dctDenoising
[32/64bit] この関数は，シンプルな dct ベースのノイズ除去を行います．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = double : double sigma
p4 = int : int psize
%inst
http://www.ipol.im/pub/art/2011/ys-dct/.See また，fastNlMeansDenoising

元関数名(C#): xphoto_dctDenoising
元DLLエクスポート名: xphoto_dctDenoising
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_dctDenoising(cv::Mat *src, cv::Mat *dst, const double sigma, const int psize)
{
    BEGIN_WRAP
    cv::xphoto::dctDenoising(*src, *dst, sigma, psize);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_inpaint
[32/64bit] この関数は，様々な単一画像のインペインティングアルゴリズムを実装しています．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr prt
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
p4 = int : int algorithm
%inst
詳細は原著論文[105](Shiftmap)または[90],[214](FSR)を参照してください。

元関数名(C#): xphoto_inpaint
元DLLエクスポート名: xphoto_inpaint
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_inpaint(cv::Mat *src, cv::Mat *mask, cv::Mat *dst, int algorithm)
{
    BEGIN_WRAP
    cv::xphoto::inpaint(*src, *mask, *dst, static_cast&amp;lt;const cv::xphoto::InpaintTypes&amp;gt;(algorithm));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_oilPainting
[32/64bit] oilPainting 詳細は原著論文[39]を参照．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int size
p4 = int : int dynRatio
p5 = int : int code
%inst
元関数名(C#): xphoto_oilPainting
元DLLエクスポート名: xphoto_oilPainting
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_oilPainting(
    cv::_InputArray *src, cv::_OutputArray *dst, int size, int dynRatio, int code)
{
    BEGIN_WRAP
    if (code &amp;gt;= 0)
        cv::xphoto::oilPainting(*src, *dst, size, dynRatio, code);
    else
        cv::xphoto::oilPainting(*src, *dst, size, dynRatio);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_TonemapDurand_getSaturation
[32/64bit] xphoto_TonemapDurand_getSaturation
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): xphoto_TonemapDurand_getSaturation
元DLLエクスポート名: xphoto_TonemapDurand_getSaturation
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_TonemapDurand_getSaturation(cv::xphoto::TonemapDurand *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getSaturation();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_TonemapDurand_setSaturation
[32/64bit] xphoto_TonemapDurand_setSaturation
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float saturation
%inst
元関数名(C#): xphoto_TonemapDurand_setSaturation
元DLLエクスポート名: xphoto_TonemapDurand_setSaturation
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_TonemapDurand_setSaturation(cv::xphoto::TonemapDurand *obj, float saturation)
{
    BEGIN_WRAP
    obj-&amp;gt;setSaturation(saturation);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_TonemapDurand_getContrast
[32/64bit] xphoto_TonemapDurand_getContrast
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): xphoto_TonemapDurand_getContrast
元DLLエクスポート名: xphoto_TonemapDurand_getContrast
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_TonemapDurand_getContrast(cv::xphoto::TonemapDurand *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getContrast();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_TonemapDurand_setContrast
[32/64bit] xphoto_TonemapDurand_setContrast
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float contrast
%inst
元関数名(C#): xphoto_TonemapDurand_setContrast
元DLLエクスポート名: xphoto_TonemapDurand_setContrast
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_TonemapDurand_setContrast(cv::xphoto::TonemapDurand *obj, float contrast)
{
    BEGIN_WRAP
    obj-&amp;gt;setContrast(contrast);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_TonemapDurand_getSigmaSpace
[32/64bit] xphoto_TonemapDurand_getSigmaSpace
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): xphoto_TonemapDurand_getSigmaSpace
元DLLエクスポート名: xphoto_TonemapDurand_getSigmaSpace
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_TonemapDurand_getSigmaSpace(cv::xphoto::TonemapDurand *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getSigmaSpace();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_TonemapDurand_setSigmaSpace
[32/64bit] xphoto_TonemapDurand_setSigmaSpace
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float saturation
%inst
元関数名(C#): xphoto_TonemapDurand_setSigmaSpace
元DLLエクスポート名: xphoto_TonemapDurand_setSigmaSpace
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_TonemapDurand_setSigmaSpace(cv::xphoto::TonemapDurand *obj, float sigma_space)
{
    BEGIN_WRAP
    obj-&amp;gt;setSigmaSpace(sigma_space);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_TonemapDurand_getSigmaColor
[32/64bit] xphoto_TonemapDurand_getSigmaColor
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): xphoto_TonemapDurand_getSigmaColor
元DLLエクスポート名: xphoto_TonemapDurand_getSigmaColor
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_TonemapDurand_getSigmaColor(cv::xphoto::TonemapDurand *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getSigmaColor();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_TonemapDurand_setSigmaColor
[32/64bit] xphoto_TonemapDurand_setSigmaColor
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float saturation
%inst
元関数名(C#): xphoto_TonemapDurand_setSigmaColor
元DLLエクスポート名: xphoto_TonemapDurand_setSigmaColor
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_TonemapDurand_setSigmaColor(cv::xphoto::TonemapDurand *obj, float sigma_color)
{
    BEGIN_WRAP
    obj-&amp;gt;setSigmaColor(sigma_color);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_createTonemapDurand
[32/64bit] TonemapDurandオブジェクトを作成します。
%prm
p1,p2,p3,p4,p5,p6
p1 = float : float gamma
p2 = float : float contrast
p3 = float : float saturation
p4 = float : float sigmaSpace
p5 = float : float sigmaColor
p6 = var : out IntPtr returnValue
%inst
これらを使うには、cmakeでOPENCV_ENABLE_NONFREEオプションを設定する必要があります。これらを使用する場合は，自己責任でお願いします．

元関数名(C#): xphoto_createTonemapDurand
元DLLエクスポート名: xphoto_createTonemapDurand
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_createTonemapDurand(
    float gamma, float contrast, float saturation, float sigma_space, float sigma_color, cv::Ptr&amp;lt;cv::xphoto::TonemapDurand&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto p = cv::xphoto::createTonemapDurand(gamma, contrast, saturation, sigma_space, sigma_color);
    *returnValue = clone(p);
    END_WRAP  
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_Ptr_TonemapDurand_delete
[32/64bit] cv::xphoto::TonemapDurand のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
このアルゴリズムは，バイラテラルフィルタを用いて画像をベース層と詳細層の2つの層に分解し，ベース層のコントラストを圧縮することで，すべての詳細部分を保存します．

この実装では，OpenCV の通常のバイラテラルフィルタを利用します．

cv::TonemapDrago のように，彩度を強調することができます．

詳細は [63] を参照してください．


元関数名(C#): xphoto_Ptr_TonemapDurand_delete
元DLLエクスポート名: xphoto_Ptr_TonemapDurand_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_Ptr_TonemapDurand_delete(cv::Ptr&amp;lt;cv::xphoto::TonemapDurand&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_Ptr_TonemapDurand_get
[32/64bit] cv::xphoto::TonemapDurand のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
このアルゴリズムは，バイラテラルフィルタを用いて画像をベース層と詳細層の2つの層に分解し，ベース層のコントラストを圧縮することで，すべての詳細部分を保存します．

この実装では，OpenCV の通常のバイラテラルフィルタを利用します．

cv::TonemapDrago のように，彩度を強調することができます．

詳細は [63] を参照してください．


元関数名(C#): xphoto_Ptr_TonemapDurand_get
元DLLエクスポート名: xphoto_Ptr_TonemapDurand_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_Ptr_TonemapDurand_get(cv::Ptr&amp;lt;cv::xphoto::TonemapDurand&amp;gt; *ptr, cv::xphoto::TonemapDurand **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_applyChannelGains
[32/64bit] 複数のホワイトバランスアルゴリズムの最後のステップである，チャンネルゲインを適用するための効率的な固定小数点近似法を実装しています．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = float : float gainB
p4 = float : float gainG
p5 = float : float gainR
%inst
元関数名(C#): xphoto_applyChannelGains
元DLLエクスポート名: xphoto_applyChannelGains
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_applyChannelGains(cv::_InputArray *src, cv::_OutputArray *dst, float gainB, float gainG, float gainR)
{
    BEGIN_WRAP
    cv::xphoto::applyChannelGains(*src, *dst, gainB, gainG, gainR);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_createGrayworldWB
[32/64bit] GrayworldWB のインスタンスを生成します．
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): xphoto_createGrayworldWB
元DLLエクスポート名: xphoto_createGrayworldWB
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_createGrayworldWB(cv::Ptr&amp;lt;cv::xphoto::GrayworldWB&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::xphoto::createGrayworldWB();
    *returnValue = new cv::Ptr&amp;lt;cv::xphoto::GrayworldWB&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_Ptr_GrayworldWB_delete
[32/64bit] cv::xphoto::createGrayworldWB のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr prt
%inst
GrayworldWB のインスタンスを生成します．


元関数名(C#): xphoto_Ptr_GrayworldWB_delete
元DLLエクスポート名: xphoto_Ptr_GrayworldWB_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_Ptr_GrayworldWB_delete(cv::Ptr&amp;lt;cv::xphoto::GrayworldWB&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_Ptr_GrayworldWB_get
[32/64bit] cv::xphoto::createGrayworldWB のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = var : out IntPtr returnValue
%inst
GrayworldWB のインスタンスを生成します．


元関数名(C#): xphoto_Ptr_GrayworldWB_get
元DLLエクスポート名: xphoto_Ptr_GrayworldWB_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_Ptr_GrayworldWB_get(cv::Ptr&amp;lt;cv::xphoto::GrayworldWB&amp;gt;* ptr, cv::xphoto::GrayworldWB **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_GrayworldWB_balanceWhite
[32/64bit] xphoto_GrayworldWB_balanceWhite
%prm
p1,p2,p3
p1 = sptr : IntPtr prt
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
%inst
元関数名(C#): xphoto_GrayworldWB_balanceWhite
元DLLエクスポート名: xphoto_GrayworldWB_balanceWhite
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_GrayworldWB_balanceWhite(cv::xphoto::GrayworldWB* ptr, cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    ptr-&amp;gt;balanceWhite(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_GrayworldWB_SaturationThreshold_get
[32/64bit] xphoto_GrayworldWB_SaturationThreshold_get
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out float returnValue
%inst
元関数名(C#): xphoto_GrayworldWB_SaturationThreshold_get
元DLLエクスポート名: xphoto_GrayworldWB_SaturationThreshold_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_GrayworldWB_SaturationThreshold_get(cv::xphoto::GrayworldWB* ptr, float* returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;getSaturationThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_GrayworldWB_SaturationThreshold_set
[32/64bit] xphoto_GrayworldWB_SaturationThreshold_set
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = float : float val
%inst
元関数名(C#): xphoto_GrayworldWB_SaturationThreshold_set
元DLLエクスポート名: xphoto_GrayworldWB_SaturationThreshold_set
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_GrayworldWB_SaturationThreshold_set(cv::xphoto::GrayworldWB* ptr, float val)
{
    BEGIN_WRAP
    ptr-&amp;gt;setSaturationThreshold(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_createLearningBasedWB
[32/64bit] LearningBasedWBのインスタンスを作成します．
%prm
p1,p2
p1 = str : string trackerType
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): xphoto_createLearningBasedWB
元DLLエクスポート名: xphoto_createLearningBasedWB
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_createLearningBasedWB(const char* path_to_model, cv::Ptr&amp;lt;cv::xphoto::LearningBasedWB&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const std::string str_path_to_model(path_to_model);
    const auto ptr = cv::xphoto::createLearningBasedWB(str_path_to_model);
    *returnValue = new cv::Ptr&amp;lt;cv::xphoto::LearningBasedWB&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_Ptr_LearningBasedWB_delete
[32/64bit] cv::xphoto::LearningBasedWB のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr prt
%inst
より洗練された学習ベースの自動ホワイトバランスアルゴリズムです。

GrayworldWBと同様に、このアルゴリズムは、入力画像のチャンネルに異なるゲインを適用することで動作しますが、その計算は、単純なグレイワールドの仮定に比べて、少し複雑です。このアルゴリズムの詳細については，[46]を参照してください。

この関数は，飽和したピクセルをマスクアウトするために，以下の条件を満たすピクセルのみを利用します．



\[ \frac{\textrm{max}(R,G,B)}{\texttt{range_max_val}}< ????? )\]



現在，CV_8UC3 と CV_16UC3 のタイプの画像をサポートしています．


元関数名(C#): xphoto_Ptr_LearningBasedWB_delete
元DLLエクスポート名: xphoto_Ptr_LearningBasedWB_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_Ptr_LearningBasedWB_delete(cv::Ptr&amp;lt;cv::xphoto::LearningBasedWB&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_Ptr_LearningBasedWB_get
[32/64bit] cv::xphoto::LearningBasedWB のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = var : out IntPtr returnValue
%inst
より洗練された学習ベースの自動ホワイトバランスアルゴリズムです。

GrayworldWBと同様に、このアルゴリズムは、入力画像のチャンネルに異なるゲインを適用することで動作しますが、その計算は、単純なグレイワールドの仮定に比べて、少し複雑です。このアルゴリズムの詳細については，[46]を参照してください。

この関数は，飽和したピクセルをマスクアウトするために，以下の条件を満たすピクセルのみを利用します．



\[ \frac{\textrm{max}(R,G,B)}{\texttt{range_max_val}}< ????? )\]



現在，CV_8UC3 と CV_16UC3 のタイプの画像をサポートしています．


元関数名(C#): xphoto_Ptr_LearningBasedWB_get
元DLLエクスポート名: xphoto_Ptr_LearningBasedWB_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_Ptr_LearningBasedWB_get(cv::Ptr&amp;lt;cv::xphoto::LearningBasedWB&amp;gt;* ptr, cv::xphoto::LearningBasedWB **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_LearningBasedWB_balanceWhite
[32/64bit] xphoto_LearningBasedWB_balanceWhite
%prm
p1,p2,p3
p1 = sptr : IntPtr prt
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
%inst
元関数名(C#): xphoto_LearningBasedWB_balanceWhite
元DLLエクスポート名: xphoto_LearningBasedWB_balanceWhite
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_LearningBasedWB_balanceWhite(cv::xphoto::LearningBasedWB* ptr, cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    ptr-&amp;gt;balanceWhite(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_LearningBasedWB_extractSimpleFeatures
[32/64bit] アルゴリズムの特徴抽出部分を実装します．
%prm
p1,p2,p3
p1 = sptr : IntPtr prt
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
%inst
46] に従って，入力画像に対して以下の特徴量を計算します：平均的な(R,G,B)タプルの色度

最も明るい(R,G,B)タプルの色度（飽和した画素は無視する）

支配的な(R,G,B)タプルの色度（RGBヒストグラムで最も高い値を持つタプルの色度）

色度パレットのモード（RGBヒストグラムで最も一般的な300色を色度平面に投影して作成されます。モードは，パレットの中で最も密度の高い点であり，これは，エパニチオフカーネル関数を用いた単純な固定帯域幅のカーネル密度推定法によって求められます．

元関数名(C#): xphoto_LearningBasedWB_extractSimpleFeatures
元DLLエクスポート名: xphoto_LearningBasedWB_extractSimpleFeatures
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_LearningBasedWB_extractSimpleFeatures(cv::xphoto::LearningBasedWB* ptr, cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    ptr-&amp;gt;extractSimpleFeatures(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_LearningBasedWB_HistBinNum_set
[32/64bit] アルゴリズムが内部的に使用する3次元RGBヒストグラムの1次元のサイズを定義します。ビット深度の高い画像では，ビンの数を増やすことがしばしば意味を持ちます（例えば，12ビットの画像では256ビン）．
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = int : int value
%inst
関連項目： logetHistBinNum

元関数名(C#): xphoto_LearningBasedWB_HistBinNum_set
元DLLエクスポート名: xphoto_LearningBasedWB_HistBinNum_set
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_LearningBasedWB_HistBinNum_set(cv::xphoto::LearningBasedWB* ptr, int val)
{
    BEGIN_WRAP
    ptr-&amp;gt;setHistBinNum(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_LearningBasedWB_RangeMaxVal_set
[32/64bit] 入力画像の最大可能値（例：8ビット画像なら255、12ビット画像なら4095）。
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = int : int value
%inst
参照：「alsogetRangeMaxVal

元関数名(C#): xphoto_LearningBasedWB_RangeMaxVal_set
元DLLエクスポート名: xphoto_LearningBasedWB_RangeMaxVal_set
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_LearningBasedWB_RangeMaxVal_set(cv::xphoto::LearningBasedWB* ptr, int val)
{
    BEGIN_WRAP
    ptr-&amp;gt;setRangeMaxVal(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_LearningBasedWB_SaturationThreshold_set
[32/64bit] 飽和した画素を判定するための閾値です。つまり、少なくとも1つのチャンネルが\\を超える画素は無視されます。
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = float : float value
%inst
See alsogetSaturationThreshold

元関数名(C#): xphoto_LearningBasedWB_SaturationThreshold_set
元DLLエクスポート名: xphoto_LearningBasedWB_SaturationThreshold_set
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_LearningBasedWB_SaturationThreshold_set(cv::xphoto::LearningBasedWB* ptr, float val)
{
    BEGIN_WRAP
    ptr-&amp;gt;setSaturationThreshold(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_LearningBasedWB_HistBinNum_get
[32/64bit] アルゴリズムが内部的に使用する3次元RGBヒストグラムの1次元のサイズを定義します。ビット深度の高い画像では，ビンの数を増やすことがしばしば意味を持ちます（例えば，12ビットの画像では256ビン）．
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = var : out int returnValue
%inst
See alsosetHistBinNum

元関数名(C#): xphoto_LearningBasedWB_HistBinNum_get
元DLLエクスポート名: xphoto_LearningBasedWB_HistBinNum_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_LearningBasedWB_HistBinNum_get(cv::xphoto::LearningBasedWB* ptr, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;getHistBinNum();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_LearningBasedWB_RangeMaxVal_get
[32/64bit] 入力画像の最大可能値（例：8ビット画像なら255、12ビット画像なら4095）。
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = var : out int returnValue
%inst
See alsosetRangeMaxVal

元関数名(C#): xphoto_LearningBasedWB_RangeMaxVal_get
元DLLエクスポート名: xphoto_LearningBasedWB_RangeMaxVal_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_LearningBasedWB_RangeMaxVal_get(cv::xphoto::LearningBasedWB* ptr, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;getRangeMaxVal();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_LearningBasedWB_SaturationThreshold_get
[32/64bit] 飽和した画素を判定するための閾値です。つまり、少なくとも1つのチャンネルが\\を超える画素は無視されます。
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = var : out float returnValue
%inst
関連項目： alsosetSaturationThreshold

元関数名(C#): xphoto_LearningBasedWB_SaturationThreshold_get
元DLLエクスポート名: xphoto_LearningBasedWB_SaturationThreshold_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_LearningBasedWB_SaturationThreshold_get(cv::xphoto::LearningBasedWB* ptr, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;getSaturationThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_createSimpleWB
[32/64bit] SimpleWBのインスタンスを作成します。
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): xphoto_createSimpleWB
元DLLエクスポート名: xphoto_createSimpleWB
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_createSimpleWB(cv::Ptr&amp;lt;cv::xphoto::SimpleWB&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::xphoto::createSimpleWB();
    *returnValue = new cv::Ptr&amp;lt;cv::xphoto::SimpleWB&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_Ptr_SimpleWB_delete
[32/64bit] cv::xphoto::SimpleWB のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr prt
%inst
シンプルなホワイトバランスアルゴリズムで、入力画像の各チャンネルを指定された範囲に独立して引き伸ばすことで動作します。堅牢性を高めるために、ピクセル値の上下を無視します。


元関数名(C#): xphoto_Ptr_SimpleWB_delete
元DLLエクスポート名: xphoto_Ptr_SimpleWB_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_Ptr_SimpleWB_delete(cv::Ptr&amp;lt;cv::xphoto::SimpleWB&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_Ptr_SimpleWB_get
[32/64bit] cv::xphoto::SimpleWB のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = var : out IntPtr returnValue
%inst
シンプルなホワイトバランスアルゴリズムで、入力画像の各チャンネルを指定された範囲に独立して引き伸ばすことで動作します。堅牢性を高めるために、ピクセル値の上下を無視します。


元関数名(C#): xphoto_Ptr_SimpleWB_get
元DLLエクスポート名: xphoto_Ptr_SimpleWB_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_Ptr_SimpleWB_get(cv::Ptr&amp;lt;cv::xphoto::SimpleWB&amp;gt;* ptr, cv::xphoto::SimpleWB **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_SimpleWB_balanceWhite
[32/64bit] xphoto_SimpleWB_balanceWhite
%prm
p1,p2,p3
p1 = sptr : IntPtr prt
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
%inst
元関数名(C#): xphoto_SimpleWB_balanceWhite
元DLLエクスポート名: xphoto_SimpleWB_balanceWhite
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_SimpleWB_balanceWhite(cv::xphoto::SimpleWB* ptr, cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    ptr-&amp;gt;balanceWhite(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_SimpleWB_InputMax_get
[32/64bit] 入力画像範囲の最大値です。
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = var : out float returnValue
%inst
See alsosetInputMax

元関数名(C#): xphoto_SimpleWB_InputMax_get
元DLLエクスポート名: xphoto_SimpleWB_InputMax_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_SimpleWB_InputMax_get(cv::xphoto::SimpleWB* ptr, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;getInputMax();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_SimpleWB_InputMax_set
[32/64bit] 入力画像範囲の最大値です。
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = float : float value
%inst
See alsogetInputMax

元関数名(C#): xphoto_SimpleWB_InputMax_set
元DLLエクスポート名: xphoto_SimpleWB_InputMax_set
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_SimpleWB_InputMax_set(cv::xphoto::SimpleWB* ptr, float val)
{
    BEGIN_WRAP
    ptr-&amp;gt;setInputMax(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_SimpleWB_InputMin_get
[32/64bit] 入力映像範囲の最小値
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = var : out float returnValue
%inst
参照：ArsosetInputMin

元関数名(C#): xphoto_SimpleWB_InputMin_get
元DLLエクスポート名: xphoto_SimpleWB_InputMin_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_SimpleWB_InputMin_get(cv::xphoto::SimpleWB* ptr, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;getInputMin();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_SimpleWB_InputMin_set
[32/64bit] 入力映像範囲の最小値
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = float : float value
%inst
alsogetInputMin参照

元関数名(C#): xphoto_SimpleWB_InputMin_set
元DLLエクスポート名: xphoto_SimpleWB_InputMin_set
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_SimpleWB_InputMin_set(cv::xphoto::SimpleWB* ptr, float val)
{
    BEGIN_WRAP
    ptr-&amp;gt;setInputMin(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_SimpleWB_OutputMax_get
[32/64bit] 出力映像範囲の最大値
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = var : out float returnValue
%inst
参照：アルソセットアウトプットマックス

元関数名(C#): xphoto_SimpleWB_OutputMax_get
元DLLエクスポート名: xphoto_SimpleWB_OutputMax_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_SimpleWB_OutputMax_get(cv::xphoto::SimpleWB* ptr, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;getOutputMax();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_SimpleWB_OutputMax_set
[32/64bit] 出力映像範囲の最大値
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = float : float value
%inst
alsogetOutputMax参照

元関数名(C#): xphoto_SimpleWB_OutputMax_set
元DLLエクスポート名: xphoto_SimpleWB_OutputMax_set
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_SimpleWB_OutputMax_set(cv::xphoto::SimpleWB* ptr, float val)
{
    BEGIN_WRAP
    ptr-&amp;gt;setOutputMax(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_SimpleWB_OutputMin_get
[32/64bit] 出力映像範囲の最小値
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = var : out float returnValue
%inst
参照：アルソセットアウトプットミン

元関数名(C#): xphoto_SimpleWB_OutputMin_get
元DLLエクスポート名: xphoto_SimpleWB_OutputMin_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_SimpleWB_OutputMin_get(cv::xphoto::SimpleWB* ptr, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;getOutputMin();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_SimpleWB_OutputMin_set
[32/64bit] 出力映像範囲の最小値
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = float : float value
%inst
alsogetOutputMin参照

元関数名(C#): xphoto_SimpleWB_OutputMin_set
元DLLエクスポート名: xphoto_SimpleWB_OutputMin_set
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_SimpleWB_OutputMin_set(cv::xphoto::SimpleWB* ptr, float val)
{
    BEGIN_WRAP
    ptr-&amp;gt;setOutputMin(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_SimpleWB_P_get
[32/64bit] 無視するトップ／ボトム値の割合。
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = var : out float returnValue
%inst
参照：アルソセットP

元関数名(C#): xphoto_SimpleWB_P_get
元DLLエクスポート名: xphoto_SimpleWB_P_get
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_SimpleWB_P_get(cv::xphoto::SimpleWB* ptr, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;getP();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
xphoto_SimpleWB_P_set
[32/64bit] 無視するトップ／ボトム値の割合。
%prm
p1,p2
p1 = sptr : IntPtr prt
p2 = float : float value
%inst
alsogetP参照

元関数名(C#): xphoto_SimpleWB_P_set
元DLLエクスポート名: xphoto_SimpleWB_P_set
参照元CSファイル: Internal\PInvoke\NativeMethods\NativeMethods_xphoto.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) xphoto_SimpleWB_P_set(cv::xphoto::SimpleWB* ptr, float val)
{
    BEGIN_WRAP
    ptr-&amp;gt;setP(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_xphoto

%index
calib3d_Rodrigues
[32/64bit] 回転行列を回転ベクトルに変換したり、逆に回転行列を回転ベクトルに変換したりします。
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr jacobian
%inst
\♪♪〜\R = I + (1- ????? ) r^T + ????? ) R = I + (1- ????? ) r^T + ????? ) R = I + (1- ????? ) R = I + (1- ????? ) R = I + (1- ????? ) R = I + (1- ????? ) R = I + (1- ????? ) R = I + (1- ????? ) R = I + (1- ????? ) R = I + (1- ?????)\回転ベクトルは、回転行列の最もコンパクトで便利な表現です。この表現は、calibrateCamera、stereoCalibrate、solvePnPなどのグローバルな3Dジオメトリ最適化手順で使用されます。

A Compact Formula for the Derivative of a 3-D Rotation in Exponential Coordinates, Guillermo Gallego, Anthony J. Yezzi [83] に記載されています。







SE(3)とLie群に関する有用な情報は、以下にあります。

A tutorial on SE(3) transformation parameterizations and on-manifold optimization, Jose-Luis Blanco [24].

Lie Groups for 2D and 3D Transformation, Ethan Eade [65].

A micro Lie theory for state estimation in robotics, Joan Sola, Jeremie Deray, Dinesh Atchuthan [226]例： samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp.

元関数名(C#): calib3d_Rodrigues
元DLLエクスポート名: calib3d_Rodrigues
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_Rodrigues(cv::_InputArray *src, cv::_OutputArray *dst, cv::_OutputArray *jacobian)
{
    BEGIN_WRAP
    cv::Rodrigues(*src, *dst, entity(jacobian));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_findHomography_InputArray
[32/64bit] 2つの平面間の透視変換を求めます。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr srcPoints
p2 = sptr : IntPtr dstPoints
p3 = int : int method
p4 = double : double ransacReprojThreshold
p5 = sptr : IntPtr mask
p6 = var : out IntPtr returnValue
%inst
この関数は，ソース平面とデスティネーション平面の間の透視変換\(H\)を求めて返します．\逆投影誤差\[sum _i ?left ( x'_i- ?frac{h_{11} x_i + h_{12} y_i + h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} ?right )^2+ ??-??-??-??-?!\h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + h_{33}} eldest ) ^2+ eldest ( y'_i- ????? )\)^2\]を最小化します。パラメータメソッドがデフォルト値の 0 に設定されている場合，この関数は，すべての点のペアを使って，単純な最小二乗法でホモグラフィの初期推定値を計算します．しかし，すべての点のペア（ ??o???,??o???）が剛体透視変換に適合しない場合（つまり，外れ値がある場合），この初期推定値は悪くなります．このような場合には，3つのロバストな手法のうちの1つを用いることができます．RANSAC，LMeDS，RHOの各手法は，対応する点のペアの多くの異なるランダムなサブセット（各4ペアで，共線的なペアは破棄されます）を試し，このサブセットと単純な最小二乗アルゴリズムを使ってホモグラフィ行列を推定し，計算されたホモグラフィの品質/良さ（RANSACの場合はインライアの数，LMeDSの場合は再投影誤差の最小中央値）を計算します．ロバストかどうかに関わらず，計算されたホモグラフィ行列は，Levenberg-Marquardt法を用いて（ロバスト法の場合はインライアのみを用いて）さらに精密化され，再投影誤差がさらに減少します。RANSAC法とRHO法は，アウトライアの比率を実質的に問わずに扱うことができますが，インライアとアウトライアを区別するための閾値が必要です。RANSACとRHOはアウトライアの比率に関係なく扱えますが、インライアとアウトライアを区別するための閾値が必要です。最後に，外れ値がなく，ノイズがかなり小さい場合は，デフォルトの手法（method=0）を利用します．この関数は，初期の内在行列と外在行列を求めるために利用されます．ホモグラフィー行列は，ある尺度まで決定されます．そのため，\(h_{33}=1\)となるように正規化されています．また，getAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective, perspectiveTransformExamples: samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, and samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp.

元関数名(C#): calib3d_findHomography_InputArray
元DLLエクスポート名: calib3d_findHomography_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_findHomography_InputArray(
    cv::_InputArray *srcPoints, cv::_InputArray *dstPoints,
    int method, double ransacReprojThreshold, cv::_OutputArray *mask,
    cv::Mat** returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::findHomography(*srcPoints, *dstPoints, method, ransacReprojThreshold, entity(mask));
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_findHomography_vector
[32/64bit] 2つの平面間の透視変換を求めます。
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = var : Point2d[] srcPoints
p2 = int : int srcPointsLength
p3 = var : Point2d[] dstPoints
p4 = int : int dstPointsLength
p5 = int : int method
p6 = double : double ransacReprojThreshold
p7 = sptr : IntPtr mask
p8 = var : out IntPtr returnValue
%inst
この関数は，ソース平面とデスティネーション平面の間の透視変換\(H\)を求めて返します．\逆投影誤差\[sum _i ?left ( x'_i- ?frac{h_{11} x_i + h_{12} y_i + h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} ?right )^2+ ??-??-??-??-?!\h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + h_{33}} eldest ) ^2+ eldest ( y'_i- ????? )\)^2\]を最小化します。パラメータメソッドがデフォルト値の 0 に設定されている場合，この関数は，すべての点のペアを使って，単純な最小二乗法でホモグラフィの初期推定値を計算します．しかし，すべての点のペア（ ??o???,??o???）が剛体透視変換に適合しない場合（つまり，外れ値がある場合），この初期推定値は悪くなります．このような場合には，3つのロバストな手法のうちの1つを用いることができます．RANSAC，LMeDS，RHOの各手法は，対応する点のペアの多くの異なるランダムなサブセット（各4ペアで，共線的なペアは破棄されます）を試し，このサブセットと単純な最小二乗アルゴリズムを使ってホモグラフィ行列を推定し，計算されたホモグラフィの品質/良さ（RANSACの場合はインライアの数，LMeDSの場合は再投影誤差の最小中央値）を計算します．ロバストかどうかに関わらず，計算されたホモグラフィ行列は，Levenberg-Marquardt法を用いて（ロバスト法の場合はインライアのみを用いて）さらに精密化され，再投影誤差がさらに減少します。RANSAC法とRHO法は，アウトライアの比率を実質的に問わずに扱うことができますが，インライアとアウトライアを区別するための閾値が必要です。RANSACとRHOはアウトライアの比率に関係なく扱えますが、インライアとアウトライアを区別するための閾値が必要です。最後に，外れ値がなく，ノイズがかなり小さい場合は，デフォルトの手法（method=0）を利用します．この関数は，初期の内在行列と外在行列を求めるために利用されます．ホモグラフィー行列は，ある尺度まで決定されます．そのため，\(h_{33}=1\)となるように正規化されています．また，getAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective, perspectiveTransformExamples: samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, and samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp.

元関数名(C#): calib3d_findHomography_vector
元DLLエクスポート名: calib3d_findHomography_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_findHomography_vector(
    cv::Point2d *srcPoints, int srcPointsLength,
    cv::Point2d *dstPoints, int dstPointsLength,
    int method, double ransacReprojThreshold, cv::_OutputArray *mask, 
    cv::Mat **returnValue)
{
    BEGIN_WRAP
    const cv::Mat srcPointsMat(srcPointsLength, 1, CV_64FC2, srcPoints);
    const cv::Mat dstPointsMat(dstPointsLength, 1, CV_64FC2, dstPoints);

    const auto ret = cv::findHomography(srcPointsMat, dstPointsMat, method, ransacReprojThreshold, entity(mask));
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_RQDecomp3x3_InputArray
[32/64bit] 3x3 行列の RQ 分解を計算します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr mtxR
p3 = sptr : IntPtr mtxQ
p4 = sptr : IntPtr qx
p5 = sptr : IntPtr qy
p6 = sptr : IntPtr qz
p7 = var : out Vec3d outVal
%inst
この関数は，与えられた回転を用いてRQ分解を行います．この関数は， decomposeProjectionMatrix の中で，射影行列の左3x3部分行列をカメラ行列と回転行列に分解するために利用されます．また，オプションとして，各軸に1つずつ配置された3つの回転行列と，OpenGLで利用可能な3つのオイラー角を（戻り値として）返します．なお，オブジェクトの向きが同じになるような3つの主軸を中心とした回転のシーケンスは，常に1つ以上存在します（例えば，[225]参照）．返された木の回転行列とそれに対応する3つのオイラー角は，可能な解決策の1つに過ぎません．

元関数名(C#): calib3d_RQDecomp3x3_InputArray
元DLLエクスポート名: calib3d_RQDecomp3x3_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_RQDecomp3x3_InputArray(
    cv::_InputArray *src, cv::_OutputArray *mtxR, cv::_OutputArray *mtxQ,
    cv::_OutputArray *qx, cv::_OutputArray *qy, cv::_OutputArray *qz, cv::Vec3d *outVec)
{
    BEGIN_WRAP
    *outVec = cv::RQDecomp3x3(*src, *mtxR, *mtxQ, entity(qx), entity(qy), entity(qz));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_RQDecomp3x3_Mat
[32/64bit] 3x3 行列の RQ 分解を計算します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr mtxR
p3 = sptr : IntPtr mtxQ
p4 = sptr : IntPtr qx
p5 = sptr : IntPtr qy
p6 = sptr : IntPtr qz
p7 = var : out Vec3d outVal
%inst
この関数は，与えられた回転を用いてRQ分解を行います．この関数は， decomposeProjectionMatrix の中で，射影行列の左3x3部分行列をカメラ行列と回転行列に分解するために利用されます．また，オプションとして，各軸に1つずつ配置された3つの回転行列と，OpenGLで利用可能な3つのオイラー角を（戻り値として）返します．なお，オブジェクトの向きが同じになるような3つの主軸を中心とした回転のシーケンスは，常に1つ以上存在します（例えば，[225]参照）．返された木の回転行列とそれに対応する3つのオイラー角は，可能な解決策の1つに過ぎません．

元関数名(C#): calib3d_RQDecomp3x3_Mat
元DLLエクスポート名: calib3d_RQDecomp3x3_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_RQDecomp3x3_Mat(
    cv::Mat *src, cv::Mat *mtxR, cv::Mat *mtxQ,
    cv::Mat *qx, cv::Mat *qy, cv::Mat *qz, cv::Vec3d *outVec)
{
    BEGIN_WRAP
    *outVec = cv::RQDecomp3x3(*src, *mtxR, *mtxQ, *qx, *qy, *qz);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_decomposeProjectionMatrix_InputArray
[32/64bit] 投影行列を，回転行列とカメラ固有の行列に分解します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr projMatrix
p2 = sptr : IntPtr cameraMatrix
p3 = sptr : IntPtr rotMatrix
p4 = sptr : IntPtr transVect
p5 = sptr : IntPtr rotMatrixX
p6 = sptr : IntPtr rotMatrixY
p7 = sptr : IntPtr rotMatrixZ
p8 = sptr : IntPtr eulerAngles
%inst
この関数は，射影行列をキャリブレーション行列と回転行列に分解し，カメラの位置を計算します．また，オプションとして，各軸に1つずつ配置された3つの回転行列と，OpenGLで利用可能な3つのオイラー角を返します．なお，オブジェクトの向きが同じになるような3つの主軸を中心とした回転のシーケンスは，常に1つ以上存在します（例えば，[225]を参照してください）．返された木の回転行列と，それに対応する3つのオイラー角は，可能な解の1つに過ぎません．

元関数名(C#): calib3d_decomposeProjectionMatrix_InputArray
元DLLエクスポート名: calib3d_decomposeProjectionMatrix_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_decomposeProjectionMatrix_InputArray(
    cv::_InputArray *projMatrix, cv::_OutputArray *cameraMatrix,
    cv::_OutputArray *rotMatrix, cv::_OutputArray *transVect, cv::_OutputArray *rotMatrixX,
    cv::_OutputArray *rotMatrixY, cv::_OutputArray *rotMatrixZ, cv::_OutputArray *eulerAngles)
{
    BEGIN_WRAP
    cv::decomposeProjectionMatrix(*projMatrix, *cameraMatrix, *rotMatrix,
        *transVect, entity(rotMatrixX), entity(rotMatrixY), entity(rotMatrixZ), entity(eulerAngles));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_decomposeProjectionMatrix_Mat
[32/64bit] 投影行列を，回転行列とカメラ固有の行列に分解します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr projMatrix
p2 = sptr : IntPtr cameraMatrix
p3 = sptr : IntPtr rotMatrix
p4 = sptr : IntPtr transVect
p5 = sptr : IntPtr rotMatrixX
p6 = sptr : IntPtr rotMatrixY
p7 = sptr : IntPtr rotMatrixZ
p8 = sptr : IntPtr eulerAngles
%inst
この関数は，射影行列をキャリブレーション行列と回転行列に分解し，カメラの位置を計算します．また，オプションとして，各軸に1つずつ配置された3つの回転行列と，OpenGLで利用可能な3つのオイラー角を返します．なお，オブジェクトの向きが同じになるような3つの主軸を中心とした回転のシーケンスは，常に1つ以上存在します（例えば，[225]を参照してください）．返された木の回転行列と，それに対応する3つのオイラー角は，可能な解の1つに過ぎません．

元関数名(C#): calib3d_decomposeProjectionMatrix_Mat
元DLLエクスポート名: calib3d_decomposeProjectionMatrix_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_decomposeProjectionMatrix_Mat(
    cv::Mat *projMatrix, cv::Mat *cameraMatrix,
    cv::Mat *rotMatrix, cv::Mat *transVect, cv::Mat *rotMatrixX,
    cv::Mat *rotMatrixY, cv::Mat *rotMatrixZ, cv::Mat *eulerAngles)
{
    BEGIN_WRAP
    cv::decomposeProjectionMatrix(*projMatrix, *cameraMatrix, *rotMatrix,
        *transVect, *rotMatrixX, *rotMatrixY, *rotMatrixZ, *eulerAngles);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_matMulDeriv
[32/64bit] 乗算された各行列に対する行列積の偏導関数を求めます．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr a
p2 = sptr : IntPtr b
p3 = sptr : IntPtr dABdA
p4 = sptr : IntPtr dABdB
%inst
この関数は，入力された2つの行列のそれぞれの要素に対する，行列積 ?A*B?の要素の偏微分を求めます．この関数は， stereoCalibrate のジャコビアン行列を計算するために利用されますが，他の類似した最適化関数でも利用できます．

元関数名(C#): calib3d_matMulDeriv
元DLLエクスポート名: calib3d_matMulDeriv
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_matMulDeriv(
    cv::_InputArray *a, cv::_InputArray *b,
    cv::_OutputArray *dABdA, cv::_OutputArray *dABdB)
{
    BEGIN_WRAP
    cv::matMulDeriv(*a, *b, *dABdA, *dABdB);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_composeRT_InputArray
[32/64bit] 2つの回転-シフト変換を組み合わせます。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14
p1 = sptr : IntPtr rvec1
p2 = sptr : IntPtr tvec1
p3 = sptr : IntPtr rvec2
p4 = sptr : IntPtr tvec2
p5 = sptr : IntPtr rvec3
p6 = sptr : IntPtr tvec3
p7 = sptr : IntPtr dr3dr1
p8 = sptr : IntPtr dr3dt1
p9 = sptr : IntPtr dr3dr2
p10 = sptr : IntPtr dr3dt2
p11 = sptr : IntPtr dt3dr1
p12 = sptr : IntPtr dt3dt1
p13 = sptr : IntPtr dt3dr2
p14 = sptr : IntPtr dt3dt2
%inst
この関数は、次のように計算します。\¶texttt{rvec3} = ¶mathrm{rodrigues}.^{-1} ????? ( ????? )( ????? )( ????? )\\ ♪♪〜( ????? )+ ????? )\ここで、\(mathrm{rodrigues}\)は回転ベクトルから回転行列への変換を表し、\(mathrm{rodrigues}^{-1}\)は逆変換を表します。また，この関数は，入力ベクトルに対する出力ベクトルの導関数を計算することができます（matMulDeriv 参照）．また，この関数は，入力ベクトルに対する出力ベクトルの導関数を計算することができます（matMulDeriv を参照）．これらの関数は stereoCalibrate 内で使用されますが，Levenberg-Marquardt などの勾配ベースのソルバーを使って，行列の乗算を含む関数を最適化するような独自のコードでも使用できます．

元関数名(C#): calib3d_composeRT_InputArray
元DLLエクスポート名: calib3d_composeRT_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_composeRT_InputArray(
    cv::_InputArray *rvec1, cv::_InputArray *tvec1,
    cv::_InputArray *rvec2, cv::_InputArray *tvec2,
    cv::_OutputArray *rvec3, cv::_OutputArray *tvec3,
    cv::_OutputArray *dr3dr1, cv::_OutputArray *dr3dt1,
    cv::_OutputArray *dr3dr2, cv::_OutputArray *dr3dt2,
    cv::_OutputArray *dt3dr1, cv::_OutputArray *dt3dt1,
    cv::_OutputArray *dt3dr2, cv::_OutputArray *dt3dt2)
{
    BEGIN_WRAP
    cv::composeRT(*rvec1, *tvec1, *rvec2, *tvec2, *rvec3, *tvec3,
        entity(dr3dr1), entity(dr3dt1), entity(dr3dr2), entity(dr3dt2),
        entity(dt3dr1), entity(dt3dt1), entity(dt3dr2), entity(dt3dt2));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_composeRT_Mat
[32/64bit] 2つの回転-シフト変換を組み合わせます。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14
p1 = sptr : IntPtr rvec1
p2 = sptr : IntPtr tvec1
p3 = sptr : IntPtr rvec2
p4 = sptr : IntPtr tvec2
p5 = sptr : IntPtr rvec3
p6 = sptr : IntPtr tvec3
p7 = sptr : IntPtr dr3dr1
p8 = sptr : IntPtr dr3dt1
p9 = sptr : IntPtr dr3dr2
p10 = sptr : IntPtr dr3dt2
p11 = sptr : IntPtr dt3dr1
p12 = sptr : IntPtr dt3dt1
p13 = sptr : IntPtr dt3dr2
p14 = sptr : IntPtr dt3dt2
%inst
この関数は、次のように計算します。\¶texttt{rvec3} = ¶mathrm{rodrigues}.^{-1} ????? ( ????? )( ????? )( ????? )\\ ♪♪〜( ????? )+ ????? )\ここで、\(mathrm{rodrigues}\)は回転ベクトルから回転行列への変換を表し、\(mathrm{rodrigues}^{-1}\)は逆変換を表します。また，この関数は，入力ベクトルに対する出力ベクトルの導関数を計算することができます（matMulDeriv 参照）．また，この関数は，入力ベクトルに対する出力ベクトルの導関数を計算することができます（matMulDeriv を参照）．これらの関数は stereoCalibrate 内で使用されますが，Levenberg-Marquardt などの勾配ベースのソルバーを使って，行列の乗算を含む関数を最適化するような独自のコードでも使用できます．

元関数名(C#): calib3d_composeRT_Mat
元DLLエクスポート名: calib3d_composeRT_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_composeRT_Mat(
    cv::Mat *rvec1, cv::Mat *tvec1,
    cv::Mat *rvec2, cv::Mat *tvec2,
    cv::Mat *rvec3, cv::Mat *tvec3,
    cv::Mat *dr3dr1, cv::Mat *dr3dt1,
    cv::Mat *dr3dr2, cv::Mat *dr3dt2,
    cv::Mat *dt3dr1, cv::Mat *dt3dt1,
    cv::Mat *dt3dr2, cv::Mat *dt3dt2)
{
    BEGIN_WRAP
    cv::composeRT(*rvec1, *tvec1, *rvec2, *tvec2, *rvec3, *tvec3,
        entity(dr3dr1), entity(dr3dt1), entity(dr3dr2), entity(dr3dt2),
        entity(dt3dr1), entity(dt3dt1), entity(dt3dr2), entity(dt3dt2));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_projectPoints_InputArray
[32/64bit] 3D ポイントを画像平面に投影します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr objectPoints
p2 = sptr : IntPtr rvec
p3 = sptr : IntPtr tvec
p4 = sptr : IntPtr cameraMatrix
p5 = sptr : IntPtr distCoeffs
p6 = sptr : IntPtr imagePoints
p7 = sptr : IntPtr jacobian
p8 = double : double aspectRatio
%inst
この関数は，カメラの内部および外部パラメータが与えられた場合に，3次元点の画像平面への2次元投影を求めます．オプションとして，この関数は，（すべての入力パラメータの関数としての）画像点の座標の偏微分の行列であるヤコビアンを，特定のパラメータ（内部および外部）に関して求めます．このヤコビアンは， calibrateCamera, solvePnP, stereoCalibrate における全体最適化の際に利用されます．Notervec = tvec = ?([0, 0, 0]?)を設定したり，cameraMatrix を 3x3 の単位行列にしたり，歪み係数を 0 にしたりすると，この関数の様々な便利な部分例を得ることができます．つまり，理想的なゼロディストーションの設定において，疎な点群に対する歪んだ座標を計算したり，透視変換を適用したり（そして，その微分を計算したり）することができるのです．

元関数名(C#): calib3d_projectPoints_InputArray
元DLLエクスポート名: calib3d_projectPoints_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_projectPoints_InputArray(
    cv::_InputArray *objectPoints,
    cv::_InputArray *rvec, cv::_InputArray *tvec,
    cv::_InputArray *cameraMatrix, cv::_InputArray *distCoeffs,
    cv::_OutputArray *imagePoints,
    cv::_OutputArray *jacobian,
    double aspectRatio)
{
    BEGIN_WRAP
    cv::projectPoints(*objectPoints, *rvec, *tvec, *cameraMatrix, *distCoeffs,
        *imagePoints, entity(jacobian), aspectRatio);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_projectPoints_Mat
[32/64bit] 3D ポイントを画像平面に投影します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr objectPoints
p2 = sptr : IntPtr rvec
p3 = sptr : IntPtr tvec
p4 = sptr : IntPtr cameraMatrix
p5 = sptr : IntPtr distCoeffs
p6 = sptr : IntPtr imagePoints
p7 = sptr : IntPtr jacobian
p8 = double : double aspectRatio
%inst
この関数は，カメラの内部および外部パラメータが与えられた場合に，3次元点の画像平面への2次元投影を求めます．オプションとして，この関数は，（すべての入力パラメータの関数としての）画像点の座標の偏微分の行列であるヤコビアンを，特定のパラメータ（内部および外部）に関して求めます．このヤコビアンは， calibrateCamera, solvePnP, stereoCalibrate における全体最適化の際に利用されます．Notervec = tvec = ?([0, 0, 0]?)を設定したり，cameraMatrix を 3x3 の単位行列にしたり，歪み係数を 0 にしたりすると，この関数の様々な便利な部分例を得ることができます．つまり，理想的なゼロディストーションの設定において，疎な点群に対する歪んだ座標を計算したり，透視変換を適用したり（そして，その微分を計算したり）することができるのです．

元関数名(C#): calib3d_projectPoints_Mat
元DLLエクスポート名: calib3d_projectPoints_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_projectPoints_Mat(
    cv::Mat *objectPoints,
    cv::Mat *rvec, cv::Mat *tvec,
    cv::Mat *cameraMatrix, cv::Mat *distCoeffs,
    cv::Mat *imagePoints,
    cv::Mat *jacobian,
    double aspectRatio)
{
    BEGIN_WRAP
    cv::projectPoints(*objectPoints, *rvec, *tvec, *cameraMatrix, *distCoeffs,
        *imagePoints, *jacobian, aspectRatio);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_solvePnP_InputArray
[32/64bit] 3次元と2次元の点の対応関係から，物体の姿勢を見つけます．この関数は，オブジェクト座標フレームで表現された3次元点を，カメラ座標フレームに変換するための回転ベクトルと並進ベクトルを，それぞれ異なる方法で返します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr selfectPoints
p2 = sptr : IntPtr imagePoints
p3 = sptr : IntPtr cameraMatrix
p4 = sptr : IntPtr distCoeffs
p5 = sptr : IntPtr rvec
p6 = sptr : IntPtr tvec
p7 = int : int useExtrinsicGuess
p8 = int : int flags
%inst
P3Pメソッド（SOLVEPNP_P3P、SOLVEPNP_AP3P）：唯一の解を返すために4つの入力点を必要とする。

SOLVEPNP_IPPE 入力点は >= 4 でなければならず、オブジェクト点は同一平面上になければならない。

SOLVEPNP_IPPE_SQUARE マーカーのポーズ推定に適した特殊なケース。入力点の数は4でなければなりません。オブジェクトポイントは以下の順序で定義する必要があります。

点0： [-squareLength / 2, squareLength / 2, 0] 。

point 1: [ squareLength / 2, squareLength / 2, 0]の順に定義される。

ポイント2：[ squareLength / 2, -squareLength / 2, 0]の順になります。

点3：［-squareLength / 2, -squareLength / 2, 0］。





この関数は，オブジェクトポイントの集合と，それに対応する画像投影，カメラの固有行列と歪み係数が与えられた場合に，オブジェクトの姿勢を推定します（より正確には，カメラフレームのX軸は右向き，Y軸は下向き，Z軸は前向き）．ワールドフレームで表現された点は、透視投影モデルとカメラ固有のパラメータマトリクスを用いて、画像平面に投影されます。\♪ u ♪ v ♪ 1 ♪ end{bmatrix} &= ??? -? ????\0.1em\\\\^{c}\\{T}_wX_{w}\\ Y_{w}\\ ♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪\\ ♪♪♪♪♪〜\\ ♪♪♪♪♪♪♪♪〜\♪♪〜♪ 1 & 0 & 0 & 0 ♪ 0 & 0 & 1 & 0 ♪ END\r_{11} & r_{12} & r_{13} & t_x ¶ r_{21} & r_{22} & r_{23} & t_y ¶ r_{31} & r_{32} & r_{33} & t_z ¶ 0 & 0 & 1 ¶ end{bmatrix}.\♪♪♪♪♪♪♪〜X_{w}\\ X_{w}/Y_{w}\\ ♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪\\\\\♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪\推定されたポーズは、ワールドフレームで表現された3Dポイントをカメラフレームに変換するための回転（rvec）と平行移動（tvec）のベクトルとなります。\\\\X_c ¶ Y_c ¶ Z_c ¶ 1 ¶end{bmatrix} &= ¶hspace{0.2em}.^{c}\\{T}_wX_{w}\\ Y_{w}\\ ♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪\\ ♪♪♪♪♪〜\\\\♪ X, Y, Z\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\♪♪♪♪♪♪♪〜X_{w}\\ X_{w}/Y_{w}\\ ♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪\\\\\♪♪♪♪end{align*}\Note

平面型拡張現実感に対する solvePnP の使用例は opencv_source_code/samples/python/plane_ar.py にあります。

Pythonをお使いの方へ。

solvePnP は連続した配列を必要とするので，Numpy 配列スライスは入力として動作しません（modules/calib3d/src/solvepnp.cpp version 2.4.9 の 55 行目あたりで cv::Mat::checkVector() を用いたアサーションにより強制されています）．

P3P アルゴリズムでは，2 チャンネルの情報を必要とする undistortPoints の呼び出し（modules/calib3d/src/solvepnp.cpp version 2.4.9 の 75 行目付近）のために，画像ポイントが (N,1,2) の形をした配列になっている必要があります．

したがって，あるデータ D = np.array(...) (D.shape = (N,M)) が与えられた場合，そのサブセットを例えば imagePoints として使用するためには，それを新しい配列に効果的にコピーしなければなりません： imagePoints = np.ascontiguousarray(D[:,:2]).reshape((N,1,2))





SOLVEPNP_DLSおよびSOLVEPNP_UPNPメソッドは、現在の実装が不安定で、完全に間違った結果を与えることがあるため、使用できません。これら2つのフラグのいずれかを渡すと、代わりにSOLVEPNP_EPNPメソッドが使用されます。

一般的なケースでは、最小ポイント数は4である。SOLVEPNP_P3PおよびSOLVEPNP_AP3P法の場合、正確に4点を使用することが必要である（最初の3点はP3P問題のすべての解を推定するために使用され、最後の1点は再投影誤差を最小化する最良の解を保持するために使用される）。

SOLVEPNP_ITERATIVEメソッドとuseExtrinsicGuess=trueを使用した場合、最小のポイント数は3です（ポーズを計算するには3ポイントで十分ですが、最大で4つの解があります）。収束させるためには、初期解をグローバル解に近づける必要があります。

SOLVEPNP_IPPEの場合、入力ポイントは≧4でなければならず、オブジェクトポイントはコプラナーでなければなりません。

SOLVEPNP_IPPE_SQUARE の場合、これはマーカーのポーズ推定に適した特殊なケースです。入力点の数は 4 でなければなりません。オブジェクトポイントは以下の順序で定義しなければならない。

点0： [-squareLength / 2, squareLength / 2, 0] 。

point 1: [ squareLength / 2, squareLength / 2, 0]の順に定義される。

ポイント2：[ squareLength / 2, -squareLength / 2, 0]の順になります。

point 3: [-squareLength / 2, -squareLength / 2, 0]SOLVEPNP_SQPNPの場合、入力ポイントは≧3でなければなりませんサンプル：samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp、samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp。

元関数名(C#): calib3d_solvePnP_InputArray
元DLLエクスポート名: calib3d_solvePnP_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_solvePnP_InputArray(
    cv::_InputArray *objectPoints, cv::_InputArray *imagePoints, cv::_InputArray *cameraMatrix, cv::_InputArray *distCoeffs,
    cv::_OutputArray *rvec, cv::_OutputArray *tvec, int useExtrinsicGuess, int flags)
{
    BEGIN_WRAP
    cv::solvePnP(*objectPoints, *imagePoints, *cameraMatrix, entity(distCoeffs), *rvec, *tvec, useExtrinsicGuess != 0, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_solvePnP_vector
[32/64bit] 3次元と2次元の点の対応関係から，物体の姿勢を見つけます．この関数は，オブジェクト座標フレームで表現された3次元点を，カメラ座標フレームに変換するための回転ベクトルと並進ベクトルを，それぞれ異なる方法で返します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11
p1 = var : Point3f[] objectPoints
p2 = int : int objectPointsLength
p3 = var : Point2f[] imagePoints
p4 = int : int imagePointsLength
p5 = var : double* cameraMatrix
p6 = var : double[]? distCoeffs
p7 = int : int distCoeffsLength
p8 = var : [Out] double[] rvec
p9 = var : [Out] double[] tvec
p10 = int : int useExtrinsicGuess
p11 = int : int flags
%inst
P3Pメソッド（SOLVEPNP_P3P、SOLVEPNP_AP3P）：唯一の解を返すために4つの入力点を必要とする。

SOLVEPNP_IPPE 入力点は >= 4 でなければならず、オブジェクト点は同一平面上になければならない。

SOLVEPNP_IPPE_SQUARE マーカーのポーズ推定に適した特殊なケース。入力点の数は4でなければなりません。オブジェクトポイントは以下の順序で定義する必要があります。

点0： [-squareLength / 2, squareLength / 2, 0] 。

point 1: [ squareLength / 2, squareLength / 2, 0]の順に定義される。

ポイント2：[ squareLength / 2, -squareLength / 2, 0]の順になります。

点3：［-squareLength / 2, -squareLength / 2, 0］。





この関数は，オブジェクトポイントの集合と，それに対応する画像投影，カメラの固有行列と歪み係数が与えられた場合に，オブジェクトの姿勢を推定します（より正確には，カメラフレームのX軸は右向き，Y軸は下向き，Z軸は前向き）．ワールドフレームで表現された点は、透視投影モデルとカメラ固有のパラメータマトリクスを用いて、画像平面に投影されます。\♪ u ♪ v ♪ 1 ♪ end{bmatrix} &= ??? -? ????\0.1em\\\\^{c}\\{T}_wX_{w}\\ Y_{w}\\ ♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪\\ ♪♪♪♪♪〜\\ ♪♪♪♪♪♪♪♪〜\♪♪〜♪ 1 & 0 & 0 & 0 ♪ 0 & 0 & 1 & 0 ♪ END\r_{11} & r_{12} & r_{13} & t_x ¶ r_{21} & r_{22} & r_{23} & t_y ¶ r_{31} & r_{32} & r_{33} & t_z ¶ 0 & 0 & 1 ¶ end{bmatrix}.\♪♪♪♪♪♪♪〜X_{w}\\ X_{w}/Y_{w}\\ ♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪\\\\\♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪\推定されたポーズは、ワールドフレームで表現された3Dポイントをカメラフレームに変換するための回転（rvec）と平行移動（tvec）のベクトルとなります。\\\\X_c ¶ Y_c ¶ Z_c ¶ 1 ¶end{bmatrix} &= ¶hspace{0.2em}.^{c}\\{T}_wX_{w}\\ Y_{w}\\ ♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪\\ ♪♪♪♪♪〜\\\\♪ X, Y, Z\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\♪♪♪♪♪♪♪〜X_{w}\\ X_{w}/Y_{w}\\ ♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪\\\\\♪♪♪♪end{align*}\Note

平面型拡張現実感に対する solvePnP の使用例は opencv_source_code/samples/python/plane_ar.py にあります。

Pythonをお使いの方へ。

solvePnP は連続した配列を必要とするので，Numpy 配列スライスは入力として動作しません（modules/calib3d/src/solvepnp.cpp version 2.4.9 の 55 行目あたりで cv::Mat::checkVector() を用いたアサーションにより強制されています）．

P3P アルゴリズムでは，2 チャンネルの情報を必要とする undistortPoints の呼び出し（modules/calib3d/src/solvepnp.cpp version 2.4.9 の 75 行目付近）のために，画像ポイントが (N,1,2) の形をした配列になっている必要があります．

したがって，あるデータ D = np.array(...) (D.shape = (N,M)) が与えられた場合，そのサブセットを例えば imagePoints として使用するためには，それを新しい配列に効果的にコピーしなければなりません： imagePoints = np.ascontiguousarray(D[:,:2]).reshape((N,1,2))





SOLVEPNP_DLSおよびSOLVEPNP_UPNPメソッドは、現在の実装が不安定で、完全に間違った結果を与えることがあるため、使用できません。これら2つのフラグのいずれかを渡すと、代わりにSOLVEPNP_EPNPメソッドが使用されます。

一般的なケースでは、最小ポイント数は4である。SOLVEPNP_P3PおよびSOLVEPNP_AP3P法の場合、正確に4点を使用することが必要である（最初の3点はP3P問題のすべての解を推定するために使用され、最後の1点は再投影誤差を最小化する最良の解を保持するために使用される）。

SOLVEPNP_ITERATIVEメソッドとuseExtrinsicGuess=trueを使用した場合、最小のポイント数は3です（ポーズを計算するには3ポイントで十分ですが、最大で4つの解があります）。収束させるためには、初期解をグローバル解に近づける必要があります。

SOLVEPNP_IPPEの場合、入力ポイントは≧4でなければならず、オブジェクトポイントはコプラナーでなければなりません。

SOLVEPNP_IPPE_SQUARE の場合、これはマーカーのポーズ推定に適した特殊なケースです。入力点の数は 4 でなければなりません。オブジェクトポイントは以下の順序で定義しなければならない。

点0： [-squareLength / 2, squareLength / 2, 0] 。

point 1: [ squareLength / 2, squareLength / 2, 0]の順に定義される。

ポイント2：[ squareLength / 2, -squareLength / 2, 0]の順になります。

point 3: [-squareLength / 2, -squareLength / 2, 0]SOLVEPNP_SQPNPの場合、入力ポイントは≧3でなければなりませんサンプル：samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp、samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp。

元関数名(C#): calib3d_solvePnP_vector
元DLLエクスポート名: calib3d_solvePnP_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_solvePnP_vector(cv::Point3f *objectPoints, int objectPointsLength,
    cv::Point2f *imagePoints, int imagePointsLength,
    double *cameraMatrix, double *distCoeffs, int distCoeffsLength,
    double *rvec, double *tvec, int useExtrinsicGuess,
    int flags)
{
    BEGIN_WRAP
    const cv::Mat objectPointsMat(objectPointsLength, 1, CV_32FC3, objectPoints);
    const cv::Mat imagePointsMat(imagePointsLength, 1, CV_32FC2, imagePoints);
    cv::Mat distCoeffsMat;
    if (distCoeffs != nullptr)
        distCoeffsMat = cv::Mat(distCoeffsLength, 1, CV_64FC1, distCoeffs);

    const cv::Matx&amp;lt;double, 3, 3&amp;gt; cameraMatrixMat(cameraMatrix);
    cv::Matx&amp;lt;double, 3, 1&amp;gt; rvecMat, tvecMat;
    cv::solvePnP(objectPointsMat, imagePointsMat, cameraMatrixMat, distCoeffsMat, rvecMat, tvecMat, useExtrinsicGuess != 0, flags);
    memcpy(rvec, rvecMat.val, sizeof(double) * 3);
    memcpy(tvec, tvecMat.val, sizeof(double) * 3);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_solvePnPRansac_InputArray
[32/64bit] RANSACスキームを用いて，3D-2Dの点の対応関係から物体のポーズを見つけます．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12
p1 = sptr : IntPtr objectPoints
p2 = sptr : IntPtr imagePoints
p3 = sptr : IntPtr cameraMatrix
p4 = sptr : IntPtr distCoeffs
p5 = sptr : IntPtr rvec
p6 = sptr : IntPtr tvec
p7 = int : int useExtrinsicGuess
p8 = int : int iterationsCount
p9 = float : float reprojectionError
p10 = double : double confidence
p11 = sptr : IntPtr inliers
p12 = int : int flags
%inst
この関数は，オブジェクトポイントの集合と，それに対応する画像投影，さらにカメラの固有行列と歪み係数が与えられた場合に，オブジェクトのポーズを推定します．この関数は，再投影誤差，つまり，観測された投影画像ポイントと，（projectPoints を用いて）投影されたオブジェクトポイントとの間の二乗距離の総和を最小にするようなポーズを求めます．RANSAC を用いることで，外れ値に強い関数となっています．

オブジェクト検出のための solvePNPRansac の使用例は， opencv_source_code/samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/ にあります．

Minimal Sample Setsステップのカメラポーズの推定に使用されるデフォルトの方法はSOLVEPNP_EPNPです。例外があります。

SOLVEPNP_P3PまたはSOLVEPNP_AP3Pを選択した場合、これらの方法が使用されます。

入力ポイント数が4に等しい場合、SOLVEPNP_P3Pが使用されます。





すべてのインライアを使用してカメラポーズを推定するために使用される手法は、SOLVEPNP_P3PまたはSOLVEPNP_AP3Pに等しくない限り、フラグパラメータによって定義される。この場合、代わりにSOLVEPNP_EPNP法が使用される。

元関数名(C#): calib3d_solvePnPRansac_InputArray
元DLLエクスポート名: calib3d_solvePnPRansac_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_solvePnPRansac_InputArray(
    cv::_InputArray *objectPoints, cv::_InputArray *imagePoints,
    cv::_InputArray *cameraMatrix, cv::_InputArray *distCoeffs, cv::_OutputArray *rvec, cv::_OutputArray *tvec,
    bool useExtrinsicGuess, int iterationsCount, float reprojectionError, double confidence,
    cv::_OutputArray *inliers, int flags)
{
    BEGIN_WRAP
    cv::solvePnPRansac(*objectPoints, *imagePoints, *cameraMatrix, entity(distCoeffs), *rvec, *tvec,
        useExtrinsicGuess != 0, iterationsCount, reprojectionError, confidence,
        entity(inliers), flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_solvePnPRansac_vector
[32/64bit] RANSACスキームを用いて，3D-2Dの点の対応関係から物体のポーズを見つけます．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15
p1 = var : Point3f[] objectPoints
p2 = int : int objectPointsLength
p3 = var : Point2f[] imagePoints
p4 = int : int imagePointsLength
p5 = var : double* cameraMatrix
p6 = var : double[]? distCoeffs
p7 = int : int distCoeffsLength
p8 = var : [Out] double[] rvec
p9 = var : [Out] double[] tvec
p10 = int : int useExtrinsicGuess
p11 = int : int iterationsCount
p12 = float : float reprojectionError
p13 = double : double confidence
p14 = sptr : IntPtr inliers
p15 = int : int flags
%inst
この関数は，オブジェクトポイントの集合と，それに対応する画像投影，さらにカメラの固有行列と歪み係数が与えられた場合に，オブジェクトのポーズを推定します．この関数は，再投影誤差，つまり，観測された投影画像ポイントと，（projectPoints を用いて）投影されたオブジェクトポイントとの間の二乗距離の総和を最小にするようなポーズを求めます．RANSAC を用いることで，外れ値に強い関数となっています．

オブジェクト検出のための solvePNPRansac の使用例は， opencv_source_code/samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/ にあります．

Minimal Sample Setsステップのカメラポーズの推定に使用されるデフォルトの方法はSOLVEPNP_EPNPです。例外があります。

SOLVEPNP_P3PまたはSOLVEPNP_AP3Pを選択した場合、これらの方法が使用されます。

入力ポイント数が4に等しい場合、SOLVEPNP_P3Pが使用されます。





すべてのインライアを使用してカメラポーズを推定するために使用される手法は、SOLVEPNP_P3PまたはSOLVEPNP_AP3Pに等しくない限り、フラグパラメータによって定義される。この場合、代わりにSOLVEPNP_EPNP法が使用される。

元関数名(C#): calib3d_solvePnPRansac_vector
元DLLエクスポート名: calib3d_solvePnPRansac_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_solvePnPRansac_vector(
    cv::Point3f *objectPoints, int objectPointsLength,
    cv::Point2f *imagePoints, int imagePointsLength,
    double *cameraMatrix,
    double *distCoeffs, int distCoeffsLength,
    double *rvec, double *tvec,
    int useExtrinsicGuess, int iterationsCount, float reprojectionError, double confidence,
    std::vector&amp;lt;int&amp;gt; *inliers, int flags)
{
    BEGIN_WRAP
    const cv::Mat objectPointsMat(objectPointsLength, 1, CV_64FC3, objectPoints);
    const cv::Mat imagePointsMat(imagePointsLength, 1, CV_64FC2, imagePoints);
    cv::Mat distCoeffsMat;
    if (distCoeffs != nullptr)
        distCoeffsMat = cv::Mat(distCoeffsLength, 1, CV_64FC1, distCoeffs);

    cv::Matx&amp;lt;double, 3, 1&amp;gt; rvecM, tvecM;

    cv::solvePnPRansac(objectPointsMat, imagePointsMat, *cameraMatrix, distCoeffsMat, rvecM, tvecM,
        useExtrinsicGuess != 0, iterationsCount, reprojectionError, confidence,
        *inliers, flags);

    memcpy(rvec, rvecM.val, sizeof(double) * 3);
    memcpy(tvec, tvecM.val, sizeof(double) * 3);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_initCameraMatrix2D_Mat
[32/64bit] 3D-2D の点の対応関係から，初期のカメラ固有マトリックスを求めます．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr[] objectPoints
p2 = int : int objectPointsLength
p3 = sptr : IntPtr[] imagePoints
p4 = int : int imagePointsLength
p5 = ARGS_SIZE : Size imageSize
p6 = double : double aspectRatio
p7 = var : out IntPtr returnValue
%inst
この関数は，カメラキャリブレーション処理のための，初期のカメラ固有マトリクスを推定して返します．現在のところ，この関数は平面的なキャリブレーションパターン（各オブジェクトポイントのz座標が0であるパターン）のみをサポートしています．

元関数名(C#): calib3d_initCameraMatrix2D_Mat
元DLLエクスポート名: calib3d_initCameraMatrix2D_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_initCameraMatrix2D_Mat(
    cv::Mat **objectPoints, int objectPointsLength,
    cv::Mat **imagePoints, int imagePointsLength, 
    MyCvSize imageSize, double aspectRatio,
    cv::Mat **returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; objectPointsVec(objectPointsLength);
    for (auto i = 0; i &amp;lt; objectPointsLength; i++)
        objectPointsVec[i] = *objectPoints[i];
    std::vector&amp;lt;cv::Mat&amp;gt; imagePointsVec(imagePointsLength);
    for (auto i = 0; i &amp;lt; objectPointsLength; i++)
        imagePointsVec[i] = *imagePoints[i];

    const auto ret = cv::initCameraMatrix2D(objectPointsVec, imagePointsVec, cpp(imageSize), aspectRatio);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_initCameraMatrix2D_array
[32/64bit] 3D-2D の点の対応関係から，初期のカメラ固有マトリックスを求めます．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr[] objectPoints
p2 = int : int opSize1
p3 = var : int[] opSize2
p4 = sptr : IntPtr[] imagePoints
p5 = int : int ipSize1
p6 = var : int[] ipSize2
p7 = ARGS_SIZE : Size imageSize
p8 = double : double aspectRatio
p9 = var : out IntPtr returnValue
%inst
この関数は，カメラキャリブレーション処理のための，初期のカメラ固有マトリクスを推定して返します．現在のところ，この関数は平面的なキャリブレーションパターン（各オブジェクトポイントのz座標が0であるパターン）のみをサポートしています．

元関数名(C#): calib3d_initCameraMatrix2D_array
元DLLエクスポート名: calib3d_initCameraMatrix2D_array
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_initCameraMatrix2D_array(
    cv::Point3f **objectPoints, int opSize1, int *opSize2,
    cv::Point2f **imagePoints, int ipSize1, int *ipSize2, MyCvSize imageSize, double aspectRatio,
    cv::Mat **returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;std::vector&amp;lt;cv::Point3f&amp;gt; &amp;gt; objectPointsVec(opSize1);
    for (auto i = 0; i &amp;lt; opSize1; i++)
        objectPointsVec[i] = std::vector&amp;lt;cv::Point3f&amp;gt;(objectPoints[i], objectPoints[i] + opSize2[i]);
    std::vector&amp;lt;std::vector&amp;lt;cv::Point3f&amp;gt; &amp;gt; imagePointsVec(ipSize1);
    for (auto i = 0; i &amp;lt; ipSize1; i++)
        imagePointsVec[i] = std::vector&amp;lt;cv::Point3f&amp;gt;(imagePoints[i], imagePoints[i] + ipSize2[i]);

    const auto ret = cv::initCameraMatrix2D(objectPointsVec, imagePointsVec, cpp(imageSize), aspectRatio);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_findChessboardCorners_InputArray
[32/64bit] チェスボードの内側の角の位置を求めます．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr image
p2 = ARGS_SIZE : Size patternSize
p3 = sptr : IntPtr corners
p4 = int : int flags
p5 = var : out int returnValue
%inst
この関数は，入力画像がチェスボードパターンを表しているかどうかを判定し，内部のチェスボードコーナーの位置を特定しようとします．この関数は，すべてのコーナーが見つかり，それらが一定の順序（行ごとに，左から右へ）で配置されていれば，0ではない値を返します．そうでない場合，この関数がすべてのコーナーを見つけることができなかったり，並べ替えることができなかったりすると，0を返します．例えば，通常のチェスボードは，8×8の正方形と7×7の内部コーナー，つまり，黒い正方形が互いに接触するポイントを持っています．検出された座標は近似値であり，その位置をより正確に決定するために，この関数は cornerSubPix を呼び出します．チェスボードの角を検出して描画するサンプルの使い方： :Size patternsize(8,6); //内部の角の数Mat gray = ....; //ソース imageevector<Point2f> corners; //これは，検出されたコーナーで埋められます/CALIB_CB_FAST_CHECK は，チェスボードのコーナーを含まない画像//に対して，多くの時間を節約しますbool patternfound = findChessboardCorners(gray, patternsize, corners, CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE + CALIB_CB_FAST_CHECK);if(patternfound) cornerSubPix(gray, corners, Size(11, 11), Size(-1, -1), TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 30, 0.1));drawChessboardCorners(img, patternsize, Mat(corners), patternfound);fragmentNoteこの関数は，さまざまな環境下での検出をより強固なものにするために，チェスボードの周囲にホワイトスペース（正方形の厚さの境界線のようなもの，広ければ広いほどよい）を必要とします．例: samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp.

元関数名(C#): calib3d_findChessboardCorners_InputArray
元DLLエクスポート名: calib3d_findChessboardCorners_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_findChessboardCorners_InputArray(
    cv::_InputArray *image, MyCvSize patternSize,
    cv::_OutputArray *corners, int flags, 
    int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::findChessboardCorners(*image, cpp(patternSize), *corners, flags) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_findChessboardCorners_vector
[32/64bit] チェスボードの内側の角の位置を求めます．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr image
p2 = ARGS_SIZE : Size patternSize
p3 = sptr : IntPtr corners
p4 = int : int flags
p5 = var : out int returnValue
%inst
この関数は，入力画像がチェスボードパターンを表しているかどうかを判定し，内部のチェスボードコーナーの位置を特定しようとします．この関数は，すべてのコーナーが見つかり，それらが一定の順序（行ごとに，左から右へ）で配置されていれば，0ではない値を返します．そうでない場合，この関数がすべてのコーナーを見つけることができなかったり，並べ替えることができなかったりすると，0を返します．例えば，通常のチェスボードは，8×8の正方形と7×7の内部コーナー，つまり，黒い正方形が互いに接触するポイントを持っています．検出された座標は近似値であり，その位置をより正確に決定するために，この関数は cornerSubPix を呼び出します．チェスボードの角を検出して描画するサンプルの使い方： :Size patternsize(8,6); //内部の角の数Mat gray = ....; //ソース imageevector<Point2f> corners; //これは，検出されたコーナーで埋められます/CALIB_CB_FAST_CHECK は，チェスボードのコーナーを含まない画像//に対して，多くの時間を節約しますbool patternfound = findChessboardCorners(gray, patternsize, corners, CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE + CALIB_CB_FAST_CHECK);if(patternfound) cornerSubPix(gray, corners, Size(11, 11), Size(-1, -1), TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 30, 0.1));drawChessboardCorners(img, patternsize, Mat(corners), patternfound);fragmentNoteこの関数は，さまざまな環境下での検出をより強固なものにするために，チェスボードの周囲にホワイトスペース（正方形の厚さの境界線のようなもの，広ければ広いほどよい）を必要とします．例: samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp.

元関数名(C#): calib3d_findChessboardCorners_vector
元DLLエクスポート名: calib3d_findChessboardCorners_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_findChessboardCorners_vector(
    cv::_InputArray *image, MyCvSize patternSize,
    std::vector&amp;lt;cv::Point2f&amp;gt; *corners, int flags, 
    int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::findChessboardCorners(*image, cpp(patternSize), *corners, flags) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_checkChessboard
[32/64bit] calib3d_checkChessboard
%prm
p1,p2,p3
p1 = sptr : IntPtr img
p2 = ARGS_SIZE : Size size
p3 = var : out int returnValue
%inst
元関数名(C#): calib3d_checkChessboard
元DLLエクスポート名: calib3d_checkChessboard
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_checkChessboard(
    cv::_InputArray *img, MyCvSize size, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::checkChessboard(*img, cpp(size)) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_findChessboardCornersSB_OutputArray
[32/64bit] チェスボードの内側の角の位置を、セクターベースのアプローチで求めます。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr image
p2 = ARGS_SIZE : Size patternSize
p3 = sptr : IntPtr corners
p4 = int : int flags
p5 = var : out int returnValue
%inst
この関数は，findChessboardCorners に類似していますが，ボックスフィルタで近似された局所的なラドン変換を利用しており，あらゆる種類のノイズに対してより頑健で，大きな画像に対してより高速であり，チェスボード内部のコーナーのサブピクセルの位置を直接返すことができます．この手法は、論文[61]「Accurate Detection and Localization of Checkerboard Corners for Calibration」に基づいています。

この方法は，論文 [61] "Accurate Detection and Localization of Checkerboard Corners for Calibration" に基づいており，返されるサブピクセル位置は cornerSubPix で返されるものよりも正確で，要求の厳しいアプリケーションに対して正確なカメラキャリブレーションを可能にすることを示しています．これらのフラグは、カメラの視野を超えるキャリブレーションパターンを使用する際に役立ちます。このような大規模なパターンでは、画像の境界にできるだけ近いコーナーを利用できるため、より正確なキャリブレーションが可能になります。この機能では、さまざまな環境下での検出を向上させるために、ボード全体の周囲にチェッカーボードの1つのフィールドとほぼ同じ幅の白いボーダーを設ける必要があります。また、局部的なラドン変換のため、ボードの外側に位置するフィールドのコーナーには丸い角を使用することが有効です。次の図は、検出に最適なチェッカーボードの例です。ただし、他のチェッカーボードを使用することも可能です。





チェッカーボード

元関数名(C#): calib3d_findChessboardCornersSB_OutputArray
元DLLエクスポート名: calib3d_findChessboardCornersSB_OutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_findChessboardCornersSB_OutputArray(
    cv::_InputArray *image, MyCvSize patternSize, cv::_OutputArray *corners, int flags, 
    int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::findChessboardCornersSB(*image, cpp(patternSize), *corners, flags) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_findChessboardCornersSB_vector
[32/64bit] チェスボードの内側の角の位置を、セクターベースのアプローチで求めます。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr image
p2 = ARGS_SIZE : Size patternSize
p3 = sptr : IntPtr corners
p4 = int : int flags
p5 = var : out int returnValue
%inst
この関数は，findChessboardCorners に類似していますが，ボックスフィルタで近似された局所的なラドン変換を利用しており，あらゆる種類のノイズに対してより頑健で，大きな画像に対してより高速であり，チェスボード内部のコーナーのサブピクセルの位置を直接返すことができます．この手法は、論文[61]「Accurate Detection and Localization of Checkerboard Corners for Calibration」に基づいています。

この方法は，論文 [61] "Accurate Detection and Localization of Checkerboard Corners for Calibration" に基づいており，返されるサブピクセル位置は cornerSubPix で返されるものよりも正確で，要求の厳しいアプリケーションに対して正確なカメラキャリブレーションを可能にすることを示しています．これらのフラグは、カメラの視野を超えるキャリブレーションパターンを使用する際に役立ちます。このような大規模なパターンでは、画像の境界にできるだけ近いコーナーを利用できるため、より正確なキャリブレーションが可能になります。この機能では、さまざまな環境下での検出を向上させるために、ボード全体の周囲にチェッカーボードの1つのフィールドとほぼ同じ幅の白いボーダーを設ける必要があります。また、局部的なラドン変換のため、ボードの外側に位置するフィールドのコーナーには丸い角を使用することが有効です。次の図は、検出に最適なチェッカーボードの例です。ただし、他のチェッカーボードを使用することも可能です。





チェッカーボード

元関数名(C#): calib3d_findChessboardCornersSB_vector
元DLLエクスポート名: calib3d_findChessboardCornersSB_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_findChessboardCornersSB_vector(
    cv::_InputArray *image, MyCvSize patternSize, std::vector&amp;lt;cv::Point2f&amp;gt; *corners, int flags, 
    int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::findChessboardCornersSB(*image, cpp(patternSize), *corners, flags) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_find4QuadCornerSubpix_InputArray
[32/64bit] チェスボードのコーナーをサブピクセル単位の精度で検出
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr img
p2 = sptr : IntPtr corners
p3 = ARGS_SIZE : Size regionSize
p4 = var : out int returnValue
%inst
元関数名(C#): calib3d_find4QuadCornerSubpix_InputArray
元DLLエクスポート名: calib3d_find4QuadCornerSubpix_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_find4QuadCornerSubpix_InputArray(
    cv::_InputArray *img, cv::_InputOutputArray *corners, MyCvSize regionSize, 
    int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::find4QuadCornerSubpix(*img, *corners, cpp(regionSize)) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_find4QuadCornerSubpix_vector
[32/64bit] チェスボードのコーナーをサブピクセル単位の精度で検出
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr img
p2 = sptr : IntPtr corners
p3 = ARGS_SIZE : Size regionSize
p4 = var : out int returnValue
%inst
元関数名(C#): calib3d_find4QuadCornerSubpix_vector
元DLLエクスポート名: calib3d_find4QuadCornerSubpix_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_find4QuadCornerSubpix_vector(
    cv::_InputArray *img, std::vector&amp;lt;cv::Point2f&amp;gt; *corners, MyCvSize regionSize, 
    int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::find4QuadCornerSubpix(*img, *corners, cpp(regionSize)) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_drawChessboardCorners_InputArray
[32/64bit] 検出されたチェスボードの角をレンダリングします。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr image
p2 = ARGS_SIZE : Size patternSize
p3 = sptr : IntPtr corners
p4 = int : int patternWasFound
%inst
この関数は、検出された個々のチェスボードの角を、ボードが見つからなかった場合は赤丸で、ボードが見つかった場合は色付きの角を線で結んで描画します。例： samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp.

元関数名(C#): calib3d_drawChessboardCorners_InputArray
元DLLエクスポート名: calib3d_drawChessboardCorners_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_drawChessboardCorners_InputArray(
    cv::_InputOutputArray *image, MyCvSize patternSize,
    cv::_InputArray *corners, int patternWasFound)
{
    BEGIN_WRAP
    cv::drawChessboardCorners(*image, cpp(patternSize), *corners, patternWasFound != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_drawChessboardCorners_array
[32/64bit] 検出されたチェスボードの角をレンダリングします。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr image
p2 = ARGS_SIZE : Size patternSize
p3 = var : [In] Point2f[] corners
p4 = int : int cornersLength
p5 = int : int patternWasFound
%inst
この関数は、検出された個々のチェスボードの角を、ボードが見つからなかった場合は赤丸で、ボードが見つかった場合は色付きの角を線で結んで描画します。例： samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp.

元関数名(C#): calib3d_drawChessboardCorners_array
元DLLエクスポート名: calib3d_drawChessboardCorners_array
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_drawChessboardCorners_array(
    cv::_InputOutputArray *image, MyCvSize patternSize,
    cv::Point2f *corners, int cornersLength, int patternWasFound)
{
    BEGIN_WRAP
    const std::vector&amp;lt;cv::Point2f&amp;gt; cornersVec(corners, corners + cornersLength);
    cv::drawChessboardCorners(*image, cpp(patternSize), cornersVec, patternWasFound != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_drawFrameAxes
[32/64bit] ポーズ推定からワールド/オブジェクト座標系の軸を描画します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr image
p2 = sptr : IntPtr cameraMatrix
p3 = sptr : IntPtr distCoeffs
p4 = sptr : IntPtr rvec
p5 = sptr : IntPtr tvec
p6 = float : float length
p7 = int : int thickness
%inst
別項参照sosolvePnPこの関数は、カメラフレームに対するワールド／オブジェクト座標系の軸を描画します。例：samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp、samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp。

元関数名(C#): calib3d_drawFrameAxes
元DLLエクスポート名: calib3d_drawFrameAxes
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_drawFrameAxes(
    cv::_InputOutputArray *image, cv::_InputArray *cameraMatrix, cv::_InputArray *distCoeffs,
    cv::_InputArray *rvec, cv::_InputArray *tvec, float length, int thickness)
{
    BEGIN_WRAP
    cv::drawFrameAxes(*image, *cameraMatrix, *distCoeffs, *rvec, *tvec, length, thickness);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_findCirclesGrid_InputArray
[32/64bit] グリッド上の円の中心を見つけます。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr image
p2 = ARGS_SIZE : Size patternSize
p3 = sptr : IntPtr centers
p4 = int : int flags
p5 = sptr : IntPtr blobDetector
p6 = var : out int returnValue
%inst
この関数は，入力画像に格子状の円が含まれているかどうかを調べます．この関数は，入力画像に格子状の円が含まれているかどうかを判定し，含まれている場合は，その円の中心を求めます．この関数は，すべての円の中心が見つかり，それらが一定の順序（行ごとに左から右へ）で配置されていれば，0以外の値を返します．そうでない場合，この関数がすべての角を見つけられなかったり，並べ替えることができなかったりすると，0を返します． 円の中心を検出して描画するサンプルの使い方:Size patternsize(7,7); //中心の数Mat gray = ...; //ソース imageevector<Point2f> centers; //これは，検出された中心で埋められますbool patternfound = findCirclesGrid(gray, patternsize, centers);drawChessboardCorners(img, patternsize, Mat(centres), patternfound);fragmentNoteこの関数は，様々な環境下で検出をより確実なものにするために，ボードの周囲にホワイトスペース（四角い厚さの境界線のようなもの，広ければ広いほど良い）を必要とします．

元関数名(C#): calib3d_findCirclesGrid_InputArray
元DLLエクスポート名: calib3d_findCirclesGrid_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_findCirclesGrid_InputArray(
    cv::_InputArray *image, MyCvSize patternSize,
    cv::_OutputArray *centers, int flags, cv::FeatureDetector* blobDetector,
    int *returnValue)
{
    BEGIN_WRAP
    if (blobDetector == nullptr)
    {
        *returnValue = cv::findCirclesGrid(*image, cpp(patternSize), *centers, flags) ? 1 : 0;
    }
    else
    {
        const cv::Ptr&amp;lt;cv::FeatureDetector&amp;gt; detectorPtr(blobDetector, BlobDetectorDeleter); // don't delete
        *returnValue = cv::findCirclesGrid(*image, cpp(patternSize), *centers, flags, detectorPtr) ? 1 : 0;
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_findCirclesGrid_vector
[32/64bit] グリッド上の円の中心を見つけます。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr image
p2 = ARGS_SIZE : Size patternSize
p3 = sptr : IntPtr centers
p4 = int : int flags
p5 = sptr : IntPtr blobDetector
p6 = var : out int returnValue
%inst
この関数は，入力画像に格子状の円が含まれているかどうかを調べます．この関数は，入力画像に格子状の円が含まれているかどうかを判定し，含まれている場合は，その円の中心を求めます．この関数は，すべての円の中心が見つかり，それらが一定の順序（行ごとに左から右へ）で配置されていれば，0以外の値を返します．そうでない場合，この関数がすべての角を見つけられなかったり，並べ替えることができなかったりすると，0を返します． 円の中心を検出して描画するサンプルの使い方:Size patternsize(7,7); //中心の数Mat gray = ...; //ソース imageevector<Point2f> centers; //これは，検出された中心で埋められますbool patternfound = findCirclesGrid(gray, patternsize, centers);drawChessboardCorners(img, patternsize, Mat(centres), patternfound);fragmentNoteこの関数は，様々な環境下で検出をより確実なものにするために，ボードの周囲にホワイトスペース（四角い厚さの境界線のようなもの，広ければ広いほど良い）を必要とします．

元関数名(C#): calib3d_findCirclesGrid_vector
元DLLエクスポート名: calib3d_findCirclesGrid_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_findCirclesGrid_vector(
    cv::_InputArray *image, MyCvSize patternSize,
    std::vector&amp;lt;cv::Point2f&amp;gt; *centers, int flags, cv::FeatureDetector* blobDetector,
    int *returnValue)
{
    BEGIN_WRAP
    if (blobDetector == nullptr)
    {
        *returnValue = cv::findCirclesGrid(*image, cpp(patternSize), *centers, flags) ? 1 : 0;
    }
    else
    {
        const cv::Ptr&amp;lt;cv::FeatureDetector&amp;gt; detectorPtr(blobDetector, BlobDetectorDeleter); // don't delete
        *returnValue = cv::findCirclesGrid(*image, cpp(patternSize), *centers, flags, detectorPtr) ? 1 : 0;
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_calibrateCamera_InputArray
[32bit] キャリブレーションパターンの複数のビューから、カメラの内在的および外在的パラメータを見つけます。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12
p1 = sptr : IntPtr[] objectPoints
p2 = int : int objectPointsSize
p3 = sptr : IntPtr[] imagePoints
p4 = int : int imagePointsSize
p5 = ARGS_SIZE : Size imageSize
p6 = sptr : IntPtr cameraMatrix
p7 = sptr : IntPtr distCoeffs
p8 = sptr : IntPtr rvecs
p9 = sptr : IntPtr tvecs
p10 = int : int flags
p11 = ARGS_TERMCRITERIA : TermCriteria criteria
p12 = var : out double returnValue
%inst
この関数は，カメラの内部パラメータと，各ビューの外部パラメータを推定します．このアルゴリズムは， [293] と [31] に基づいています．各ビューにおける3次元オブジェクトポイントの座標と，それに対応する2次元射影を指定する必要があります．これは、既知のジオメトリと簡単に検出できる特徴点を持つオブジェクトを使用することで実現できます。このようなオブジェクトは，キャリブレーションリグやキャリブレーションパターンと呼ばれます．OpenCVは，キャリブレーションリグとしてチェスボードをビルトインでサポートしています（findChessboardCornersを参照してください）．現在のところ，内部パラメータの初期化（CALIB_USE_INTRINSIC_GUESS がセットされていない場合）は，平面的なキャリブレーションパターン（オブジェクトポイントのZ座標はすべて0でなければいけない）に対してのみ実装されています．アルゴリズムは以下のステップを実行します：初期固有パラメータを計算する（平面キャリブレーションパターンでのみ利用可能なオプション）、または入力パラメータから読み取る。CALIB_FIX_K? の一部が指定されていない限り、歪み係数はすべてゼロに初期設定されます。

固有のパラメータが既に知られているかのように、初期のカメラポーズを推定する。これは solvePnP を用いて行われる。

グローバル Levenberg-Marquardt 最適化アルゴリズムを実行して，再投影誤差，つまり，観測された特徴点 imagePoints と，（カメラパラメータとポーズの現在の推定値を用いて）投影されたオブジェクト点 objectPoints との間の二乗距離の総和を最小化します．詳細は projectPoints を参照してください。非正方(non-N-by-N)グリッドを使用し、findChessboardCorners でキャリブレーションを行った場合、 calibrateCamera が悪い値(歪み係数がゼロ、\(c_x\)と\(c_y\)が画像の中心から非常に離れている、\(f_x\)と?(f_yansen)の差が大きい(比率が10:1以上））の場合は、findChessboardCornersでpatternSize=cvSize(cols,rows)を使うのではなく、patternSize=cvSize(rows,cols)を使っていると思われます。関連項目：ocalibrateCameraRO, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate, undistort

元関数名(C#): calib3d_calibrateCamera_InputArray
元DLLエクスポート名: calib3d_calibrateCamera_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_calibrateCamera_InputArray(
    cv::Mat **objectPoints, int objectPointsSize,
    cv::Mat **imagePoints, int imagePointsSize,
    MyCvSize imageSize,
    cv::_InputOutputArray *cameraMatrix,
    cv::_InputOutputArray *distCoeffs,
    std::vector&amp;lt;cv::Mat&amp;gt; *rvecs, std::vector&amp;lt;cv::Mat&amp;gt; *tvecs,
    int flags,
    MyCvTermCriteria criteria,
    double *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; objectPointsVec(objectPointsSize);
    for (auto i = 0; i &amp;lt; objectPointsSize; i++)
        objectPointsVec[i] = *objectPoints[i];
    std::vector&amp;lt;cv::Mat&amp;gt; imagePointsVec(imagePointsSize);
    for (auto i = 0; i &amp;lt; imagePointsSize; i++)
        imagePointsVec[i] = *imagePoints[i];

    *returnValue = cv::calibrateCamera(objectPointsVec, imagePointsVec, cpp(imageSize),
        *cameraMatrix, *distCoeffs, *rvecs, *tvecs, flags, cpp(criteria));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_calibrateCamera_InputArray
[64bit] キャリブレーションパターンの複数のビューから、カメラの内在的および外在的パラメータを見つけます。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12
p1 = sptr : IntPtr[] objectPoints
p2 = int : int objectPointsSize
p3 = sptr : IntPtr[] imagePoints
p4 = int : int imagePointsSize
p5 = ARGS_SIZE : Size imageSize
p6 = sptr : IntPtr cameraMatrix
p7 = sptr : IntPtr distCoeffs
p8 = sptr : IntPtr rvecs
p9 = sptr : IntPtr tvecs
p10 = int : int flags
p11 = var : TermCriteria criteria
p12 = var : out double returnValue
%inst
この関数は，カメラの内部パラメータと，各ビューの外部パラメータを推定します．このアルゴリズムは， [293] と [31] に基づいています．各ビューにおける3次元オブジェクトポイントの座標と，それに対応する2次元射影を指定する必要があります．これは、既知のジオメトリと簡単に検出できる特徴点を持つオブジェクトを使用することで実現できます。このようなオブジェクトは，キャリブレーションリグやキャリブレーションパターンと呼ばれます．OpenCVは，キャリブレーションリグとしてチェスボードをビルトインでサポートしています（findChessboardCornersを参照してください）．現在のところ，内部パラメータの初期化（CALIB_USE_INTRINSIC_GUESS がセットされていない場合）は，平面的なキャリブレーションパターン（オブジェクトポイントのZ座標はすべて0でなければいけない）に対してのみ実装されています．アルゴリズムは以下のステップを実行します：初期固有パラメータを計算する（平面キャリブレーションパターンでのみ利用可能なオプション）、または入力パラメータから読み取る。CALIB_FIX_K? の一部が指定されていない限り、歪み係数はすべてゼロに初期設定されます。

固有のパラメータが既に知られているかのように、初期のカメラポーズを推定する。これは solvePnP を用いて行われる。

グローバル Levenberg-Marquardt 最適化アルゴリズムを実行して，再投影誤差，つまり，観測された特徴点 imagePoints と，（カメラパラメータとポーズの現在の推定値を用いて）投影されたオブジェクト点 objectPoints との間の二乗距離の総和を最小化します．詳細は projectPoints を参照してください。非正方(non-N-by-N)グリッドを使用し、findChessboardCorners でキャリブレーションを行った場合、 calibrateCamera が悪い値(歪み係数がゼロ、\(c_x\)と\(c_y\)が画像の中心から非常に離れている、\(f_x\)と?(f_yansen)の差が大きい(比率が10:1以上））の場合は、findChessboardCornersでpatternSize=cvSize(cols,rows)を使うのではなく、patternSize=cvSize(rows,cols)を使っていると思われます。関連項目：ocalibrateCameraRO, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate, undistort

元関数名(C#): calib3d_calibrateCamera_InputArray
元DLLエクスポート名: calib3d_calibrateCamera_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_calibrateCamera_InputArray(
    cv::Mat **objectPoints, int objectPointsSize,
    cv::Mat **imagePoints, int imagePointsSize,
    MyCvSize imageSize,
    cv::_InputOutputArray *cameraMatrix,
    cv::_InputOutputArray *distCoeffs,
    std::vector&amp;lt;cv::Mat&amp;gt; *rvecs, std::vector&amp;lt;cv::Mat&amp;gt; *tvecs,
    int flags,
    MyCvTermCriteria criteria,
    double *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; objectPointsVec(objectPointsSize);
    for (auto i = 0; i &amp;lt; objectPointsSize; i++)
        objectPointsVec[i] = *objectPoints[i];
    std::vector&amp;lt;cv::Mat&amp;gt; imagePointsVec(imagePointsSize);
    for (auto i = 0; i &amp;lt; imagePointsSize; i++)
        imagePointsVec[i] = *imagePoints[i];

    *returnValue = cv::calibrateCamera(objectPointsVec, imagePointsVec, cpp(imageSize),
        *cameraMatrix, *distCoeffs, *rvecs, *tvecs, flags, cpp(criteria));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_calibrateCamera_vector
[32bit] キャリブレーションパターンの複数のビューから、カメラの内在的および外在的パラメータを見つけます。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15
p1 = sptr : IntPtr[] objectPoints
p2 = int : int opSize1
p3 = var : int[] opSize2
p4 = sptr : IntPtr[] imagePoints
p5 = int : int ipSize1
p6 = var : int[] ipSize2
p7 = ARGS_SIZE : Size imageSize
p8 = var : double* cameraMatrix
p9 = var : [In, Out] double[] distCoeffs
p10 = int : int distCoeffsSize
p11 = sptr : IntPtr rvecs
p12 = sptr : IntPtr tvecs
p13 = int : int flags
p14 = ARGS_TERMCRITERIA : TermCriteria criteria
p15 = var : out double returnValue
%inst
この関数は，カメラの内部パラメータと，各ビューの外部パラメータを推定します．このアルゴリズムは， [293] と [31] に基づいています．各ビューにおける3次元オブジェクトポイントの座標と，それに対応する2次元射影を指定する必要があります．これは、既知のジオメトリと簡単に検出できる特徴点を持つオブジェクトを使用することで実現できます。このようなオブジェクトは，キャリブレーションリグやキャリブレーションパターンと呼ばれます．OpenCVは，キャリブレーションリグとしてチェスボードをビルトインでサポートしています（findChessboardCornersを参照してください）．現在のところ，内部パラメータの初期化（CALIB_USE_INTRINSIC_GUESS がセットされていない場合）は，平面的なキャリブレーションパターン（オブジェクトポイントのZ座標はすべて0でなければいけない）に対してのみ実装されています．アルゴリズムは以下のステップを実行します：初期固有パラメータを計算する（平面キャリブレーションパターンでのみ利用可能なオプション）、または入力パラメータから読み取る。CALIB_FIX_K? の一部が指定されていない限り、歪み係数はすべてゼロに初期設定されます。

固有のパラメータが既に知られているかのように、初期のカメラポーズを推定する。これは solvePnP を用いて行われる。

グローバル Levenberg-Marquardt 最適化アルゴリズムを実行して，再投影誤差，つまり，観測された特徴点 imagePoints と，（カメラパラメータとポーズの現在の推定値を用いて）投影されたオブジェクト点 objectPoints との間の二乗距離の総和を最小化します．詳細は projectPoints を参照してください。非正方(non-N-by-N)グリッドを使用し、findChessboardCorners でキャリブレーションを行った場合、 calibrateCamera が悪い値(歪み係数がゼロ、\(c_x\)と\(c_y\)が画像の中心から非常に離れている、\(f_x\)と?(f_yansen)の差が大きい(比率が10:1以上））の場合は、findChessboardCornersでpatternSize=cvSize(cols,rows)を使うのではなく、patternSize=cvSize(rows,cols)を使っていると思われます。関連項目：ocalibrateCameraRO, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate, undistort

元関数名(C#): calib3d_calibrateCamera_vector
元DLLエクスポート名: calib3d_calibrateCamera_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_calibrateCamera_vector(
    cv::Point3f **objectPoints, int opSize1, int *opSize2,
    cv::Point2f **imagePoints, int ipSize1, int *ipSize2,
    MyCvSize imageSize,
    double *cameraMatrix,
    double *distCoeffs, int distCoeffsSize,
    std::vector&amp;lt;cv::Mat&amp;gt; *rvecs, std::vector&amp;lt;cv::Mat&amp;gt; *tvecs,
    int flags,
    MyCvTermCriteria criteria,
    double *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;std::vector&amp;lt;cv::Point3f&amp;gt; &amp;gt; objectPointsVec(opSize1);
    for (auto i = 0; i &amp;lt; opSize1; i++)
        objectPointsVec[i] = std::vector&amp;lt;cv::Point3f&amp;gt;(objectPoints[i], objectPoints[i] + opSize2[i]);

    std::vector&amp;lt;std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt; imagePointsVec(ipSize1);
    for (auto i = 0; i &amp;lt; ipSize1; i++)
        imagePointsVec[i] = std::vector&amp;lt;cv::Point2f&amp;gt;(imagePoints[i], imagePoints[i] + ipSize2[i]);

    cv::Mat cametaMatrixM(3, 3, CV_64FC1, cameraMatrix);
    cv::Mat distCoeffsM(distCoeffsSize, 1, CV_64FC1, distCoeffs);

    *returnValue = cv::calibrateCamera(objectPointsVec, imagePointsVec, cpp(imageSize),
        cametaMatrixM, distCoeffsM, *rvecs, *tvecs, flags, cpp(criteria));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_calibrateCamera_vector
[64bit] キャリブレーションパターンの複数のビューから、カメラの内在的および外在的パラメータを見つけます。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15
p1 = sptr : IntPtr[] objectPoints
p2 = int : int opSize1
p3 = var : int[] opSize2
p4 = sptr : IntPtr[] imagePoints
p5 = int : int ipSize1
p6 = var : int[] ipSize2
p7 = ARGS_SIZE : Size imageSize
p8 = var : double* cameraMatrix
p9 = var : [In, Out] double[] distCoeffs
p10 = int : int distCoeffsSize
p11 = sptr : IntPtr rvecs
p12 = sptr : IntPtr tvecs
p13 = int : int flags
p14 = var : TermCriteria criteria
p15 = var : out double returnValue
%inst
この関数は，カメラの内部パラメータと，各ビューの外部パラメータを推定します．このアルゴリズムは， [293] と [31] に基づいています．各ビューにおける3次元オブジェクトポイントの座標と，それに対応する2次元射影を指定する必要があります．これは、既知のジオメトリと簡単に検出できる特徴点を持つオブジェクトを使用することで実現できます。このようなオブジェクトは，キャリブレーションリグやキャリブレーションパターンと呼ばれます．OpenCVは，キャリブレーションリグとしてチェスボードをビルトインでサポートしています（findChessboardCornersを参照してください）．現在のところ，内部パラメータの初期化（CALIB_USE_INTRINSIC_GUESS がセットされていない場合）は，平面的なキャリブレーションパターン（オブジェクトポイントのZ座標はすべて0でなければいけない）に対してのみ実装されています．アルゴリズムは以下のステップを実行します：初期固有パラメータを計算する（平面キャリブレーションパターンでのみ利用可能なオプション）、または入力パラメータから読み取る。CALIB_FIX_K? の一部が指定されていない限り、歪み係数はすべてゼロに初期設定されます。

固有のパラメータが既に知られているかのように、初期のカメラポーズを推定する。これは solvePnP を用いて行われる。

グローバル Levenberg-Marquardt 最適化アルゴリズムを実行して，再投影誤差，つまり，観測された特徴点 imagePoints と，（カメラパラメータとポーズの現在の推定値を用いて）投影されたオブジェクト点 objectPoints との間の二乗距離の総和を最小化します．詳細は projectPoints を参照してください。非正方(non-N-by-N)グリッドを使用し、findChessboardCorners でキャリブレーションを行った場合、 calibrateCamera が悪い値(歪み係数がゼロ、\(c_x\)と\(c_y\)が画像の中心から非常に離れている、\(f_x\)と?(f_yansen)の差が大きい(比率が10:1以上））の場合は、findChessboardCornersでpatternSize=cvSize(cols,rows)を使うのではなく、patternSize=cvSize(rows,cols)を使っていると思われます。関連項目：ocalibrateCameraRO, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate, undistort

元関数名(C#): calib3d_calibrateCamera_vector
元DLLエクスポート名: calib3d_calibrateCamera_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_calibrateCamera_vector(
    cv::Point3f **objectPoints, int opSize1, int *opSize2,
    cv::Point2f **imagePoints, int ipSize1, int *ipSize2,
    MyCvSize imageSize,
    double *cameraMatrix,
    double *distCoeffs, int distCoeffsSize,
    std::vector&amp;lt;cv::Mat&amp;gt; *rvecs, std::vector&amp;lt;cv::Mat&amp;gt; *tvecs,
    int flags,
    MyCvTermCriteria criteria,
    double *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;std::vector&amp;lt;cv::Point3f&amp;gt; &amp;gt; objectPointsVec(opSize1);
    for (auto i = 0; i &amp;lt; opSize1; i++)
        objectPointsVec[i] = std::vector&amp;lt;cv::Point3f&amp;gt;(objectPoints[i], objectPoints[i] + opSize2[i]);

    std::vector&amp;lt;std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt; imagePointsVec(ipSize1);
    for (auto i = 0; i &amp;lt; ipSize1; i++)
        imagePointsVec[i] = std::vector&amp;lt;cv::Point2f&amp;gt;(imagePoints[i], imagePoints[i] + ipSize2[i]);

    cv::Mat cametaMatrixM(3, 3, CV_64FC1, cameraMatrix);
    cv::Mat distCoeffsM(distCoeffsSize, 1, CV_64FC1, distCoeffs);

    *returnValue = cv::calibrateCamera(objectPointsVec, imagePointsVec, cpp(imageSize),
        cametaMatrixM, distCoeffsM, *rvecs, *tvecs, flags, cpp(criteria));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_calibrationMatrixValues_InputArray
[32/64bit] カメラ固有の行列から有用なカメラ特性を計算します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr cameraMatrix
p2 = ARGS_SIZE : Size imageSize
p3 = double : double apertureWidth
p4 = double : double apertureHeight
p5 = var : out double fovx
p6 = var : out double fovy
p7 = var : out double focalLength
p8 = var : out Point2d principalPoint
p9 = var : out double aspectRatio
%inst
この関数は，事前に推定されたカメラ行列から，様々な有用なカメラ特性を計算します．注意点として，統一的な尺度である「mm」は，チェスボードのピッチを表す任意の単位を表していることに注意してください（したがって，任意の値になります）．

元関数名(C#): calib3d_calibrationMatrixValues_InputArray
元DLLエクスポート名: calib3d_calibrationMatrixValues_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_calibrationMatrixValues_InputArray(cv::_InputArray *cameraMatrix, MyCvSize imageSize,
    double apertureWidth, double apertureHeight, double *fovx, double *fovy, double *focalLength,
    cv::Point2d *principalPoint, double *aspectRatio)
{
    BEGIN_WRAP
    double fovx0, fovy0, focalLength0, aspectRatio0;
    cv::Point2d principalPoint0;
    cv::calibrationMatrixValues(*cameraMatrix, cpp(imageSize), apertureWidth, apertureHeight,
        fovx0, fovy0, focalLength0, principalPoint0, aspectRatio0);
    *fovx = fovx0;
    *fovy = fovy0;
    *principalPoint = principalPoint0;
    *focalLength = focalLength0;
    *aspectRatio = aspectRatio0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_calibrationMatrixValues_array
[32/64bit] カメラ固有の行列から有用なカメラ特性を計算します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = var : double* cameraMatrix
p2 = ARGS_SIZE : Size imageSize
p3 = double : double apertureWidth
p4 = double : double apertureHeight
p5 = var : out double fovx
p6 = var : out double fovy
p7 = var : out double focalLength
p8 = var : out Point2d principalPoint
p9 = var : out double aspectRatio
%inst
この関数は，事前に推定されたカメラ行列から，様々な有用なカメラ特性を計算します．注意点として，統一的な尺度である「mm」は，チェスボードのピッチを表す任意の単位を表していることに注意してください（したがって，任意の値になります）．

元関数名(C#): calib3d_calibrationMatrixValues_array
元DLLエクスポート名: calib3d_calibrationMatrixValues_array
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_calibrationMatrixValues_array(double *cameraMatrix, MyCvSize imageSize,
    double apertureWidth, double apertureHeight, double *fovx, double *fovy, double *focalLength,
    cv::Point2d *principalPoint, double *aspectRatio)
{
    BEGIN_WRAP
    const cv::Mat cameraMatrixM(3, 3, CV_64FC1, cameraMatrix);
    cv::_InputArray cameraMatrixI(cameraMatrixM);
    calib3d_calibrationMatrixValues_InputArray(&amp;cameraMatrixI, imageSize, apertureWidth, apertureHeight,
        fovx, fovy, focalLength, principalPoint, aspectRatio);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_stereoCalibrate_InputArray
[32bit] ステレオカメラセットのキャリブレーションを行います。この関数は、2台のカメラそれぞれの固有パラメータと、2台のカメラ間の外部パラメータを求めます。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18
p1 = sptr : IntPtr[] objectPoints
p2 = int : int opSize
p3 = sptr : IntPtr[] imagePoints1
p4 = int : int ip1Size
p5 = sptr : IntPtr[] imagePoints2
p6 = int : int ip2Size
p7 = sptr : IntPtr cameraMatrix1
p8 = sptr : IntPtr distCoeffs1
p9 = sptr : IntPtr cameraMatrix2
p10 = sptr : IntPtr distCoeffs2
p11 = ARGS_SIZE : Size imageSize
p12 = sptr : IntPtr R
p13 = sptr : IntPtr T
p14 = sptr : IntPtr E
p15 = sptr : IntPtr F
p16 = int : int flags
p17 = ARGS_TERMCRITERIA : TermCriteria criteria
p18 = var : out double returnValue
%inst
この関数は，ステレオペアを構成する2つのカメラ間の変換を推定します．2つのカメラ間の相対的な位置と姿勢が固定されているステレオカメラにおいて，1番目のカメラと2番目のカメラに対する物体の姿勢をそれぞれ( ????? ), ( ????? ), ( ????? ) と計算すると，それらの姿勢は確実に互いに関連していることになります．つまり、2つのカメラの相対的な位置と向き（\(R\)、\(T\)）がわかっていれば、（\(R_1\)、\(T_1\)）が与えられたときに、（\(R_2\)、\(T_2amer)）を計算することができます。これが，この関数の役割です．R_2=R R_1\]T_2=R T_1 + T.\]従って、1台目のカメラの座標系での3次元点の座標表現が与えられたとき、2台目のカメラの座標系での3次元点の座標表現を計算することができます。♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪R＆T」は、0＆1で構成されています。\\\\Optionally, the essential matrix E:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\R\(t=[t_0, t_1, t_2]^t\) .また，この関数は，基本行列Fを計算することもできます：\[F = cameraMatrix2^{-T}\cdot E ?cdot cameraMatrix1^{-1}\]ステレオ関連の情報の他に，2台のカメラそれぞれのフルキャリブレーションを行うこともできます。しかし，パラメータ空間の次元が高く，入力データにノイズが含まれているため，この関数は正しい解から乖離する可能性があります．各カメラの固有パラメータを個別に高精度に推定できる場合（例えば，calibrateCamera を用いて）は，そうしてから，計算された固有パラメータとともに CALIB_FIX_INTRINSIC フラグを関数に渡すことをお勧めします．また，すべてのパラメータが一度に推定される場合は，いくつかのパラメータを制限することに意味があります．例えば，CALIB_SAME_FOCAL_LENGTH フラグと CALIB_ZERO_TANGENT_DIST フラグを渡しますが，これは通常，妥当な仮定です． calibrateCamera と同様に，この関数は，両方のカメラから得られるすべての利用可能なビューのすべてのポイントに対して，合計再投影誤差を最小化します．この関数は，再投影誤差の最終的な値を返します．

元関数名(C#): calib3d_stereoCalibrate_InputArray
元DLLエクスポート名: calib3d_stereoCalibrate_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_stereoCalibrate_InputArray(
    cv::_InputArray **objectPoints, int opSize,
    cv::_InputArray **imagePoints1, int ip1Size,
    cv::_InputArray **imagePoints2, int ip2Size,
    cv::_InputOutputArray *cameraMatrix1,
    cv::_InputOutputArray *distCoeffs1,
    cv::_InputOutputArray *cameraMatrix2,
    cv::_InputOutputArray *distCoeffs2,
    MyCvSize imageSize,
    cv::_OutputArray *R, cv::_OutputArray *T,
    cv::_OutputArray *E, cv::_OutputArray *F,
    int flags, 
    MyCvTermCriteria criteria,
    double *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::_InputArray&amp;gt; objectPointsVec(opSize);
    std::vector&amp;lt;cv::_InputArray&amp;gt; imagePoints1Vec(ip1Size);
    std::vector&amp;lt;cv::_InputArray&amp;gt; imagePoints2Vec(ip2Size);
    for (auto i = 0; i &amp;lt; opSize; i++)
        objectPointsVec[i] = *objectPoints[i];
    for (auto i = 0; i &amp;lt; ip1Size; i++)
        imagePoints1Vec[i] = *imagePoints1[i];
    for (auto i = 0; i &amp;lt; ip2Size; i++)
        imagePoints2Vec[i] = *imagePoints2[i];

    *returnValue = cv::stereoCalibrate(objectPointsVec, imagePoints1Vec, imagePoints2Vec,
        *cameraMatrix1, *distCoeffs1,
        *cameraMatrix2, *distCoeffs2,
        cpp(imageSize), entity(R), entity(T), entity(E), entity(F), flags, cpp(criteria));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_stereoCalibrate_InputArray
[64bit] ステレオカメラセットのキャリブレーションを行います。この関数は、2台のカメラそれぞれの固有パラメータと、2台のカメラ間の外部パラメータを求めます。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18
p1 = sptr : IntPtr[] objectPoints
p2 = int : int opSize
p3 = sptr : IntPtr[] imagePoints1
p4 = int : int ip1Size
p5 = sptr : IntPtr[] imagePoints2
p6 = int : int ip2Size
p7 = sptr : IntPtr cameraMatrix1
p8 = sptr : IntPtr distCoeffs1
p9 = sptr : IntPtr cameraMatrix2
p10 = sptr : IntPtr distCoeffs2
p11 = ARGS_SIZE : Size imageSize
p12 = sptr : IntPtr R
p13 = sptr : IntPtr T
p14 = sptr : IntPtr E
p15 = sptr : IntPtr F
p16 = int : int flags
p17 = var : TermCriteria criteria
p18 = var : out double returnValue
%inst
この関数は，ステレオペアを構成する2つのカメラ間の変換を推定します．2つのカメラ間の相対的な位置と姿勢が固定されているステレオカメラにおいて，1番目のカメラと2番目のカメラに対する物体の姿勢をそれぞれ( ????? ), ( ????? ), ( ????? ) と計算すると，それらの姿勢は確実に互いに関連していることになります．つまり、2つのカメラの相対的な位置と向き（\(R\)、\(T\)）がわかっていれば、（\(R_1\)、\(T_1\)）が与えられたときに、（\(R_2\)、\(T_2amer)）を計算することができます。これが，この関数の役割です．R_2=R R_1\]T_2=R T_1 + T.\]従って、1台目のカメラの座標系での3次元点の座標表現が与えられたとき、2台目のカメラの座標系での3次元点の座標表現を計算することができます。♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪R＆T」は、0＆1で構成されています。\\\\Optionally, the essential matrix E:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\R\(t=[t_0, t_1, t_2]^t\) .また，この関数は，基本行列Fを計算することもできます：\[F = cameraMatrix2^{-T}\cdot E ?cdot cameraMatrix1^{-1}\]ステレオ関連の情報の他に，2台のカメラそれぞれのフルキャリブレーションを行うこともできます。しかし，パラメータ空間の次元が高く，入力データにノイズが含まれているため，この関数は正しい解から乖離する可能性があります．各カメラの固有パラメータを個別に高精度に推定できる場合（例えば，calibrateCamera を用いて）は，そうしてから，計算された固有パラメータとともに CALIB_FIX_INTRINSIC フラグを関数に渡すことをお勧めします．また，すべてのパラメータが一度に推定される場合は，いくつかのパラメータを制限することに意味があります．例えば，CALIB_SAME_FOCAL_LENGTH フラグと CALIB_ZERO_TANGENT_DIST フラグを渡しますが，これは通常，妥当な仮定です． calibrateCamera と同様に，この関数は，両方のカメラから得られるすべての利用可能なビューのすべてのポイントに対して，合計再投影誤差を最小化します．この関数は，再投影誤差の最終的な値を返します．

元関数名(C#): calib3d_stereoCalibrate_InputArray
元DLLエクスポート名: calib3d_stereoCalibrate_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_stereoCalibrate_InputArray(
    cv::_InputArray **objectPoints, int opSize,
    cv::_InputArray **imagePoints1, int ip1Size,
    cv::_InputArray **imagePoints2, int ip2Size,
    cv::_InputOutputArray *cameraMatrix1,
    cv::_InputOutputArray *distCoeffs1,
    cv::_InputOutputArray *cameraMatrix2,
    cv::_InputOutputArray *distCoeffs2,
    MyCvSize imageSize,
    cv::_OutputArray *R, cv::_OutputArray *T,
    cv::_OutputArray *E, cv::_OutputArray *F,
    int flags, 
    MyCvTermCriteria criteria,
    double *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::_InputArray&amp;gt; objectPointsVec(opSize);
    std::vector&amp;lt;cv::_InputArray&amp;gt; imagePoints1Vec(ip1Size);
    std::vector&amp;lt;cv::_InputArray&amp;gt; imagePoints2Vec(ip2Size);
    for (auto i = 0; i &amp;lt; opSize; i++)
        objectPointsVec[i] = *objectPoints[i];
    for (auto i = 0; i &amp;lt; ip1Size; i++)
        imagePoints1Vec[i] = *imagePoints1[i];
    for (auto i = 0; i &amp;lt; ip2Size; i++)
        imagePoints2Vec[i] = *imagePoints2[i];

    *returnValue = cv::stereoCalibrate(objectPointsVec, imagePoints1Vec, imagePoints2Vec,
        *cameraMatrix1, *distCoeffs1,
        *cameraMatrix2, *distCoeffs2,
        cpp(imageSize), entity(R), entity(T), entity(E), entity(F), flags, cpp(criteria));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_stereoCalibrate_array
[32bit] ステレオカメラセットのキャリブレーションを行います。この関数は、2台のカメラそれぞれの固有パラメータと、2台のカメラ間の外部パラメータを求めます。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23
p1 = sptr : IntPtr[] objectPoints
p2 = int : int opSize1
p3 = var : int[] opSizes2
p4 = sptr : IntPtr[] imagePoints1
p5 = int : int ip1Size1
p6 = var : int[] ip1Sizes2
p7 = sptr : IntPtr[] imagePoints2
p8 = int : int ip2Size1
p9 = var : int[] ip2Sizes2
p10 = var : double* cameraMatrix1
p11 = var : [In, Out] double[] distCoeffs1
p12 = int : int dc1Size
p13 = var : double* cameraMatrix2
p14 = var : [In, Out] double[] distCoeffs2
p15 = int : int dc2Size
p16 = ARGS_SIZE : Size imageSize
p17 = sptr : IntPtr R
p18 = sptr : IntPtr T
p19 = sptr : IntPtr E
p20 = sptr : IntPtr F
p21 = int : int flags
p22 = ARGS_TERMCRITERIA : TermCriteria criteria
p23 = var : out double returnValue
%inst
この関数は，ステレオペアを構成する2つのカメラ間の変換を推定します．2つのカメラ間の相対的な位置と姿勢が固定されているステレオカメラにおいて，1番目のカメラと2番目のカメラに対する物体の姿勢をそれぞれ( ????? ), ( ????? ), ( ????? ) と計算すると，それらの姿勢は確実に互いに関連していることになります．つまり、2つのカメラの相対的な位置と向き（\(R\)、\(T\)）がわかっていれば、（\(R_1\)、\(T_1\)）が与えられたときに、（\(R_2\)、\(T_2amer)）を計算することができます。これが，この関数の役割です．R_2=R R_1\]T_2=R T_1 + T.\]従って、1台目のカメラの座標系での3次元点の座標表現が与えられたとき、2台目のカメラの座標系での3次元点の座標表現を計算することができます。♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪R＆T」は、0＆1で構成されています。\\\\Optionally, the essential matrix E:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\R\(t=[t_0, t_1, t_2]^t\) .また，この関数は，基本行列Fを計算することもできます：\[F = cameraMatrix2^{-T}\cdot E ?cdot cameraMatrix1^{-1}\]ステレオ関連の情報の他に，2台のカメラそれぞれのフルキャリブレーションを行うこともできます。しかし，パラメータ空間の次元が高く，入力データにノイズが含まれているため，この関数は正しい解から乖離する可能性があります．各カメラの固有パラメータを個別に高精度に推定できる場合（例えば，calibrateCamera を用いて）は，そうしてから，計算された固有パラメータとともに CALIB_FIX_INTRINSIC フラグを関数に渡すことをお勧めします．また，すべてのパラメータが一度に推定される場合は，いくつかのパラメータを制限することに意味があります．例えば，CALIB_SAME_FOCAL_LENGTH フラグと CALIB_ZERO_TANGENT_DIST フラグを渡しますが，これは通常，妥当な仮定です． calibrateCamera と同様に，この関数は，両方のカメラから得られるすべての利用可能なビューのすべてのポイントに対して，合計再投影誤差を最小化します．この関数は，再投影誤差の最終的な値を返します．

元関数名(C#): calib3d_stereoCalibrate_array
元DLLエクスポート名: calib3d_stereoCalibrate_array
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_stereoCalibrate_array(
    cv::Point3f **objectPoints, int opSize1, int *opSizes2,
    cv::Point2f **imagePoints1, int ip1Size1, int *ip1Sizes2,
    cv::Point2f **imagePoints2, int ip2Size1, int *ip2Sizes2,
    double *cameraMatrix1,
    double *distCoeffs1, int dc1Size,
    double *cameraMatrix2,
    double *distCoeffs2, int dc2Size,
    MyCvSize imageSize,
    cv::_OutputArray *R, cv::_OutputArray *T,
    cv::_OutputArray *E, cv::_OutputArray *F,
    int flags, 
    MyCvTermCriteria criteria,
    double *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;std::vector&amp;lt;cv::Point3f&amp;gt; &amp;gt; objectPointsVec(opSize1);
    std::vector&amp;lt;std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt; imagePoints1Vec(ip1Size1);
    std::vector&amp;lt;std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt; imagePoints2Vec(ip2Size1);
    for (auto i = 0; i &amp;lt; opSize1; i++)
        objectPointsVec[i] = std::vector&amp;lt;cv::Point3f&amp;gt;(
        objectPoints[i], objectPoints[i] + opSizes2[i]);
    for (auto i = 0; i &amp;lt; ip1Size1; i++)
        imagePoints1Vec[i] = std::vector&amp;lt;cv::Point2f&amp;gt;(
        imagePoints1[i], imagePoints1[i] + ip1Sizes2[i]);
    for (auto i = 0; i &amp;lt; ip2Size1; i++)
        imagePoints2Vec[i] = std::vector&amp;lt;cv::Point2f&amp;gt;(
        imagePoints2[i], imagePoints2[i] + ip2Sizes2[i]);

    cv::Mat cameraMatrix1M(3, 3, CV_64FC1, cameraMatrix1);
    cv::Mat cameraMatrix2M(3, 3, CV_64FC1, cameraMatrix2);
    cv::Mat distCoeffs1M(dc1Size, 1, CV_64FC1, distCoeffs1);
    cv::Mat distCoeffs2M(dc2Size, 1, CV_64FC1, distCoeffs2);

    *returnValue = cv::stereoCalibrate(objectPointsVec, imagePoints1Vec, imagePoints2Vec,
        cameraMatrix1M, distCoeffs1M,
        cameraMatrix2M, distCoeffs2M,
        cpp(imageSize), entity(R), entity(T), entity(E), entity(F), flags, cpp(criteria));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_stereoCalibrate_array
[64bit] ステレオカメラセットのキャリブレーションを行います。この関数は、2台のカメラそれぞれの固有パラメータと、2台のカメラ間の外部パラメータを求めます。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23
p1 = sptr : IntPtr[] objectPoints
p2 = int : int opSize1
p3 = var : int[] opSizes2
p4 = sptr : IntPtr[] imagePoints1
p5 = int : int ip1Size1
p6 = var : int[] ip1Sizes2
p7 = sptr : IntPtr[] imagePoints2
p8 = int : int ip2Size1
p9 = var : int[] ip2Sizes2
p10 = var : double* cameraMatrix1
p11 = var : [In, Out] double[] distCoeffs1
p12 = int : int dc1Size
p13 = var : double* cameraMatrix2
p14 = var : [In, Out] double[] distCoeffs2
p15 = int : int dc2Size
p16 = ARGS_SIZE : Size imageSize
p17 = sptr : IntPtr R
p18 = sptr : IntPtr T
p19 = sptr : IntPtr E
p20 = sptr : IntPtr F
p21 = int : int flags
p22 = var : TermCriteria criteria
p23 = var : out double returnValue
%inst
この関数は，ステレオペアを構成する2つのカメラ間の変換を推定します．2つのカメラ間の相対的な位置と姿勢が固定されているステレオカメラにおいて，1番目のカメラと2番目のカメラに対する物体の姿勢をそれぞれ( ????? ), ( ????? ), ( ????? ) と計算すると，それらの姿勢は確実に互いに関連していることになります．つまり、2つのカメラの相対的な位置と向き（\(R\)、\(T\)）がわかっていれば、（\(R_1\)、\(T_1\)）が与えられたときに、（\(R_2\)、\(T_2amer)）を計算することができます。これが，この関数の役割です．R_2=R R_1\]T_2=R T_1 + T.\]従って、1台目のカメラの座標系での3次元点の座標表現が与えられたとき、2台目のカメラの座標系での3次元点の座標表現を計算することができます。♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪R＆T」は、0＆1で構成されています。\\\\Optionally, the essential matrix E:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\R\(t=[t_0, t_1, t_2]^t\) .また，この関数は，基本行列Fを計算することもできます：\[F = cameraMatrix2^{-T}\cdot E ?cdot cameraMatrix1^{-1}\]ステレオ関連の情報の他に，2台のカメラそれぞれのフルキャリブレーションを行うこともできます。しかし，パラメータ空間の次元が高く，入力データにノイズが含まれているため，この関数は正しい解から乖離する可能性があります．各カメラの固有パラメータを個別に高精度に推定できる場合（例えば，calibrateCamera を用いて）は，そうしてから，計算された固有パラメータとともに CALIB_FIX_INTRINSIC フラグを関数に渡すことをお勧めします．また，すべてのパラメータが一度に推定される場合は，いくつかのパラメータを制限することに意味があります．例えば，CALIB_SAME_FOCAL_LENGTH フラグと CALIB_ZERO_TANGENT_DIST フラグを渡しますが，これは通常，妥当な仮定です． calibrateCamera と同様に，この関数は，両方のカメラから得られるすべての利用可能なビューのすべてのポイントに対して，合計再投影誤差を最小化します．この関数は，再投影誤差の最終的な値を返します．

元関数名(C#): calib3d_stereoCalibrate_array
元DLLエクスポート名: calib3d_stereoCalibrate_array
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_stereoCalibrate_array(
    cv::Point3f **objectPoints, int opSize1, int *opSizes2,
    cv::Point2f **imagePoints1, int ip1Size1, int *ip1Sizes2,
    cv::Point2f **imagePoints2, int ip2Size1, int *ip2Sizes2,
    double *cameraMatrix1,
    double *distCoeffs1, int dc1Size,
    double *cameraMatrix2,
    double *distCoeffs2, int dc2Size,
    MyCvSize imageSize,
    cv::_OutputArray *R, cv::_OutputArray *T,
    cv::_OutputArray *E, cv::_OutputArray *F,
    int flags, 
    MyCvTermCriteria criteria,
    double *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;std::vector&amp;lt;cv::Point3f&amp;gt; &amp;gt; objectPointsVec(opSize1);
    std::vector&amp;lt;std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt; imagePoints1Vec(ip1Size1);
    std::vector&amp;lt;std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt; imagePoints2Vec(ip2Size1);
    for (auto i = 0; i &amp;lt; opSize1; i++)
        objectPointsVec[i] = std::vector&amp;lt;cv::Point3f&amp;gt;(
        objectPoints[i], objectPoints[i] + opSizes2[i]);
    for (auto i = 0; i &amp;lt; ip1Size1; i++)
        imagePoints1Vec[i] = std::vector&amp;lt;cv::Point2f&amp;gt;(
        imagePoints1[i], imagePoints1[i] + ip1Sizes2[i]);
    for (auto i = 0; i &amp;lt; ip2Size1; i++)
        imagePoints2Vec[i] = std::vector&amp;lt;cv::Point2f&amp;gt;(
        imagePoints2[i], imagePoints2[i] + ip2Sizes2[i]);

    cv::Mat cameraMatrix1M(3, 3, CV_64FC1, cameraMatrix1);
    cv::Mat cameraMatrix2M(3, 3, CV_64FC1, cameraMatrix2);
    cv::Mat distCoeffs1M(dc1Size, 1, CV_64FC1, distCoeffs1);
    cv::Mat distCoeffs2M(dc2Size, 1, CV_64FC1, distCoeffs2);

    *returnValue = cv::stereoCalibrate(objectPointsVec, imagePoints1Vec, imagePoints2Vec,
        cameraMatrix1M, distCoeffs1M,
        cameraMatrix2M, distCoeffs2M,
        cpp(imageSize), entity(R), entity(T), entity(E), entity(F), flags, cpp(criteria));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_stereoRectify_InputArray
[32/64bit] キャリブレーションされたステレオカメラの各ヘッドに対して，平行化変換を計算します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17
p1 = sptr : IntPtr cameraMatrix1
p2 = sptr : IntPtr distCoeffs1
p3 = sptr : IntPtr cameraMatrix2
p4 = sptr : IntPtr distCoeffs2
p5 = ARGS_SIZE : Size imageSize
p6 = sptr : IntPtr R
p7 = sptr : IntPtr T
p8 = sptr : IntPtr R1
p9 = sptr : IntPtr R2
p10 = sptr : IntPtr P1
p11 = sptr : IntPtr P2
p12 = sptr : IntPtr Q
p13 = int : int flags
p14 = double : double alpha
p15 = ARGS_SIZE : Size newImageSize
p16 = var : out Rect validPixROI1
p17 = var : out Rect validPixROI2
%inst
この関数は，各カメラの回転行列を計算し，両カメラの画像平面を（仮想的に）同一平面にします．その結果，すべてのエピポーラ線が平行になり，密なステレオ対応関係の問題が簡単になります．この関数は， stereoCalibrate によって計算された行列を入力として受け取ります．出力として，2つの回転行列と，新しい座標への2つの投影行列が得られます．この関数は，以下の2つのケースを区別します：水平ステレオ：1番目と2番目のカメラのビューが，主にx軸に沿って相対的にシフトします（わずかな垂直方向のシフトもあり得ます）．整形された画像では，左右のカメラの対応するエピポーラ線は水平で，同じy座標を持ちます．P1とP2は次のようになります。



\P1} = ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ??_?CC





\\\\,\]



ここで、T_x\はカメラ間の水平方向の移動量、CALIB_ZERO_DISPARITYが設定されている場合は、\(cx_1=cx_2\)となります。



垂直方向のステレオ：1台目と2台目のカメラのビューは、主に垂直方向に相対的にシフトします（おそらく水平方向にも少しシフトします）。整形された画像のエピポーララインは垂直で，同じx座標を持っています．P1とP2は次のようになります。



\P1 = ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ??_?CC





\♪\\\\



ご覧のように、P1、P2の最初の3列は、実質的に新しい「平行化された」カメラ行列となります。この行列は，R1 と R2 とともに initUndistortRectifyMap に渡され，各カメラの平行化マップを初期化します。以下に，stereo_calib.cpp サンプルのスクリーンショットを示します。いくつかの赤い水平線が，対応する画像領域を通過しています．これは，画像がよく平行化されていることを意味しており，ほとんどのステレオ対応付けアルゴリズムがこれに依存しています．緑色の四角形は， roi1 と roi2 です．これらの内部は，すべて有効なピクセルであることが分かります．

元関数名(C#): calib3d_stereoRectify_InputArray
元DLLエクスポート名: calib3d_stereoRectify_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_stereoRectify_InputArray(
    cv::_InputArray *cameraMatrix1, cv::_InputArray *distCoeffs1,
    cv::_InputArray *cameraMatrix2, cv::_InputArray *distCoeffs2,
    MyCvSize imageSize, cv::_InputArray *R, cv::_InputArray *T,
    cv::_OutputArray *R1, cv::_OutputArray *R2,
    cv::_OutputArray *P1, cv::_OutputArray *P2,
    cv::_OutputArray *Q, int flags,
    double alpha, CvSize newImageSize,
    MyCvRect *validPixROI1, MyCvRect *validPixROI2)
{
    BEGIN_WRAP
    cv::Rect _validPixROI1, _validPixROI2;
    cv::stereoRectify(*cameraMatrix1, *distCoeffs1, *cameraMatrix2, *distCoeffs2,
        cpp(imageSize), *R, *T, *R1, *R2, *P1, *P2, *Q, flags, alpha, newImageSize,
        &amp;_validPixROI1, &amp;_validPixROI2);
    *validPixROI1 = c(_validPixROI1);
    *validPixROI2 = c(_validPixROI2);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_stereoRectify_array
[32/64bit] キャリブレーションされたステレオカメラの各ヘッドに対して，平行化変換を計算します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19
p1 = var : double* cameraMatrix1
p2 = var : double[] distCoeffs1
p3 = int : int dc1Size
p4 = var : double* cameraMatrix2
p5 = var : double[] distCoeffs2
p6 = int : int dc2Size
p7 = ARGS_SIZE : Size imageSize
p8 = var : double* R
p9 = var : double[] T
p10 = var : double* R1
p11 = var : double* R2
p12 = var : double* P1
p13 = var : double* P2
p14 = var : double* Q
p15 = int : int flags
p16 = double : double alpha
p17 = ARGS_SIZE : Size newImageSize
p18 = var : out Rect validPixROI1
p19 = var : out Rect validPixROI2
%inst
この関数は，各カメラの回転行列を計算し，両カメラの画像平面を（仮想的に）同一平面にします．その結果，すべてのエピポーラ線が平行になり，密なステレオ対応関係の問題が簡単になります．この関数は， stereoCalibrate によって計算された行列を入力として受け取ります．出力として，2つの回転行列と，新しい座標への2つの投影行列が得られます．この関数は，以下の2つのケースを区別します：水平ステレオ：1番目と2番目のカメラのビューが，主にx軸に沿って相対的にシフトします（わずかな垂直方向のシフトもあり得ます）．整形された画像では，左右のカメラの対応するエピポーラ線は水平で，同じy座標を持ちます．P1とP2は次のようになります。



\P1} = ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ??_?CC





\\\\,\]



ここで、T_x\はカメラ間の水平方向の移動量、CALIB_ZERO_DISPARITYが設定されている場合は、\(cx_1=cx_2\)となります。



垂直方向のステレオ：1台目と2台目のカメラのビューは、主に垂直方向に相対的にシフトします（おそらく水平方向にも少しシフトします）。整形された画像のエピポーララインは垂直で，同じx座標を持っています．P1とP2は次のようになります。



\P1 = ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ??_?CC





\♪\\\\



ご覧のように、P1、P2の最初の3列は、実質的に新しい「平行化された」カメラ行列となります。この行列は，R1 と R2 とともに initUndistortRectifyMap に渡され，各カメラの平行化マップを初期化します。以下に，stereo_calib.cpp サンプルのスクリーンショットを示します。いくつかの赤い水平線が，対応する画像領域を通過しています．これは，画像がよく平行化されていることを意味しており，ほとんどのステレオ対応付けアルゴリズムがこれに依存しています．緑色の四角形は， roi1 と roi2 です．これらの内部は，すべて有効なピクセルであることが分かります．

元関数名(C#): calib3d_stereoRectify_array
元DLLエクスポート名: calib3d_stereoRectify_array
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_stereoRectify_array(double *cameraMatrix1,
    double *distCoeffs1, int dc1Size,
    double *cameraMatrix2,
    double *distCoeffs2, int dc2Size,
    MyCvSize imageSize,
    double *R, double *T,
    double *R1, double *R2, double *P1, double *P2,
    double *Q, int flags, double alpha, MyCvSize newImageSize,
    MyCvRect *validPixROI1, MyCvRect *validPixROI2)
{
    BEGIN_WRAP
    cv::Mat cameraMatrix1M(3, 3, CV_64FC1, cameraMatrix1);
    cv::Mat cameraMatrix2M(3, 3, CV_64FC1, cameraMatrix2);
    cv::Mat distCoeffs1M(dc1Size, 1, CV_64FC1, distCoeffs1);
    cv::Mat distCoeffs2M(dc2Size, 1, CV_64FC1, distCoeffs2);
    cv::Mat RM(3, 3, CV_64FC1, R);
    cv::Mat TM(1, 3, CV_64FC1, T);

    cv::Mat R1M(3, 3, CV_64FC1, R1);
    cv::Mat R2M(3, 3, CV_64FC1, R2);
    cv::Mat P1M(3, 4, CV_64FC1, P1);
    cv::Mat P2M(3, 4, CV_64FC1, P2);
    cv::Mat QM(4, 4, CV_64FC1, Q);

    cv::Rect _validPixROI1, _validPixROI2;
    cv::stereoRectify(cameraMatrix1M, distCoeffs1M, cameraMatrix2M, distCoeffs2M,
        cpp(imageSize), RM, TM, R1M, R2M, P1M, P2M, QM, flags, alpha, cpp(newImageSize),
        &amp;_validPixROI1, &amp;_validPixROI2);
    *validPixROI1 = c(_validPixROI1);
    *validPixROI2 = c(_validPixROI2);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_stereoRectifyUncalibrated_InputArray
[32/64bit] キャリブレーションされていないステレオカメラに対して，平行化変換を行います．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr points1
p2 = sptr : IntPtr points2
p3 = sptr : IntPtr F
p4 = ARGS_SIZE : Size imgSize
p5 = sptr : IntPtr H1
p6 = sptr : IntPtr H2
p7 = double : double threshold
p8 = var : out int returnValue
%inst
この関数は，カメラの固有のパラメータや空間内の相対的な位置を知らずに，平行化変換を計算するので，「uncalibrated」という接尾辞が付きます．stereoRectify とのもう1つの関連する違いは，この関数が物体（3次元）空間における平行化変換ではなく，ホモグラフィ行列 H1 と H2 によってエンコードされた平面透視変換を出力することです．この関数は，アルゴリズム [104] を実装しています． 注意このアルゴリズムは，カメラの固有のパラメータを知る必要はありませんが，エピポーラ幾何学に大きく依存します．したがって，カメラレンズに大きな歪みがある場合は，基本行列を計算してこの関数を呼び出す前に，その歪みを補正した方が良いでしょう．例えば， calibrateCamera を使って，ステレオカメラの各ヘッドの歪み係数を個別に推定することができます．その後， undistort を用いて画像を補正したり， undistortPoints を用いて点座標だけを補正したりすることができます．

元関数名(C#): calib3d_stereoRectifyUncalibrated_InputArray
元DLLエクスポート名: calib3d_stereoRectifyUncalibrated_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_stereoRectifyUncalibrated_InputArray(cv::_InputArray *points1, cv::_InputArray *points2,
    cv::_InputArray *F, MyCvSize imgSize,
    cv::_OutputArray *H1, cv::_OutputArray *H2,
    double threshold,
    int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::stereoRectifyUncalibrated(*points1, *points2, *F, cpp(imgSize), *H1, *H2, threshold) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_stereoRectifyUncalibrated_array
[32/64bit] キャリブレーションされていないステレオカメラに対して，平行化変換を行います．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = var : Point2d[] points1
p2 = int : int points1Size
p3 = var : Point2d[] points2
p4 = int : int points2Size
p5 = var : double* F
p6 = ARGS_SIZE : Size imgSize
p7 = var : double* H1
p8 = var : double* H2
p9 = double : double threshold
p10 = var : out int returnValue
%inst
この関数は，カメラの固有のパラメータや空間内の相対的な位置を知らずに，平行化変換を計算するので，「uncalibrated」という接尾辞が付きます．stereoRectify とのもう1つの関連する違いは，この関数が物体（3次元）空間における平行化変換ではなく，ホモグラフィ行列 H1 と H2 によってエンコードされた平面透視変換を出力することです．この関数は，アルゴリズム [104] を実装しています． 注意このアルゴリズムは，カメラの固有のパラメータを知る必要はありませんが，エピポーラ幾何学に大きく依存します．したがって，カメラレンズに大きな歪みがある場合は，基本行列を計算してこの関数を呼び出す前に，その歪みを補正した方が良いでしょう．例えば， calibrateCamera を使って，ステレオカメラの各ヘッドの歪み係数を個別に推定することができます．その後， undistort を用いて画像を補正したり， undistortPoints を用いて点座標だけを補正したりすることができます．

元関数名(C#): calib3d_stereoRectifyUncalibrated_array
元DLLエクスポート名: calib3d_stereoRectifyUncalibrated_array
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_stereoRectifyUncalibrated_array(cv::Point2d *points1, int points1Size,
    cv::Point2d *points2, int points2Size,
    cv::_InputArray *F, MyCvSize imgSize,
    double *H1, double *H2,
    double threshold,
    int *returnValue)
{
    BEGIN_WRAP
    const cv::Mat points1Mat(points1Size, 1, CV_64FC2, points1);
    const cv::Mat points2Mat(points2Size, 1, CV_64FC2, points2);
    cv::Mat H1M(3, 3, CV_64FC1, H1);
    cv::Mat H2M(3, 3, CV_64FC1, H2);
    *returnValue = cv::stereoRectifyUncalibrated(points1Mat, points2Mat, *F, cpp(imgSize), H1M, H2M, threshold) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_rectify3Collinear_InputArray
[32/64bit] すべてのヘッドが同じ線上にある，3ヘッドカメラの平行化変換を求めます．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23,p24,p25,p26,p27,p28
p1 = sptr : IntPtr cameraMatrix1
p2 = sptr : IntPtr distCoeffs1
p3 = sptr : IntPtr cameraMatrix2
p4 = sptr : IntPtr distCoeffs2
p5 = sptr : IntPtr cameraMatrix3
p6 = sptr : IntPtr distCoeffs3
p7 = sptr : IntPtr[] imgpt1
p8 = int : int imgpt1Size
p9 = sptr : IntPtr[] imgpt3
p10 = int : int imgpt3Size
p11 = ARGS_SIZE : Size imageSize
p12 = sptr : IntPtr R12
p13 = sptr : IntPtr T12
p14 = sptr : IntPtr R13
p15 = sptr : IntPtr T13
p16 = sptr : IntPtr R1
p17 = sptr : IntPtr R2
p18 = sptr : IntPtr R3
p19 = sptr : IntPtr P1
p20 = sptr : IntPtr P2
p21 = sptr : IntPtr P3
p22 = sptr : IntPtr Q
p23 = double : double alpha
p24 = ARGS_SIZE : Size newImgSize
p25 = var : out Rect roi1
p26 = var : out Rect roi2
p27 = int : int flags
p28 = var : out float returnValue
%inst
元関数名(C#): calib3d_rectify3Collinear_InputArray
元DLLエクスポート名: calib3d_rectify3Collinear_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_rectify3Collinear_InputArray(
    cv::_InputArray *cameraMatrix1, cv::_InputArray *distCoeffs1,
    cv::_InputArray *cameraMatrix2, cv::_InputArray *distCoeffs2,
    cv::_InputArray *cameraMatrix3, cv::_InputArray *distCoeffs3,
    cv::_InputArray **imgpt1, int imgpt1Size,
    cv::_InputArray **imgpt3, int imgpt3Size,
    MyCvSize imageSize, cv::_InputArray *R12, cv::_InputArray *T12,
    cv::_InputArray *R13, cv::_InputArray *T13,
    cv::_OutputArray *R1, cv::_OutputArray *R2, cv::_OutputArray *R3,
    cv::_OutputArray *P1, cv::_OutputArray *P2, cv::_OutputArray *P3,
    cv::_OutputArray *Q, double alpha, CvSize newImgSize,
    MyCvRect *roi1, MyCvRect *roi2, int flags,
    float *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::_InputArray&amp;gt; imgpt1Vec(imgpt1Size);
    std::vector&amp;lt;cv::_InputArray&amp;gt; imgpt3Vec(imgpt3Size);
    for (auto i = 0; i &amp;lt; imgpt1Size; i++)
        imgpt1Vec[i] = *(imgpt1[i]);
    for (auto i = 0; i &amp;lt; imgpt1Size; i++)
        imgpt3Vec[i] = *(imgpt3[i]);
    cv::Rect _roi1, _roi2;

    const auto ret = cv::rectify3Collinear(*cameraMatrix1, *distCoeffs1,
        *cameraMatrix2, *distCoeffs2, *cameraMatrix3, *distCoeffs3,
        imgpt1Vec, imgpt3Vec, cpp(imageSize), *R12, *T12, *R13, *T13,
        *R1, *R2, *R3, *P1, *P2, *P3, *Q, alpha, newImgSize,
        &amp;_roi1, &amp;_roi2, flags);
    *roi1 = c(_roi1);
    *roi2 = c(_roi2);
    *returnValue = ret;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_getOptimalNewCameraMatrix_InputArray
[32/64bit] フリースケーリングパラメータに基づいた，新しいカメラ固有の行列を返します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr cameraMatrix
p2 = sptr : IntPtr distCoeffs
p3 = ARGS_SIZE : Size imageSize
p4 = double : double alpha
p5 = ARGS_SIZE : Size newImgSize
p6 = var : out Rect validPixROI
p7 = int : int centerPrincipalPoint
p8 = var : out IntPtr returnValue
%inst
この関数は，フリースケーリングパラメータに基づいて，最適な新しいカメラ固有の行列を計算し，それを返します．このパラメータを変化させることで，意味のあるピクセルだけを取り出したり alpha=0 ，コーナーに貴重な情報がある場合に元画像のピクセルをすべて残したり alpha=1 ，その中間の値を得たりすることができます．alpha>0の場合，歪みのない結果には，キャプチャされた歪んだ画像の外側にある「仮想」ピクセルに対応するいくつかの黒いピクセルが含まれる可能性があります．元のカメラの内部行列，歪み係数，計算された新しいカメラの内部行列，そして newImageSize は，リマップ用のマップを生成するために initUndistortRectifyMap に渡されなければいけません．

元関数名(C#): calib3d_getOptimalNewCameraMatrix_InputArray
元DLLエクスポート名: calib3d_getOptimalNewCameraMatrix_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_getOptimalNewCameraMatrix_InputArray(
    cv::_InputArray *cameraMatrix, cv::_InputArray *distCoeffs,
    MyCvSize imageSize, double alpha, MyCvSize newImgSize,
    MyCvRect* validPixROI, int centerPrincipalPoint,
    cv::Mat **returnValue)
{
    BEGIN_WRAP
    cv::Rect _validPixROI;
    const auto mat = cv::getOptimalNewCameraMatrix(*cameraMatrix, entity(distCoeffs),
        cpp(imageSize), alpha, cpp(newImgSize), &amp;_validPixROI, centerPrincipalPoint != 0);
    *validPixROI = c(_validPixROI);
    *returnValue = new cv::Mat(mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_getOptimalNewCameraMatrix_array
[32/64bit] フリースケーリングパラメータに基づいた，新しいカメラ固有の行列を返します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = var : double* cameraMatrix
p2 = var : [In] double[] distCoeffs
p3 = int : int distCoeffsSize
p4 = ARGS_SIZE : Size imageSize
p5 = double : double alpha
p6 = ARGS_SIZE : Size newImgSize
p7 = var : out Rect validPixROI
p8 = int : int centerPrincipalPoint
p9 = var : out IntPtr returnValue
%inst
この関数は，フリースケーリングパラメータに基づいて，最適な新しいカメラ固有の行列を計算し，それを返します．このパラメータを変化させることで，意味のあるピクセルだけを取り出したり alpha=0 ，コーナーに貴重な情報がある場合に元画像のピクセルをすべて残したり alpha=1 ，その中間の値を得たりすることができます．alpha>0の場合，歪みのない結果には，キャプチャされた歪んだ画像の外側にある「仮想」ピクセルに対応するいくつかの黒いピクセルが含まれる可能性があります．元のカメラの内部行列，歪み係数，計算された新しいカメラの内部行列，そして newImageSize は，リマップ用のマップを生成するために initUndistortRectifyMap に渡されなければいけません．

元関数名(C#): calib3d_getOptimalNewCameraMatrix_array
元DLLエクスポート名: calib3d_getOptimalNewCameraMatrix_array
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_getOptimalNewCameraMatrix_array(
    double *cameraMatrix,
    double *distCoeffs, int distCoeffsSize,
    MyCvSize imageSize, double alpha, MyCvSize newImgSize,
    MyCvRect* validPixROI, int centerPrincipalPoint,
    cv::Mat **returnValue)
{
    BEGIN_WRAP
    const cv::Mat cameraMatrixM(3, 3, CV_64FC1, cameraMatrix);
    const auto distCoeffsM = (distCoeffs == nullptr) ? cv::Mat() : cv::Mat(distCoeffsSize, 1, CV_64FC1, distCoeffs);

    cv::Rect _validPixROI;
    const auto mat = cv::getOptimalNewCameraMatrix(cameraMatrixM, distCoeffsM, cpp(imageSize),
        alpha, cpp(newImgSize), &amp;_validPixROI, centerPrincipalPoint != 0);
    *validPixROI = c(_validPixROI);
    *returnValue = new cv::Mat(mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_calibrateHandEye
[32/64bit] Hand-Eye Calibrationを計算します．\(_{}^{g}\textrm{T}_c\).
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11
p1 = sptr : IntPtr[] R_gripper2baseMats
p2 = int : int R_gripper2baseMatsSize
p3 = sptr : IntPtr[] t_gripper2baseMats
p4 = int : int t_gripper2baseMatsSize
p5 = sptr : IntPtr[] R_target2camMats
p6 = int : int R_target2camMatsSize
p7 = sptr : IntPtr[] t_target2camMats
p8 = int : int t_target2camMatsSize
p9 = sptr : IntPtr R_cam2gripper
p10 = sptr : IntPtr t_cam2gripper
p11 = int : int method
%inst
この関数は，様々な手法を用いて手と目のキャリブレーションを行います．一つの方法は，回転と平行移動を推定することであり（分離可能な解），以下の方法が実装されています：R. Tsai, R. Lenz A.S.A.Tsai, R. Lenz A New Technique for Fully Autonomous and Efficient 3D Robotics Hand/EyeCalibration [249].

F.Park, B. Martin Robot Sensor Calibration:ユークリッドグループ上でAX = XBを解決する [190]。

R.Horaud, F. Dornaika Hand-Eye Calibration [112]別のアプローチは，回転と平行移動を同時に推定すること（同時解）であり，次のような実装方法がある：N.Andreff, R. Horaud, B. Espiau On-line Hand-Eye Calibration [11].

K.Daniilidis Hand-Eye Calibration Using Dual Quaternions [52]次の図は、ロボットグリッパー（「ハンド」）に取り付けられたカメラ（「アイ」）間の変換を推定しなければならないハンドアイのキャリブレーション問題を説明しています。Eye-to-Hand構成は、ロボットのエンドエフェクタに取り付けられた校正パターンを観察する静的なカメラで構成されています。カメラからロボットのベースフレームへの変換は、適切な変換を関数に入力することで推定できます（以下参照）。

ロボットのグリッパーを動かして，複数のポーズを取得する

各ポーズについて、グリッパーフレームとロボットベースフレームの間の同次変換が、例えばロボットキネマティクスを用いて記録されます。

\Mr.X_b\ Y_b\ Z_b\ 1 ????? ) = ????? ) = ????? )_{}^{b}\\{R}_g & _{}^{b}\\{t}_g\\0_{1 ??(?????????????)\\\\♪♪♪♪♪♪♪〜\]





各ポーズについて、キャリブレーションターゲットフレームとカメラフレームの間の同次変換を、例えば、2D-3D点対応からのポーズ推定法（PnP）を用いて記録します。

\????? )X_c\ Y_c%% Z_c%% 1 ????? ) = ????? )_{}^{c}\\{R}_t & _{}^{c}\\{t}_t 0_{1 ??(?????????????)\\\\♪ X t\\ Y t ♪ Z t ♪ 1\ハンドアイ キャリブレーションではX_g\ Y_g\ Z_g\ 1 ardent{bmatrix} = ??? -? ????♪♪♪♪♪〜\\\\X_c\ Y_cadows Z_cadows 1 end{bmatrix}.\この問題は別名、目と手の関係を表す

\♪♪〜^{b}{\textrm{T}_g}^{(1)}\0.2em}になります。^{g}\textrm{T}_c \hspace{0.2em}^{c}{\\{T}_t}^{(1)} &= ????? )^{b}{\textrm{T}_g}^{(2)}\ω＾）ノ^{g}\textrm{T}_c \hspace{0.2em}^{c}{\textrm{T}_t}^{(2)}(^{b}{\\{T}_g}^{(2)})^{-1} ??? -? ????^{b}{\textrm{T}_g}^{(1)}\0.2em}になります。^{g}\\{T}_c &= ??? -? ????^{g}\textrm{T}_c \hspace{0.2em}^{c}{\\{T}_t}^{(2)} (^{c}{\\\{T}_t}^{(1)})^{-1} \\{A}_i ?? &= ???????????????????????????????????????????????????????\]





for an eye-to-hand configuration

\♪♪〜^{g}{\textrm{T}_b}^{(1)}\0.2em}になります。^{b}\textrm{T}_c \hspace{0.2em}^{c}{\\{T}_t}^{(1)} &= ??? -? ????^{g}{\textrm{T}_b}^{(2)}\0.2em}になります。^{b}\textrm{T}_c \hspace{0.2em}^{c}{\textrm{T}_t}^{(2)}(^{g}{\\{T}_b}^{(2)})^{-1} ??? -? ????^{g}{\textrm{T}_b}^{(1)}\0.2em}になります。^{b}\\{T}_c &= \\\{T}_c^{b}\textrm{T}_c \hspace{0.2em}^{c}{\\{T}_t}^{(2)} (^{c}{\\\{T}_t}^{(1)})^{-1} ????? )\NoteAdditional information are found on this website.



手目線の変換を判定するためには、回転軸が平行でないモーションが最低2つ必要です。そのため、最低でも3種類のポーズが必要ですが、それ以上のポーズを使用することを強く推奨します。

元関数名(C#): calib3d_calibrateHandEye
元DLLエクスポート名: calib3d_calibrateHandEye
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_calibrateHandEye(
    cv::Mat **R_gripper2baseMats, const int32_t R_gripper2baseMatsSize,
    cv::Mat **t_gripper2baseMats, const int32_t t_gripper2baseMatsSize,
    cv::Mat **R_target2camMats, const int32_t R_target2camMatsSize,
    cv::Mat **t_target2camMats, const int32_t t_target2camMatsSize,
    cv::_OutputArray *R_cam2gripper, 
    cv::_OutputArray *t_cam2gripper,
    int32_t method)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; R_gripper2base;
    std::vector&amp;lt;cv::Mat&amp;gt; t_gripper2base;
    std::vector&amp;lt;cv::Mat&amp;gt; R_target2cam;
    std::vector&amp;lt;cv::Mat&amp;gt; t_target2cam;
    toVec(R_gripper2baseMats, R_gripper2baseMatsSize, R_gripper2base);
    toVec(t_gripper2baseMats, t_gripper2baseMatsSize, t_gripper2base);
    toVec(R_target2camMats, R_target2camMatsSize, R_target2cam);
    toVec(t_target2camMats, t_target2camMatsSize, t_target2cam);
    cv::calibrateHandEye(
        R_gripper2base, t_gripper2base, 
        R_target2cam, t_target2cam, 
        *R_cam2gripper, *t_cam2gripper,
        static_cast&amp;lt;cv::HandEyeCalibrationMethod&amp;gt;(method));
    END_WRAP    
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_calibrateRobotWorldHandEye_OutputArray
[32/64bit] Robot-World/Hand-Eye Calibrationを計算します。\(_{}^{w}\textrm{T}_b\), \(_{}^{c}\textrm{T}_g\)
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13
p1 = sptr : IntPtr[] R_world2camMats
p2 = int : int R_world2camMatsSize
p3 = sptr : IntPtr[] t_world2camMats
p4 = int : int t_world2camMatsSize
p5 = sptr : IntPtr[] R_base2gripperMats
p6 = int : int R_base2gripperMatsSize
p7 = sptr : IntPtr[] t_base2gripperMats
p8 = int : int t_base2gripperMatsSize
p9 = sptr : IntPtr R_base2world
p10 = sptr : IntPtr t_base2world
p11 = sptr : IntPtr R_gripper2cam
p12 = sptr : IntPtr t_gripper2cam
p13 = int : int method
%inst
この関数は，様々な方法を用いて，Robot-World/Hand-Eyeのキャリブレーションを行います．一つの方法は，回転と平行移動を推定することです（分離可能な解）：M.Shah, Solving the robot-world/hand-eye calibration problem using the kronecker product [221]もう1つの方法は，回転と平行移動を同時に推定する方法（同時解法）で，次のように実装されています：A. Li, L. Wang, and D. Wu, Simultaneous robot-world/Hand-Eye calibration problem using the kronecker product [221].A. Li, L. Wang, and D. Wu, Simultaneous robot-world and hand-eye calibration using dual-quaternions and kronecker product [143]次の図は、ロボットとワールドフレームの間の変換、およびロボットグリッパー（「ハンド」）とロボットエンドエフェクタに取り付けられたカメラ（「アイ」）の間の変換を推定しなければならない、ロボット-ワールド/ハンド-アイのキャリブレーション問題を説明しています。

ロボットのグリッパーを動かして，複数のポーズを取得する

各ポーズについて、グリッパーフレームとロボットベースフレームの間の同次変換が、例えばロボットキネマティクスを用いて記録されます。

\キャリブレーションの手順は以下の通りです。X_g\ Y_g\ Z_g\ 1 end{bmatrix} = ????? )_{}^{g}\\{R}/b & _{}^{g}\\{t}/b\\\\♪♪♪♪♪♪♪♪♪〜\]





各ポーズについて、キャリブレーション対象フレーム（ワールドフレーム）とカメラフレームの間の同次変換を、例えば、2D-3D点対応からのポーズ推定法（PnP）を用いて記録する。

\????? )X_c\ Y_citness Z_citness 1 ??? -? ??? = ??? -? ??? )_{}^{c}\\{R}_w & _{}^{c}\\{t}_w\\\\X w\\ Y wadows\Robot-World/Hand-Eyeキャリブレーション手順では、以下のような同次変換が行われます。X_w\ Y_w\ Z_w\ 1 end{bmatrix} = ????? )♪♪♪♪♪〜\\\\♪♪♪♪♪♪♪♪♪〜\♪♪♪♪♪〜♪♪♪♪♪♪♪〜_{}^{c}\\{R}_g & _{}^{c}\{t}_g\\\\X'g\ Y'g\ Z'g\\ 1 end{bmatrix}.この問題は別名、\\\\\\\\\\\\\\\\\\\\\とも呼ばれます。

\♪♪♪♪♪♪♪〜

\♪♪〜

\Note最低でも3つの測定値が必要です（入力ベクトルのサイズは3以上です）。

元関数名(C#): calib3d_calibrateRobotWorldHandEye_OutputArray
元DLLエクスポート名: calib3d_calibrateRobotWorldHandEye_OutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_calibrateRobotWorldHandEye_OutputArray(
    cv::Mat** R_world2camMats, int32_t R_world2camMatsSize,
    cv::Mat** t_world2camMats, int32_t t_world2camMatsSize,
    cv::Mat** R_base2gripperMats, int32_t R_base2gripperMatsSize,
    cv::Mat** t_base2gripperMats, int32_t t_base2gripperMatsSize,
    cv::_OutputArray* R_base2world, cv::_OutputArray* t_base2world,
    cv::_OutputArray* R_gripper2cam, cv::_OutputArray* t_gripper2cam,
    int32_t method)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; R_gripper2base;
    std::vector&amp;lt;cv::Mat&amp;gt; t_gripper2base;
    std::vector&amp;lt;cv::Mat&amp;gt; R_target2cam;
    std::vector&amp;lt;cv::Mat&amp;gt; t_target2cam;
    toVec(R_world2camMats, R_world2camMatsSize, R_gripper2base);
    toVec(t_world2camMats, t_world2camMatsSize, t_gripper2base);
    toVec(R_base2gripperMats, R_base2gripperMatsSize, R_target2cam);
    toVec(t_base2gripperMats, t_base2gripperMatsSize, t_target2cam);
    cv::calibrateRobotWorldHandEye(
        R_gripper2base, t_gripper2base,
        R_target2cam, t_target2cam,
        *R_base2world, *t_base2world,
        *R_gripper2cam, *t_gripper2cam,
        static_cast&amp;lt;cv::RobotWorldHandEyeCalibrationMethod&amp;gt;(method));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_calibrateRobotWorldHandEye_Pointer
[32/64bit] Robot-World/Hand-Eye Calibrationを計算します。\(_{}^{w}\textrm{T}_b\), \(_{}^{c}\textrm{T}_g\)
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13
p1 = sptr : IntPtr[] R_world2camMats
p2 = int : int R_world2camMatsSize
p3 = sptr : IntPtr[] t_world2camMats
p4 = int : int t_world2camMatsSize
p5 = sptr : IntPtr[] R_base2gripperMats
p6 = int : int R_base2gripperMatsSize
p7 = sptr : IntPtr[] t_base2gripperMats
p8 = int : int t_base2gripperMatsSize
p9 = var : [MarshalAs(UnmanagedType.LPArray), Out] double[,] R_base2world
p10 = var : [MarshalAs(UnmanagedType.LPArray), Out] double[] t_base2world
p11 = var : [MarshalAs(UnmanagedType.LPArray), Out] double[,] R_gripper2cam
p12 = var : [MarshalAs(UnmanagedType.LPArray), Out] double[] t_gripper2cam
p13 = int : int method
%inst
この関数は，様々な方法を用いて，Robot-World/Hand-Eyeのキャリブレーションを行います．一つの方法は，回転と平行移動を推定することです（分離可能な解）：M.Shah, Solving the robot-world/hand-eye calibration problem using the kronecker product [221]もう1つの方法は，回転と平行移動を同時に推定する方法（同時解法）で，次のように実装されています：A. Li, L. Wang, and D. Wu, Simultaneous robot-world/Hand-Eye calibration problem using the kronecker product [221].A. Li, L. Wang, and D. Wu, Simultaneous robot-world and hand-eye calibration using dual-quaternions and kronecker product [143]次の図は、ロボットとワールドフレームの間の変換、およびロボットグリッパー（「ハンド」）とロボットエンドエフェクタに取り付けられたカメラ（「アイ」）の間の変換を推定しなければならない、ロボット-ワールド/ハンド-アイのキャリブレーション問題を説明しています。

ロボットのグリッパーを動かして，複数のポーズを取得する

各ポーズについて、グリッパーフレームとロボットベースフレームの間の同次変換が、例えばロボットキネマティクスを用いて記録されます。

\キャリブレーションの手順は以下の通りです。X_g\ Y_g\ Z_g\ 1 end{bmatrix} = ????? )_{}^{g}\\{R}/b & _{}^{g}\\{t}/b\\\\♪♪♪♪♪♪♪♪♪〜\]





各ポーズについて、キャリブレーション対象フレーム（ワールドフレーム）とカメラフレームの間の同次変換を、例えば、2D-3D点対応からのポーズ推定法（PnP）を用いて記録する。

\????? )X_c\ Y_citness Z_citness 1 ??? -? ??? = ??? -? ??? )_{}^{c}\\{R}_w & _{}^{c}\\{t}_w\\\\X w\\ Y wadows\Robot-World/Hand-Eyeキャリブレーション手順では、以下のような同次変換が行われます。X_w\ Y_w\ Z_w\ 1 end{bmatrix} = ????? )♪♪♪♪♪〜\\\\♪♪♪♪♪♪♪♪♪〜\♪♪♪♪♪〜♪♪♪♪♪♪♪〜_{}^{c}\\{R}_g & _{}^{c}\{t}_g\\\\X'g\ Y'g\ Z'g\\ 1 end{bmatrix}.この問題は別名、\\\\\\\\\\\\\\\\\\\\\とも呼ばれます。

\♪♪♪♪♪♪♪〜

\♪♪〜

\Note最低でも3つの測定値が必要です（入力ベクトルのサイズは3以上です）。

元関数名(C#): calib3d_calibrateRobotWorldHandEye_Pointer
元DLLエクスポート名: calib3d_calibrateRobotWorldHandEye_Pointer
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_calibrateRobotWorldHandEye_Pointer(
    cv::Mat** R_world2camMats, int32_t R_world2camMatsSize,
    cv::Mat** t_world2camMats, int32_t t_world2camMatsSize,
    cv::Mat** R_base2gripperMats, int32_t R_base2gripperMatsSize,
    cv::Mat** t_base2gripperMats, int32_t t_base2gripperMatsSize,
    double* R_base2world, double* t_base2world,
    double* R_gripper2cam, double* t_gripper2cam,
    int32_t method)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; R_gripper2base;
    std::vector&amp;lt;cv::Mat&amp;gt; t_gripper2base;
    std::vector&amp;lt;cv::Mat&amp;gt; R_target2cam;
    std::vector&amp;lt;cv::Mat&amp;gt; t_target2cam;
    toVec(R_world2camMats, R_world2camMatsSize, R_gripper2base);
    toVec(t_world2camMats, t_world2camMatsSize, t_gripper2base);
    toVec(R_base2gripperMats, R_base2gripperMatsSize, R_target2cam);
    toVec(t_base2gripperMats, t_base2gripperMatsSize, t_target2cam);
    cv::Matx33d R_base2worldM;
    cv::Matx31d t_base2worldM;
    cv::Matx33d R_gripper2camM;
    cv::Matx31d t_gripper2camM;
    cv::calibrateRobotWorldHandEye(
        R_gripper2base, t_gripper2base,
        R_target2cam, t_target2cam,
        R_base2worldM, t_base2worldM,
        R_gripper2camM, t_gripper2camM,
        static_cast&amp;lt;cv::RobotWorldHandEyeCalibrationMethod&amp;gt;(method));

    std::memcpy(R_base2world, R_base2worldM.val, 9 * sizeof(double));
    std::memcpy(t_base2world, t_base2worldM.val, 3 * sizeof(double));
    std::memcpy(R_gripper2cam, R_gripper2camM.val, 9 * sizeof(double));
    std::memcpy(t_gripper2cam, t_gripper2camM.val, 3 * sizeof(double));

    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_convertPointsToHomogeneous_InputArray
[32/64bit] 点をユークリッド空間から同次元空間に変換します。
%prm
p1,p2
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
%inst
この関数は，点の座標のタプルに1を追加することで，点をユークリッド空間から同次空間に変換します．つまり、各点(x1, x2, ..., xn)は(x1, x2, ..., xn, 1)に変換されます。

元関数名(C#): calib3d_convertPointsToHomogeneous_InputArray
元DLLエクスポート名: calib3d_convertPointsToHomogeneous_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_convertPointsToHomogeneous_InputArray(cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::convertPointsToHomogeneous(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_convertPointsToHomogeneous_array1
[32/64bit] 点を同次空間からユークリッド空間に変換します。
%prm
p1,p2,p3
p1 = var : [In] Vec2f[] src
p2 = var : [In, Out] Vec3f[] dst
p3 = int : int length
%inst
この関数は、透視投影を用いて、同次元点をユークリッド空間に変換します。つまり、各点(x1, x2, ... x(n-1), xn)は、(x1/xn, x2/xn, ..., x(n-1)/xn)に変換されます。xn=0の場合、出力される点座標は(0,0,0,...)となります。

元関数名(C#): calib3d_convertPointsToHomogeneous_array1
元DLLエクスポート名: calib3d_convertPointsToHomogeneous_array1
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_convertPointsToHomogeneous_array1(cv::Vec2f *src, cv::Vec3f *dst, int length)
{
    BEGIN_WRAP
    const cv::Mat srcMat(length, 1, CV_64FC2, src);
    cv::Mat dstMat(length, 1, CV_64FC3, dst);
    cv::convertPointsFromHomogeneous(srcMat, dstMat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_convertPointsToHomogeneous_array2
[32/64bit] 点を同次空間からユークリッド空間に変換します。
%prm
p1,p2,p3
p1 = var : [In] Vec3f[] src
p2 = var : [In, Out] Vec4f[] dst
p3 = int : int length
%inst
この関数は、透視投影を用いて、同次元点をユークリッド空間に変換します。つまり、各点(x1, x2, ... x(n-1), xn)は、(x1/xn, x2/xn, ..., x(n-1)/xn)に変換されます。xn=0の場合、出力される点座標は(0,0,0,...)となります。

元関数名(C#): calib3d_convertPointsToHomogeneous_array2
元DLLエクスポート名: calib3d_convertPointsToHomogeneous_array2
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_convertPointsToHomogeneous_array2(cv::Vec3f *src, cv::Vec4f *dst, int length)
{
    BEGIN_WRAP
    const cv::Mat srcMat(length, 1, CV_64FC3, src);
    cv::Mat dstMat(length, 1, CV_64FC4, dst);
    cv::convertPointsFromHomogeneous(srcMat, dstMat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_convertPointsFromHomogeneous_InputArray
[32/64bit] 点を同次空間からユークリッド空間に変換します。
%prm
p1,p2
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
%inst
この関数は、透視投影を用いて、同次元点をユークリッド空間に変換します。つまり、各点(x1, x2, ... x(n-1), xn)は、(x1/xn, x2/xn, ..., x(n-1)/xn)に変換されます。xn=0の場合、出力される点座標は(0,0,0,...)となります。

元関数名(C#): calib3d_convertPointsFromHomogeneous_InputArray
元DLLエクスポート名: calib3d_convertPointsFromHomogeneous_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_convertPointsFromHomogeneous_InputArray(cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::convertPointsFromHomogeneous(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_convertPointsFromHomogeneous_array1
[32/64bit] 点を同次空間からユークリッド空間に変換します。
%prm
p1,p2,p3
p1 = var : [In] Vec3f[] src
p2 = var : [In, Out] Vec2f[] dst
p3 = int : int length
%inst
この関数は、透視投影を用いて、同次元点をユークリッド空間に変換します。つまり、各点(x1, x2, ... x(n-1), xn)は、(x1/xn, x2/xn, ..., x(n-1)/xn)に変換されます。xn=0の場合、出力される点座標は(0,0,0,...)となります。

元関数名(C#): calib3d_convertPointsFromHomogeneous_array1
元DLLエクスポート名: calib3d_convertPointsFromHomogeneous_array1
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_convertPointsFromHomogeneous_array1(cv::Vec3f *src, cv::Vec2f *dst, int length)
{
    BEGIN_WRAP
    const cv::Mat srcMat(length, 1, CV_64FC3, src);
    cv::Mat dstMat(length, 1, CV_64FC2, dst);
    cv::convertPointsFromHomogeneous(srcMat, dstMat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_convertPointsFromHomogeneous_array2
[32/64bit] 点を同次空間からユークリッド空間に変換します。
%prm
p1,p2,p3
p1 = var : [In] Vec4f[] src
p2 = var : [In, Out] Vec3f[] dst
p3 = int : int length
%inst
この関数は、透視投影を用いて、同次元点をユークリッド空間に変換します。つまり、各点(x1, x2, ... x(n-1), xn)は、(x1/xn, x2/xn, ..., x(n-1)/xn)に変換されます。xn=0の場合、出力される点座標は(0,0,0,...)となります。

元関数名(C#): calib3d_convertPointsFromHomogeneous_array2
元DLLエクスポート名: calib3d_convertPointsFromHomogeneous_array2
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_convertPointsFromHomogeneous_array2(cv::Vec4f *src, cv::Vec3f *dst, int length)
{
    BEGIN_WRAP
    const cv::Mat srcMat(length, 1, CV_64FC4, src);
    cv::Mat dstMat(length, 1, CV_64FC3, dst);
    cv::convertPointsFromHomogeneous(srcMat, dstMat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_convertPointsHomogeneous
[32/64bit] 点を同次座標に，または同次座標から変換します．
%prm
p1,p2
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
%inst
この関数は， convertPointsToHomogeneous または convertPointsFromHomogeneous を呼び出すことで，2次元または3次元の点を同次座標に変換します．代わりに，前の2つの関数のいずれかを使ってください．

元関数名(C#): calib3d_convertPointsHomogeneous
元DLLエクスポート名: calib3d_convertPointsHomogeneous
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_convertPointsHomogeneous(cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::convertPointsHomogeneous(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_findFundamentalMat_InputArray
[32/64bit] 2つの画像中の対応する点から，基本行列を求めます．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr points1
p2 = sptr : IntPtr points2
p3 = int : int method
p4 = double : double param1
p5 = double : double param2
p6 = sptr : IntPtr mask
p7 = var : out IntPtr returnValue
%inst
この関数は，上述した4つの手法のうちの1つを用いて基本行列を計算し，その結果を返します．通常は，1つの行列だけが求められます．計算された基本行列は，指定された点に対応するエピポーラ線を求める computeCorrespondEpilines に渡すことができます．また，stereoRectifyUncalibrated に渡して，平行化変換を計算することもできます． :// 例．RANSAC アルゴリズムを用いた基本行列の推定int point_count = 100;vector<Point2f> points1(point_count);vector<Point2f> points2(point_count);// ここでポイントを初期化します ....for( int i = 0; i < point_count; i++ ){ points1[i] = ...; points2[i] = ...;}Mat fundamental_matrix = findFundamentalMat(points1, points2, FM_RANSAC, 3, 0.99);fragment

元関数名(C#): calib3d_findFundamentalMat_InputArray
元DLLエクスポート名: calib3d_findFundamentalMat_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_findFundamentalMat_InputArray(
    cv::_InputArray *points1, cv::_InputArray *points2,
    int method, double param1, double param2,
    cv::_OutputArray *mask,
    cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto mat = cv::findFundamentalMat(
        *points1, *points2, method, param1, param2, entity(mask));
    *returnValue = new cv::Mat(mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_findFundamentalMat_arrayF64
[32/64bit] 2つの画像中の対応する点から，基本行列を求めます．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = var : Point2d[] points1
p2 = int : int points1Size
p3 = var : Point2d[] points2
p4 = int : int points2Size
p5 = int : int method
p6 = double : double param1
p7 = double : double param2
p8 = sptr : IntPtr mask
p9 = var : out IntPtr returnValue
%inst
この関数は，上述した4つの手法のうちの1つを用いて基本行列を計算し，その結果を返します．通常は，1つの行列だけが求められます．計算された基本行列は，指定された点に対応するエピポーラ線を求める computeCorrespondEpilines に渡すことができます．また，stereoRectifyUncalibrated に渡して，平行化変換を計算することもできます． :// 例．RANSAC アルゴリズムを用いた基本行列の推定int point_count = 100;vector<Point2f> points1(point_count);vector<Point2f> points2(point_count);// ここでポイントを初期化します ....for( int i = 0; i < point_count; i++ ){ points1[i] = ...; points2[i] = ...;}Mat fundamental_matrix = findFundamentalMat(points1, points2, FM_RANSAC, 3, 0.99);fragment

元関数名(C#): calib3d_findFundamentalMat_arrayF64
元DLLエクスポート名: calib3d_findFundamentalMat_arrayF64
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_findFundamentalMat_arrayF64(
    cv::Point2d *points1, int points1Size,
    cv::Point2d *points2, int points2Size,
    int method, double param1, double param2,
    cv::_OutputArray *mask,
    cv::Mat **returnValue)
{
    BEGIN_WRAP
    const cv::Mat points1M(points1Size, 1, CV_64FC2, points1);
    const cv::Mat points2M(points2Size, 1, CV_64FC2, points2);
    const auto mat = cv::findFundamentalMat(
        points1M, points2M, method, param1, param2, entity(mask));
    *returnValue = new cv::Mat(mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_findFundamentalMat_arrayF32
[32/64bit] 2つの画像中の対応する点から，基本行列を求めます．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = var : Point2f[] points1
p2 = int : int points1Size
p3 = var : Point2f[] points2
p4 = int : int points2Size
p5 = int : int method
p6 = double : double param1
p7 = double : double param2
p8 = sptr : IntPtr mask
p9 = var : out IntPtr returnValue
%inst
この関数は，上述した4つの手法のうちの1つを用いて基本行列を計算し，その結果を返します．通常は，1つの行列だけが求められます．計算された基本行列は，指定された点に対応するエピポーラ線を求める computeCorrespondEpilines に渡すことができます．また，stereoRectifyUncalibrated に渡して，平行化変換を計算することもできます． :// 例．RANSAC アルゴリズムを用いた基本行列の推定int point_count = 100;vector<Point2f> points1(point_count);vector<Point2f> points2(point_count);// ここでポイントを初期化します ....for( int i = 0; i < point_count; i++ ){ points1[i] = ...; points2[i] = ...;}Mat fundamental_matrix = findFundamentalMat(points1, points2, FM_RANSAC, 3, 0.99);fragment

元関数名(C#): calib3d_findFundamentalMat_arrayF32
元DLLエクスポート名: calib3d_findFundamentalMat_arrayF32
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_findFundamentalMat_arrayF32(
    cv::Point2f *points1, int points1Size,
    cv::Point2f *points2, int points2Size,
    int method, double param1, double param2,
    cv::_OutputArray *mask,
    cv::Mat **returnValue)
{
    BEGIN_WRAP
    const cv::Mat points1M(points1Size, 1, CV_32FC2, points1);
    const cv::Mat points2M(points2Size, 1, CV_32FC2, points2);
    const auto mat = cv::findFundamentalMat(
        points1M, points2M, method, param1, param2, entity(mask));
    *returnValue = new cv::Mat(mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_computeCorrespondEpilines_InputArray
[32/64bit] ステレオペアの画像中の点に対して，もう片方の画像中の対応するエピラインを計算します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr points
p2 = int : int whichImage
p3 = sptr : IntPtr F
p4 = sptr : IntPtr lines
%inst
この関数は，ステレオペアの2つの画像のうち，片方の画像内の各点に対して，もう片方の画像内の対応するエピポーラ線の方程式を求めます．基本行列の定義（ findFundamentalMat 参照）から，1枚目の画像中の点\(p^{(1)}_i\)に対する2枚目の画像中の線\(l^{(2)}_i\)は，次のように計算されます（whichImage=1 の場合）．\また、whichImage=2の場合、\(p^{(2)}_i\)から、\(l^{(1)}_i\)が計算されます：\[l^{(1)}_i = F^T p^{(2)}_i\]線の係数は、ある尺度まで定義されます。a_i^2+b_i^2=1\）となるように規格化されています。

元関数名(C#): calib3d_computeCorrespondEpilines_InputArray
元DLLエクスポート名: calib3d_computeCorrespondEpilines_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_computeCorrespondEpilines_InputArray(
    cv::_InputArray *points,
    int whichImage, cv::_InputArray *F,
    cv::_OutputArray *lines)
{
    BEGIN_WRAP
    cv::computeCorrespondEpilines(*points, whichImage, *F, *lines);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_computeCorrespondEpilines_array2d
[32/64bit] ステレオペアの画像中の点に対して，もう片方の画像中の対応するエピラインを計算します．
%prm
p1,p2,p3,p4,p5
p1 = var : [In] Point2d[] points
p2 = int : int pointsSize
p3 = int : int whichImage
p4 = var : double* F
p5 = var : [In, Out] Point3f[] lines
%inst
この関数は，ステレオペアの2つの画像のうち，片方の画像内の各点に対して，もう片方の画像内の対応するエピポーラ線の方程式を求めます．基本行列の定義（ findFundamentalMat 参照）から，1枚目の画像中の点\(p^{(1)}_i\)に対する2枚目の画像中の線\(l^{(2)}_i\)は，次のように計算されます（whichImage=1 の場合）．\また、whichImage=2の場合、\(p^{(2)}_i\)から、\(l^{(1)}_i\)が計算されます：\[l^{(1)}_i = F^T p^{(2)}_i\]線の係数は、ある尺度まで定義されます。a_i^2+b_i^2=1\）となるように規格化されています。

元関数名(C#): calib3d_computeCorrespondEpilines_array2d
元DLLエクスポート名: calib3d_computeCorrespondEpilines_array2d
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_computeCorrespondEpilines_array2d(
    cv::Point2d *points, int pointsSize,
    int whichImage, double *F,
    cv::Point3f *lines)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point2d&amp;gt; pointsM(pointsSize, 1, points);
    const cv::Mat_&amp;lt;double&amp;gt; FM(3, 3, F);
    cv::Mat_&amp;lt;cv::Point3f&amp;gt; linesM(pointsSize, 1, lines);
    cv::computeCorrespondEpilines(pointsM, whichImage, FM, linesM);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_computeCorrespondEpilines_array3d
[32/64bit] ステレオペアの画像中の点に対して，もう片方の画像中の対応するエピラインを計算します．
%prm
p1,p2,p3,p4,p5
p1 = var : [In] Point3d[] points
p2 = int : int pointsSize
p3 = int : int whichImage
p4 = var : double* F
p5 = var : [In, Out] Point3f[] lines
%inst
この関数は，ステレオペアの2つの画像のうち，片方の画像内の各点に対して，もう片方の画像内の対応するエピポーラ線の方程式を求めます．基本行列の定義（ findFundamentalMat 参照）から，1枚目の画像中の点\(p^{(1)}_i\)に対する2枚目の画像中の線\(l^{(2)}_i\)は，次のように計算されます（whichImage=1 の場合）．\また、whichImage=2の場合、\(p^{(2)}_i\)から、\(l^{(1)}_i\)が計算されます：\[l^{(1)}_i = F^T p^{(2)}_i\]線の係数は、ある尺度まで定義されます。a_i^2+b_i^2=1\）となるように規格化されています。

元関数名(C#): calib3d_computeCorrespondEpilines_array3d
元DLLエクスポート名: calib3d_computeCorrespondEpilines_array3d
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_computeCorrespondEpilines_array3d(
    cv::Point3d *points, int pointsSize,
    int whichImage, double *F,
    cv::Point3f *lines)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point3d&amp;gt; pointsM(pointsSize, 1, points);
    const cv::Mat_&amp;lt;double&amp;gt; FM(3, 3, F);
    cv::Mat_&amp;lt;cv::Point3f&amp;gt; linesM(pointsSize, 1, lines);
    cv::computeCorrespondEpilines(pointsM, whichImage, FM, linesM);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_triangulatePoints_InputArray
[32/64bit] この関数は，ステレオカメラによる観測結果を用いて，3次元の点（同次座標）を再構成します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr projMatr1
p2 = sptr : IntPtr projMatr2
p3 = sptr : IntPtr projPoints1
p4 = sptr : IntPtr projPoints2
p5 = sptr : IntPtr points4D
%inst
注意この関数が動作するためには，すべての入力データが float 型でなければならないことに注意してください．



stereoRectifyからの投影行列が使われた場合，返される点は，最初のカメラの平行化された座標系で表されます． 参照：soreprojectImageTo3D

元関数名(C#): calib3d_triangulatePoints_InputArray
元DLLエクスポート名: calib3d_triangulatePoints_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_triangulatePoints_InputArray(
    cv::_InputArray *projMatr1, cv::_InputArray *projMatr2,
    cv::_InputArray *projPoints1, cv::_InputArray *projPoints2,
    cv::_OutputArray *points4D)
{
    BEGIN_WRAP
    cv::triangulatePoints(*projMatr1, *projMatr2, *projPoints1, *projPoints2, *points4D);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_triangulatePoints_array
[32/64bit] この関数は，ステレオカメラによる観測結果を用いて，3次元の点（同次座標）を再構成します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = var : double* projMatr1
p2 = var : double* projMatr2
p3 = var : [In] Point2d[] projPoints1
p4 = int : int projPoints1Size
p5 = var : [In] Point2d[] projPoints2
p6 = int : int projPoints2Size
p7 = var : [In, Out] Vec4d[] points4D
%inst
注意この関数が動作するためには，すべての入力データが float 型でなければならないことに注意してください．



stereoRectifyからの投影行列が使われた場合，返される点は，最初のカメラの平行化された座標系で表されます． 参照：soreprojectImageTo3D

元関数名(C#): calib3d_triangulatePoints_array
元DLLエクスポート名: calib3d_triangulatePoints_array
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_triangulatePoints_array(
    double *projMatr1, double *projMatr2,
    cv::Point2d *projPoints1, int projPoints1Size,
    cv::Point2d *projPoints2, int projPoints2Size,
    cv::Vec4d *points4D)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;double&amp;gt; projMatr1M(3, 4, projMatr1);
    const cv::Mat_&amp;lt;double&amp;gt; projMatr2M(3, 4, projMatr2);
    const cv::Mat_&amp;lt;cv::Point2d&amp;gt; projPoints1M(projPoints1Size, 1, projPoints1);
    const cv::Mat_&amp;lt;cv::Point2d&amp;gt; projPoints2M(projPoints2Size, 1, projPoints2);
    cv::Mat_&amp;lt;cv::Vec4d&amp;gt; points4DM(1, projPoints1Size, points4D);
    cv::triangulatePoints(projMatr1M, projMatr2M,
        projPoints1M, projPoints2M, points4DM);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_correctMatches_InputArray
[32/64bit] 対応する点の座標を修正します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr F
p2 = sptr : IntPtr points1
p3 = sptr : IntPtr points2
p4 = sptr : IntPtr newPoints1
p5 = sptr : IntPtr newPoints2
%inst
この関数は，Optimal Triangulation Method を実装しています（詳細は，「多視点幾何学」を参照してください）．この関数は，与えられた各点の対応点 points1[i] <-> points2[i]，および基本行列 F に対して，幾何学的誤差 ????? (d(points1[i],d(points1[i], newPoints1[i])^2 + d(points2[i],newPoints2[i])^2\) (ここで、\(d(a,b)\)は、点\(a)と点\(b)の間の幾何学的距離です)。

元関数名(C#): calib3d_correctMatches_InputArray
元DLLエクスポート名: calib3d_correctMatches_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_correctMatches_InputArray(
    cv::_InputArray *F, cv::_InputArray *points1, cv::_InputArray *points2,
    cv::_OutputArray *newPoints1, cv::_OutputArray *newPoints2)
{
    BEGIN_WRAP
    cv::correctMatches(*F, *points1, *points2, *newPoints1, *newPoints2);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_correctMatches_array
[32/64bit] 対応する点の座標を修正します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = var : double* F
p2 = var : Point2d[] points1
p3 = int : int points1Size
p4 = var : Point2d[] points2
p5 = int : int points2Size
p6 = var : Point2d[] newPoints1
p7 = var : Point2d[] newPoints2
%inst
この関数は，Optimal Triangulation Method を実装しています（詳細は，「多視点幾何学」を参照してください）．この関数は，与えられた各点の対応点 points1[i] <-> points2[i]，および基本行列 F に対して，幾何学的誤差 ????? (d(points1[i],d(points1[i], newPoints1[i])^2 + d(points2[i],newPoints2[i])^2\) (ここで、\(d(a,b)\)は、点\(a)と点\(b)の間の幾何学的距離です)。

元関数名(C#): calib3d_correctMatches_array
元DLLエクスポート名: calib3d_correctMatches_array
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_correctMatches_array(
    double *F,
    cv::Point2d *points1, int points1Size,
    cv::Point2d *points2, int points2Size,
    cv::Point2d *newPoints1, cv::Point2d *newPoints2)
{
    BEGIN_WRAP
    cv::Mat_&amp;lt;double&amp;gt; FM(3, 3, F);
    cv::Mat_&amp;lt;cv::Point2d&amp;gt; points1M(points1Size, 1, points1);
    cv::Mat_&amp;lt;cv::Point2d&amp;gt; points2M(points2Size, 1, points2);
    cv::Mat_&amp;lt;double&amp;gt; points1MM = points1M.reshape(2);
    cv::Mat_&amp;lt;double&amp;gt; points2MM = points2M.reshape(2);
    cv::Mat_&amp;lt;cv::Point2d&amp;gt; newPoints1M(points1Size, 1, newPoints1);
    cv::Mat_&amp;lt;cv::Point2d&amp;gt; newPoints2M(points2Size, 1, newPoints2);
    cv::Mat_&amp;lt;double&amp;gt; newPoints1MM = points1M.reshape(2);
    cv::Mat_&amp;lt;double&amp;gt; newPoints2MM = points2M.reshape(2);
    cv::correctMatches(FM, points1MM, points2MM, newPoints1MM, newPoints2MM);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_filterSpeckles
[32/64bit] 視差マップに含まれる小さなノイズの塊（スペックル）を除去します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr img
p2 = double : double newVal
p3 = int : int maxSpeckleSize
p4 = double : double maxDiff
p5 = sptr : IntPtr buf
%inst
元関数名(C#): calib3d_filterSpeckles
元DLLエクスポート名: calib3d_filterSpeckles
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_filterSpeckles(
    cv::_InputOutputArray *img, double newVal, int maxSpeckleSize, double maxDiff, cv::_InputOutputArray *buf)
{
    BEGIN_WRAP
    cv::filterSpeckles(*img, newVal, maxSpeckleSize, maxDiff, entity(buf));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_getValidDisparityROI
[32bit] stereoRectify によって返される）平行化された画像の有効な ROI から，有効な視差の ROI を計算します．
%prm
p1,p2,p3,p4,p5,p6
p1 = ARGS_RECT : Rect roi1
p2 = ARGS_RECT : Rect roi2
p3 = int : int minDisparity
p4 = int : int numberOfDisparities
p5 = int : int SADWindowSize
p6 = var : out Rect returnValue
%inst
元関数名(C#): calib3d_getValidDisparityROI
元DLLエクスポート名: calib3d_getValidDisparityROI
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_getValidDisparityROI(
    MyCvRect roi1, MyCvRect roi2,
    int minDisparity, int numberOfDisparities, int SADWindowSize,
    MyCvRect *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(cv::getValidDisparityROI(
        cpp(roi1), cpp(roi2), minDisparity, numberOfDisparities, SADWindowSize));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_getValidDisparityROI
[64bit] stereoRectify によって返される）平行化された画像の有効な ROI から，有効な視差の ROI を計算します．
%prm
p1,p2,p3,p4,p5,p6
p1 = var : Rect roi1
p2 = var : Rect roi2
p3 = int : int minDisparity
p4 = int : int numberOfDisparities
p5 = int : int SADWindowSize
p6 = var : out Rect returnValue
%inst
元関数名(C#): calib3d_getValidDisparityROI
元DLLエクスポート名: calib3d_getValidDisparityROI
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_getValidDisparityROI(
    MyCvRect roi1, MyCvRect roi2,
    int minDisparity, int numberOfDisparities, int SADWindowSize,
    MyCvRect *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(cv::getValidDisparityROI(
        cpp(roi1), cpp(roi2), minDisparity, numberOfDisparities, SADWindowSize));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_validateDisparity
[32/64bit] 左右のチェックを利用して，視差を検証します．行列の「コスト」は，ステレオ対応点探索アルゴリズムによって計算されます．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr disparity
p2 = sptr : IntPtr cost
p3 = int : int minDisparity
p4 = int : int numberOfDisparities
p5 = int : int disp12MaxDisp
%inst
元関数名(C#): calib3d_validateDisparity
元DLLエクスポート名: calib3d_validateDisparity
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_validateDisparity(
    cv::_InputOutputArray *disparity, cv::_InputArray *cost,
    int minDisparity, int numberOfDisparities, int disp12MaxDisp)
{
    BEGIN_WRAP
    cv::validateDisparity(*disparity, *cost, minDisparity, numberOfDisparities, disp12MaxDisp);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_reprojectImageTo3D
[32/64bit] 視差画像を，3次元空間に再投影します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr disparity
p2 = sptr : IntPtr _3dImage
p3 = sptr : IntPtr Q
p4 = int : int handleMissingValues
p5 = int : int ddepth
%inst
この関数は，シングルチャンネルの視差マップを，3次元表面を表す3チャンネルの画像に変換します．つまり，各ピクセル（x,y）と，それに対応する視差 d=disparity(x,y) に対して，次のように計算します：[??? -? ???][????][??? -? ???].Disparity d=disparity(x,y)を計算します。(x,y) \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\??????。

元関数名(C#): calib3d_reprojectImageTo3D
元DLLエクスポート名: calib3d_reprojectImageTo3D
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_reprojectImageTo3D(
    cv::_InputArray *disparity, cv::_OutputArray *_3dImage,
    cv::_InputArray *Q, int handleMissingValues, int ddepth)
{
    BEGIN_WRAP
    cv::reprojectImageTo3D(*disparity, *_3dImage, *Q, handleMissingValues != 0, ddepth);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_estimateAffine3D
[32/64bit] 2つの3次元点群の間で，最適なアフィン変換を計算します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr outVal
p4 = sptr : IntPtr inliers
p5 = double : double ransacThreshold
p6 = double : double confidence
p7 = var : out int returnValue
%inst
計算結果は、\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject reject r\♪♪〜♪♪♪♪♪♪♪〜+ b_1\\ b_2kPa\RANSACアルゴリズムを用いて、2つの3次元点群間の最適な3次元アフィン変換を推定する機能です。

元関数名(C#): calib3d_estimateAffine3D
元DLLエクスポート名: calib3d_estimateAffine3D
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_estimateAffine3D(cv::_InputArray *src, cv::_InputArray *dst,
    cv::_OutputArray *out, cv::_OutputArray *inliers,
    double ransacThreshold, double confidence,
    int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::estimateAffine3D(*src, *dst, *out, *inliers, ransacThreshold, confidence);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_sampsonDistance_InputArray
[32/64bit] 2つの点の間の Sampson Distance を計算します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr pt1
p2 = sptr : IntPtr pt2
p3 = sptr : IntPtr F
p4 = var : out double returnValue
%inst
関数 cv::sampsonDistance は，幾何誤差の一次近似値を次のように計算して返します：?[ sd( ????? ) , ????? ) = ????? ){((???????)(0))^2 + ((????)(1))^2 + ((????)(0))^2 + ((???????)(1))^2}.\基本行列は，findFundamentalMat関数を使って計算できます。詳細は，[103] 11.4.3 を参照してください．

元関数名(C#): calib3d_sampsonDistance_InputArray
元DLLエクスポート名: calib3d_sampsonDistance_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_sampsonDistance_InputArray(
    cv::_InputArray *pt1, cv::_InputArray *pt2, cv::_InputArray *F,
    double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::sampsonDistance(*pt1, *pt2, *F);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_sampsonDistance_Point3d
[32bit] 2つの点の間の Sampson Distance を計算します．
%prm
p1,p2,p3,p4
p1 = ARGS_POINT3D : Point3d pt1
p2 = ARGS_POINT3D : Point3d pt2
p3 = var : double* F
p4 = var : out double returnValue
%inst
関数 cv::sampsonDistance は，幾何誤差の一次近似値を次のように計算して返します：?[ sd( ????? ) , ????? ) = ????? ){((???????)(0))^2 + ((????)(1))^2 + ((????)(0))^2 + ((???????)(1))^2}.\基本行列は，findFundamentalMat関数を使って計算できます。詳細は，[103] 11.4.3 を参照してください．

元関数名(C#): calib3d_sampsonDistance_Point3d
元DLLエクスポート名: calib3d_sampsonDistance_Point3d
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_sampsonDistance_Point3d(
    MyCvPoint3D64f pt1, MyCvPoint3D64f pt2, MyCvPoint3D64f *F,
    double *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Point3d&amp;gt; f(9);
    for (size_t i = 0; i &amp;lt; 9; i++)
    {
        f[i] = cpp(F[i]);
    }
    *returnValue = cv::sampsonDistance(cv::Mat(cpp(pt1)), cv::Mat(cpp(pt2)), f);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_sampsonDistance_Point3d
[64bit] 2つの点の間の Sampson Distance を計算します．
%prm
p1,p2,p3,p4
p1 = var : Point3d pt1
p2 = var : Point3d pt2
p3 = var : double* F
p4 = var : out double returnValue
%inst
関数 cv::sampsonDistance は，幾何誤差の一次近似値を次のように計算して返します：?[ sd( ????? ) , ????? ) = ????? ){((???????)(0))^2 + ((????)(1))^2 + ((????)(0))^2 + ((???????)(1))^2}.\基本行列は，findFundamentalMat関数を使って計算できます。詳細は，[103] 11.4.3 を参照してください．

元関数名(C#): calib3d_sampsonDistance_Point3d
元DLLエクスポート名: calib3d_sampsonDistance_Point3d
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_sampsonDistance_Point3d(
    MyCvPoint3D64f pt1, MyCvPoint3D64f pt2, MyCvPoint3D64f *F,
    double *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Point3d&amp;gt; f(9);
    for (size_t i = 0; i &amp;lt; 9; i++)
    {
        f[i] = cpp(F[i]);
    }
    *returnValue = cv::sampsonDistance(cv::Mat(cpp(pt1)), cv::Mat(cpp(pt2)), f);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_estimateAffine2D
[32/64bit] calib3d_estimateAffine2D
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr from
p2 = sptr : IntPtr to
p3 = sptr : IntPtr inliers
p4 = int : int method
p5 = double : double ransacReprojThreshold
p6 = ARGS_ULONG : ulong maxIters
p7 = double : double confidence
p8 = ARGS_ULONG : ulong refineIters
p9 = var : out IntPtr returnValue
%inst
元関数名(C#): calib3d_estimateAffine2D
元DLLエクスポート名: calib3d_estimateAffine2D
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_estimateAffine2D(
    cv::_InputArray *from, cv::_InputArray *to, cv::_OutputArray *inliers,
    int method, double ransacReprojThreshold,
    uint64_t maxIters, double confidence, uint64_t refineIters,
    cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto result = cv::estimateAffine2D(
        *from, *to, entity(inliers), method, ransacReprojThreshold, static_cast&amp;lt;size_t&amp;gt;(maxIters), confidence, static_cast&amp;lt;size_t&amp;gt;(refineIters));
    *returnValue = new cv::Mat(result);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_estimateAffinePartial2D
[32/64bit] calib3d_estimateAffinePartial2D
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr from
p2 = sptr : IntPtr to
p3 = sptr : IntPtr inliers
p4 = int : int method
p5 = double : double ransacReprojThreshold
p6 = ARGS_ULONG : ulong maxIters
p7 = double : double confidence
p8 = ARGS_ULONG : ulong refineIters
p9 = var : out IntPtr returnValue
%inst
元関数名(C#): calib3d_estimateAffinePartial2D
元DLLエクスポート名: calib3d_estimateAffinePartial2D
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_estimateAffinePartial2D(
    cv::_InputArray *from, cv::_InputArray *to, cv::_OutputArray *inliers,
    int method, double ransacReprojThreshold,
    uint64_t maxIters, double confidence, uint64_t refineIters,
    cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto result = cv::estimateAffinePartial2D(
        *from, *to, entity(inliers), method, ransacReprojThreshold, static_cast&amp;lt;size_t&amp;gt;(maxIters), confidence, static_cast&amp;lt;size_t&amp;gt;(refineIters));
    *returnValue = new cv::Mat(result);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_decomposeHomographyMat
[32/64bit] ホモグラフィ行列を，回転（複数），並進（複数），平面法線（複数）に分解します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr H
p2 = sptr : IntPtr K
p3 = sptr : IntPtr rotations
p4 = sptr : IntPtr translations
p5 = sptr : IntPtr normals
p6 = var : out int returnValue
%inst
この関数は，平面物体の2つのビュー間の相対的なカメラの動きを抽出し，回転，並進，平面法線の最大4つの数学的解のタプルを返す．ホモグラフィ行列Hの分解については，[160]で詳しく述べられています．平面によって誘導されたホモグラフィHが、ソース画像点\(p_i\)とデスティネーション画像点\(p'_i\)に制約を与える場合、回転と平行移動のタプルを返します。とすると，回転[k]と並進[k]のタプルは，ソースカメラの座標系からデスティネーションカメラの座標系への基底の変更となる．ただし，H を分解することで，シーンの（通常は未知の）深度で正規化された並進，つまり，方向は正規化された長さでしか得られません．点の対応が得られる場合は，正の深度制約，つまり，すべての点がカメラの前になければならないという制約を適用することで，少なくとも2つの解がさらに無効になることがあります．

元関数名(C#): calib3d_decomposeHomographyMat
元DLLエクスポート名: calib3d_decomposeHomographyMat
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_decomposeHomographyMat(
    cv::_InputArray *H,
    cv::_InputArray *K,
    std::vector&amp;lt;cv::Mat&amp;gt; *rotations,
    std::vector&amp;lt;cv::Mat&amp;gt; *translations,
    std::vector&amp;lt;cv::Mat&amp;gt; *normals,
    int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::decomposeHomographyMat(*H, *K, *rotations, *translations, *normals);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_filterHomographyDecompByVisibleRefpoints
[32/64bit] 追加情報に基づいて、ホモグラフィーの分解をフィルタリングします。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr rotations
p2 = sptr : IntPtr normals
p3 = sptr : IntPtr beforePoints
p4 = sptr : IntPtr afterPoints
p5 = sptr : IntPtr possibleSolutions
p6 = sptr : IntPtr pointsMask
%inst
この関数は， decomposeHomographyMat の出力を， [160] で述べられているような追加情報に基づいてフィルタリングするためのものです．このメソッドの概要： decomposeHomographyMat 関数は，2つのユニークな解とその「反対」の解，合計4つの解を返します．ホモグラフィー変換の適用前後で，カメラフレーム内に見える点の集合にアクセスできるならば，どのホモグラフィーが，すべての可視参照点がカメラの前にあることと矛盾しないかを検証することで，どれが真の潜在的な解で，どれが反対の解かを決定することができます．入力は変更されません。フィルタリングされた解答セットは、既存の解答セットへのインデックスとして返されます。

元関数名(C#): calib3d_filterHomographyDecompByVisibleRefpoints
元DLLエクスポート名: calib3d_filterHomographyDecompByVisibleRefpoints
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_filterHomographyDecompByVisibleRefpoints(
    std::vector&amp;lt;cv::Mat&amp;gt; *rotations,
    std::vector&amp;lt;cv::Mat&amp;gt; *normals,
    cv::_InputArray *beforePoints,
    cv::_InputArray *afterPoints,
    cv::_OutputArray *possibleSolutions,
    cv::_InputArray *pointsMask)
{
    BEGIN_WRAP
    cv::filterHomographyDecompByVisibleRefpoints(*rotations, *normals, *beforePoints, *afterPoints, *possibleSolutions, entity(pointsMask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_undistort
[32/64bit] レンズの歪みを補正するために，画像を変換します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr cameraMatrix
p4 = sptr : IntPtr distCoeffs
p5 = sptr : IntPtr newCameraMatrix
%inst
この関数は，半径方向と接線方向のレンズ歪みを補正するために画像を変換します．この関数は，単に initUndistortRectifyMap（ユニティーR付き）と remap（バイリニア補間付き）を組み合わせたものです．この関数は， initUndistortRectifyMap (with unity R ) と remap (with bilinear interpolation) を単純に組み合わせたものです．実行される変換の詳細については，前者の関数を参照してください．出力画像の中で，ソース画像に対応するピクセルが存在しないピクセルは，ゼロ（黒色）で埋められます．getOptimalNewCameraMatrix を使えば，必要に応じて適切な newCameraMatrix を計算することができます．カメラ行列と歪みパラメータは， calibrateCamera を使って決定することができます．画像の解像度がキャリブレーションの段階で使用された解像度と異なる場合，歪み係数はそのままで，それに応じて ????? / ????? / ?????

元関数名(C#): calib3d_undistort
元DLLエクスポート名: calib3d_undistort
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_undistort(
    cv::_InputArray *src, cv::_OutputArray *dst,
    cv::_InputArray *cameraMatrix, cv::_InputArray *distCoeffs, cv::_InputArray *newCameraMatrix)
{
    BEGIN_WRAP
    cv::undistort(*src, *dst, *cameraMatrix, entity(distCoeffs), entity(newCameraMatrix));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_initUndistortRectifyMap
[32/64bit] 歪み補正と平行化の変換マップを計算します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr cameraMatrix
p2 = sptr : IntPtr distCoeffs
p3 = sptr : IntPtr R
p4 = sptr : IntPtr newCameraMatrix
p5 = ARGS_SIZE : Size size
p6 = int : int m1type
p7 = sptr : IntPtr map1
p8 = sptr : IntPtr map2
%inst
この関数は，歪み補正と平行化の変換を合同で計算し，その結果をリマップ用のマップの形で表現します．歪みのない画像は，カメラ行列 =newCameraMatrix を用いたカメラで撮影されたかのように，元の画像と同じように見え，歪みもありません．単眼カメラの場合，newCameraMatrix は通常 cameraMatrix と等しくなりますが，スケーリングをより正確に制御するために， getOptimalNewCameraMatrix によって計算することもできます．ステレオカメラの場合，newCameraMatrix は通常，stereoRectify によって求められた P1 または P2 に設定されます．また，この新しいカメラは，R に従って，座標空間内で異なる向きに配置されます．例えば，ステレオカメラの2つのヘッドを調整して，両方の画像のエピポーラ線が水平になり，同じ y-座標を持つようにすることができます（水平に配置されたステレオカメラの場合）．つまり，この関数は，補正・平行化された出力画像の各ピクセル ?((u, v)?))に対して，元画像（つまり，カメラから出力されたオリジナル画像）における対応する座標を計算します．このような処理を行います。^T ardarrow R^{-1}*[x ?, y?,1]^T ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ !!!!+ 2p_1 x' y' + p_2(r^2 + 2 x'^2) + s_1 r^2 + s_2 r^4\ y'' ??{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6}。+ p_1 (r^2 + 2 y'^2) + 2 p_2 x' y' + s_3 r^2 + s_4 r^4 ????? = ?????{R_{33}(?????)}{0}{R_{13}((?????)}){0}{R_{33}(??? -? ???)}{R_{23}(????)}{0}{0}{1}R(\tau_x, \tau_y) \vecthree{x''}{y''}{1}\ map_x(u,v) ????? ????? ????? ????? ?????\ステレオカメラの場合，この関数は，各カメラヘッドに対して，stereoRectify の後，stereoCalibrate の後に 2 回呼び出されます．しかし，ステレオカメラがキャリブレーションされていない場合は， stereoRectifyUncalibrated を用いて，基本行列から直接，平行化変換を計算することができます．各カメラに対して，この関数は，3次元空間の回転行列 R ではなく，ピクセル領域の平行化変換としてホモグラフィ H を求めます．R は，H から次のようにして求められます：[??? -? ???] = ??? -? ??? )^{-1} ????? )\ここで，CameraMatrix は任意に選択できます．

元関数名(C#): calib3d_initUndistortRectifyMap
元DLLエクスポート名: calib3d_initUndistortRectifyMap
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_initUndistortRectifyMap(
    cv::_InputArray *cameraMatrix, cv::_InputArray *distCoeffs,
    cv::_InputArray *R, cv::_InputArray *newCameraMatrix,
    MyCvSize size, int m1type, cv::_OutputArray *map1, cv::_OutputArray *map2)
{
    BEGIN_WRAP
    cv::initUndistortRectifyMap(*cameraMatrix, *distCoeffs, *R, *newCameraMatrix, cpp(size), m1type, *map1, *map2);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_initWideAngleProjMap
[32/64bit] 広角用のリマップのために，マップを初期化します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = sptr : IntPtr cameraMatrix
p2 = sptr : IntPtr distCoeffs
p3 = ARGS_SIZE : Size imageSize
p4 = int : int destImageWidth
p5 = int : int m1type
p6 = sptr : IntPtr map1
p7 = sptr : IntPtr map2
p8 = int : int projType
p9 = double : double alpha
p10 = var : out float returnValue
%inst
元関数名(C#): calib3d_initWideAngleProjMap
元DLLエクスポート名: calib3d_initWideAngleProjMap
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_initWideAngleProjMap(
    cv::_InputArray *cameraMatrix, cv::_InputArray *distCoeffs,
    MyCvSize imageSize, int destImageWidth,
    int m1type, cv::_OutputArray *map1, cv::_OutputArray *map2,
    int projType, double alpha,
    float *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::initWideAngleProjMap(*cameraMatrix, *distCoeffs, cpp(imageSize), destImageWidth, m1type, 
        *map1, *map2, static_cast&amp;lt;cv::UndistortTypes&amp;gt;(projType), alpha);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_getDefaultNewCameraMatrix
[32/64bit] デフォルトの新しいカメラ行列を返します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr cameraMatrix
p2 = ARGS_SIZE : Size imgsize
p3 = int : int centerPrincipalPoint
p4 = var : out IntPtr returnValue
%inst
この関数は，入力された cameraMatrix の完全なコピー（centerPrinicipalPoint=false の場合），あるいは修正されたカメラ行列（centerPrincipalPoint=true の場合）を返します．後者の場合，新しいカメラ行列は次のようになります：??? -? ??? f_x && 0 && ( ??? -? ??? ) 0 && f_y && ( ??? -? ??? ) 0 && 0 && 1 ????デフォルトでは，OpenCV の歪み補正関数（ initUndistortRectifyMap, undistort 参照）は，主点を移動させません．しかし，ステレオを扱う場合，両方のビューの主点を同じ y 座標に移動させることが重要であり（これは，ほとんどのステレオ対応点探索アルゴリズムで要求されます），同じ x 座標に移動させることもあります．そこで、各ビューに対して、主点が中心に位置する新しいカメラ行列を形成します。

元関数名(C#): calib3d_getDefaultNewCameraMatrix
元DLLエクスポート名: calib3d_getDefaultNewCameraMatrix
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_getDefaultNewCameraMatrix(
    cv::_InputArray *cameraMatrix, MyCvSize imgsize, int centerPrincipalPoint,
    cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto result = cv::getDefaultNewCameraMatrix(*cameraMatrix, cpp(imgsize), centerPrincipalPoint != 0);
    *returnValue = new cv::Mat(result);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_undistortPoints
[32/64bit] 観測された点座標から，理想的な点座標を計算します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr cameraMatrix
p4 = sptr : IntPtr distCoeffs
p5 = sptr : IntPtr R
p6 = sptr : IntPtr P
%inst
この関数は， undistort および initUndistortRectifyMap に似ていますが，ラスタ画像ではなく，疎な点の集合を操作します．また，この関数は，projectPoints とは逆の変換を行います．3次元物体の場合は，その3次元座標を再構成しませんが，平面物体の場合は，適切なRが指定されていれば，並進ベクトルまで再構成します．この関数は，観測された各点座標 ?((u, v)?)に対して，次のように計算します\y^{"}」となります。♪\\\\\\\\\\\\^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T\\ ¶ u' ¶ leftarrow x {f'}_x + {c'}_x ¶ v' ¶ leftarrow y {f'}_y + {c'}_y ¶end{array}.\ここで，undistort は，正規化された歪んだ点座標から，正規化された元の点座標を推定する近似的な反復アルゴリズムです（「正規化」とは，座標がカメラ行列に依存しないことを意味します）．

元関数名(C#): calib3d_undistortPoints
元DLLエクスポート名: calib3d_undistortPoints
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_undistortPoints(
    cv::_InputArray *src, cv::_OutputArray *dst,
    cv::_InputArray *cameraMatrix, cv::_InputArray *distCoeffs,
    cv::_InputArray *R, cv::_InputArray *P)
{
    BEGIN_WRAP
    cv::undistortPoints(*src, *dst, *cameraMatrix, *distCoeffs, entity(R), entity(P));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_undistortPointsIter
[32bit] 観測された点座標から，理想的な点座標を計算します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr cameraMatrix
p4 = sptr : IntPtr distCoeffs
p5 = sptr : IntPtr R
p6 = sptr : IntPtr P
p7 = ARGS_TERMCRITERIA : TermCriteria criteria
%inst
この関数は， undistort および initUndistortRectifyMap に似ていますが，ラスタ画像ではなく，疎な点の集合を操作します．また，この関数は，projectPoints とは逆の変換を行います．3次元物体の場合は，その3次元座標を再構成しませんが，平面物体の場合は，適切なRが指定されていれば，並進ベクトルまで再構成します．この関数は，観測された各点座標 ?((u, v)?)に対して，次のように計算します\y^{"}」となります。♪\\\\\\\\\\\\^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T\\ ¶ u' ¶ leftarrow x {f'}_x + {c'}_x ¶ v' ¶ leftarrow y {f'}_y + {c'}_y ¶end{array}.\ここで，undistort は，正規化された歪んだ点座標から，正規化された元の点座標を推定する近似的な反復アルゴリズムです（「正規化」とは，座標がカメラ行列に依存しないことを意味します）．

元関数名(C#): calib3d_undistortPointsIter
元DLLエクスポート名: calib3d_undistortPointsIter
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_undistortPointsIter(
    cv::_InputArray *src, cv::_OutputArray *dst,
    cv::_InputArray *cameraMatrix, cv::_InputArray *distCoeffs,
    cv::_InputArray *R, cv::_InputArray *P, MyCvTermCriteria criteria)
{
    BEGIN_WRAP
    cv::undistortPoints(*src, *dst, *cameraMatrix, *distCoeffs, entity(R), entity(P), cpp(criteria));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_undistortPointsIter
[64bit] 観測された点座標から，理想的な点座標を計算します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr cameraMatrix
p4 = sptr : IntPtr distCoeffs
p5 = sptr : IntPtr R
p6 = sptr : IntPtr P
p7 = var : TermCriteria criteria
%inst
この関数は， undistort および initUndistortRectifyMap に似ていますが，ラスタ画像ではなく，疎な点の集合を操作します．また，この関数は，projectPoints とは逆の変換を行います．3次元物体の場合は，その3次元座標を再構成しませんが，平面物体の場合は，適切なRが指定されていれば，並進ベクトルまで再構成します．この関数は，観測された各点座標 ?((u, v)?)に対して，次のように計算します\y^{"}」となります。♪\\\\\\\\\\\\^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T ^T\\ ¶ u' ¶ leftarrow x {f'}_x + {c'}_x ¶ v' ¶ leftarrow y {f'}_y + {c'}_y ¶end{array}.\ここで，undistort は，正規化された歪んだ点座標から，正規化された元の点座標を推定する近似的な反復アルゴリズムです（「正規化」とは，座標がカメラ行列に依存しないことを意味します）．

元関数名(C#): calib3d_undistortPointsIter
元DLLエクスポート名: calib3d_undistortPointsIter
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_undistortPointsIter(
    cv::_InputArray *src, cv::_OutputArray *dst,
    cv::_InputArray *cameraMatrix, cv::_InputArray *distCoeffs,
    cv::_InputArray *R, cv::_InputArray *P, MyCvTermCriteria criteria)
{
    BEGIN_WRAP
    cv::undistortPoints(*src, *dst, *cameraMatrix, *distCoeffs, entity(R), entity(P), cpp(criteria));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_recoverPose_InputArray1
[32/64bit] 推定された本質的な行列と，それに対応する2つの画像中の点から，カメラの相対的な回転と並進を，不正性のチェックを用いて復元します．このチェックに合格したインライアの数を返します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr E
p2 = sptr : IntPtr points1
p3 = sptr : IntPtr points2
p4 = sptr : IntPtr cameraMatrix
p5 = sptr : IntPtr R
p6 = sptr : IntPtr P
p7 = sptr : IntPtr mask
p8 = var : out int returnValue
%inst
この関数は， decomposeEssentialMat を用いて本質的な行列を分解した後，頬性チェックを行うことで，可能性のあるポーズの仮説を検証します．チアラリティチェックとは，三角形化された3次元点が正の深度を持つことを意味します．この関数は， findEssentialMat からの出力 E と mask を処理するために利用できます．このシナリオでは，point1 と points2 は findEssentialMat の同じ入力です： // 例．RANSAC アルゴリズムを用いた基本行列の推定int point_count = 100;vector<Point2f> points1(point_count);vector<Point2f> points2(point_count);// ここでポイントを初期化します ...for( int i = 0; i < point_count; i++ ){ points1[i] = ...; points2[i] = ....;}// 両方の焦点距離 = 1, 主点 = (0, 0)Mat cameraMatrix = Mat::eye(3, 3, CV_64F);Mat E, R, t, mask;E = findEssentialMat(points1, points2, cameraMatrix, RANSAC, 0.999, 1.0, mask);recoverPose(E, points1, points2, cameraMatrix, R, t, mask);fragment

元関数名(C#): calib3d_recoverPose_InputArray1
元DLLエクスポート名: calib3d_recoverPose_InputArray1
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_recoverPose_InputArray1(
    cv::_InputArray *E, cv::_InputArray *points1, cv::_InputArray *points2,
    cv::_InputArray *cameraMatrix,
    cv::_OutputArray *R, cv::_OutputArray *t, cv::_InputOutputArray *mask,
    int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::recoverPose(*E, *points1, *points2, *cameraMatrix, *R, *t, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_recoverPose_InputArray2
[32bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr E
p2 = sptr : IntPtr points1
p3 = sptr : IntPtr points2
p4 = sptr : IntPtr R
p5 = sptr : IntPtr P
p6 = double : double focal
p7 = ARGS_POINT2D : Point2d pp
p8 = sptr : IntPtr mask
p9 = var : out int returnValue
%inst
この関数は，上述の関数とは異なり，焦点距離と主点からカメラの固有マトリクスを求めます： ??? -? ??? A = ???? f & 0 & x_{pp} ???? A = ??? -? ???\\ 0 & f & y_{pp}\\ 0 & 0 & 1 ″end{bmatrix}\ ″となります。］

元関数名(C#): calib3d_recoverPose_InputArray2
元DLLエクスポート名: calib3d_recoverPose_InputArray2
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_recoverPose_InputArray2(
    cv::_InputArray *E, cv::_InputArray *points1, cv::_InputArray *points2,
    cv::_OutputArray *R, cv::_OutputArray *t, double focal, MyCvPoint2D64f pp,
    cv::_InputOutputArray *mask,
    int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::recoverPose(*E, *points1, *points2, *R, *t, focal, cpp(pp), entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_recoverPose_InputArray2
[64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr E
p2 = sptr : IntPtr points1
p3 = sptr : IntPtr points2
p4 = sptr : IntPtr R
p5 = sptr : IntPtr P
p6 = double : double focal
p7 = var : Point2d pp
p8 = sptr : IntPtr mask
p9 = var : out int returnValue
%inst
この関数は，上述の関数とは異なり，焦点距離と主点からカメラの固有マトリクスを求めます： ??? -? ??? A = ???? f & 0 & x_{pp} ???? A = ??? -? ???\\ 0 & f & y_{pp}\\ 0 & 0 & 1 ″end{bmatrix}\ ″となります。］

元関数名(C#): calib3d_recoverPose_InputArray2
元DLLエクスポート名: calib3d_recoverPose_InputArray2
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_recoverPose_InputArray2(
    cv::_InputArray *E, cv::_InputArray *points1, cv::_InputArray *points2,
    cv::_OutputArray *R, cv::_OutputArray *t, double focal, MyCvPoint2D64f pp,
    cv::_InputOutputArray *mask,
    int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::recoverPose(*E, *points1, *points2, *R, *t, focal, cpp(pp), entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_recoverPose_InputArray3
[32/64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = sptr : IntPtr E
p2 = sptr : IntPtr points1
p3 = sptr : IntPtr points2
p4 = sptr : IntPtr cameraMatrix
p5 = sptr : IntPtr R
p6 = sptr : IntPtr P
p7 = double : double distanceTresh
p8 = sptr : IntPtr mask
p9 = sptr : IntPtr triangulatedPoints
p10 = var : out int returnValue
%inst
この関数は，上記の関数とは異なり，不正性のチェックに使用される三角測量された3次元点を出力します．

元関数名(C#): calib3d_recoverPose_InputArray3
元DLLエクスポート名: calib3d_recoverPose_InputArray3
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_recoverPose_InputArray3(
    cv::_InputArray *E, cv::_InputArray *points1, cv::_InputArray *points2,
    cv::_InputArray *cameraMatrix, double distanceTresh,
    cv::_OutputArray *R, cv::_OutputArray *t, cv::_InputOutputArray *mask, cv::_OutputArray *triangulatedPoints,
    int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::recoverPose(*E, *points1, *points2, *cameraMatrix, *R, *t, distanceTresh, entity(mask), entity(triangulatedPoints));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_findEssentialMat_InputArray1
[32/64bit] 2つの画像中の対応する点から，必須行列を計算します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr points1
p2 = sptr : IntPtr points2
p3 = sptr : IntPtr cameraMatrix
p4 = int : int method
p5 = double : double prob
p6 = double : double threshold
p7 = sptr : IntPtr mask
p8 = var : out IntPtr returnValue
%inst
この関数は，[186]の5点アルゴリズムソルバーに基づいて，必須行列を推定します．また，[228]も関連しています．エピポーラ形状は，次の式で表されます： ?[[p_2; 1]^T K^{-T}].E K^{-1} [p_1; 1] = 0\]ここで，\(E\)は本質的な行列で，\(p_1)，\(p_2)はそれぞれ1枚目と2枚目の画像の対応点です．この関数の結果は，カメラ間の相対的な姿勢を復元するために，さらに decomposeEssentialMat や recoverPose に渡すことができます．

元関数名(C#): calib3d_findEssentialMat_InputArray1
元DLLエクスポート名: calib3d_findEssentialMat_InputArray1
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_findEssentialMat_InputArray1(
    cv::_InputArray *points1, cv::_InputArray *points2, cv::_InputArray *cameraMatrix,
    int method, double prob, double threshold,
    cv::_OutputArray *mask,
    cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto mat = cv::findEssentialMat(
        *points1, *points2, *cameraMatrix, method, prob, threshold, entity(mask));
    *returnValue = new cv::Mat(mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_findEssentialMat_InputArray2
[32bit] 2つの画像中の対応する点から，必須行列を計算します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr points1
p2 = sptr : IntPtr points2
p3 = double : double focal
p4 = ARGS_POINT2D : Point2d pp
p5 = int : int method
p6 = double : double prob
p7 = double : double threshold
p8 = sptr : IntPtr mask
p9 = var : out IntPtr returnValue
%inst
この関数は，[186]の5点アルゴリズムソルバーに基づいて，必須行列を推定します．また，[228]も関連しています．エピポーラ形状は，次の式で表されます： ?[[p_2; 1]^T K^{-T}].E K^{-1} [p_1; 1] = 0\]ここで，\(E\)は本質的な行列で，\(p_1)，\(p_2)はそれぞれ1枚目と2枚目の画像の対応点です．この関数の結果は，カメラ間の相対的な姿勢を復元するために，さらに decomposeEssentialMat や recoverPose に渡すことができます．

元関数名(C#): calib3d_findEssentialMat_InputArray2
元DLLエクスポート名: calib3d_findEssentialMat_InputArray2
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_findEssentialMat_InputArray2(
    cv::_InputArray *points1, cv::_InputArray *points2, double focal, MyCvPoint2D64f pp,
    int method, double prob, double threshold,
    cv::_OutputArray *mask,
    cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto mat = cv::findEssentialMat(
        *points1, *points2, focal, cpp(pp), method, prob, threshold, entity(mask));
    *returnValue = new cv::Mat(mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_findEssentialMat_InputArray2
[64bit] 2つの画像中の対応する点から，必須行列を計算します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr points1
p2 = sptr : IntPtr points2
p3 = double : double focal
p4 = var : Point2d pp
p5 = int : int method
p6 = double : double prob
p7 = double : double threshold
p8 = sptr : IntPtr mask
p9 = var : out IntPtr returnValue
%inst
この関数は，[186]の5点アルゴリズムソルバーに基づいて，必須行列を推定します．また，[228]も関連しています．エピポーラ形状は，次の式で表されます： ?[[p_2; 1]^T K^{-T}].E K^{-1} [p_1; 1] = 0\]ここで，\(E\)は本質的な行列で，\(p_1)，\(p_2)はそれぞれ1枚目と2枚目の画像の対応点です．この関数の結果は，カメラ間の相対的な姿勢を復元するために，さらに decomposeEssentialMat や recoverPose に渡すことができます．

元関数名(C#): calib3d_findEssentialMat_InputArray2
元DLLエクスポート名: calib3d_findEssentialMat_InputArray2
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_findEssentialMat_InputArray2(
    cv::_InputArray *points1, cv::_InputArray *points2, double focal, MyCvPoint2D64f pp,
    int method, double prob, double threshold,
    cv::_OutputArray *mask,
    cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto mat = cv::findEssentialMat(
        *points1, *points2, focal, cpp(pp), method, prob, threshold, entity(mask));
    *returnValue = new cv::Mat(mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d

%index
calib3d_fisheye_projectPoints2
[32/64bit] 魚眼モデルを用いてポイントを投影します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr objectPoints
p2 = sptr : IntPtr imagePoints
p3 = sptr : IntPtr rvec
p4 = sptr : IntPtr tvec
p5 = sptr : IntPtr K
p6 = sptr : IntPtr D
p7 = double : double alpha
p8 = sptr : IntPtr jacobian
%inst
この関数は，カメラの内部および外部パラメータを与えて，3次元点の画像平面への投影を求めます．オプションとして，この関数は，（すべての入力パラメータの関数としての）画像点座標の偏微分の行列であるヤコビアンを，特定のパラメータ（内在および外在）に関して計算します．

元関数名(C#): calib3d_fisheye_projectPoints2
元DLLエクスポート名: calib3d_fisheye_projectPoints2
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_fisheye.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_fisheye_projectPoints2(
    cv::_InputArray *objectPoints, cv::_OutputArray *imagePoints, cv::_InputArray *rvec, cv::_InputArray *tvec,
    cv::_InputArray *K, cv::_InputArray *D, double alpha, cv::_OutputArray *jacobian)
{
    BEGIN_WRAP
    cv::fisheye::projectPoints(*objectPoints, *imagePoints, *rvec, *tvec, *K, *D, alpha, entity(jacobian));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_fisheye

%index
calib3d_fisheye_distortPoints
[32/64bit] 魚眼モデルを用いて，2次元点を歪めます．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr undistorted
p2 = sptr : IntPtr distorted
p3 = sptr : IntPtr K
p4 = sptr : IntPtr D
p5 = double : double alpha
%inst
この関数は，歪んでいない点のカメラ固有の行列を，恒等式と仮定していることに注意してください．つまり，fisheye::undistortPoints によって歪められていない点を元に戻したい場合は，それらの点に ??o??? を掛けなければいけません．

元関数名(C#): calib3d_fisheye_distortPoints
元DLLエクスポート名: calib3d_fisheye_distortPoints
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_fisheye.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_fisheye_distortPoints(
    cv::_InputArray *undistorted, cv::_OutputArray *distorted, cv::_InputArray *K, cv::_InputArray *D, double alpha)
{
    BEGIN_WRAP
    cv::fisheye::distortPoints(*undistorted, *distorted, *K, *D, alpha);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_fisheye

%index
calib3d_fisheye_undistortPoints
[32/64bit] 魚眼モデルを使って2Dポイントの歪みを補正します。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr distorted
p2 = sptr : IntPtr undistorted
p3 = sptr : IntPtr K
p4 = sptr : IntPtr D
p5 = sptr : IntPtr R
p6 = sptr : IntPtr P
%inst
元関数名(C#): calib3d_fisheye_undistortPoints
元DLLエクスポート名: calib3d_fisheye_undistortPoints
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_fisheye.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_fisheye_undistortPoints(
    cv::_InputArray *distorted, cv::_OutputArray *undistorted,
    cv::_InputArray *K, cv::_InputArray *D, cv::_InputArray *R, cv::_InputArray *P)
{
    BEGIN_WRAP
    cv::fisheye::undistortPoints(*distorted, *undistorted, *K, *D, entity(R), entity(P));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_fisheye

%index
calib3d_fisheye_initUndistortRectifyMap
[32/64bit] remap による画像変換に対して，歪み補正マップと平行化マップを計算します．D が空の場合は，ゼロディストーションが利用され，R または P が空の場合は，単位行列が利用されます．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr K
p2 = sptr : IntPtr D
p3 = sptr : IntPtr R
p4 = sptr : IntPtr P
p5 = ARGS_SIZE : Size size
p6 = int : int m1type
p7 = sptr : IntPtr map1
p8 = sptr : IntPtr map2
%inst
元関数名(C#): calib3d_fisheye_initUndistortRectifyMap
元DLLエクスポート名: calib3d_fisheye_initUndistortRectifyMap
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_fisheye.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_fisheye_initUndistortRectifyMap(
    cv::_InputArray *K, cv::_InputArray *D, cv::_InputArray *R, cv::_InputArray *P,
    MyCvSize size, int m1type, cv::_OutputArray *map1, cv::_OutputArray *map2)
{
    BEGIN_WRAP
    cv::fisheye::initUndistortRectifyMap(*K, *D, *R, *P, cpp(size), m1type, *map1, *map2);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_fisheye

%index
calib3d_fisheye_undistortImage
[32/64bit] 魚眼レンズの歪みを補正するために，画像を変換します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr distorted
p2 = sptr : IntPtr undistorted
p3 = sptr : IntPtr K
p4 = sptr : IntPtr D
p5 = sptr : IntPtr Knew
p6 = ARGS_SIZE : Size newSize
%inst
この関数は，半径方向と接線方向のレンズ歪みを補正するために画像を変換します．この関数は，単純に fisheye::initUndistortRectifyMap（ユニティーR付き）と remap（バイリニア補間付き）を組み合わせたものです．この関数は，fisheye: initUndistortRectifyMap (with unity R ) と remap (with bilar interpolation) を単純に組み合わせたもので，実行される変換の詳細については，前者の関数を参照してください．undistortImageの結果は以下のとおりです．）

b) 魚眼カメラモデルの fisheye::undistortImage の結果 (魚眼レンズの歪みのすべての係数 (k_1, k_2, k_3, k_4) がキャリブレーションにより最適化されている)

c) 元の画像を魚眼レンズで撮影したもの写真a)とb)はほぼ同じです。しかし、画像の中心から離れた場所にある画像の点を考慮すると、画像a)ではこれらの点が歪んでいることがわかります。

元関数名(C#): calib3d_fisheye_undistortImage
元DLLエクスポート名: calib3d_fisheye_undistortImage
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_fisheye.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_fisheye_undistortImage(
    cv::_InputArray *distorted, cv::_OutputArray *undistorted,
    cv::_InputArray *K, cv::_InputArray *D, cv::_InputArray *Knew, MyCvSize newSize)
{
    BEGIN_WRAP
    cv::fisheye::undistortImage(*distorted, *undistorted, *K, *D, entity(Knew), cpp(newSize));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_fisheye

%index
calib3d_fisheye_estimateNewCameraMatrixForUndistortRectify
[32/64bit] 歪み補正や平行化のために，新しいカメラ固有の行列を推定します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr K
p2 = sptr : IntPtr D
p3 = ARGS_SIZE : Size image_size
p4 = sptr : IntPtr R
p5 = sptr : IntPtr P
p6 = double : double balance
p7 = ARGS_SIZE : Size newSize
p8 = double : double fov_scale
%inst
元関数名(C#): calib3d_fisheye_estimateNewCameraMatrixForUndistortRectify
元DLLエクスポート名: calib3d_fisheye_estimateNewCameraMatrixForUndistortRectify
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_fisheye.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_fisheye_estimateNewCameraMatrixForUndistortRectify(
    cv::_InputArray *K, cv::_InputArray *D, MyCvSize image_size, cv::_InputArray *R,
    cv::_OutputArray *P, double balance, MyCvSize newSize, double fov_scale)
{
    BEGIN_WRAP
    cv::fisheye::estimateNewCameraMatrixForUndistortRectify(*K, *D, cpp(image_size), *R, *P, balance, cpp(newSize), fov_scale);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_fisheye

%index
calib3d_fisheye_calibrate
[32bit] カメラのキャリブレーションを行います。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = sptr : IntPtr objectPoints
p2 = sptr : IntPtr imagePoints
p3 = ARGS_SIZE : Size imageSize
p4 = sptr : IntPtr K
p5 = sptr : IntPtr D
p6 = sptr : IntPtr rvecs
p7 = sptr : IntPtr tvecs
p8 = int : int flags
p9 = ARGS_TERMCRITERIA : TermCriteria criteria
p10 = var : out double returnValue
%inst
元関数名(C#): calib3d_fisheye_calibrate
元DLLエクスポート名: calib3d_fisheye_calibrate
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_fisheye.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_fisheye_calibrate(
    std::vector&amp;lt;cv::Mat&amp;gt; *objectPoints,
    std::vector&amp;lt;cv::Mat&amp;gt; *imagePoints,
    MyCvSize imageSize,
    cv::_InputOutputArray *K,
    cv::_InputOutputArray *D,
    std::vector&amp;lt;cv::Mat&amp;gt; *rvecs,
    std::vector&amp;lt;cv::Mat&amp;gt; *tvecs,
    int flags,
    MyCvTermCriteria criteria,
    double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::fisheye::calibrate(
        *objectPoints, *imagePoints, cpp(imageSize),
        *K, *D, *rvecs, *tvecs, flags, cpp(criteria));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_fisheye

%index
calib3d_fisheye_calibrate
[64bit] カメラのキャリブレーションを行います。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = sptr : IntPtr objectPoints
p2 = sptr : IntPtr imagePoints
p3 = ARGS_SIZE : Size imageSize
p4 = sptr : IntPtr K
p5 = sptr : IntPtr D
p6 = sptr : IntPtr rvecs
p7 = sptr : IntPtr tvecs
p8 = int : int flags
p9 = var : TermCriteria criteria
p10 = var : out double returnValue
%inst
元関数名(C#): calib3d_fisheye_calibrate
元DLLエクスポート名: calib3d_fisheye_calibrate
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_fisheye.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_fisheye_calibrate(
    std::vector&amp;lt;cv::Mat&amp;gt; *objectPoints,
    std::vector&amp;lt;cv::Mat&amp;gt; *imagePoints,
    MyCvSize imageSize,
    cv::_InputOutputArray *K,
    cv::_InputOutputArray *D,
    std::vector&amp;lt;cv::Mat&amp;gt; *rvecs,
    std::vector&amp;lt;cv::Mat&amp;gt; *tvecs,
    int flags,
    MyCvTermCriteria criteria,
    double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::fisheye::calibrate(
        *objectPoints, *imagePoints, cpp(imageSize),
        *K, *D, *rvecs, *tvecs, flags, cpp(criteria));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_fisheye

%index
calib3d_fisheye_stereoRectify
[32/64bit] 魚眼カメラモデルのステレオ平行化を行います。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16
p1 = sptr : IntPtr K1
p2 = sptr : IntPtr D1
p3 = sptr : IntPtr K2
p4 = sptr : IntPtr D2
p5 = ARGS_SIZE : Size imageSize
p6 = sptr : IntPtr R
p7 = sptr : IntPtr tvec
p8 = sptr : IntPtr R1
p9 = sptr : IntPtr R2
p10 = sptr : IntPtr P1
p11 = sptr : IntPtr P2
p12 = sptr : IntPtr Q
p13 = int : int flags
p14 = ARGS_SIZE : Size newImageSize
p15 = double : double balance
p16 = double : double fov_scale
%inst
元関数名(C#): calib3d_fisheye_stereoRectify
元DLLエクスポート名: calib3d_fisheye_stereoRectify
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_fisheye.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_fisheye_stereoRectify(
    cv::_InputArray *K1, cv::_InputArray *D1, cv::_InputArray *K2, cv::_InputArray *D2, MyCvSize imageSize, cv::_InputArray *R, cv::_InputArray *tvec,
    cv::_OutputArray *R1, cv::_OutputArray *R2, cv::_OutputArray *P1, cv::_OutputArray *P2, cv::_OutputArray *Q, int flags, MyCvSize newImageSize,
    double balance, double fov_scale)
{
    BEGIN_WRAP
    cv::fisheye::stereoRectify(*K1, *D1, *K2, *D2, cpp(imageSize), *R, *tvec, *R1, *R2, *P1, *P2, *Q, flags, cpp(newImageSize), balance, fov_scale);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_fisheye

%index
calib3d_fisheye_stereoCalibrate
[32bit] ステレオキャリブレーションを行います．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13
p1 = sptr : IntPtr objectPoints
p2 = sptr : IntPtr imagePoints1
p3 = sptr : IntPtr imagePoints2
p4 = sptr : IntPtr K1
p5 = sptr : IntPtr D1
p6 = sptr : IntPtr K2
p7 = sptr : IntPtr D2
p8 = ARGS_SIZE : Size imageSize
p9 = sptr : IntPtr R
p10 = sptr : IntPtr T
p11 = int : int flags
p12 = ARGS_TERMCRITERIA : TermCriteria criteria
p13 = var : out double returnValue
%inst
元関数名(C#): calib3d_fisheye_stereoCalibrate
元DLLエクスポート名: calib3d_fisheye_stereoCalibrate
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_fisheye.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_fisheye_stereoCalibrate(
    std::vector&amp;lt;cv::Mat&amp;gt; *objectPoints,
    std::vector&amp;lt;cv::Mat&amp;gt; *imagePoints1, 
    std::vector&amp;lt;cv::Mat&amp;gt; *imagePoints2, 
    cv::_InputOutputArray *K1,
    cv::_InputOutputArray *D1,
    cv::_InputOutputArray *K2,
    cv::_InputOutputArray *D2,
    MyCvSize imageSize,
    cv::_OutputArray *R,
    cv::_OutputArray *T,
    int flags,
    MyCvTermCriteria criteria,
    double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::fisheye::stereoCalibrate(
        *objectPoints, *imagePoints1, *imagePoints2,
        *K1, *D1,
        *K2, *D2,
        cpp(imageSize), entity(R), entity(T), flags, cpp(criteria));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_fisheye

%index
calib3d_fisheye_stereoCalibrate
[64bit] ステレオキャリブレーションを行います．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13
p1 = sptr : IntPtr objectPoints
p2 = sptr : IntPtr imagePoints1
p3 = sptr : IntPtr imagePoints2
p4 = sptr : IntPtr K1
p5 = sptr : IntPtr D1
p6 = sptr : IntPtr K2
p7 = sptr : IntPtr D2
p8 = ARGS_SIZE : Size imageSize
p9 = sptr : IntPtr R
p10 = sptr : IntPtr T
p11 = int : int flags
p12 = var : TermCriteria criteria
p13 = var : out double returnValue
%inst
元関数名(C#): calib3d_fisheye_stereoCalibrate
元DLLエクスポート名: calib3d_fisheye_stereoCalibrate
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_fisheye.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_fisheye_stereoCalibrate(
    std::vector&amp;lt;cv::Mat&amp;gt; *objectPoints,
    std::vector&amp;lt;cv::Mat&amp;gt; *imagePoints1, 
    std::vector&amp;lt;cv::Mat&amp;gt; *imagePoints2, 
    cv::_InputOutputArray *K1,
    cv::_InputOutputArray *D1,
    cv::_InputOutputArray *K2,
    cv::_InputOutputArray *D2,
    MyCvSize imageSize,
    cv::_OutputArray *R,
    cv::_OutputArray *T,
    int flags,
    MyCvTermCriteria criteria,
    double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::fisheye::stereoCalibrate(
        *objectPoints, *imagePoints1, *imagePoints2,
        *K1, *D1,
        *K2, *D2,
        cpp(imageSize), entity(R), entity(T), flags, cpp(criteria));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_fisheye

%index
calib3d_StereoMatcher_compute
[32/64bit] 指定されたステレオペアの視差マップを計算します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr left
p3 = sptr : IntPtr right
p4 = sptr : IntPtr disparity
%inst
cv::cuda::StereoSGM で実装されています．

元関数名(C#): calib3d_StereoMatcher_compute
元DLLエクスポート名: calib3d_StereoMatcher_compute
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoMatcher_compute(
    cv::Ptr&amp;lt;cv::StereoMatcher&amp;gt; *obj, cv::_InputArray *left, cv::_InputArray *right, cv::_OutputArray *disparity)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;compute(*left, *right, *disparity);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoMatcher_getMinDisparity
[32/64bit] calib3d_StereoMatcher_getMinDisparity
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): calib3d_StereoMatcher_getMinDisparity
元DLLエクスポート名: calib3d_StereoMatcher_getMinDisparity
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoMatcher_getMinDisparity(
    cv::Ptr&amp;lt;cv::StereoMatcher&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*obj)-&amp;gt;getMinDisparity();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoMatcher_setMinDisparity
[32/64bit] calib3d_StereoMatcher_setMinDisparity
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): calib3d_StereoMatcher_setMinDisparity
元DLLエクスポート名: calib3d_StereoMatcher_setMinDisparity
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoMatcher_setMinDisparity(
    cv::Ptr&amp;lt;cv::StereoMatcher&amp;gt; *obj, int value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setMinDisparity(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoMatcher_getNumDisparities
[32/64bit] calib3d_StereoMatcher_getNumDisparities
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): calib3d_StereoMatcher_getNumDisparities
元DLLエクスポート名: calib3d_StereoMatcher_getNumDisparities
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoMatcher_getNumDisparities(
    cv::Ptr&amp;lt;cv::StereoMatcher&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*obj)-&amp;gt;getNumDisparities();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoMatcher_setNumDisparities
[32/64bit] calib3d_StereoMatcher_setNumDisparities
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): calib3d_StereoMatcher_setNumDisparities
元DLLエクスポート名: calib3d_StereoMatcher_setNumDisparities
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoMatcher_setNumDisparities(
    cv::Ptr&amp;lt;cv::StereoMatcher&amp;gt; *obj, int value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setNumDisparities(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoMatcher_getBlockSize
[32/64bit] calib3d_StereoMatcher_getBlockSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): calib3d_StereoMatcher_getBlockSize
元DLLエクスポート名: calib3d_StereoMatcher_getBlockSize
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoMatcher_getBlockSize(
    cv::Ptr&amp;lt;cv::StereoMatcher&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*obj)-&amp;gt;getBlockSize();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoMatcher_setBlockSize
[32/64bit] calib3d_StereoMatcher_setBlockSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): calib3d_StereoMatcher_setBlockSize
元DLLエクスポート名: calib3d_StereoMatcher_setBlockSize
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoMatcher_setBlockSize(
    cv::Ptr&amp;lt;cv::StereoMatcher&amp;gt; *obj, int value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setBlockSize(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoMatcher_getSpeckleWindowSize
[32/64bit] calib3d_StereoMatcher_getSpeckleWindowSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): calib3d_StereoMatcher_getSpeckleWindowSize
元DLLエクスポート名: calib3d_StereoMatcher_getSpeckleWindowSize
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoMatcher_getSpeckleWindowSize(
    cv::Ptr&amp;lt;cv::StereoMatcher&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*obj)-&amp;gt;getSpeckleWindowSize();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoMatcher_setSpeckleWindowSize
[32/64bit] calib3d_StereoMatcher_setSpeckleWindowSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): calib3d_StereoMatcher_setSpeckleWindowSize
元DLLエクスポート名: calib3d_StereoMatcher_setSpeckleWindowSize
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoMatcher_setSpeckleWindowSize(
    cv::Ptr&amp;lt;cv::StereoMatcher&amp;gt; *obj, int value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setSpeckleWindowSize(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoMatcher_getSpeckleRange
[32/64bit] calib3d_StereoMatcher_getSpeckleRange
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): calib3d_StereoMatcher_getSpeckleRange
元DLLエクスポート名: calib3d_StereoMatcher_getSpeckleRange
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoMatcher_getSpeckleRange(
    cv::Ptr&amp;lt;cv::StereoMatcher&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*obj)-&amp;gt;getSpeckleRange();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoMatcher_setSpeckleRange
[32/64bit] calib3d_StereoMatcher_setSpeckleRange
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): calib3d_StereoMatcher_setSpeckleRange
元DLLエクスポート名: calib3d_StereoMatcher_setSpeckleRange
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoMatcher_setSpeckleRange(
    cv::Ptr&amp;lt;cv::StereoMatcher&amp;gt; *obj, int value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setSpeckleRange(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoMatcher_getDisp12MaxDiff
[32/64bit] calib3d_StereoMatcher_getDisp12MaxDiff
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): calib3d_StereoMatcher_getDisp12MaxDiff
元DLLエクスポート名: calib3d_StereoMatcher_getDisp12MaxDiff
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoMatcher_getDisp12MaxDiff(
    cv::Ptr&amp;lt;cv::StereoMatcher&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*obj)-&amp;gt;getDisp12MaxDiff();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoMatcher_setDisp12MaxDiff
[32/64bit] calib3d_StereoMatcher_setDisp12MaxDiff
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): calib3d_StereoMatcher_setDisp12MaxDiff
元DLLエクスポート名: calib3d_StereoMatcher_setDisp12MaxDiff
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoMatcher_setDisp12MaxDiff(
    cv::Ptr&amp;lt;cv::StereoMatcher&amp;gt; *obj, int value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setDisp12MaxDiff(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_Ptr_StereoBM_delete
[32/64bit] cv::StereoBM のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
K. KonoligeによってOpenCVに導入・貢献された，ブロックマッチングアルゴリズムを用いてステレオ対応点を計算するためのクラス．


元関数名(C#): calib3d_Ptr_StereoBM_delete
元DLLエクスポート名: calib3d_Ptr_StereoBM_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_Ptr_StereoBM_delete(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_Ptr_StereoBM_get
[32/64bit] cv::StereoBM のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
K. KonoligeによってOpenCVに導入・貢献された，ブロックマッチングアルゴリズムを用いてステレオ対応点を計算するためのクラス．


元関数名(C#): calib3d_Ptr_StereoBM_get
元DLLエクスポート名: calib3d_Ptr_StereoBM_get
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_Ptr_StereoBM_get(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, cv::StereoBM **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_create
[32/64bit] StereoBM オブジェクトを作成します．
%prm
p1,p2,p3
p1 = int : int numDisparities
p2 = int : int blockSize
p3 = var : out IntPtr returnValue
%inst
この関数は，StereoBM オブジェクトを作成します．そして，StereoBM::compute() を呼び出して，特定のステレオペアの視差を計算することができます．

元関数名(C#): calib3d_StereoBM_create
元DLLエクスポート名: calib3d_StereoBM_create
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_create(
    int numDisparities, int blockSize, cv::Ptr&amp;lt;cv::StereoBM&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto obj = cv::StereoBM::create(numDisparities, blockSize);
    *returnValue = clone(obj);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_getPreFilterType
[32/64bit] calib3d_StereoBM_getPreFilterType
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): calib3d_StereoBM_getPreFilterType
元DLLエクスポート名: calib3d_StereoBM_getPreFilterType
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_getPreFilterType(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*obj)-&amp;gt;getPreFilterType();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_setPreFilterType
[32/64bit] calib3d_StereoBM_setPreFilterType
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): calib3d_StereoBM_setPreFilterType
元DLLエクスポート名: calib3d_StereoBM_setPreFilterType
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_setPreFilterType(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, int value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setPreFilterType(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_getPreFilterSize
[32/64bit] calib3d_StereoBM_getPreFilterSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): calib3d_StereoBM_getPreFilterSize
元DLLエクスポート名: calib3d_StereoBM_getPreFilterSize
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_getPreFilterSize(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*obj)-&amp;gt;getPreFilterSize();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_setPreFilterSize
[32/64bit] calib3d_StereoBM_setPreFilterSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): calib3d_StereoBM_setPreFilterSize
元DLLエクスポート名: calib3d_StereoBM_setPreFilterSize
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_setPreFilterSize(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, int value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setPreFilterSize(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_getPreFilterCap
[32/64bit] calib3d_StereoBM_getPreFilterCap
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): calib3d_StereoBM_getPreFilterCap
元DLLエクスポート名: calib3d_StereoBM_getPreFilterCap
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_getPreFilterCap(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*obj)-&amp;gt;getPreFilterCap();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_setPreFilterCap
[32/64bit] calib3d_StereoBM_setPreFilterCap
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): calib3d_StereoBM_setPreFilterCap
元DLLエクスポート名: calib3d_StereoBM_setPreFilterCap
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_setPreFilterCap(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, int value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setPreFilterCap(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_getTextureThreshold
[32/64bit] calib3d_StereoBM_getTextureThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): calib3d_StereoBM_getTextureThreshold
元DLLエクスポート名: calib3d_StereoBM_getTextureThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_getTextureThreshold(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*obj)-&amp;gt;getTextureThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_setTextureThreshold
[32/64bit] calib3d_StereoBM_setTextureThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): calib3d_StereoBM_setTextureThreshold
元DLLエクスポート名: calib3d_StereoBM_setTextureThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_setTextureThreshold(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, int value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setTextureThreshold(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_getUniquenessRatio
[32/64bit] calib3d_StereoBM_getUniquenessRatio
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): calib3d_StereoBM_getUniquenessRatio
元DLLエクスポート名: calib3d_StereoBM_getUniquenessRatio
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_getUniquenessRatio(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*obj)-&amp;gt;getUniquenessRatio();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_setUniquenessRatio
[32/64bit] calib3d_StereoBM_setUniquenessRatio
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): calib3d_StereoBM_setUniquenessRatio
元DLLエクスポート名: calib3d_StereoBM_setUniquenessRatio
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_setUniquenessRatio(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, int value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setUniquenessRatio(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_getSmallerBlockSize
[32/64bit] calib3d_StereoBM_getSmallerBlockSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): calib3d_StereoBM_getSmallerBlockSize
元DLLエクスポート名: calib3d_StereoBM_getSmallerBlockSize
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_getSmallerBlockSize(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*obj)-&amp;gt;getSmallerBlockSize();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_setSmallerBlockSize
[32/64bit] calib3d_StereoBM_setSmallerBlockSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): calib3d_StereoBM_setSmallerBlockSize
元DLLエクスポート名: calib3d_StereoBM_setSmallerBlockSize
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_setSmallerBlockSize(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, int value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setSmallerBlockSize(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_getROI1
[32/64bit] calib3d_StereoBM_getROI1
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out Rect returnValue
%inst
元関数名(C#): calib3d_StereoBM_getROI1
元DLLエクスポート名: calib3d_StereoBM_getROI1
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_getROI1(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, MyCvRect *returnValue)
{
    BEGIN_WRAP
    *returnValue = c((*obj)-&amp;gt;getROI1());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_setROI1
[32bit] calib3d_StereoBM_setROI1
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = ARGS_RECT : Rect value
%inst
元関数名(C#): calib3d_StereoBM_setROI1
元DLLエクスポート名: calib3d_StereoBM_setROI1
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_setROI1(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, MyCvRect value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setROI1(cpp(value));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_setROI1
[64bit] calib3d_StereoBM_setROI1
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : Rect value
%inst
元関数名(C#): calib3d_StereoBM_setROI1
元DLLエクスポート名: calib3d_StereoBM_setROI1
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_setROI1(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, MyCvRect value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setROI1(cpp(value));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_getROI2
[32/64bit] calib3d_StereoBM_getROI2
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out Rect returnValue
%inst
元関数名(C#): calib3d_StereoBM_getROI2
元DLLエクスポート名: calib3d_StereoBM_getROI2
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_getROI2(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, MyCvRect *returnValue)
{
    BEGIN_WRAP
    *returnValue = c((*obj)-&amp;gt;getROI2());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_setROI2
[32bit] calib3d_StereoBM_setROI2
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = ARGS_RECT : Rect value
%inst
元関数名(C#): calib3d_StereoBM_setROI2
元DLLエクスポート名: calib3d_StereoBM_setROI2
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_setROI2(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, MyCvRect value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setROI2(cpp(value));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoBM_setROI2
[64bit] calib3d_StereoBM_setROI2
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : Rect value
%inst
元関数名(C#): calib3d_StereoBM_setROI2
元DLLエクスポート名: calib3d_StereoBM_setROI2
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoBM_setROI2(
    cv::Ptr&amp;lt;cv::StereoBM&amp;gt; *obj, MyCvRect value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setROI2(cpp(value));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_Ptr_StereoSGBM_get
[32/64bit] cv::StereoSGBM のインスタンスを破棄します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
このクラスは，修正された H. Hirschmuller アルゴリズム [111] を実装しており，オリジナルのアルゴリズムとは以下のように異なります．



createStereoSGBM で mode=StereoSGBM::MODE_HH を設定すると，アルゴリズムの完全なバリエーションが実行されますが，大量のメモリを消費する可能性があることに注意してください．

このアルゴリズムは、個々のピクセルではなく、ブロックをマッチングします。ただし、blockSize=1を設定すると、ブロックが単一のピクセルに縮小されます。

相互情報コスト関数は実装されていません。代わりに、[23]のより単純なBirchfield-Tomasiサブピクセルメトリックが使用されます。ただし、カラー画像にも対応しています。

K. KonoligeのアルゴリズムであるStereoBMのいくつかの前処理および後処理ステップが含まれています。例えば，プレフィルタリング（StereoBM::PREFILTER_XSOBEL型）およびポストフィルタリング（一意性チェック，2次補間，スペックルフィルタリング）があります。



備考

(Python) StereoSGBM マッチングアルゴリズムの使用例は、opencv_source_code/samples/python/stereo_match.py にあります。


元関数名(C#): calib3d_Ptr_StereoSGBM_get
元DLLエクスポート名: calib3d_Ptr_StereoSGBM_get
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_Ptr_StereoSGBM_get(
    cv::Ptr&amp;lt;cv::StereoSGBM&amp;gt; *obj, cv::StereoSGBM **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_Ptr_StereoSGBM_delete
[32/64bit] cv::StereoSGBM のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr obj
%inst
このクラスは，修正された H. Hirschmuller アルゴリズム [111] を実装しており，オリジナルのアルゴリズムとは以下のように異なります．



createStereoSGBM で mode=StereoSGBM::MODE_HH を設定すると，アルゴリズムの完全なバリエーションが実行されますが，大量のメモリを消費する可能性があることに注意してください．

このアルゴリズムは、個々のピクセルではなく、ブロックをマッチングします。ただし、blockSize=1を設定すると、ブロックが単一のピクセルに縮小されます。

相互情報コスト関数は実装されていません。代わりに、[23]のより単純なBirchfield-Tomasiサブピクセルメトリックが使用されます。ただし、カラー画像にも対応しています。

K. KonoligeのアルゴリズムであるStereoBMのいくつかの前処理および後処理ステップが含まれています。例えば，プレフィルタリング（StereoBM::PREFILTER_XSOBEL型）およびポストフィルタリング（一意性チェック，2次補間，スペックルフィルタリング）があります。



備考

(Python) StereoSGBM マッチングアルゴリズムの使用例は、opencv_source_code/samples/python/stereo_match.py にあります。


元関数名(C#): calib3d_Ptr_StereoSGBM_delete
元DLLエクスポート名: calib3d_Ptr_StereoSGBM_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_Ptr_StereoSGBM_delete(cv::Ptr&amp;lt;cv::StereoSGBM&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoSGBM_create
[32/64bit] StereoSGBMオブジェクトを作成します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12
p1 = int : int minDisparity
p2 = int : int numDisparities
p3 = int : int blockSize
p4 = int : int P1
p5 = int : int P2
p6 = int : int disp12MaxDiff
p7 = int : int preFilterCap
p8 = int : int uniquenessRatio
p9 = int : int speckleWindowSize
p10 = int : int speckleRange
p11 = int : int mode
p12 = var : out IntPtr returnValue
%inst
最初のコンストラクタは，すべてのデフォルトパラメータで StereoSGBM を初期化します。そのため，StereoSGBM::numDisparities を最小値に設定するだけでよいです。2番目のコンストラクタでは，各パラメータをカスタム値に設定することができます。

元関数名(C#): calib3d_StereoSGBM_create
元DLLエクスポート名: calib3d_StereoSGBM_create
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoSGBM_create(
    int minDisparity, int numDisparities, int blockSize,
    int P1, int P2, int disp12MaxDiff,
    int preFilterCap, int uniquenessRatio,
    int speckleWindowSize, int speckleRange, int mode,
    cv::Ptr&amp;lt;cv::StereoSGBM&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto obj = cv::StereoSGBM::create(
        minDisparity, numDisparities, blockSize,
        P1, P2, disp12MaxDiff,
        preFilterCap, uniquenessRatio,
        speckleWindowSize, speckleRange, mode);
    *returnValue = new cv::Ptr&amp;lt;cv::StereoSGBM&amp;gt;(obj);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoSGBM_getPreFilterCap
[32/64bit] calib3d_StereoSGBM_getPreFilterCap
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): calib3d_StereoSGBM_getPreFilterCap
元DLLエクスポート名: calib3d_StereoSGBM_getPreFilterCap
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoSGBM_getPreFilterCap(cv::Ptr&amp;lt;cv::StereoSGBM&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*obj)-&amp;gt;getPreFilterCap();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoSGBM_setPreFilterCap
[32/64bit] calib3d_StereoSGBM_setPreFilterCap
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): calib3d_StereoSGBM_setPreFilterCap
元DLLエクスポート名: calib3d_StereoSGBM_setPreFilterCap
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoSGBM_setPreFilterCap(cv::Ptr&amp;lt;cv::StereoSGBM&amp;gt; *obj, int value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setPreFilterCap(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoSGBM_getUniquenessRatio
[32/64bit] calib3d_StereoSGBM_getUniquenessRatio
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): calib3d_StereoSGBM_getUniquenessRatio
元DLLエクスポート名: calib3d_StereoSGBM_getUniquenessRatio
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoSGBM_getUniquenessRatio(cv::Ptr&amp;lt;cv::StereoSGBM&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*obj)-&amp;gt;getUniquenessRatio();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoSGBM_setUniquenessRatio
[32/64bit] calib3d_StereoSGBM_setUniquenessRatio
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): calib3d_StereoSGBM_setUniquenessRatio
元DLLエクスポート名: calib3d_StereoSGBM_setUniquenessRatio
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoSGBM_setUniquenessRatio(cv::Ptr&amp;lt;cv::StereoSGBM&amp;gt; *obj, int value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setUniquenessRatio(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoSGBM_getP1
[32/64bit] calib3d_StereoSGBM_getP1
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): calib3d_StereoSGBM_getP1
元DLLエクスポート名: calib3d_StereoSGBM_getP1
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoSGBM_getP1(cv::Ptr&amp;lt;cv::StereoSGBM&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*obj)-&amp;gt;getP1();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoSGBM_setP1
[32/64bit] calib3d_StereoSGBM_setP1
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): calib3d_StereoSGBM_setP1
元DLLエクスポート名: calib3d_StereoSGBM_setP1
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoSGBM_setP1(cv::Ptr&amp;lt;cv::StereoSGBM&amp;gt; *obj, int value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setP1(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoSGBM_getP2
[32/64bit] calib3d_StereoSGBM_getP2
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): calib3d_StereoSGBM_getP2
元DLLエクスポート名: calib3d_StereoSGBM_getP2
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoSGBM_getP2(cv::Ptr&amp;lt;cv::StereoSGBM&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*obj)-&amp;gt;getP2();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoSGBM_setP2
[32/64bit] calib3d_StereoSGBM_setP2
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): calib3d_StereoSGBM_setP2
元DLLエクスポート名: calib3d_StereoSGBM_setP2
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoSGBM_setP2(cv::Ptr&amp;lt;cv::StereoSGBM&amp;gt; *obj, int value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setP2(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoSGBM_getMode
[32/64bit] calib3d_StereoSGBM_getMode
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): calib3d_StereoSGBM_getMode
元DLLエクスポート名: calib3d_StereoSGBM_getMode
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoSGBM_getMode(cv::Ptr&amp;lt;cv::StereoSGBM&amp;gt; *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*obj)-&amp;gt;getMode();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
calib3d_StereoSGBM_setMode
[32/64bit] calib3d_StereoSGBM_setMode
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): calib3d_StereoSGBM_setMode
元DLLエクスポート名: calib3d_StereoSGBM_setMode
参照元CSファイル: Internal\PInvoke\NativeMethods\calib3d\NativeMethods_calib3d_StereoMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) calib3d_StereoSGBM_setMode(cv::Ptr&amp;lt;cv::StereoSGBM&amp;gt; *obj, int value)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;setMode(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_calib3d_StereoMatcher

%index
core_setBreakOnError
[32/64bit] ブレークオンエラーモードの設定/リセット。
%prm
p1
p1 = int : int flag
%inst
ブレークオンエラーモードが設定されていると、デフォルトのエラーハンドラがハードウェア例外を発行するので、デバッグが便利になります。例：samples/cpp/stitching_detailed.cpp.

元関数名(C#): core_setBreakOnError
元DLLエクスポート名: core_setBreakOnError
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(int) core_setBreakOnError(int flag)
{
    return cv::setBreakOnError(flag != 0) ? 1 : 0;
}

</pre>
}html
%group
NativeMethods_core

%index
redirectError
[32/64bit] 新しいエラーハンドラと、オプションのユーザデータを設定します。
%prm
p1,p2,p3
p1 = sptr : CvErrorCallback errCallback
p2 = sptr : IntPtr userdata
p3 = var : ref IntPtr prevUserdata
%inst
この関数は，cv::error()から呼び出される新しいエラーハンドラを設定します．

元関数名(C#): redirectError
元DLLエクスポート名: redirectError
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::ErrorCallback) redirectError(cv::ErrorCallback errCallback, void* userdata, void** prevUserdata)
{
    return cv::redirectError(errCallback, userdata, prevUserdata);
}

</pre>
}html
%group
NativeMethods_core

%index
core_glob
[32/64bit] 例： samples/cpp/train_HOG.cpp.
%prm
p1,p2,p3
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string pattern
p2 = sptr : IntPtr result
p3 = int : int recursive
%inst
元関数名(C#): core_glob
元DLLエクスポート名: core_glob
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_glob(const char *pattern, std::vector&amp;lt;std::string&amp;gt; *result, int recursive)
{
    BEGIN_WRAP
    cv::glob(pattern, *result, recursive != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_setNumThreads
[32/64bit] OpenCV は，次の並列領域のスレッド数の設定を試みます．
%prm
p1
p1 = int : int nthreads
%inst
threads == 0 の場合，OpenCV はスレッド最適化を無効にし，すべての関数を逐次実行します．threads < 0 を渡すと，スレッド数がシステムのデフォルトにリセットされます．OpenCV は，指定されたスレッド数で関数を実行しようとしますが，いくつかの動作はフレームワークと異なります： TBB - ユーザ定義の並列構造は，別のスレッドが指定されなければ，同じスレッド数で実行されます．後にユーザが独自のスケジューラを作成した場合，OpenCVはそれを使用します．

OpenMP - 特別に定義された動作はありません．

Concurrency - threads == 1 の場合，OpenCV はスレッドの最適化を無効にし，その関数を順次実行します．

GCD - <= 0 の値のみをサポートします．

C= - 特別な定義はありません．パラメータ

  

    nthreads OpenCV が利用するスレッド数．

  

  



関連項目： getNumThreads, getThreadNum

元関数名(C#): core_setNumThreads
元DLLエクスポート名: core_setNumThreads
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_setNumThreads(int nthreads)
{
    BEGIN_WRAP
    cv::setNumThreads(nthreads);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_getNumThreads
[32/64bit] OpenCVが並列領域で利用するスレッド数を返します．
%prm
p1
p1 = var : out int returnValue
%inst
OpenCVがスレッドをサポートせずに構築されている場合は，常に1を返します．戻り値の正確な意味は，OpenCVライブラリで利用されているスレッドフレームワークに依存します：TBB - OpenCVが並列領域に利用しようとするスレッド数．ユーザコード内の tbb::thread_scheduler_init が OpenCV と衝突している場合，この関数は TBB ライブラリで利用されるデフォルトのスレッド数を返します．

OpenMP - 新しいチームを形成するために使用されるスレッド数の上限。

Concurrency - OpenCV が並列領域に利用しようとするスレッド数．

GCD - サポートされていません．互換性のために，GCD スレッドプールの上限（512）を返します．

C= - OpenCV が並列領域で利用しようとするスレッド数． setNumThreads を呼び出す前に threads > 0 であれば，プロセスで利用可能な論理 CPU の数が返されます．関連項目： setNumThreads, getThreadNum

元関数名(C#): core_getNumThreads
元DLLエクスポート名: core_getNumThreads
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_getNumThreads(int* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::getNumThreads();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_getThreadNum
[32/64bit] 現在の並列領域内で、現在実行されているスレッドのインデックスを 返します。並列領域の外から呼び出された場合は、常に 0 を返します。
%prm
p1
p1 = var : out int returnValue
%inst
Deprecated：現在の実装は，このドキュメントに対応していません．戻り値の正確な意味は，OpenCV ライブラリで利用されているスレッドフレームワークに依存します： TBB - 現在の 4.1 TBB リリースではサポートされていません．将来的にはサポートされるかもしれません．

OpenMP - 呼び出したスレッドの，現在のチーム内のスレッド番号．

Concurrency - 現在のコンテキストが実行されている仮想プロセッサのID (マスタースレッドは0，その他は一意の番号，ただし，1,2,3,...は不要)．

GCD - システムを呼び出すスレッドのID。並列領域内では決して0を返しません。

C= - 現在の並列タスクのインデックスです．関連項目： setNumThreads, getNumThreads

元関数名(C#): core_getThreadNum
元DLLエクスポート名: core_getThreadNum
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_getThreadNum(int* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::getThreadNum();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_getBuildInformation
[32/64bit] 完全な設定時間の cmake 出力を返します。
%prm
p1
p1 = sptr : IntPtr buf
%inst
返される値は、バージョンコントロールシステムのリビジョン、コンパイラのバージョン、コンパイラフラグ、有効なモジュールやサードパーティライブラリなどを含む生の cmake 出力です。出力形式はターゲットのアーキテクチャに依存します。

元関数名(C#): core_getBuildInformation
元DLLエクスポート名: core_getBuildInformation
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_getBuildInformation(std::string *buf)
{
    BEGIN_WRAP
    const auto&amp; str = cv::getBuildInformation();
    buf-&amp;gt;assign(str);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_getVersionString
[32/64bit] ライブラリのバージョンを文字列で返します。
%prm
p1,p2
p1 = var : byte* buf
p2 = int : int maxLength
%inst
getMajorVersion, getMinorVersion, getRevisionVersionも参照してください。

元関数名(C#): core_getVersionString
元DLLエクスポート名: core_getVersionString
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_getVersionString(char *buf, int bufLength)
{
    BEGIN_WRAP
    const auto&amp; str = cv::getVersionString();
    copyString(str, buf, bufLength);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_getVersionMajor
[32/64bit] ライブラリのメジャーバージョンを返します。
%prm
p1
p1 = var : out int returnValue
%inst
元関数名(C#): core_getVersionMajor
元DLLエクスポート名: core_getVersionMajor
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_getVersionMajor(int* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::getVersionMajor();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_getVersionMinor
[32/64bit] ライブラリのメジャーバージョンを返します マイナーバージョンを返します
%prm
p1
p1 = var : out int returnValue
%inst
元関数名(C#): core_getVersionMinor
元DLLエクスポート名: core_getVersionMinor
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_getVersionMinor(int* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::getVersionMinor();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_getVersionRevision
[32/64bit] ライブラリのバージョンのリビジョン欄を返します
%prm
p1
p1 = var : out int returnValue
%inst
元関数名(C#): core_getVersionRevision
元DLLエクスポート名: core_getVersionRevision
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_getVersionRevision(int* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::getVersionRevision();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_getTickCount
[32/64bit] 刻みの数を返します。
%prm
p1
p1 = var : out long returnValue
%inst
この関数は、特定のイベント（例えば、マシンの電源が入った時など）の後のティック数を返します。他にもgetTickFrequency、TickMeterExamples: fld_lines.cpp、samples/cpp/facedetect.cpp、samples/cpp/image_alignment.cpp、samples/cpp/peopledetect.cpp、samples/cpp/stitching_detailed.cpp、samples/cpp/watershed.cpp、samples/tapi/hog.cpp、samples/tapi/squares.cppを参照してください。

元関数名(C#): core_getTickCount
元DLLエクスポート名: core_getTickCount
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_getTickCount(int64* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::getTickCount();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_getTickFrequency
[32/64bit] 1秒あたりの目盛りの数を返します。
%prm
p1
p1 = var : out double returnValue
%inst
この関数は、1秒あたりの目盛りの数を返します。つまり、次のコードは、実行時間を秒単位で計算します。double t = (double)getTickCount();// 何かをする ...t = ((double)getTickCount() - t)/getTickFrequency();fragmentSee alsogetTickCount, TickMeterExamples: fld_lines.cpp, samples/cpp/facedetect.cpp、samples/cpp/image_alignment.cpp、samples/cpp/peopledetect.cpp、samples/cpp/stitching_detailed.cpp、samples/cpp/watershed.cpp、samples/dnn/classification.cpp、samples/dnn/object_detection.cpp、samples/dnn/segmentation.cpp、samples/tapi/hog.cpp、samples/tapi/squares.cppがあります。

元関数名(C#): core_getTickFrequency
元DLLエクスポート名: core_getTickFrequency
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_getTickFrequency(double* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::getTickFrequency();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_getCPUTickCount
[32/64bit] CPUティック数を返します。
%prm
p1
p1 = var : out long returnValue
%inst
この関数は、一部のアーキテクチャ（x86、x64、PowerPCなど）では、現在のCPUチック数を返します。その他のプラットフォームでは，この関数はgetTickCountと同等です。この関数は，非常に正確な時間の測定や，RNGの初期化にも使用できます．マルチCPUシステムの場合，getCPUTickCountが呼び出されたスレッドは中断され，別のCPUで独自のカウンタを使って再開できることに注意してください。そのため，理論的には（そして実際には），この関数の後続の呼び出しは，単調に増加する値を返す必要はありません。また，最近のCPUは負荷に応じてCPUの周波数を変化させるため，あるコードに費やされたCPUクロック数を時間単位に直接変換することはできません。そのため、実行時間を計測するには、一般的にgetTickCountの方が望ましいとされています。

元関数名(C#): core_getCPUTickCount
元DLLエクスポート名: core_getCPUTickCount
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_getCPUTickCount(int64* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::getCPUTickCount();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_checkHardwareSupport
[32/64bit] 指定された機能がホストハードウェアでサポートされている場合、trueを返します。
%prm
p1,p2
p1 = int : int feature
p2 = var : out int returnValue
%inst
この関数は，ホストハードウェアが指定された機能をサポートしていれば，真を返します．ユーザが setUseOptimized(false) を呼び出すと，それ以降の checkHardwareSupport() は，setUseOptimized(true) が呼び出されるまで false を返します．このようにして，ユーザは OpenCV で最適化されたコードを動的にオン・オフすることができます．

元関数名(C#): core_checkHardwareSupport
元DLLエクスポート名: core_checkHardwareSupport
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_checkHardwareSupport(int feature, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::checkHardwareSupport(feature) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_getHardwareFeatureName
[32/64bit] ID によるフィーチャー名を返します．
%prm
p1,p2
p1 = int : int feature
p2 = sptr : IntPtr buf
%inst
機能が定義されていない場合は，空の文字列を返します．

元関数名(C#): core_getHardwareFeatureName
元DLLエクスポート名: core_getHardwareFeatureName
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_getHardwareFeatureName(int feature, std::string *buf)
{
    BEGIN_WRAP
    const auto&amp; str = cv::getHardwareFeatureName(feature);
    buf-&amp;gt;assign(str);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_getCPUFeaturesLine
[32/64bit] コンパイル時に有効な CPU 機能のリストを返します．
%prm
p1
p1 = sptr : IntPtr buf
%inst
返される値は，CPU機能のリストをスペースで区切った文字列で，以下のマーカーが付いています： no markers - ベースライン機能

prefix * - ディスパッチャーで有効になった機能

suffix ?- 有効だがHWExampleでは使用できない機能。sse sse2 sse3 *sse4.1 *sse4.2 *fp16 *avx *avx2 *avx512-skx?

元関数名(C#): core_getCPUFeaturesLine
元DLLエクスポート名: core_getCPUFeaturesLine
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_getCPUFeaturesLine(std::string *buf)
{
    BEGIN_WRAP
    const auto&amp; str = cv::getCPUFeaturesLine();
    buf-&amp;gt;assign(str);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_getNumberOfCPUs
[32/64bit] プロセスで使用可能な論理 CPU の数を返します。
%prm
p1
p1 = var : out int returnValue
%inst
元関数名(C#): core_getNumberOfCPUs
元DLLエクスポート名: core_getNumberOfCPUs
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_getNumberOfCPUs(int* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::getNumberOfCPUs();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_setUseOptimized
[32/64bit] 最適化されたコードを有効にしたり無効にしたりします。
%prm
p1
p1 = int : int onoff
%inst
この関数は，最適化されたディスパッチコード（SSE4.2やAVX/AVX2などの命令をサポートするプラットフォームで使用されるコード）を動的にオン／オフするために使用できます。これは，OpenCVの関数によってさらにチェックされるグローバルフラグを設定します．このフラグは，OpenCV の内部ループではチェックされないので，アプリケーションの最上位で，他の OpenCV 関数が実行されていないことが確認できる場合にのみ，この関数を呼び出すのが安全です．デフォルトでは，CMake で無効にしない限り，最適化されたコードが有効になります．現在の状態は， useOptimized で取得できます．

元関数名(C#): core_setUseOptimized
元DLLエクスポート名: core_setUseOptimized
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_setUseOptimized(int onoff)
{
    BEGIN_WRAP
    cv::setUseOptimized(onoff != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_useOptimized
[32/64bit] 最適化されたコードの使用状況を返します．
%prm
p1
p1 = var : out int returnValue
%inst
この関数は，最適化されたコードが有効な場合は true を返します。それ以外の場合は false を返します。

元関数名(C#): core_useOptimized
元DLLエクスポート名: core_useOptimized
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_useOptimized(int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::useOptimized() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_format
[32/64bit] core_format
%prm
p1,p2,p3
p1 = sptr : IntPtr mtx
p2 = int : int fmt
p3 = sptr : IntPtr buf
%inst
元関数名(C#): core_format
元DLLエクスポート名: core_format
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_format(cv::_InputArray *mtx, int fmt, std::string *buf)
{
    BEGIN_WRAP
    const auto formatted = cv::format(*mtx, static_cast&amp;lt;cv::Formatter::FormatType&amp;gt;(fmt));

    std::stringstream s;
    s &amp;lt;&amp;lt; formatted;
    buf-&amp;gt;assign(s.str());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_borderInterpolate
[32/64bit] 外挿したピクセルのソース位置を計算します。
%prm
p1,p2,p3,p4
p1 = int : int p
p2 = int : int len
p3 = int : int borderType
p4 = var : out int returnValue
%inst
この関数は，指定された外挿分割モードを用いた場合に，指定された外挿分割ピクセルに対応するドナーピクセルの座標を計算して返します．例えば，水平方向に cv::BORDER_WRAP モード，垂直方向に cv::BORDER_REFLECT_101 モードを利用し，浮動小数点型画像 img の「仮想」ピクセル Point(-5, 100) の値を求める場合，次のようになります： float val = img.at<float>(borderInterpolate(100, img.rows, cv::BORDER_REFLECT_101), borderInterpolate(-5, img.cols, cv::BORDER_WRAP));fragment通常，この関数が直接呼ばれることはありません．この関数は，フィルタリング関数の内部や，copyMakeBorderの中で利用されます．

元関数名(C#): core_borderInterpolate
元DLLエクスポート名: core_borderInterpolate
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_borderInterpolate(int p, int len, int borderType, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::borderInterpolate(p, len, borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_copyMakeBorder
[32bit] 画像の周りに境界線を形成します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int top
p4 = int : int bottom
p5 = int : int left
p6 = int : int right
p7 = int : int borderType
p8 = ARGS_SCALAR : Scalar value
%inst
この関数は，入力画像を出力画像の中央にコピーします．コピーされたソース画像の左、右、上、下の領域は、外挿されたピクセルで埋められます。これは，この関数を基にしたフィルタリング関数が行っていること（オンザフライでピクセルを外挿すること）とは異なりますが，あなた自身の関数を含む他のより複雑な関数が，画像の境界処理を簡単にするために行っていることもあります． この関数は，src が既に dst の中央にある場合のモードをサポートしています．この場合，この関数は src 自身をコピーせず，単に境界を作成します．例えば，次のようにします： // 境界はすべての方向で同じであるとするint border=2;// 画像と境界の両方に合うように，より大きな画像を作成するMat gray_buf(rgb.rows + border*2, rgb.cols + border*2, rgb.depth());// dataMat gray(gray_canvas, Rect(border, border, rgb.cols, rgb.rows));// 画像を RGB からグレースケールに変換するecvtColor(rgb, gray, COLOR_RGB2GRAY);// その場で境界線を形成するcopyMakeBorder(gray, gray_buf, border, border, border, BORDER_REPLICATE);// 独自のフィルタリングを行う ......fragment注：入力画像が大きな画像の一部（ROI）である場合、この関数は ROI の外側のピクセルを使って境界線を形成しようとします。この機能を無効にして、あたかもsrcがROIでないかのように常に外挿するには、 borderType | BORDER_ISOLATEDを使用してください。他にもborderInterpolateExamples: samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cppを参照してください。

元関数名(C#): core_copyMakeBorder
元DLLエクスポート名: core_copyMakeBorder
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_copyMakeBorder(
    cv::_InputArray* src, cv::_OutputArray* dst, int top, int bottom, int left, int right, int borderType, MyCvScalar value)
{
    BEGIN_WRAP
    cv::copyMakeBorder(*src, *dst, top, bottom, left, right, borderType, cpp(value));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_copyMakeBorder
[64bit] 画像の周りに境界線を形成します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int top
p4 = int : int bottom
p5 = int : int left
p6 = int : int right
p7 = int : int borderType
p8 = var : Scalar value
%inst
この関数は，入力画像を出力画像の中央にコピーします．コピーされたソース画像の左、右、上、下の領域は、外挿されたピクセルで埋められます。これは，この関数を基にしたフィルタリング関数が行っていること（オンザフライでピクセルを外挿すること）とは異なりますが，あなた自身の関数を含む他のより複雑な関数が，画像の境界処理を簡単にするために行っていることもあります． この関数は，src が既に dst の中央にある場合のモードをサポートしています．この場合，この関数は src 自身をコピーせず，単に境界を作成します．例えば，次のようにします： // 境界はすべての方向で同じであるとするint border=2;// 画像と境界の両方に合うように，より大きな画像を作成するMat gray_buf(rgb.rows + border*2, rgb.cols + border*2, rgb.depth());// dataMat gray(gray_canvas, Rect(border, border, rgb.cols, rgb.rows));// 画像を RGB からグレースケールに変換するecvtColor(rgb, gray, COLOR_RGB2GRAY);// その場で境界線を形成するcopyMakeBorder(gray, gray_buf, border, border, border, BORDER_REPLICATE);// 独自のフィルタリングを行う ......fragment注：入力画像が大きな画像の一部（ROI）である場合、この関数は ROI の外側のピクセルを使って境界線を形成しようとします。この機能を無効にして、あたかもsrcがROIでないかのように常に外挿するには、 borderType | BORDER_ISOLATEDを使用してください。他にもborderInterpolateExamples: samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cppを参照してください。

元関数名(C#): core_copyMakeBorder
元DLLエクスポート名: core_copyMakeBorder
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_copyMakeBorder(
    cv::_InputArray* src, cv::_OutputArray* dst, int top, int bottom, int left, int right, int borderType, MyCvScalar value)
{
    BEGIN_WRAP
    cv::copyMakeBorder(*src, *dst, top, bottom, left, right, borderType, cpp(value));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_add
[32/64bit] 2つの配列，または配列とスカラの要素毎の和を求めます．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
p4 = sptr : IntPtr mask
p5 = int : int dtype
%inst
関数 add は，同じサイズ，同じチャンネル数の入力配列を持つ2つの配列の和を求めます．

\I） = ????? ( ????? )\♪♪〜





src2 が Scalar で構成されているか，または src1.channels() と同じ数の要素を持つ場合，配列とスカラの和になります．

\I） = ????? ( ????? )\I (if mask}(I)





src1 が Scalar で構成されている場合や， src2.channels() と同じ数の要素を持つ場合に，スカラと配列の和を求めます．

\I） = ????? ( ????? )+ ????? )\I (I)



 ここで I は，配列要素の多次元インデックスです．上のリストの最初の関数は，行列式に置き換えることができます： dst = src1 + src2;dst += src1; // add(dst, src1, dst);fragment入力配列と出力配列のビット深度は，すべて同じでも異なっていても構いません．例えば，16 ビットの符号なし配列と 8 ビットの符号あり配列を加算し，その和を 32 ビットの浮動小数点配列として格納することができます．出力配列の深さは、dtypeパラメータで決定されます。上記の 2 番目と 3 番目のケース，そして最初のケースと同様に， src1.depth() == src2.depth() の場合， dtype をデフォルトの -1 に設定することができます． この場合，出力配列のビット深度は， src1，src2，またはその両方の入力配列と同じになります． 注意出力配列のビット深度が CV_32S の場合，彩度は適用されません．subtract, addWeighted, scaleAdd, Mat::convertToExamples も参照してください： modules/shape/samples/shape_example.cpp.

元関数名(C#): core_add
元DLLエクスポート名: core_add
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_add(
    cv::_InputArray *src1, cv::_InputArray *src2, cv::_OutputArray *dst, cv::_InputArray *mask, int dtype)
{
    BEGIN_WRAP
    cv::add(*src1, *src2, *dst, entity(mask), dtype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_subtract_InputArray2
[32/64bit] 2 つの配列同士，あるいは配列とスカラの要素毎の差を求めます．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
p4 = sptr : IntPtr mask
p5 = int : int dtype
%inst
関数 subtract は，入力配列が同じサイズ，同じチャンネル数の場合に，2つの配列の差を計算します．

\I） = ????? ( ????? )\I (if mask}(I)





src2 が Scalar で構成されている場合や src1.channels() と同じ数の要素を持つ場合の，配列とスカラの違い。

\I） = ????? ( ????? )\I (if mask}(I)





src1 が Scalar で構成されている場合や， src2.channels() と同じ数の要素を持つ場合の，スカラと配列の違いです．

\I） = ????? ( ????? )- src2}(I)\♪♪〜





SubRSの場合、スカラとアレイの違いは逆です。

\\\\ ( ????? )\I (if mask}(I)



 ここで I は，配列要素の多次元インデックスです．上のリストの最初の関数は，行列式に置き換えることができます： dst = src1 - src2;dst -= src1; // subtract(dst, src1, dst) と等価です;fragment入力配列と出力配列のビット深度は，すべて同じでも異なっていても構いません．例えば，8 ビットの符号なし配列に対して減算を行い，その差を 16 ビットの符号付き配列に格納することができます．出力配列の深さは，dtypeパラメータで決まります．上記の 2 番目と 3 番目のケース，そして最初のケースと同様に， src1.depth() == src2.depth() の場合， dtype をデフォルトの -1 に設定することができます． この場合，出力配列のビット深度は， src1，src2，またはその両方の入力配列と同じになります．See alsoadd, addWeighted, scaleAdd, Mat::convertToExamples: samples/cpp/image_alignment.cpp.

元関数名(C#): core_subtract_InputArray2
元DLLエクスポート名: core_subtract_InputArray2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_subtract_InputArray2(
    cv::_InputArray *src1, cv::_InputArray *src2, cv::_OutputArray *dst, cv::_InputArray *mask, int dtype)
{
    BEGIN_WRAP
    cv::subtract(*src1, *src2, *dst, entity(mask), dtype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_subtract_InputArrayScalar
[32bit] 2 つの配列同士，あるいは配列とスカラの要素毎の差を求めます．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src1
p2 = ARGS_SCALAR : Scalar src2
p3 = sptr : IntPtr dst
p4 = sptr : IntPtr mask
p5 = int : int dtype
%inst
関数 subtract は，入力配列が同じサイズ，同じチャンネル数の場合に，2つの配列の差を計算します．

\I） = ????? ( ????? )\I (if mask}(I)





src2 が Scalar で構成されている場合や src1.channels() と同じ数の要素を持つ場合の，配列とスカラの違い。

\I） = ????? ( ????? )\I (if mask}(I)





src1 が Scalar で構成されている場合や， src2.channels() と同じ数の要素を持つ場合の，スカラと配列の違いです．

\I） = ????? ( ????? )- src2}(I)\♪♪〜





SubRSの場合、スカラとアレイの違いは逆です。

\\\\ ( ????? )\I (if mask}(I)



 ここで I は，配列要素の多次元インデックスです．上のリストの最初の関数は，行列式に置き換えることができます： dst = src1 - src2;dst -= src1; // subtract(dst, src1, dst) と等価です;fragment入力配列と出力配列のビット深度は，すべて同じでも異なっていても構いません．例えば，8 ビットの符号なし配列に対して減算を行い，その差を 16 ビットの符号付き配列に格納することができます．出力配列の深さは，dtypeパラメータで決まります．上記の 2 番目と 3 番目のケース，そして最初のケースと同様に， src1.depth() == src2.depth() の場合， dtype をデフォルトの -1 に設定することができます． この場合，出力配列のビット深度は， src1，src2，またはその両方の入力配列と同じになります．See alsoadd, addWeighted, scaleAdd, Mat::convertToExamples: samples/cpp/image_alignment.cpp.

元関数名(C#): core_subtract_InputArrayScalar
元DLLエクスポート名: core_subtract_InputArrayScalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_subtract_InputArrayScalar(
    cv::_InputArray *src1, MyCvScalar src2, cv::_OutputArray *dst, cv::_InputArray *mask, int dtype)
{
    BEGIN_WRAP
    cv::subtract(*src1, cpp(src2), *dst, entity(mask), dtype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_subtract_InputArrayScalar
[64bit] 2 つの配列同士，あるいは配列とスカラの要素毎の差を求めます．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src1
p2 = var : Scalar src2
p3 = sptr : IntPtr dst
p4 = sptr : IntPtr mask
p5 = int : int dtype
%inst
関数 subtract は，入力配列が同じサイズ，同じチャンネル数の場合に，2つの配列の差を計算します．

\I） = ????? ( ????? )\I (if mask}(I)





src2 が Scalar で構成されている場合や src1.channels() と同じ数の要素を持つ場合の，配列とスカラの違い。

\I） = ????? ( ????? )\I (if mask}(I)





src1 が Scalar で構成されている場合や， src2.channels() と同じ数の要素を持つ場合の，スカラと配列の違いです．

\I） = ????? ( ????? )- src2}(I)\♪♪〜





SubRSの場合、スカラとアレイの違いは逆です。

\\\\ ( ????? )\I (if mask}(I)



 ここで I は，配列要素の多次元インデックスです．上のリストの最初の関数は，行列式に置き換えることができます： dst = src1 - src2;dst -= src1; // subtract(dst, src1, dst) と等価です;fragment入力配列と出力配列のビット深度は，すべて同じでも異なっていても構いません．例えば，8 ビットの符号なし配列に対して減算を行い，その差を 16 ビットの符号付き配列に格納することができます．出力配列の深さは，dtypeパラメータで決まります．上記の 2 番目と 3 番目のケース，そして最初のケースと同様に， src1.depth() == src2.depth() の場合， dtype をデフォルトの -1 に設定することができます． この場合，出力配列のビット深度は， src1，src2，またはその両方の入力配列と同じになります．See alsoadd, addWeighted, scaleAdd, Mat::convertToExamples: samples/cpp/image_alignment.cpp.

元関数名(C#): core_subtract_InputArrayScalar
元DLLエクスポート名: core_subtract_InputArrayScalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_subtract_InputArrayScalar(
    cv::_InputArray *src1, MyCvScalar src2, cv::_OutputArray *dst, cv::_InputArray *mask, int dtype)
{
    BEGIN_WRAP
    cv::subtract(*src1, cpp(src2), *dst, entity(mask), dtype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_subtract_ScalarInputArray
[32bit] 2 つの配列同士，あるいは配列とスカラの要素毎の差を求めます．
%prm
p1,p2,p3,p4,p5
p1 = ARGS_SCALAR : Scalar src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
p4 = sptr : IntPtr mask
p5 = int : int dtype
%inst
関数 subtract は，入力配列が同じサイズ，同じチャンネル数の場合に，2つの配列の差を計算します．

\I） = ????? ( ????? )\I (if mask}(I)





src2 が Scalar で構成されている場合や src1.channels() と同じ数の要素を持つ場合の，配列とスカラの違い。

\I） = ????? ( ????? )\I (if mask}(I)





src1 が Scalar で構成されている場合や， src2.channels() と同じ数の要素を持つ場合の，スカラと配列の違いです．

\I） = ????? ( ????? )- src2}(I)\♪♪〜





SubRSの場合、スカラとアレイの違いは逆です。

\\\\ ( ????? )\I (if mask}(I)



 ここで I は，配列要素の多次元インデックスです．上のリストの最初の関数は，行列式に置き換えることができます： dst = src1 - src2;dst -= src1; // subtract(dst, src1, dst) と等価です;fragment入力配列と出力配列のビット深度は，すべて同じでも異なっていても構いません．例えば，8 ビットの符号なし配列に対して減算を行い，その差を 16 ビットの符号付き配列に格納することができます．出力配列の深さは，dtypeパラメータで決まります．上記の 2 番目と 3 番目のケース，そして最初のケースと同様に， src1.depth() == src2.depth() の場合， dtype をデフォルトの -1 に設定することができます． この場合，出力配列のビット深度は， src1，src2，またはその両方の入力配列と同じになります．See alsoadd, addWeighted, scaleAdd, Mat::convertToExamples: samples/cpp/image_alignment.cpp.

元関数名(C#): core_subtract_ScalarInputArray
元DLLエクスポート名: core_subtract_ScalarInputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_subtract_ScalarInputArray(
    MyCvScalar src1, cv::_InputArray *src2, cv::_OutputArray *dst, cv::_InputArray *mask, int dtype)
{
    BEGIN_WRAP
    cv::subtract(cpp(src1), *src2, *dst, entity(mask), dtype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_subtract_ScalarInputArray
[64bit] 2 つの配列同士，あるいは配列とスカラの要素毎の差を求めます．
%prm
p1,p2,p3,p4,p5
p1 = var : Scalar src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
p4 = sptr : IntPtr mask
p5 = int : int dtype
%inst
関数 subtract は，入力配列が同じサイズ，同じチャンネル数の場合に，2つの配列の差を計算します．

\I） = ????? ( ????? )\I (if mask}(I)





src2 が Scalar で構成されている場合や src1.channels() と同じ数の要素を持つ場合の，配列とスカラの違い。

\I） = ????? ( ????? )\I (if mask}(I)





src1 が Scalar で構成されている場合や， src2.channels() と同じ数の要素を持つ場合の，スカラと配列の違いです．

\I） = ????? ( ????? )- src2}(I)\♪♪〜





SubRSの場合、スカラとアレイの違いは逆です。

\\\\ ( ????? )\I (if mask}(I)



 ここで I は，配列要素の多次元インデックスです．上のリストの最初の関数は，行列式に置き換えることができます： dst = src1 - src2;dst -= src1; // subtract(dst, src1, dst) と等価です;fragment入力配列と出力配列のビット深度は，すべて同じでも異なっていても構いません．例えば，8 ビットの符号なし配列に対して減算を行い，その差を 16 ビットの符号付き配列に格納することができます．出力配列の深さは，dtypeパラメータで決まります．上記の 2 番目と 3 番目のケース，そして最初のケースと同様に， src1.depth() == src2.depth() の場合， dtype をデフォルトの -1 に設定することができます． この場合，出力配列のビット深度は， src1，src2，またはその両方の入力配列と同じになります．See alsoadd, addWeighted, scaleAdd, Mat::convertToExamples: samples/cpp/image_alignment.cpp.

元関数名(C#): core_subtract_ScalarInputArray
元DLLエクスポート名: core_subtract_ScalarInputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_subtract_ScalarInputArray(
    MyCvScalar src1, cv::_InputArray *src2, cv::_OutputArray *dst, cv::_InputArray *mask, int dtype)
{
    BEGIN_WRAP
    cv::subtract(cpp(src1), *src2, *dst, entity(mask), dtype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_multiply
[32/64bit] 2 つの配列の要素毎のスケーリングされた積を求めます．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
p4 = double : double scale
p5 = int : int dtype
%inst
関数 multiply は，2つの配列の要素毎の積を計算します： ????? )(I)= \\\ ( ????? )\♪♪♪♪♪〜(I）\\\\(I))には，MatrixExpressions に適した最初の関数もあります．Mat::mul を参照してください．また，要素毎ではない行列積については， gemm を参照してください．また，add, subtract, divide, scaleAdd, addWeighted, accumulate, accumulateProduct, accumulateSquare, Mat::convertTo も参照してください．

元関数名(C#): core_multiply
元DLLエクスポート名: core_multiply
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_multiply(
    cv::_InputArray *src1, cv::_InputArray *src2, cv::_OutputArray *dst, double scale, int dtype)
{
    BEGIN_WRAP
    cv::multiply(*src1, *src2, *dst, scale, dtype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_divide1
[32/64bit] 2 つの配列，あるいはスカラを配列で割る，要素毎の除算を行います．
%prm
p1,p2,p3,p4
p1 = double : double scale
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
p4 = int : int dtype
%inst
関数 cv::divide は，ある配列を別の配列で分割します．また，src1 が存在しない場合は，スカラを配列で分割します．整数型の場合，src2(I)が0のとき，dst(I)も0になります．注：浮動小数点データの場合，src2(I)が0のときの特別な動作は定義されていません．通常の浮動小数点演算が行われます。浮動小数点データ（NaN，Infの結果値を含む）に対するIEEE754の正しい動作を期待してください。



出力配列のビット深度が CV_32S の場合，Saturation は適用されません．他にも，omultiply, add, subtractExamples: samples/dnn/classification.cpp を参照してください．

元関数名(C#): core_divide1
元DLLエクスポート名: core_divide1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_divide1(
    double scale, cv::_InputArray *src2, cv::_OutputArray *dst, int dtype)
{
    BEGIN_WRAP
    cv::divide(scale, *src2, *dst, dtype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_divide2
[32/64bit] 2 つの配列，あるいはスカラを配列で割る，要素毎の除算を行います．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
p4 = double : double scale
p5 = int : int dtype
%inst
関数 cv::divide は，ある配列を別の配列で分割します．また，src1 が存在しない場合は，スカラを配列で分割します．整数型の場合，src2(I)が0のとき，dst(I)も0になります．注：浮動小数点データの場合，src2(I)が0のときの特別な動作は定義されていません．通常の浮動小数点演算が行われます。浮動小数点データ（NaN，Infの結果値を含む）に対するIEEE754の正しい動作を期待してください。



出力配列のビット深度が CV_32S の場合，Saturation は適用されません．他にも，omultiply, add, subtractExamples: samples/dnn/classification.cpp を参照してください．

元関数名(C#): core_divide2
元DLLエクスポート名: core_divide2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_divide2(
    cv::_InputArray *src1, cv::_InputArray *src2, cv::_OutputArray *dst, double scale, int dtype)
{
    BEGIN_WRAP
    cv::divide(*src1, *src2, *dst, scale, dtype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_scaleAdd
[32/64bit] スケーリングされた配列と別の配列の和を計算します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src1
p2 = double : double alpha
p3 = sptr : IntPtr src2
p4 = sptr : IntPtr dst
%inst
関数 scaleAdd は，古典的な原始線形代数演算の一つで，BLAS では DAXPY または SAXPY として知られています．スケーリングされた配列と別の配列の和を計算します。(I)= \\\\\\\\(I) + ??? -? ????(Mat A(3, 3, CV_64F);...A.row(0) = A.row(1)*2 + A.row(2);fragmentSee alsoadd, addWeighted, subtract, Mat::dot, Mat::convertTo

元関数名(C#): core_scaleAdd
元DLLエクスポート名: core_scaleAdd
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_scaleAdd(cv::_InputArray *src1, double alpha, cv::_InputArray *src2, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::scaleAdd(*src1, alpha, *src2, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_addWeighted
[32/64bit] 2 つの配列の加重和を求めます．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src1
p2 = double : double alpha
p3 = sptr : IntPtr src2
p4 = double : double beta
p5 = double : double gamma
p6 = sptr : IntPtr dst
p7 = int : int dtype
%inst
関数 addWeighted は，次のように2つの配列の加重和を計算します： ??? -? ??? ???? ???? ??? -? ???(I)= ????? ( ????? )(I）* ????? + ?????(I)* ????? )]ここで I は，配列要素の多次元インデックスです．マルチチャンネル配列の場合は，各チャンネルが独立して処理されます．この関数は，行列式に置き換えることができます： dst = src1*alpha + src2*beta + gamma;fragment注 出力配列のビット深度が CV_32S の場合，彩度は適用されません．Add, subtract, scaleAdd, Mat::convertToExamples: samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/dnn/segmentation.cpp も参照してください．

元関数名(C#): core_addWeighted
元DLLエクスポート名: core_addWeighted
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_addWeighted(cv::_InputArray *src1, double alpha, cv::_InputArray *src2,
                             double beta, double gamma, cv::_OutputArray *dst, int dtype)
{
    BEGIN_WRAP
    cv::addWeighted(*src1, alpha, *src2, beta, gamma, *dst, dtype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_convertScaleAbs
[32/64bit] スケーリングを行い、絶対値を計算し、結果を8ビットに変換します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = double : double alpha
p4 = double : double beta
%inst
関数 convertScaleAbs は，入力配列の各要素に対して，スケーリング，絶対値の取得，符号なし8ビット型への変換，という3つの処理を順次行います．(I)= \\\\(| | src})(I)* ????? )]マルチチャンネル配列の場合は，各チャンネルを独立して処理します．出力が 8 ビットではない場合， Mat::convertTo メソッドを呼び出して（あるいは，行列式を利用して），その結果の絶対値を計算することで，この処理をエミュレートすることができます．例えば，Mat_<float> A(30,30);randu(A, Scalar(-100), Scalar(100));Mat_<float> B = A*5 + 3;B = abs(B);// Mat_<float> B = abs(A*5+3) でも動作しますが，一時的な行列フラグメントが確保されます． 参照：Mat::convertTo, cv::abs(const Mat&)例： samples/cpp/laplace.cpp, および samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp.

元関数名(C#): core_convertScaleAbs
元DLLエクスポート名: core_convertScaleAbs
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_convertScaleAbs(cv::_InputArray* src, cv::_OutputArray* dst, double alpha, double beta)
{
    BEGIN_WRAP
    cv::convertScaleAbs(*src, *dst, alpha, beta);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_convertFp16
[32/64bit] 配列を半精度浮動小数点数に変換します．
%prm
p1,p2
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
%inst
この関数は，FP32（単精度浮動小数点）をFP16（半精度浮動小数点）と相互に変換します．CV_16S フォーマットは，FP16 データを表現するために利用されます．2つの使用モード（ src -> dst ）があります．CV_32F -> CV_16S と CV_16S -> CV_32F です．CV_32F -> CV_16S と CV_16S -> CV_32F です．ビット深度を表すためには，入力配列の型が CV_32F か CV_16S でなければいけません．入力配列がそのどちらでもない場合，この関数はエラーを発生させます．半精度浮動小数点のフォーマットは，IEEE 754-2008 で定義されています．

元関数名(C#): core_convertFp16
元DLLエクスポート名: core_convertFp16
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_convertFp16(cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::convertFp16(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_LUT
[32/64bit] 配列に対して，ルックアップテーブル変換を行います．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr lut
p3 = sptr : IntPtr dst
%inst
関数 LUT は，ルックアップテーブルの値で出力配列を埋めます．エントリのインデックスは，入力配列から取得されます．つまり，この関数は src の各要素を以下のように処理します．\d = ????? ) if ????? )Mat::convertTo

元関数名(C#): core_LUT
元DLLエクスポート名: core_LUT
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_LUT(cv::_InputArray* src, cv::_InputArray* lut, cv::_OutputArray* dst)
{
    BEGIN_WRAP
    cv::LUT(*src, *lut, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_sum
[32/64bit] 配列の要素の和を求めます．
%prm
p1,p2
p1 = sptr : IntPtr src
p2 = var : out Scalar returnValue
%inst
関数 cv::sum は，各チャンネル毎に配列要素の総和を計算して返します． 参照：ocountNonZero, mean, meanStdDev, norm, minMaxLoc, reduce

元関数名(C#): core_sum
元DLLエクスポート名: core_sum
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_sum(cv::_InputArray* src, MyCvScalar* returnValue)
{
    BEGIN_WRAP
    *returnValue = c(cv::sum(*src));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_countNonZero
[32/64bit] ゼロではない配列要素を数えます．
%prm
p1,p2
p1 = sptr : IntPtr src
p2 = var : out int returnValue
%inst
この関数は， src に含まれる 0 ではない要素の数を返します :???＞??*)

元関数名(C#): core_countNonZero
元DLLエクスポート名: core_countNonZero
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_countNonZero(cv::_InputArray* src, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::countNonZero(*src);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_findNonZero
[32/64bit] 0 ではないピクセルの位置のリストを返します．
%prm
p1,p2
p1 = sptr : IntPtr src
p2 = sptr : IntPtr idx
%inst
2値行列（おそらく，threshold()，compare()，>，==などの処理から返されます）が与えられた場合，すべての非ゼロインデックスを cv::Mat または std::vector<cv::Point> (x,y) として返します．例えば， cv::Mat binaryImage; // 入力であるバイナリ画像ecv::Mat locations; // 出力である，非ゼロピクセルの位置cv::findNonZero(binaryImage, locations);// ピクセル座標へのアクセスPoint pnt = locations.at<Point>(i);fragmentorcv::Mat binaryImage; // 入力，バイナリイメージevector<Point> locations; // 出力，0ではないピクセルの位置cv::findNonZero(binaryImage, locations);// アクセスピクセル座標Point pnt = locations[i];fragment

元関数名(C#): core_findNonZero
元DLLエクスポート名: core_findNonZero
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_findNonZero(cv::_InputArray* src, cv::_OutputArray* idx)
{
    BEGIN_WRAP
    cv::findNonZero(*src, *idx);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_mean
[32/64bit] 配列の要素の平均値を求めます．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr mask
p3 = var : out Scalar returnValue
%inst
関数 cv::mean は，各チャンネル毎に配列要素の平均値 M を求め，それを返します．N = sum _{I:\♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪(1 M_c = "N" = "Sum _{I:\♪♪〜(I) eldest son}{ eldest son(I)_c}\end{array}\]すべてのマスク要素が0のとき，Scalar::all(0)を返します． 参照：ocountNonZero, meanStdDev, norm, minMaxLocExamples: samples/dn/classification.cpp, samples/dn/object_detection.cpp, samples/dn/segmentation.cpp.

元関数名(C#): core_mean
元DLLエクスポート名: core_mean
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_mean(cv::_InputArray* src, cv::_InputArray* mask, MyCvScalar* returnValue)
{
    BEGIN_WRAP
    *returnValue = c(cv::mean(*src, entity(mask)));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_meanStdDev_OutputArray
[32/64bit] 配列の要素の平均値と標準偏差を計算します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr mean
p3 = sptr : IntPtr stddev
p4 = sptr : IntPtr mask
%inst
関数 cv::meanStdDev は，各チャンネル毎に，配列要素の平均値と標準偏差 M を計算し，それを出力パラメータとして返します．N = sum _{I, ?????1_c = ????? )\I）\\ 0} ??(I)_c}{N}\\ ♪♪〜\\\ 0} ?? ( ????? )(I）_c - ????? )_c )^2}{N}}\注意：計算された標準偏差は、完全な正規化共分散行列の対角線上にしかありません。完全な行列が必要ならば，マルチチャンネル配列 M x N をシングルチャンネル配列 M*N x mtx.channels() に変換し（行列が連続である場合のみ可能），その行列を calcCovarMatrix に渡します． 他にも，ocountNonZero, mean, norm, minMaxLoc, calcCovarMatrix を参照してください．

元関数名(C#): core_meanStdDev_OutputArray
元DLLエクスポート名: core_meanStdDev_OutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_meanStdDev_OutputArray(
    cv::_InputArray* src, cv::_OutputArray* mean, cv::_OutputArray* stddev, cv::_InputArray* mask)
{
    BEGIN_WRAP
    cv::meanStdDev(*src, *mean, *stddev, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_meanStdDev_Scalar
[32/64bit] 配列の要素の平均値と標準偏差を計算します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = var : out Scalar mean
p3 = var : out Scalar stddev
p4 = sptr : IntPtr mask
%inst
関数 cv::meanStdDev は，各チャンネル毎に，配列要素の平均値と標準偏差 M を計算し，それを出力パラメータとして返します．N = sum _{I, ?????1_c = ????? )\I）\\ 0} ??(I)_c}{N}\\ ♪♪〜\\\ 0} ?? ( ????? )(I）_c - ????? )_c )^2}{N}}\注意：計算された標準偏差は、完全な正規化共分散行列の対角線上にしかありません。完全な行列が必要ならば，マルチチャンネル配列 M x N をシングルチャンネル配列 M*N x mtx.channels() に変換し（行列が連続である場合のみ可能），その行列を calcCovarMatrix に渡します． 他にも，ocountNonZero, mean, norm, minMaxLoc, calcCovarMatrix を参照してください．

元関数名(C#): core_meanStdDev_Scalar
元DLLエクスポート名: core_meanStdDev_Scalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_meanStdDev_Scalar(
    cv::_InputArray* src, MyCvScalar* mean, MyCvScalar* stddev, cv::_InputArray* mask)
{
    BEGIN_WRAP
    cv::Scalar mean0, stddev0;
    cv::meanStdDev(*src, mean0, stddev0, entity(mask));
    *mean = c(mean0);
    *stddev = c(stddev0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_norm1
[32/64bit] 配列の絶対値ノルムを求めます．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src1
p2 = int : int normType
p3 = sptr : IntPtr mask
p4 = var : out double returnValue
%inst
このバージョンの norm は， src1 の絶対値ノルムを計算します．計算するノルムの種類は，NormTypesを用いて指定します．1つの配列の例として，関数 \(r(x)= origin{pmatrix} x ?????, x ?????) を考えます．サンプル値のノルムである?( L_{1}, L_{2} ? )は、?( L_{infty} ? )と同じです。-1 ♯2 ♯2 ♯2 ♯2 ♯2 ♯2 ♯2 ♯2 ♯2 ♯2 ♯2 ♯2 ♯2 ♯2 ♯2...\| r_{L_1} &= |-1| + |2| = 3 R_{L_2} &= |sqrt{(-1)^{2} + (2)^{2}}。+ (2)^{2}} = ????? )\\ R(-1)0.5\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\| 0.5+0.5+=1 ¶ r(0.5) ¶ L_2 ¶ &= ¶sqrt{(0.5)^{2}.+ (0.5)^{2}} = ″0.5″になります。\\ r(0.5) &= ~max(|0.5|,|0.5|) = 0.5.\end{align*}次の図は、3つのノルム関数\\ r(x), \ r(x), \ r(x), \ r(x),  r(x),  r(x),  r(x),  r(x),  r(x),  r(x),  r(x),  r(x),  r(x),  r(x),  r(x).例題の関数 ?( r(x) ? )の場合、上側が ?( L_{1} ? )ノルム、下側が ?( L_{infty} ? )ノルムになっていることがわかります。マルチチャンネル入力配列は，シングルチャンネル配列として扱われます．つまり，すべてのチャンネルの結果が組み合わされます．

元関数名(C#): core_norm1
元DLLエクスポート名: core_norm1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_norm1(cv::_InputArray* src1, int normType, cv::_InputArray* mask, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::norm(*src1, normType, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_norm2
[32/64bit] 絶対差分ノルム，または相対差分ノルムを求めます．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = int : int normType
p4 = sptr : IntPtr mask
p5 = var : out double returnValue
%inst
このバージョンの cv::norm は，配列 src1 と src2 の絶対差分ノルム，あるいは相対差分ノルムを求めます．計算するノルムの種類は， NormTypes を用いて指定します．

元関数名(C#): core_norm2
元DLLエクスポート名: core_norm2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_norm2(cv::_InputArray* src1, cv::_InputArray* src2,
    int normType, cv::_InputArray* mask, double* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::norm(*src1, *src2, normType, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_PSNR
[32/64bit] 画質指標である PSNR（Peak Signal-to-Noise Ratio）を計算します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = double : double r
p4 = var : out double returnValue
%inst
この関数は，2つの入力配列 src1 と src2 の間の，デシベル（dB）単位で表されるピーク信号対雑音比（PSNR）の画質を求めます．PSNR は，次のように計算されます： ??? -? ??? Rは深度の最大整数値（CV_8Uデータの場合は255），MSEは2つの配列間の平均2乗誤差です．

元関数名(C#): core_PSNR
元DLLエクスポート名: core_PSNR
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PSNR(cv::_InputArray* src1, cv::_InputArray* src2, double R, double* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::PSNR(*src1, *src2, R);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_batchDistance
[32/64bit] ナイーブな最近傍探索機
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dist
p4 = int : int dtype
p5 = sptr : IntPtr nidx
p6 = int : int normType
p7 = int : int k
p8 = sptr : IntPtr mask
p9 = int : int update
p10 = int : int crosscheck
%inst
http://en.wikipedia.org/wiki/Nearest_neighbor_searchTodo:document を参照してください．

元関数名(C#): core_batchDistance
元DLLエクスポート名: core_batchDistance
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_batchDistance(
    cv::_InputArray* src1, cv::_InputArray* src2,
    cv::_OutputArray* dist, int dtype, cv::_OutputArray* nidx,
    int normType, int K, cv::_InputArray* mask,
    int update, int crosscheck)
{
    BEGIN_WRAP
    cv::batchDistance(
        *src1, *src2, *dist, dtype, *nidx, normType, K, entity(mask), update, crosscheck != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_normalize
[32/64bit] 配列のノルムや値域を正規化します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = double : double alpha
p4 = double : double beta
p5 = int : int normType
p6 = int : int dtype
p7 = sptr : IntPtr mask
%inst
関数 cv::normalize は，normType=NORM_INF, NORM_L1, NORM_L2 の場合に，それぞれ以下のように入力配列の要素をスケーリングしたりシフトしたりして正規化します．(I)= ????? ) , ????? ) , ????? )(normType=NORM_MINMAX（密な配列の場合のみ）の場合は， [I (I)= ??? -? ???]となります．）オプションのマスクは，正規化されるサブアレイを指定します．これは，副配列に対してノルムやmin-n-maxが計算され，その後，この副配列が正規化されるように修正されることを意味します。ノルムやミニマムを計算するためにマスクを利用するだけで，配列全体を修正したい場合は，norm と Mat::convertTo を利用できます．疎な行列の場合は，ゼロではない値のみが分析・変換されます．このため，ゼロレベルを移動させることができるので，疎な行列に対する範囲変換はできません．いくつかの正の例示データを用いた可能な利用法： vector<double> positiveData = { 2.0, 8.0, 10.0 };vector<double> normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;// Norm to probability (total count)// sum(numbers) = 20.0// 2.0.1 0.1 (2.0/20.0)// 8.0 0.4 (8.0/20.0)// 10.0 0.5 (10.0/20.0)normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);// 単位ベクトルへのノーム。||positiveData|= 1.0//2.0 0.15//8.0 0.62//10.0 0.77normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);// 最大要素へのノルム//2.0.2 0.2 (2.0/10.0)// 8.0 0.8 (8.0/10.0)// 10.0 1.0 (10.0/10.0)normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);// 範囲に合わせたノーム [0.0;1.0]// 2.0 0.0 (左境界への移動)// 8.0 0.75 (6.0/8.0)// 10.0 1.0 (右境界への移動)normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX);fragmentSee alsonorm, Mat::convertTo, SparseMat::convertTo

元関数名(C#): core_normalize
元DLLエクスポート名: core_normalize
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_normalize(
    cv::_InputArray* src, cv::_InputOutputArray* dst, double alpha, double beta, int normType, int dtype, cv::_InputArray* mask)
{
    BEGIN_WRAP
    cv::InputArray maskVal = entity(mask);
    cv::normalize(*src, *dst, alpha, beta, normType, dtype, maskVal);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_minMaxLoc1
[32/64bit] 配列のグローバルな最小値と最大値を求めます．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = var : out double minVal
p3 = var : out double maxVal
%inst
関数 cv::minMaxLoc は，要素の最小値と最大値，そしてそれらの位置を求めます．極値は，配列全体，あるいは mask が空の配列ではない場合は，指定された配列領域で探索されます．この関数は，マルチチャンネル配列では動作しません．すべてのチャンネルで最小や最大の要素を見つける必要がある場合は，まず Mat::reshape を利用して配列をシングルチャンネルとして再解釈します．あるいは， extractImageCOI ， mixChannels ， split のいずれかを用いて特定のチャンネルを抽出します． 関連項目：omax, min, compare, inRange, extractImageCOI, mixChannels, split, Mat::reshapeExamples: samples/cpp/image_alignment.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/dnn/classification.cpp, samples/dnn/object_detection.cpp, and samples/dnn/openpose.cpp.

元関数名(C#): core_minMaxLoc1
元DLLエクスポート名: core_minMaxLoc1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_minMaxLoc1(cv::_InputArray* src, double* minVal, double* maxVal)
{
    BEGIN_WRAP
    cv::minMaxLoc(*src, minVal, maxVal);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_minMaxLoc2
[32/64bit] 配列のグローバルな最小値と最大値を求めます．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = var : out double minVal
p3 = var : out double maxVal
p4 = var : out Point minLoc
p5 = var : out Point maxLoc
p6 = sptr : IntPtr mask
%inst
関数 cv::minMaxLoc は，要素の最小値と最大値，そしてそれらの位置を求めます．極値は，配列全体，あるいは mask が空の配列ではない場合は，指定された配列領域で探索されます．この関数は，マルチチャンネル配列では動作しません．すべてのチャンネルで最小や最大の要素を見つける必要がある場合は，まず Mat::reshape を利用して配列をシングルチャンネルとして再解釈します．あるいは， extractImageCOI ， mixChannels ， split のいずれかを用いて特定のチャンネルを抽出します． 関連項目：omax, min, compare, inRange, extractImageCOI, mixChannels, split, Mat::reshapeExamples: samples/cpp/image_alignment.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/dnn/classification.cpp, samples/dnn/object_detection.cpp, and samples/dnn/openpose.cpp.

元関数名(C#): core_minMaxLoc2
元DLLエクスポート名: core_minMaxLoc2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_minMaxLoc2(cv::_InputArray* src, double* minVal, double* maxVal,
    MyCvPoint* minLoc, MyCvPoint* maxLoc, cv::_InputArray* mask)
{
    BEGIN_WRAP
    cv::InputArray maskVal = entity(mask);
    cv::Point minLoc0, maxLoc0;
    cv::minMaxLoc(*src, minVal, maxVal, &amp;minLoc0, &amp;maxLoc0, maskVal);
    *minLoc = c(minLoc0);
    *maxLoc = c(maxLoc0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_minMaxIdx1
[32/64bit] 配列のグローバルな最小値と最大値を求めます．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = var : out double minVal
p3 = var : out double maxVal
%inst
関数 cv::minMaxIdx は，最小と最大の要素の値とその位置を求めます．極値は，配列全体，あるいは mask が空の配列ではない場合には，指定された配列領域内で探索されます．この関数は，マルチチャンネル配列では動作しません．すべてのチャンネルで最小や最大の要素を見つける必要がある場合は，最初に Mat::reshape を利用して配列をシングルチャンネルとして再解釈します．あるいは， extractImageCOI や mixChannels ，split などを用いて，特定のチャンネルを抽出しても構いません．疎な行列の場合，最小値は 0 ではない要素の中でのみ求められます．注意 minIdx が NULL ではない場合，たとえ src が 1 行や 1 列の行列であっても，（ maxIdx と同様に）少なくとも 2 つの要素を持たなければいけません．OpenCVでは（MATLABに倣って），各配列は少なくとも2次元です．つまり，1列の行列は Mx1 行列（したがって，minIdx/maxIdx は (i1,0)/(i2,0) となります），1列の行列は 1xN 行列（したがって，minIdx/maxIdx は (0,j1)/(0,j2) となります）．

元関数名(C#): core_minMaxIdx1
元DLLエクスポート名: core_minMaxIdx1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_minMaxIdx1(cv::_InputArray* src, double* minVal, double* maxVal)
{
    BEGIN_WRAP
    cv::minMaxIdx(*src, minVal, maxVal);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_minMaxIdx2
[32/64bit] 配列のグローバルな最小値と最大値を求めます．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = var : out double minVal
p3 = var : out double maxVal
p4 = var : [MarshalAs(UnmanagedType.LPArray), Out] int[] minIdx
p5 = var : [MarshalAs(UnmanagedType.LPArray), Out] int[] maxIdx
p6 = sptr : IntPtr mask
%inst
関数 cv::minMaxIdx は，最小と最大の要素の値とその位置を求めます．極値は，配列全体，あるいは mask が空の配列ではない場合には，指定された配列領域内で探索されます．この関数は，マルチチャンネル配列では動作しません．すべてのチャンネルで最小や最大の要素を見つける必要がある場合は，最初に Mat::reshape を利用して配列をシングルチャンネルとして再解釈します．あるいは， extractImageCOI や mixChannels ，split などを用いて，特定のチャンネルを抽出しても構いません．疎な行列の場合，最小値は 0 ではない要素の中でのみ求められます．注意 minIdx が NULL ではない場合，たとえ src が 1 行や 1 列の行列であっても，（ maxIdx と同様に）少なくとも 2 つの要素を持たなければいけません．OpenCVでは（MATLABに倣って），各配列は少なくとも2次元です．つまり，1列の行列は Mx1 行列（したがって，minIdx/maxIdx は (i1,0)/(i2,0) となります），1列の行列は 1xN 行列（したがって，minIdx/maxIdx は (0,j1)/(0,j2) となります）．

元関数名(C#): core_minMaxIdx2
元DLLエクスポート名: core_minMaxIdx2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_minMaxIdx2(cv::_InputArray* src, double* minVal, double* maxVal,
    int* minIdx, int* maxIdx, cv::_InputArray* mask)
{
    BEGIN_WRAP
    cv::InputArray maskVal = entity(mask);
    cv::minMaxIdx(*src, minVal, maxVal, minIdx, maxIdx, maskVal);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_reduce
[32/64bit] 行列をベクトルに変換します。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int dim
p4 = int : int rtype
p5 = int : int dtype
%inst
関数 reduce は，行列の行/列を 1 次元ベクトルの集合として扱い，単一の行/列が得られるまで，そのベクトルに対して指定された処理を行うことで，行列をベクトルに変換します．例えば，この関数は，ラスター画像の水平・垂直方向の投影図を求めるために利用できます．REDUCE_MAX および REDUCE_MIN の場合，出力画像は入力画像と同じ型でなければいけません．REDUCE_SUM や REDUCE_AVG の場合，精度を保つために，出力の要素のビット深度を大きくすることができます．また，この2つのリダクションモードでは，マルチチャンネル配列もサポートされています．以下のコードは，シングルチャンネルの行列に対する使い方を示しています．Mat m = (Mat_<uchar>(3,2) << 1,2,3,4,5,6); Mat col_sum, row_sum; reduce(m, col_sum, 0, REDUCE_SUM, CV_32F); reduce(m, row_sum, 1, REDUCE_SUM, CV_32F); /* m = [ 1, 2;           3, 4; 5, 6] col_sum = [9, 12] row_sum = [3; 7; 11] */fragmentまた，次のコードは，2チャンネルの行列に対する使い方を示しています．// 2 チャンネル char d[] = {1,2,3,4,5,6}; Mat m(3, 1, CV_8UC2, d); Mat col_sum_per_channel; reduce(m, col_sum_per_channel, 0, REDUCE_SUM, CV_32F); /* col_sum_per_channel = [9, 12] */fragment他の項目も参照してください．

元関数名(C#): core_reduce
元DLLエクスポート名: core_reduce
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_reduce(cv::_InputArray* src, cv::_OutputArray* dst, int dim, int rtype, int dtype)
{
    BEGIN_WRAP
    cv::reduce(*src, *dst, dim, rtype, dtype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_merge
[32/64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3
p1 = sptr : [MarshalAs(UnmanagedType.LPArray)] IntPtr[] mv
p2 = int : uint count
p3 = sptr : IntPtr dst
%inst
元関数名(C#): core_merge
元DLLエクスポート名: core_merge
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_merge(cv::Mat** mv, uint32_t count, cv::Mat* dst)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; vec(static_cast&amp;lt;size_t&amp;gt;(count));
    for (uint32_t i = 0; i &amp;lt; count; i++)
        vec[i] = *mv[i];

    cv::merge(vec, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_split
[32/64bit] マルチチャンネル配列を，複数のシングルチャンネル配列に分割します．
%prm
p1,p2
p1 = sptr : IntPtr src
p2 = sptr : IntPtr mv
%inst
関数 cv::split は，マルチチャンネル配列を別々のシングルチャンネル配列に分割します．(以下の例では，3 チャンネルの行列を 3 つのシングルチャンネルの行列に分割しています．char d[] = {1,2,3,4,5,6,7,8,9,10,11,12}; Mat m(2, 2, CV_8UC3, d); Mat channels[3]; split(m, channels); /* channels[0] = [ 1, 4; 7, 10] channels[1] = [ 2, 5; 8, 11] channels[2] = [ 3, 6; 9, 12] */fragment 他にも，somerge, mixChannels, cvtColorExamples を参照してください．samples/cpp/tutorial_code/videoio/video-write/video-write.cpp を参照してください．

元関数名(C#): core_split
元DLLエクスポート名: core_split
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_split(cv::Mat* src, std::vector&amp;lt;cv::Mat&amp;gt;* mv)
{
    BEGIN_WRAP
    cv::split(*src, *mv);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_mixChannels
[32/64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr[] src
p2 = int : uint nsrcs
p3 = sptr : IntPtr[] dst
p4 = int : uint ndsts
p5 = var : int[] fromTo
p6 = int : uint npairs
%inst
元関数名(C#): core_mixChannels
元DLLエクスポート名: core_mixChannels
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_mixChannels(cv::Mat** src, uint32_t nsrcs, cv::Mat** dst, uint32_t ndsts, int* fromTo, uint32_t npairs)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; srcVec(static_cast&amp;lt;size_t&amp;gt;(nsrcs));
    std::vector&amp;lt;cv::Mat&amp;gt; dstVec(static_cast&amp;lt;size_t&amp;gt;(ndsts));
    for (uint32_t i = 0; i &amp;lt; nsrcs; i++)
        srcVec[i] = *(src[i]);
    for (uint32_t i = 0; i &amp;lt; ndsts; i++)
        dstVec[i] = *(dst[i]);

    cv::mixChannels(srcVec, dstVec, fromTo, npairs);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_extractChannel
[32/64bit] src から 1 つのチャンネルを抽出します（ coi は 0 ベースのインデックスです）．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int coi
%inst
alsomixChannels, splitExamples: samples/dnn/colorization.cpp を参照してください．

元関数名(C#): core_extractChannel
元DLLエクスポート名: core_extractChannel
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_extractChannel(cv::_InputArray* src, cv::_OutputArray* dst, int coi)
{
    BEGIN_WRAP
    cv::extractChannel(*src, *dst, coi);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_insertChannel
[32/64bit] dst に 1 つのチャンネルを挿入します（coi は 0 ベースのインデックス）．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int coi
%inst
See alsomixChannels, merge

元関数名(C#): core_insertChannel
元DLLエクスポート名: core_insertChannel
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_insertChannel(cv::_InputArray* src, cv::_InputOutputArray* dst, int coi)
{
    BEGIN_WRAP
    cv::insertChannel(*src, *dst, coi);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_flip
[32/64bit] 2 次元配列を，垂直，水平，または両軸で反転させます．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int flipCode
%inst
関数 cv::flip は，3つの異なる方法のうちの1つで配列を反転させます（行と列のインデックスは 0 ベースです）．_{ij} = ????? )\♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪_{texttttt{src.rows}-i-1,j} & if\; ??? -? ??? ???? ??? -? ???_{i, ????? )-j-1} & if; ????? )> 0以上_{ ????? )-j-1} & if\; ?????< 0 }\\\\この関数の使用例は以下の通りです。画像を垂直方向に反転させ（flipCode == 0），画像の原点を左上と左下に切り替える．Microsoft Windows*での動画処理でよく見られる操作です。垂直軸方向の対称性を確認するために、水平方向に反転させた後、水平方向にシフトさせ、差分の絶対値を計算する（flipCode > 0）。水平・垂直方向に同時に反転させ、その後シフトと絶対値の差を計算して中心軸の対称性を確認する（flipCode < 0）。点配列の順序を反転させる (flipCode > 0 or flipCode == 0).alsootranspose , repeat , completeSymmExamples: samples/cpp/facedetect.cpp, and samples/cpp/train_HOG.cppを参照してください。

元関数名(C#): core_flip
元DLLエクスポート名: core_flip
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_flip(cv::_InputArray* src, cv::_OutputArray* dst, int flipCode)
{
    BEGIN_WRAP
    cv::flip(*src, *dst, flipCode);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_rotate
[32/64bit] 2 次元配列を 90 度の倍数で回転させます．関数 cv::rotate は，3つの異なる方法のうちの1つで配列を回転させます．時計回りに90度回転させます（rotateCode = ROTATE_90_CLOCKWISE）．時計回りに180度回転させます（rotateCode = ROTATE_180）．時計回りに270度回転させる(rotateCode = ROTATE_90_COUNTERCLOCKWISE)。
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int rotateCode
%inst
関連項目：otranspose, repeat, completeSymm, flip, RotateFlags

元関数名(C#): core_rotate
元DLLエクスポート名: core_rotate
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_rotate(cv::_InputArray *src, cv::_OutputArray *dst, int rotateCode)
{
    BEGIN_WRAP
    cv::rotate(*src, *dst, rotateCode);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_repeat1
[32/64bit] 入力配列を繰り返しコピーして、出力配列を埋めます。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = int : int ny
p3 = int : int nx
p4 = sptr : IntPtr dst
%inst
関数 cv::repeat は，入力配列を2つの軸それぞれに沿って1回または複数回複製します：\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\??。

元関数名(C#): core_repeat1
元DLLエクスポート名: core_repeat1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_repeat1(cv::_InputArray* src, int ny, int nx, cv::_OutputArray* dst)
{
    BEGIN_WRAP
    cv::repeat(*src, ny, nx, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_repeat2
[32/64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = int : int ny
p3 = int : int nx
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_repeat2
元DLLエクスポート名: core_repeat2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_repeat2(cv::Mat* src, int ny, int nx, cv::Mat** returnValue)
{
    BEGIN_WRAP
    const cv::Mat ret = cv::repeat(*src, ny, nx);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_hconcat1
[32/64bit] 与えられた行列に対して，水平方向の連結処理を行います．
%prm
p1,p2,p3
p1 = sptr : [MarshalAs(UnmanagedType.LPArray)] IntPtr[] src
p2 = int : uint nsrc
p3 = sptr : IntPtr dst
%inst
この関数は，（同じ行数の）2つ以上の cv::Mat 行列を水平方向に連結します．cv::Mat matArray[] = { cv::Mat(4, 1, CV_8UC1, cv::Scalar(1)), cv::Mat(4, 1, CV_8UC1, cv::Scalar(2)), cv::Mat(4, 1, CV_8UC1, cv::Scalar(3)),};cv::Mat out;cv::hconcat( matArray, 3, out );//out://[1, 2, 3;// 1, 2, 3;// 1, 2, 3]fragment また，socv::vconcat(const Mat*, size_t, OutputArray) も参照してください．



cv::vconcat(InputArrayOfArrays, OutputArray), および



cv::vconcat(InputArray, InputArray, OutputArray)例: samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp.

元関数名(C#): core_hconcat1
元DLLエクスポート名: core_hconcat1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_hconcat1(cv::Mat** src, uint32_t nsrc, cv::_OutputArray* dst)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; srcVec(static_cast&amp;lt;size_t&amp;gt;(nsrc));
    for (uint32_t i = 0; i &amp;lt; nsrc; i++)
        srcVec[i] = *(src[i]);
    cv::hconcat(&amp;srcVec[0], nsrc, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_hconcat2
[32/64bit] 与えられた行列に対して，水平方向の連結処理を行います．
%prm
p1,p2,p3
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
%inst
この関数は，（同じ行数の）2つ以上の cv::Mat 行列を水平方向に連結します．cv::Mat matArray[] = { cv::Mat(4, 1, CV_8UC1, cv::Scalar(1)), cv::Mat(4, 1, CV_8UC1, cv::Scalar(2)), cv::Mat(4, 1, CV_8UC1, cv::Scalar(3)),};cv::Mat out;cv::hconcat( matArray, 3, out );//out://[1, 2, 3;// 1, 2, 3;// 1, 2, 3]fragment また，socv::vconcat(const Mat*, size_t, OutputArray) も参照してください．



cv::vconcat(InputArrayOfArrays, OutputArray), および



cv::vconcat(InputArray, InputArray, OutputArray)例: samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp.

元関数名(C#): core_hconcat2
元DLLエクスポート名: core_hconcat2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_hconcat2(cv::_InputArray* src1, cv::_InputArray* src2, cv::_OutputArray* dst)
{
    BEGIN_WRAP
    cv::hconcat(*src1, *src2, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_vconcat1
[32/64bit] 与えられた行列に対して、垂直方向の連結処理を行います。
%prm
p1,p2,p3
p1 = sptr : [MarshalAs(UnmanagedType.LPArray)] IntPtr[] src
p2 = int : uint nsrc
p3 = sptr : IntPtr dst
%inst
この関数は，2つ以上の cv::Mat 行列（同じ数の cols を持つ）を垂直方向に連結します．cv::Mat matArray[] = { cv::Mat(1, 4, CV_8UC1, cv::Scalar(1)), cv::Mat(1, 4, CV_8UC1, cv::Scalar(2)), cv::Mat(1, 4, CV_8UC1, cv::Scalar(3)),};cv::Mat out;cv::vconcat( matArray, 3, out );//out://[1, 1, 1, 1;// 2, 2, 2;// 3, 3, 3]fragment また，ocv::hconcat(const Mat*, size_t, OutputArray) も参照してください．



cv::hconcat(InputArrayOfArrays, OutputArray), および



cv::hconcat(InputArray, InputArray, OutputArray)

元関数名(C#): core_vconcat1
元DLLエクスポート名: core_vconcat1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_vconcat1(cv::Mat** src, uint32_t nsrc, cv::_OutputArray* dst)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; srcVec(static_cast&amp;lt;size_t&amp;gt;(nsrc));
    for (uint32_t i = 0; i &amp;lt; nsrc; i++)
        srcVec[i] = *(src[i]);
    cv::vconcat(&amp;srcVec[0], nsrc, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_vconcat2
[32/64bit] 与えられた行列に対して、垂直方向の連結処理を行います。
%prm
p1,p2,p3
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
%inst
この関数は，2つ以上の cv::Mat 行列（同じ数の cols を持つ）を垂直方向に連結します．cv::Mat matArray[] = { cv::Mat(1, 4, CV_8UC1, cv::Scalar(1)), cv::Mat(1, 4, CV_8UC1, cv::Scalar(2)), cv::Mat(1, 4, CV_8UC1, cv::Scalar(3)),};cv::Mat out;cv::vconcat( matArray, 3, out );//out://[1, 1, 1, 1;// 2, 2, 2;// 3, 3, 3]fragment また，ocv::hconcat(const Mat*, size_t, OutputArray) も参照してください．



cv::hconcat(InputArrayOfArrays, OutputArray), および



cv::hconcat(InputArray, InputArray, OutputArray)

元関数名(C#): core_vconcat2
元DLLエクスポート名: core_vconcat2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_vconcat2(cv::_InputArray* src1, cv::_InputArray* src2, cv::_OutputArray* dst)
{
    BEGIN_WRAP
    cv::vconcat(*src1, *src2, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_bitwise_and
[32/64bit] 2 つの配列のビット単位の論理和を求めます （dst = src1 & src2） 2 つの配列，あるいは配列とスカラの要素毎のビット単位の論理和を求めます．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
p4 = sptr : IntPtr mask
%inst
関数 cv::bitwise_and は，各要素毎にビット単位の論理積を計算します．src1 と src2 が同じサイズの場合の 2 つの配列．(I) = ????? )(I） ?????(I） ＃＃quad ＃＃if mask(I) \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\(I) = ????? )(I） ¶ wedge ¶ src2 ¶ wedge ¶ src2 ¶ wedge ¶ wedge\♪♪「if mask(I) \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\(I) = ″src1″ (I) = ″src1″ (I)\????? ?????(I） ♯♯♯♯♯♯♯♯♯(I) ??? -? ??? 浮動小数点型配列の場合は，マシン固有のビット表現（通常，IEEE754準拠）を用いて演算します．また，マルチチャンネル配列の場合は，各チャンネルが独立して処理されます．例： samples/cpp/create_mask.cpp.

元関数名(C#): core_bitwise_and
元DLLエクスポート名: core_bitwise_and
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_bitwise_and(
    cv::_InputArray *src1, cv::_InputArray *src2, cv::_OutputArray *dst, cv::_InputArray *mask)
{
    BEGIN_WRAP
    cv::bitwise_and(*src1, *src2, *dst, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_bitwise_or
[32/64bit] 2 つの配列，あるいは配列とスカラの要素毎のビット単位の論理和を求めます．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
p4 = sptr : IntPtr mask
%inst
関数 cv::bitwise_or は，要素毎のビット単位の論理和を求めます．src1 と src2 が同じサイズの場合の 2 つの配列： ??o???(I) = ??? -? ??? "src1(I）\\\\(I）\\\\(I) \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\(I) = ????? )(I) ??? -? ??? ????\♪♪「if mask(I) \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\(I) = ″src1″ (I) = ″src1″ (I)\src2} (I)(I） ¶quad ¶if mask(I) ??? -? ??? 浮動小数点型配列の場合は，マシン固有のビット表現（通常，IEEE754準拠）を用いて演算します．また，マルチチャンネル配列の場合は，各チャンネルが独立して処理されます．上記の2番目と3番目のケースでは，まずスカラが配列型に変換されます．

元関数名(C#): core_bitwise_or
元DLLエクスポート名: core_bitwise_or
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_bitwise_or(
    cv::_InputArray *src1, cv::_InputArray *src2, cv::_OutputArray *dst, cv::_InputArray *mask)
{
    BEGIN_WRAP
    cv::bitwise_or(*src1, *src2, *dst, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_bitwise_xor
[32/64bit] 2つの配列，あるいは配列とスカラの要素毎に，ビット単位の排他的論理和を計算します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
p4 = sptr : IntPtr mask
%inst
関数 cv::bitwise_xor は，各要素に対するビット単位の論理的な「排他的論理和」演算を求めます．src1 と src2 が同じサイズの場合の 2 つの配列： ??o???(I) = ????? )(I) ¶oplus ¶src2}(I）\\\\(I) \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\(I) = ??o???(I) ¶oplus ¶src2}\♪♪〜(I) \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\(I) = ″src1″ (I) = ″src1″ (I)\Plus(I） ??? -? ???(I) ??? -? ??? 浮動小数点型配列の場合は，マシン固有のビット表現（通常，IEEE754準拠）を用いて演算します．また，マルチチャンネル配列の場合は，各チャンネルが独立して処理されます．上記の2番目と3番目のケースでは，まずスカラが配列型に変換されます．

元関数名(C#): core_bitwise_xor
元DLLエクスポート名: core_bitwise_xor
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_bitwise_xor(
    cv::_InputArray *src1, cv::_InputArray *src2, cv::_OutputArray *dst, cv::_InputArray *mask)
{
    BEGIN_WRAP
    cv::bitwise_xor(*src1, *src2, *dst, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_bitwise_not
[32/64bit] 配列の各ビットを反転させます。
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr mask
%inst
関数 cv::bitwise_not は，入力配列の要素毎に，ビット単位の反転を計算します： ??? -? ??? 浮動小数点型の入力配列の場合は，マシン固有のビット表現（通常は IEEE754 準拠）が用いられます．例：samples/cpp/camshiftdemo.cpp.

元関数名(C#): core_bitwise_not
元DLLエクスポート名: core_bitwise_not
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_bitwise_not(
    cv::_InputArray *src, cv::_OutputArray *dst, cv::_InputArray *mask)
{
    BEGIN_WRAP
    cv::bitwise_not(*src, *dst, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_absdiff
[32/64bit] 2 つの配列同士，あるいは配列とスカラの間の要素毎の絶対値の差を求めます．
%prm
p1,p2,p3
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
%inst
関数 cv::absdiff は，次のように計算します．2つの配列が同じサイズ，同じ型である場合の，配列とスカラの絶対値の差：\texttt{dst}(I) = ??o??? (| ??o???) (| ??o???)\1番目の配列がスカラから構築されるか，または src2 のチャンネル数と同じ数の要素を持つ場合の，スカラと配列の絶対値の差を表します．\ここで，I は，配列要素の多次元インデックスです．マルチチャンネル配列の場合，各チャンネルは独立して処理されます． 注意点配列のビット深度が CV_32S の場合，彩度は適用されません．また，オーバーフロー時には負の値を得ることもあります．ocv::abs(const Mat&) も参照してください．

元関数名(C#): core_absdiff
元DLLエクスポート名: core_absdiff
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_absdiff(
    cv::_InputArray *src1, cv::_InputArray *src2, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::absdiff(*src1, *src2, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_copyTo
[32/64bit] これは，利便性のために提供されるオーバーロードされたメンバ関数です（python） 行列を別の行列にコピーします．操作マスクが指定されている場合，上述の Mat::create 呼び出しが行列を再割り当てすると，データをコピーする前に，新しく割り当てられた行列がすべて 0 で初期化されます．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr mask
%inst
元関数名(C#): core_copyTo
元DLLエクスポート名: core_copyTo
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_copyTo(cv::_InputArray *src, cv::_OutputArray *dst, cv::_InputArray *mask)
{
    BEGIN_WRAP
    cv::copyTo(*src, *dst, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_inRange_InputArray
[32/64bit] 配列の要素が，他の2つの配列の要素の間にあるかどうかをチェックします．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr lowerb
p3 = sptr : IntPtr upperb
p4 = sptr : IntPtr dst
%inst
この関数は，シングルチャンネルの入力配列の各要素に対して，以下のように範囲をチェックします．

\dst(I)= ??-??-?)(I)_0 ???д??? ???? ???? ???д???(I)_0 \\\\(I)_0\]





2チャンネルアレイの場合

\\\\(I)= \\\\(I)_0 ??? -? ????(I)_0 \\\\(I）_0 I'm _0 eldest person(I)_1 wrestler's younger brother(I)_1 ??? -? ??? ????(I)_1\]





つまり，src（I）が指定された1D，2D，3D，...のボックス内にあれば，dst（I）は255（すべて1ビット）に，そうでなければ0に設定されます．下界や上界のパラメータがスカラーの場合は，上の式のlowerbやupperbのインデックス（I）を省略します．

元関数名(C#): core_inRange_InputArray
元DLLエクスポート名: core_inRange_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_inRange_InputArray(
    cv::_InputArray *src, cv::_InputArray *lowerb, cv::_InputArray *upperb, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::inRange(*src, *lowerb, *upperb, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_inRange_Scalar
[32bit] 配列の要素が，他の2つの配列の要素の間にあるかどうかをチェックします．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = ARGS_SCALAR : Scalar lowerb
p3 = ARGS_SCALAR : Scalar upperb
p4 = sptr : IntPtr dst
%inst
この関数は，シングルチャンネルの入力配列の各要素に対して，以下のように範囲をチェックします．

\dst(I)= ??-??-?)(I)_0 ???д??? ???? ???? ???д???(I)_0 \\\\(I)_0\]





2チャンネルアレイの場合

\\\\(I)= \\\\(I)_0 ??? -? ????(I)_0 \\\\(I）_0 I'm _0 eldest person(I)_1 wrestler's younger brother(I)_1 ??? -? ??? ????(I)_1\]





つまり，src（I）が指定された1D，2D，3D，...のボックス内にあれば，dst（I）は255（すべて1ビット）に，そうでなければ0に設定されます．下界や上界のパラメータがスカラーの場合は，上の式のlowerbやupperbのインデックス（I）を省略します．

元関数名(C#): core_inRange_Scalar
元DLLエクスポート名: core_inRange_Scalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_inRange_Scalar(
    cv::_InputArray *src, MyCvScalar lowerb, MyCvScalar upperb, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::inRange(*src, cpp(lowerb), cpp(upperb), *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_inRange_Scalar
[64bit] 配列の要素が，他の2つの配列の要素の間にあるかどうかをチェックします．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = var : Scalar lowerb
p3 = var : Scalar upperb
p4 = sptr : IntPtr dst
%inst
この関数は，シングルチャンネルの入力配列の各要素に対して，以下のように範囲をチェックします．

\dst(I)= ??-??-?)(I)_0 ???д??? ???? ???? ???д???(I)_0 \\\\(I)_0\]





2チャンネルアレイの場合

\\\\(I)= \\\\(I)_0 ??? -? ????(I)_0 \\\\(I）_0 I'm _0 eldest person(I)_1 wrestler's younger brother(I)_1 ??? -? ??? ????(I)_1\]





つまり，src（I）が指定された1D，2D，3D，...のボックス内にあれば，dst（I）は255（すべて1ビット）に，そうでなければ0に設定されます．下界や上界のパラメータがスカラーの場合は，上の式のlowerbやupperbのインデックス（I）を省略します．

元関数名(C#): core_inRange_Scalar
元DLLエクスポート名: core_inRange_Scalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_inRange_Scalar(
    cv::_InputArray *src, MyCvScalar lowerb, MyCvScalar upperb, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::inRange(*src, cpp(lowerb), cpp(upperb), *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_compare
[32/64bit] 2つの配列，あるいは配列とスカラ値の要素毎の比較を行います．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
p4 = int : int cmpop
%inst
この関数は，比較を行います．src1 と src2 が同じサイズの場合，2つの配列の要素を比較します．\src1がスカラから構成される場合や、単一の要素を持つ場合は、src2の要素を持つsrc1となります。\比較結果が True の場合、出力配列の対応する要素は 255 に設定されます。比較演算は，等価な行列表現に置き換えることができます： Mat dst1 = src1 >= src2;Mat dst2 = src1 < 8;...fragmentSee alsocheckRange, min, max, threshold

元関数名(C#): core_compare
元DLLエクスポート名: core_compare
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_compare(
    cv::_InputArray *src1, cv::_InputArray *src2, cv::_OutputArray *dst, int cmpop)
{
    BEGIN_WRAP
    cv::compare(*src1, *src2, *dst, cmpop);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_min1
[32/64bit] 2つの配列，あるいは配列とスカラの要素毎の最小値を求めます．
%prm
p1,p2,p3
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
%inst
関数 cv::min は，2つの配列の要素毎の最小値を求めます： ????? ) または，配列とスカラの組み合わせ．\See alsomax, compare, inRange, minMaxLoc

元関数名(C#): core_min1
元DLLエクスポート名: core_min1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_min1(cv::_InputArray *src1, cv::_InputArray *src2, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::min(*src1, *src2, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_min_MatMat
[32/64bit] 2つの配列，あるいは配列とスカラの要素毎の最小値を求めます．
%prm
p1,p2,p3
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
%inst
関数 cv::min は，2つの配列の要素毎の最小値を求めます： ????? ) または，配列とスカラの組み合わせ．\See alsomax, compare, inRange, minMaxLoc

元関数名(C#): core_min_MatMat
元DLLエクスポート名: core_min_MatMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_min_MatMat(cv::Mat* src1, cv::Mat* src2, cv::Mat* dst)
{
    BEGIN_WRAP
    cv::min(*src1, *src2, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_min_MatDouble
[32/64bit] 2つの配列，あるいは配列とスカラの要素毎の最小値を求めます．
%prm
p1,p2,p3
p1 = sptr : IntPtr src1
p2 = double : double src2
p3 = sptr : IntPtr dst
%inst
関数 cv::min は，2つの配列の要素毎の最小値を求めます： ????? ) または，配列とスカラの組み合わせ．\See alsomax, compare, inRange, minMaxLoc

元関数名(C#): core_min_MatDouble
元DLLエクスポート名: core_min_MatDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_min_MatDouble(cv::Mat* src1, double src2, cv::Mat* dst)
{
    BEGIN_WRAP
    cv::min(*src1, src2, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_max1
[32/64bit] 2つの配列，あるいは，配列とスカラの 要素毎の最大値を求めます．
%prm
p1,p2,p3
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
%inst
関数 cv::max は，2つの配列の要素毎の最大値を求めます： ????? ) または，配列とスカラの組み合わせ．\See alsomin, compare, inRange, minMaxLoc, MatrixExpressions

元関数名(C#): core_max1
元DLLエクスポート名: core_max1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_max1(cv::_InputArray *src1, cv::_InputArray *src2, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::max(*src1, *src2, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_max_MatMat
[32/64bit] 2つの配列，あるいは，配列とスカラの 要素毎の最大値を求めます．
%prm
p1,p2,p3
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
%inst
関数 cv::max は，2つの配列の要素毎の最大値を求めます： ????? ) または，配列とスカラの組み合わせ．\See alsomin, compare, inRange, minMaxLoc, MatrixExpressions

元関数名(C#): core_max_MatMat
元DLLエクスポート名: core_max_MatMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_max_MatMat(cv::Mat *src1, const cv::Mat *src2, cv::Mat *dst)
{
    BEGIN_WRAP
    cv::max(*src1, *src2, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_max_MatDouble
[32/64bit] 2つの配列，あるいは，配列とスカラの 要素毎の最大値を求めます．
%prm
p1,p2,p3
p1 = sptr : IntPtr src1
p2 = double : double src2
p3 = sptr : IntPtr dst
%inst
関数 cv::max は，2つの配列の要素毎の最大値を求めます： ????? ) または，配列とスカラの組み合わせ．\See alsomin, compare, inRange, minMaxLoc, MatrixExpressions

元関数名(C#): core_max_MatDouble
元DLLエクスポート名: core_max_MatDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_max_MatDouble(cv::Mat *src1, double src2, cv::Mat *dst)
{
    BEGIN_WRAP
    cv::max(*src1, src2, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_sqrt
[32/64bit] 配列の要素の平方根を計算します．
%prm
p1,p2
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
%inst
関数 cv::sqrt は，入力配列の各要素の平方根を求めます．マルチチャンネル配列の場合，各チャンネルは独立して処理されます．その精度は，組み込みの std::sqrt とほぼ同じです．

元関数名(C#): core_sqrt
元DLLエクスポート名: core_sqrt
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_sqrt(cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::sqrt(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_pow_Mat
[32/64bit] 各配列要素をべき乗します．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = double : double power
p3 = sptr : IntPtr dst
%inst
関数 cv::pow は，入力配列の各要素をべき乗にします．(I) = \\\\\\\\\\\\\\\しかし，いくつかの追加演算を行うことで，負の値に対する真の値を得ることができます．以下の例では，配列 src の 5 次根を計算すると，次のようになります： Mat mask = src < 0;pow(src, 1./5, dst);subtract(Scalar::all(0), dst, dst, mask);fragment整数値である 0.5 や -0.5 などの一部の累乗値に対しては，特殊な高速アルゴリズムが用いられます．特殊な値（NaN, Inf）は扱われません．

元関数名(C#): core_pow_Mat
元DLLエクスポート名: core_pow_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_pow_Mat(cv::_InputArray *src, double power, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::pow(*src, power, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_exp_Mat
[32/64bit] 各配列要素の指数を求めます．
%prm
p1,p2
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
%inst
関数 cv::exp は，入力配列の各要素の指数を求めます．[I] = e^{ src(I) }\]最大の相対誤差は，単精度入力では約 7e-6，倍精度入力では 1e-10 未満です．現在，この関数は，非正規化された値をゼロに変換して出力します．関連項目：olog , cartToPolar , polarToCart , phase , pow , sqrt , magnitude

元関数名(C#): core_exp_Mat
元DLLエクスポート名: core_exp_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_exp_Mat(cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::exp(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_log_Mat
[32/64bit] 例
%prm
p1,p2
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
%inst
quatd q1{1,2,3,4};cout << log(q1) << endl;fragmentExamples: samples/cpp/polar_transforms.cpp, and samples/cpp/stitching_detailed.cpp.

元関数名(C#): core_log_Mat
元DLLエクスポート名: core_log_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_log_Mat(cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::log(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_polarToCart
[32/64bit] 2次元ベクトルの大きさと角度からx,y座標を計算します。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr magnitude
p2 = sptr : IntPtr angle
p3 = sptr : IntPtr x
p4 = sptr : IntPtr y
p5 = int : int angleInDegrees
%inst
関数 cv::polarToCart は，magnitude と angle の対応する要素で表される各 2 次元ベクトルのデカルト座標を求めます．\x(I) = ??-??-??(I） cos ( ????? )(I))\\ ♪♪♪♪♪♪♪〜(I) = ????? )(sin ( ????? )(I))\\ 参照：socartToPolar, magnitude, phase, exp, log, pow, sqrt

元関数名(C#): core_polarToCart
元DLLエクスポート名: core_polarToCart
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_polarToCart(cv::_InputArray* magnitude, cv::_InputArray* angle,
    cv::_OutputArray* x, cv::_OutputArray* y, int angleInDegrees)
{
    BEGIN_WRAP
    cv::polarToCart(*magnitude, *angle, *x, *y, angleInDegrees != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_cartToPolar
[32/64bit] 2D ベクトルの大きさと角度を計算します。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr x
p2 = sptr : IntPtr y
p3 = sptr : IntPtr magnitude
p4 = sptr : IntPtr angle
p5 = int : int angleInDegrees
%inst
関数 cv::cartToPolar は，すべての 2 次元ベクトル (x(I),y(I)) に対して，大きさ，角度，またはその両方を計算します．|magnitude}。(I)= \sqrt{\texttt{x}(I)^2+\texttt{y}(I)^2}♪♪♪♪〜(I）＝ ??? -? ???(I), ????? )(I))[ ??? -? ??? ]角度は約0.3度の精度で計算されています。点(0,0)の場合、角度は0になります。

元関数名(C#): core_cartToPolar
元DLLエクスポート名: core_cartToPolar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_cartToPolar(cv::_InputArray* x, cv::_InputArray* y,
    cv::_OutputArray* magnitude, cv::_OutputArray* angle, int angleInDegrees)
{
    BEGIN_WRAP
    cv::cartToPolar(*x, *y, *magnitude, *angle, angleInDegrees != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_phase
[32/64bit] 2次元ベクトルの回転角度を計算します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr x
p2 = sptr : IntPtr y
p3 = sptr : IntPtr angle
p4 = int : int angleInDegrees
%inst
関数 cv::phase は，x と y の対応する要素で構成される各 2 次元ベクトルの回転角を求めます．x(I)=y(I)=0のとき，対応する角度(I)は0になります。

元関数名(C#): core_phase
元DLLエクスポート名: core_phase
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_phase(cv::_InputArray* x, cv::_InputArray* y, cv::_OutputArray* angle, int angleInDegrees)
{
    BEGIN_WRAP
    cv::phase(*x, *y, *angle, angleInDegrees != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_magnitude_Mat
[32/64bit] 2次元ベクトルの大きさを計算します。
%prm
p1,p2,p3
p1 = sptr : IntPtr x
p2 = sptr : IntPtr y
p3 = sptr : IntPtr magnitude
%inst
関数 cv::magnitude は，x と y の配列の対応する要素から生成される 2 次元ベクトルの大きさを求めます：\\\ (I) = sqrt{\\ (I)^2 + ???????????????????????????????????????????????????????????????????????????????????????????????????????????????

元関数名(C#): core_magnitude_Mat
元DLLエクスポート名: core_magnitude_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_magnitude_Mat(cv::_InputArray* x, cv::_InputArray* y, cv::_OutputArray* magnitude)
{
    BEGIN_WRAP
    cv::magnitude(*x, *y, *magnitude);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_checkRange
[32/64bit] 入力配列の各要素に無効な値がないかチェックします。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr a
p2 = int : int quiet
p3 = var : out Point pos
p4 = double : double minVal
p5 = double : double maxVal
p6 = var : out int returnValue
%inst
関数 cv::checkRange は，各配列要素が NaN でも無限でもないことをチェックします．また，minVal > -DBL_MAX かつ maxVal < DBL_MAX の場合は，各値が minVal と maxVal の間にあるかどうかをチェックします．マルチチャンネル配列の場合，各チャンネルは独立して処理されます．いくつかの値が範囲外である場合，最初に外れた値の位置が pos に格納されます（ pos != NULL の場合）．そして，この関数は，（ quiet=true の場合）偽を返すか，例外を発生させます．

元関数名(C#): core_checkRange
元DLLエクスポート名: core_checkRange
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_checkRange(cv::_InputArray* a, int quiet, MyCvPoint* pos, double minVal, double maxVal, int* returnValue)
{
    BEGIN_WRAP
    cv::Point pos0;
    *returnValue = cv::checkRange(*a, quiet != 0, &amp;pos0, minVal, maxVal);
    *pos = c(pos0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_patchNaNs
[32/64bit] NaNを指定された数値に変換します．
%prm
p1,p2
p1 = sptr : IntPtr a
p2 = double : double val
%inst
元関数名(C#): core_patchNaNs
元DLLエクスポート名: core_patchNaNs
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_patchNaNs(cv::_InputOutputArray *a, double val)
{
    BEGIN_WRAP
    cv::patchNaNs(*a, val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_gemm
[32/64bit] 一般化された行列の乗算を行います．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = double : double alpha
p4 = sptr : IntPtr src3
p5 = double : double gamma
p6 = sptr : IntPtr dst
p7 = int : int flags
%inst
関数 cv::gemm は，BLAS レベル 3 の gemm 関数と同様に，一般化された行列の乗算を行います．例えば， gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T) は，次のように対応します：[?????] = ?????^T ????? )+ ????? )^T**]複素数（2チャンネル）のデータの場合は、複素数行列の乗算を行います。この関数は、行列式に置き換えることができます。例えば，上記の呼び出しは次のように置き換えることができます：dst = alpha*src1.t()*src2 + beta*src3.t();fragmentSee alsomulTransposed , transformExamples: samples/cpp/image_alignment.cpp.

元関数名(C#): core_gemm
元DLLエクスポート名: core_gemm
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_gemm(cv::_InputArray *src1, cv::_InputArray *src2, double alpha,
                      cv::_InputArray *src3, double gamma, cv::_OutputArray *dst, int flags)
{
    BEGIN_WRAP
    cv::gemm(*src1, *src2, alpha, *src3, gamma, *dst, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_mulTransposed
[32/64bit] 行列とその転置行列の積を求めます．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int aTa
p4 = sptr : IntPtr delta
p5 = double : double scale
p6 = int : int dtype
%inst
関数 cv::mulTransposed は， src とその転置の積を計算します： ??? -? ??? ( ???? )( ????? ) ^T ( ????? ) ATa=true , and\[????? )( ??? -? ??? ) ( ?????? )この関数は，共分散行列を計算するために使われます。デルタが 0 の場合は，一般的な行列積 A*B when B=A の高速な代替手段として利用できます．

元関数名(C#): core_mulTransposed
元DLLエクスポート名: core_mulTransposed
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_mulTransposed(cv::_InputArray *src, cv::_OutputArray *dst, int aTa,
                               cv::_InputArray *delta, double scale, int dtype)
{
    BEGIN_WRAP
    cv::mulTransposed(*src, *dst, aTa != 0, entity(delta), scale, dtype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_transpose
[32/64bit] 行列を転置します．
%prm
p1,p2
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
%inst
関数 cv::transpose は，行列 src を転置します．例：samples/cpp/train_HOG.cpp.

元関数名(C#): core_transpose
元DLLエクスポート名: core_transpose
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_transpose(cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::transpose(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_transform
[32/64bit] 配列の各要素に対して，行列変換を行います．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr m
%inst
関数 cv::transform は，配列 src の各要素に対して行列変換を行い，その結果を dst に格納します :??? -? ??? ???? (I) = ??? -? ??? (I) ???? (m.cols=src.channels()), or\[???? (I) = ??? -? ??? (I) = ??? -? ??? (I)(I) = \\\\\Nチャンネル配列 src の各要素は， M x N または M x (N+1) の行列 m を用いて変換された N 個の要素のベクトルとして解釈され，出力配列 dst の対応する要素となります．この関数は，N - 次元の点の幾何学的変換，任意の線形色空間変換（様々な RGB から YUV への変換など），画像チャンネルの入れ替えなどに利用できます． 関連項目：operspectiveTransform, getAffineTransform, estimateAffine2D, warpAffine, warpPerspective

元関数名(C#): core_transform
元DLLエクスポート名: core_transform
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_transform(cv::_InputArray *src, cv::_OutputArray *dst, cv::_InputArray *m)
{
    BEGIN_WRAP
    cv::transform(*src, *dst, *m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_perspectiveTransform
[32/64bit] ベクトルの透視行列変換を行います．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr m
%inst
関数 cv::parkentTransform は， src の各要素を 2 次元または 3 次元のベクトルとして扱い，次のように変換します：?[(x, y, z)] ?[Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions].\ここでは、3次元ベクトル変換を示しています。2次元ベクトル変換の場合は，z成分が省略されています．注：この関数は，2次元または3次元ベクトルの疎な集合を変換します．透視変換を用いて画像を変換したい場合は， warpPerspective を利用してください．逆問題がある場合，つまり，対応する複数の点の組から最も確率の高い透視変換を計算したい場合は， getPerspectiveTransform や findHomography を利用できます．

元関数名(C#): core_perspectiveTransform
元DLLエクスポート名: core_perspectiveTransform
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_perspectiveTransform(cv::_InputArray *src, cv::_OutputArray *dst, cv::_InputArray *m)
{
    BEGIN_WRAP
    cv::perspectiveTransform(*src, *dst, *m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_perspectiveTransform_Mat
[32/64bit] ベクトルの透視行列変換を行います．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr m
%inst
関数 cv::parkentTransform は， src の各要素を 2 次元または 3 次元のベクトルとして扱い，次のように変換します：?[(x, y, z)] ?[Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions].\ここでは、3次元ベクトル変換を示しています。2次元ベクトル変換の場合は，z成分が省略されています．注：この関数は，2次元または3次元ベクトルの疎な集合を変換します．透視変換を用いて画像を変換したい場合は， warpPerspective を利用してください．逆問題がある場合，つまり，対応する複数の点の組から最も確率の高い透視変換を計算したい場合は， getPerspectiveTransform や findHomography を利用できます．

元関数名(C#): core_perspectiveTransform_Mat
元DLLエクスポート名: core_perspectiveTransform_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_perspectiveTransform_Mat(cv::Mat *src, cv::Mat *dst, cv::Mat *m)
{
    BEGIN_WRAP
    cv::perspectiveTransform(*src, *dst, *m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_perspectiveTransform_Point2f
[32/64bit] ベクトルの透視行列変換を行います．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = int : int srcLength
p3 = sptr : IntPtr dst
p4 = int : int dstLength
p5 = sptr : IntPtr m
%inst
関数 cv::parkentTransform は， src の各要素を 2 次元または 3 次元のベクトルとして扱い，次のように変換します：?[(x, y, z)] ?[Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions].\ここでは、3次元ベクトル変換を示しています。2次元ベクトル変換の場合は，z成分が省略されています．注：この関数は，2次元または3次元ベクトルの疎な集合を変換します．透視変換を用いて画像を変換したい場合は， warpPerspective を利用してください．逆問題がある場合，つまり，対応する複数の点の組から最も確率の高い透視変換を計算したい場合は， getPerspectiveTransform や findHomography を利用できます．

元関数名(C#): core_perspectiveTransform_Point2f
元DLLエクスポート名: core_perspectiveTransform_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_perspectiveTransform_Point2f(cv::Point2f *src, int srcLength, cv::Point2f *dst, int dstLength, cv::_InputArray *m)
{
    BEGIN_WRAP
    const std::vector&amp;lt;cv::Point2f&amp;gt; srcVector(src, src + srcLength);
    std::vector&amp;lt;cv::Point2f&amp;gt; dstVector(dst, dst + dstLength);
    cv::perspectiveTransform(srcVector, dstVector, *m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_perspectiveTransform_Point2d
[32/64bit] ベクトルの透視行列変換を行います．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = int : int srcLength
p3 = sptr : IntPtr dst
p4 = int : int dstLength
p5 = sptr : IntPtr m
%inst
関数 cv::parkentTransform は， src の各要素を 2 次元または 3 次元のベクトルとして扱い，次のように変換します：?[(x, y, z)] ?[Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions].\ここでは、3次元ベクトル変換を示しています。2次元ベクトル変換の場合は，z成分が省略されています．注：この関数は，2次元または3次元ベクトルの疎な集合を変換します．透視変換を用いて画像を変換したい場合は， warpPerspective を利用してください．逆問題がある場合，つまり，対応する複数の点の組から最も確率の高い透視変換を計算したい場合は， getPerspectiveTransform や findHomography を利用できます．

元関数名(C#): core_perspectiveTransform_Point2d
元DLLエクスポート名: core_perspectiveTransform_Point2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_perspectiveTransform_Point2d(cv::Point2d *src, int srcLength, cv::Point2d *dst, int dstLength, cv::_InputArray *m)
{
    BEGIN_WRAP
    const std::vector&amp;lt;cv::Point2d&amp;gt; srcVector(src, src + srcLength);
    std::vector&amp;lt;cv::Point2d&amp;gt; dstVector(dst, dst + dstLength);
    cv::perspectiveTransform(srcVector, dstVector, *m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_perspectiveTransform_Point3f
[32/64bit] ベクトルの透視行列変換を行います．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = int : int srcLength
p3 = sptr : IntPtr dst
p4 = int : int dstLength
p5 = sptr : IntPtr m
%inst
関数 cv::parkentTransform は， src の各要素を 2 次元または 3 次元のベクトルとして扱い，次のように変換します：?[(x, y, z)] ?[Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions].\ここでは、3次元ベクトル変換を示しています。2次元ベクトル変換の場合は，z成分が省略されています．注：この関数は，2次元または3次元ベクトルの疎な集合を変換します．透視変換を用いて画像を変換したい場合は， warpPerspective を利用してください．逆問題がある場合，つまり，対応する複数の点の組から最も確率の高い透視変換を計算したい場合は， getPerspectiveTransform や findHomography を利用できます．

元関数名(C#): core_perspectiveTransform_Point3f
元DLLエクスポート名: core_perspectiveTransform_Point3f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_perspectiveTransform_Point3f(cv::Point3f *src, int srcLength, cv::Point3f *dst, int dstLength, cv::_InputArray *m)
{
    BEGIN_WRAP
    const std::vector&amp;lt;cv::Point3f&amp;gt; srcVector(src, src + srcLength);
    std::vector&amp;lt;cv::Point3f&amp;gt; dstVector(dst, dst + dstLength);
    cv::perspectiveTransform(srcVector, dstVector, *m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_perspectiveTransform_Point3d
[32/64bit] ベクトルの透視行列変換を行います．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = int : int srcLength
p3 = sptr : IntPtr dst
p4 = int : int dstLength
p5 = sptr : IntPtr m
%inst
関数 cv::parkentTransform は， src の各要素を 2 次元または 3 次元のベクトルとして扱い，次のように変換します：?[(x, y, z)] ?[Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions], [Ictions].\ここでは、3次元ベクトル変換を示しています。2次元ベクトル変換の場合は，z成分が省略されています．注：この関数は，2次元または3次元ベクトルの疎な集合を変換します．透視変換を用いて画像を変換したい場合は， warpPerspective を利用してください．逆問題がある場合，つまり，対応する複数の点の組から最も確率の高い透視変換を計算したい場合は， getPerspectiveTransform や findHomography を利用できます．

元関数名(C#): core_perspectiveTransform_Point3d
元DLLエクスポート名: core_perspectiveTransform_Point3d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_perspectiveTransform_Point3d(cv::Point3d *src, int srcLength, cv::Point3d *dst, int dstLength, cv::_InputArray *m)
{
    BEGIN_WRAP
    const std::vector&amp;lt;cv::Point3d&amp;gt; srcVector(src, src + srcLength);
    std::vector&amp;lt;cv::Point3d&amp;gt; dstVector(dst, dst + dstLength);
    cv::perspectiveTransform(srcVector, dstVector, *m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_completeSymm
[32/64bit] 正方行列の下半分または上半分を，もう一方の半分にコピーします．
%prm
p1,p2
p1 = sptr : IntPtr mtx
p2 = int : int lowerToUpper
%inst
関数 cv::completeSymm は，正方行列の下半分または上半分を，もう片方の半分にコピーします．行列の対角線は変更されません： ?(??? -? ???) for ?(??? -? ???) if lowerToUpper=false

\for elderToUpper=trueSee alsoflip, transpose

元関数名(C#): core_completeSymm
元DLLエクスポート名: core_completeSymm
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_completeSymm(cv::_InputOutputArray *mtx, int lowerToUpper)
{
    BEGIN_WRAP
    cv::completeSymm(*mtx, lowerToUpper != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_setIdentity
[32bit] スケーリングされた単位行列を初期化します．
%prm
p1,p2
p1 = sptr : IntPtr mtx
p2 = ARGS_SCALAR : Scalar s
%inst
関数 cv::setIdentity は，拡大された単位行列を初期化します．この関数は，行列の初期化子と行列表現を用いて，模倣することもできます．Mat A = Mat::eye(4, 3, CV_32F)*5;// A は，[[5, 0, 0], [0, 5, 0], [0, 0, 5], [0, 0, 0]]fragmentSee alsoMat::zeros, Mat::ones, Mat::setTo, Mat::operator=Examples: samples/cpp/kalman.cpp.

元関数名(C#): core_setIdentity
元DLLエクスポート名: core_setIdentity
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_setIdentity(cv::_InputOutputArray *mtx, MyCvScalar s)
{
    BEGIN_WRAP
    cv::setIdentity(*mtx, cpp(s));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_setIdentity
[64bit] スケーリングされた単位行列を初期化します．
%prm
p1,p2
p1 = sptr : IntPtr mtx
p2 = var : Scalar s
%inst
関数 cv::setIdentity は，拡大された単位行列を初期化します．この関数は，行列の初期化子と行列表現を用いて，模倣することもできます．Mat A = Mat::eye(4, 3, CV_32F)*5;// A は，[[5, 0, 0], [0, 5, 0], [0, 0, 5], [0, 0, 0]]fragmentSee alsoMat::zeros, Mat::ones, Mat::setTo, Mat::operator=Examples: samples/cpp/kalman.cpp.

元関数名(C#): core_setIdentity
元DLLエクスポート名: core_setIdentity
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_setIdentity(cv::_InputOutputArray *mtx, MyCvScalar s)
{
    BEGIN_WRAP
    cv::setIdentity(*mtx, cpp(s));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_determinant
[32/64bit] 浮動小数点型正方行列の行列式を返します．
%prm
p1,p2
p1 = sptr : IntPtr mtx
p2 = var : out double returnValue
%inst
関数 cv::determinant は，指定された行列の行列式を計算し，それを返します．小さな行列 ( mtx.cols=mtx.rows<=3 ) に対しては，直接法が用いられます．対称的な正定値行列に対しては，行列式を計算するために固有値分解を利用することも可能です． 関連項目：トレース，反転，解，固有値，MatrixExpressions

元関数名(C#): core_determinant
元DLLエクスポート名: core_determinant
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_determinant(cv::_InputArray *mtx, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::determinant(*mtx);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_trace
[32/64bit] 行列のトレースを返します。
%prm
p1,p2
p1 = sptr : IntPtr mtx
p2 = var : out Scalar returnValue
%inst
関数 cv::trace は，行列 mtx の対角要素の和を返します．

元関数名(C#): core_trace
元DLLエクスポート名: core_trace
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_trace(cv::_InputArray *mtx, MyCvScalar *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(cv::trace(*mtx));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_invert
[32/64bit] 逆行列（擬似逆行列）を求めます。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int flags
p4 = var : out double returnValue
%inst
関数 cv::invert は，行列 src を反転し，その結果を dst に格納します．行列 src が特異または非正方である場合，この関数は，ノルム(src*dst - I) が最小となるような擬似逆行列（dst 行列）を求めます（ここで I は単位行列）．DECOMP_SVD メソッドの場合，この関数は src の逆数（最小の特異値と最大の特異値の比）を返し， src が特異な場合は 0 を返します．DECOMP_LU と同様に，DECOMP_CHOLESKY メソッドも，非特異な正方行列（対称で正定値である必要があります）に対してのみ動作します．この場合，この関数は，反転した行列を dst に格納し，0 以外の値を返します。他にも，solve, SVD を参照してください。

元関数名(C#): core_invert
元DLLエクスポート名: core_invert
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_invert(cv::_InputArray *src, cv::_OutputArray *dst, int flags, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::invert(*src, *dst, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_solve
[32/64bit] 1 つまたは複数の連立方程式や最小二乗問題を解きます．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
p4 = int : int flags
p5 = var : out int returnValue
%inst
関数 cv::solve は，連立方程式や最小二乗問題を解きます（後者は，SVD や QR などの手法を用いるか，DECOMP_NORMAL フラグを指定することで可能になります）： ??? -? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ??? -? ???\\\\\\\\\\\\\\\\\\\\\\\\\\\|\DECOMP_LU または DECOMP_CHOLESKY メソッドが使われた場合， src1 (または ??? -? ???) が非特異点であれば，1を返します．また，後者の場合，dst は無効です．注意定義されていない特異系\(????? ) のユニティノルム解を求めたい場合，関数solveでは解が得られません．SVD::solveZを使ってください．参照：invert, SVD, eigen

元関数名(C#): core_solve
元DLLエクスポート名: core_solve
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_solve(cv::_InputArray *src1, cv::_InputArray *src2, cv::_OutputArray *dst, int flags, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::solve(*src1, *src2, *dst, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_solveLP
[32/64bit] 与えられた（非整数）線形計画問題を Simplex Algorithm (Simplex Method) を用いて解きます。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr func
p2 = sptr : IntPtr constr
p3 = sptr : IntPtr z
p4 = var : out int returnValue
%inst
ここでいう「線形計画問題」（略してLP問題）は、次のように定式化できます。ここで、\\は1×nの行ベクトル、A\はm×nの行列、b?はm×1の列ベクトル、x?はn×1の任意の列ベクトルであり、制約条件を満たしている。Simplexアルゴリズムは、この種の問題を効率的に処理するために設計された数多くのアルゴリズムの1つです。理論的には最適ではありませんが（上のように書かれた問題を多項式時間で解くことができるアルゴリズムは存在しますが、シンプレックス法はいくつかの特別なケースでは指数時間に縮退します）、よく研究されており、実装も簡単で、実際の目的にもよく合うことが示されています。特定の実装は、T. H. Cormen, C. E. Leiserson, R. L. Rivest and Clifford Stein著のIntroduction to Algorithms, third editionからほぼそのまま引用しています。特に、循環を防ぐために、Blandのルールhttp://en.wikipedia.org/wiki/Bland%27s_rule を使用しています。

元関数名(C#): core_solveLP
元DLLエクスポート名: core_solveLP
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_solveLP(cv::_InputArray *Func, cv::_InputArray *Constr, cv::_OutputArray *z, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::solveLP(*Func, *Constr, *z);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_sort
[32/64bit] 行列の各行または各列をソートします。
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int flags
%inst
関数 cv::sort は，行列の各行または各列を，昇順または降順にソートします．したがって，目的の動作を得るためには，2つの操作フラグを渡す必要があります．行列の行や列を辞書的にソートしたい場合は，STL の汎用関数 std::sort と適切な比較述語を利用することができます．他にも，sortIdx, randShuffleExamples: samples/cpp/stitching_detailed.cpp を参照してください．

元関数名(C#): core_sort
元DLLエクスポート名: core_sort
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_sort(cv::_InputArray *src, cv::_OutputArray *dst, int flags)
{
    BEGIN_WRAP
    cv::sort(*src, *dst, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_sortIdx
[32/64bit] 行列の各行または各列をソートします。
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int flags
%inst
関数 cv::sortIdx は，行列の各行または各列を，昇順または降順にソートします．したがって，望ましい動作を得るためには，2つの操作フラグを渡す必要があります．この関数は，要素自体を並べ替えるのではなく，ソートされた要素のインデックスを出力配列に格納します．例： Mat A = Mat::eye(3,3,CV_32F), B;sortIdx(A, B, SORT_EVERY_ROW + SORT_ASCENDING);// B はおそらく，// （A の要素が等しいので，いくつかの順列が可能です）：// [[1, 2, 0], [0, 2, 1], [0, 1, 2]]fragment 他にも，sort, randShuffle を参照してください．

元関数名(C#): core_sortIdx
元DLLエクスポート名: core_sortIdx
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_sortIdx(cv::_InputArray *src, cv::_OutputArray *dst, int flags)
{
    BEGIN_WRAP
    cv::sortIdx(*src, *dst, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_solveCubic
[32/64bit] 三次方程式の実根を求めます。
%prm
p1,p2,p3
p1 = sptr : IntPtr coeffs
p2 = sptr : IntPtr roots
p3 = var : out int returnValue
%inst
関数 solveCubic は， coeffs が 4 要素のベクトルである場合に，3 次方程式の実根を求めます．

\coeffs を 4 要素のベクトルとすると[0] x^3 + ?????[1] x^2 + \\[2] x + ????? )[3] = 0\]





coeffsが3要素のベクトルの場合。

\x^3 + ????? )[0] x^2 + ???д??? [1] x + ???? [2] x^2 + ???? [3] = 0[1] x + ????? [2] = 0[2] = 0\]根は roots配列に格納されます。

元関数名(C#): core_solveCubic
元DLLエクスポート名: core_solveCubic
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_solveCubic(cv::_InputArray *coeffs, cv::_OutputArray *roots, int *returnValue)
{
    BEGIN_WRAP
    *returnValue =  cv::solveCubic(*coeffs, *roots);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_solvePoly
[32/64bit] 多項式の実根または複素根を求めます。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr coeffs
p2 = sptr : IntPtr roots
p3 = int : int maxIters
p4 = var : out double returnValue
%inst
関数 cv::solvePoly は，多項式方程式の実根と複素根を求めます：????? )[n] x^{n}.+ ????? )[n-1] x^{n-1} + ...+ ?????[1] x + ?????[0] = 0\]

元関数名(C#): core_solvePoly
元DLLエクスポート名: core_solvePoly
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_solvePoly(cv::_InputArray *coeffs, cv::_OutputArray *roots, int maxIters, double *returnValue)
{
    BEGIN_WRAP
    *returnValue =  cv::solvePoly(*coeffs, *roots, maxIters);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_eigen
[32/64bit] 対称行列の固有値と固有ベクトルを求めます．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr eigenvalues
p3 = sptr : IntPtr eigenvectors
p4 = var : out int returnValue
%inst
関数 cv::eigen は，対称行列 src の固有値のみ，あるいは固有値と固有ベクトルを計算します： src*eigenvectors.row(i).t() = eigenvalues.at<srcType>(i)*eigenvectors.row(i).t()fragmentNote 非対称行列の実在の固有値と固有ベクトルを計算するには， cv::eigenNonSymmetric を利用します．eigenNonSymmetric, completeSymm , PCA も参照してください．

元関数名(C#): core_eigen
元DLLエクスポート名: core_eigen
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_eigen(cv::_InputArray *src, cv::_OutputArray *eigenvalues,    cv::_OutputArray *eigenvectors, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::eigen(*src, *eigenvalues, *eigenvectors) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_eigenNonSymmetric
[32/64bit] 非対称な行列の固有値と固有ベクトルを求めます（実数の固有値のみ）．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr eigenvalues
p3 = sptr : IntPtr eigenvectors
%inst
注意実数の固有値を仮定しています．この関数は，正方行列 src の固有値と固有ベクトル（オプション）を計算します： src*eigenvectors.row(i).t() = eigenvalues.at<srcType>(i)*eigenvectors.row(i).t()fragment See alsoeigen

元関数名(C#): core_eigenNonSymmetric
元DLLエクスポート名: core_eigenNonSymmetric
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_eigenNonSymmetric(
    cv::_InputArray *src,  cv::_OutputArray *eigenvalues, cv::_OutputArray *eigenvectors)
{
    BEGIN_WRAP
    cv::eigenNonSymmetric(*src, *eigenvalues, *eigenvectors);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_calcCovarMatrix_Mat
[32/64bit] ベクトルの集合の共分散行列を計算します。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : [MarshalAs(UnmanagedType.LPArray)] IntPtr[] samples
p2 = int : int nsamples
p3 = sptr : IntPtr covar
p4 = sptr : IntPtr mean
p5 = int : int flags
p6 = int : int ctype
%inst
関数 cv::calcCovarMatrix は，入力ベクトル集合の共分散行列と，オプションとして平均ベクトルを求めます．

元関数名(C#): core_calcCovarMatrix_Mat
元DLLエクスポート名: core_calcCovarMatrix_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_calcCovarMatrix_Mat(cv::Mat **samples, int nsamples, cv::Mat *covar, 
                                     cv::Mat *mean, int flags, int ctype)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; samplesVec(nsamples);
    for (int i = 0; i &amp;lt; nsamples; i++)    
        samplesVec[i] = *samples[i];
    
    cv::calcCovarMatrix(&amp;samplesVec[0], nsamples, *covar, *mean, flags, ctype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_calcCovarMatrix_InputArray
[32/64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr samples
p2 = sptr : IntPtr covar
p3 = sptr : IntPtr mean
p4 = int : int flags
p5 = int : int ctype
%inst
COVAR_ROWS または COVAR_COLS フラグを利用してください．

元関数名(C#): core_calcCovarMatrix_InputArray
元DLLエクスポート名: core_calcCovarMatrix_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_calcCovarMatrix_InputArray(cv::_InputArray *samples, cv::_OutputArray *covar, 
                                            cv::_InputOutputArray *mean, int flags, int ctype)
{
    BEGIN_WRAP
    cv::calcCovarMatrix(*samples, *covar, *mean, flags, ctype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_PCACompute
[32/64bit] ラップ PCA::operator()
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr data
p2 = sptr : IntPtr mean
p3 = sptr : IntPtr eigenvectors
p4 = int : int maxComponents
%inst
元関数名(C#): core_PCACompute
元DLLエクスポート名: core_PCACompute
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCACompute(cv::_InputArray *data, cv::_InputOutputArray *mean,
                            cv::_OutputArray *eigenvectors, int maxComponents)
{
    BEGIN_WRAP
    cv::PCACompute(*data, *mean, *eigenvectors, maxComponents);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_PCACompute2
[32/64bit] ラップ PCA::operator()
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr data
p2 = sptr : IntPtr mean
p3 = sptr : IntPtr eigenvectors
p4 = sptr : IntPtr eigenvalues
p5 = int : int maxComponents
%inst
元関数名(C#): core_PCACompute2
元DLLエクスポート名: core_PCACompute2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCACompute2(cv::_InputArray *data, cv::_InputOutputArray *mean,
                            cv::_OutputArray *eigenvectors, cv::_OutputArray *eigenvalues, int maxComponents)
{
    BEGIN_WRAP
    cv::PCACompute(*data, *mean, *eigenvectors, *eigenvalues, maxComponents);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_PCAComputeVar
[32/64bit] ラップ PCA::operator()
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr data
p2 = sptr : IntPtr mean
p3 = sptr : IntPtr eigenvectors
p4 = double : double retainedVariance
%inst
元関数名(C#): core_PCAComputeVar
元DLLエクスポート名: core_PCAComputeVar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCAComputeVar(cv::_InputArray *data, cv::_InputOutputArray *mean,
                               cv::_OutputArray *eigenvectors, double retainedVariance)
{
    BEGIN_WRAP
    cv::PCACompute(*data, *mean, *eigenvectors, retainedVariance);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_PCAComputeVar2
[32/64bit] ラップ PCA::operator()
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr data
p2 = sptr : IntPtr mean
p3 = sptr : IntPtr eigenvectors
p4 = sptr : IntPtr eigenvalues
p5 = double : double retainedVariance
%inst
元関数名(C#): core_PCAComputeVar2
元DLLエクスポート名: core_PCAComputeVar2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCAComputeVar2(cv::_InputArray *data, cv::_InputOutputArray *mean,
                               cv::_OutputArray *eigenvectors, cv::_OutputArray *eigenvalues, double retainedVariance)
{
    BEGIN_WRAP
    cv::PCACompute(*data, *mean, *eigenvectors, *eigenvalues, retainedVariance);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_PCAProject
[32/64bit] ラップ PCA::プロジェクト
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr data
p2 = sptr : IntPtr mean
p3 = sptr : IntPtr eigenvectors
p4 = sptr : IntPtr result
%inst
元関数名(C#): core_PCAProject
元DLLエクスポート名: core_PCAProject
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCAProject(cv::_InputArray *data, cv::_InputArray *mean,
                            cv::_InputArray *eigenvectors, cv::_OutputArray *result)
{
    BEGIN_WRAP
    cv::PCAProject(*data, *mean, *eigenvectors, *result);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_PCABackProject
[32/64bit] ラップ PCA::バックプロジェクト
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr data
p2 = sptr : IntPtr mean
p3 = sptr : IntPtr eigenvectors
p4 = sptr : IntPtr result
%inst
元関数名(C#): core_PCABackProject
元DLLエクスポート名: core_PCABackProject
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCABackProject(cv::_InputArray *data, cv::_InputArray *mean,
                                cv::_InputArray *eigenvectors, cv::_OutputArray *result)
{
    BEGIN_WRAP
    cv::PCABackProject(*data, *mean, *eigenvectors, *result);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_SVDecomp
[32/64bit] wrap SVD::compute
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = sptr : IntPtr w
p3 = sptr : IntPtr u
p4 = sptr : IntPtr vt
p5 = int : int flags
%inst
例: samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp.

元関数名(C#): core_SVDecomp
元DLLエクスポート名: core_SVDecomp
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SVDecomp(cv::_InputArray *src, cv::_OutputArray *w,
                          cv::_OutputArray *u, cv::_OutputArray *vt, int flags)
{
    BEGIN_WRAP
    cv::SVDecomp(*src, *w, *u, *vt, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_SVBackSubst
[32/64bit] ラップ SVD::BackSubst
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr w
p2 = sptr : IntPtr u
p3 = sptr : IntPtr vt
p4 = sptr : IntPtr rhs
p5 = sptr : IntPtr dst
%inst
元関数名(C#): core_SVBackSubst
元DLLエクスポート名: core_SVBackSubst
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SVBackSubst(cv::_InputArray *w, cv::_InputArray *u, cv::_InputArray *vt,
                             cv::_InputArray *rhs, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::SVBackSubst(*w, *u, *vt, *rhs, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_Mahalanobis
[32/64bit] 2 つのベクトル間のマハラノビス距離を計算します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr v1
p2 = sptr : IntPtr v2
p3 = sptr : IntPtr icovar
p4 = var : out double returnValue
%inst
関数 cv::Mahalanobis は，2 つのベクトル間の重み付き距離を計算し，それを返します．\d( ????? ) = ????? (?????)CalcCovarMatrix関数を用いて共分散行列を計算し，invert関数を用いて逆行列を求めることができます（最も精度の高いDECOMP_SVD法を用いるのが望ましい）。

元関数名(C#): core_Mahalanobis
元DLLエクスポート名: core_Mahalanobis
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mahalanobis(cv::_InputArray *v1, cv::_InputArray *v2, cv::_InputArray *icovar, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::Mahalanobis(*v1, *v2, *icovar);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_dft
[32/64bit] 1 次元または 2 次元の浮動小数点型配列に対して，離散フーリエ変換または逆変換を行います．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int flags
p4 = int : int nonzeroRows
%inst
関数 cv::dft は，以下のいずれかの処理を行います： N 個の要素を持つ 1 次元ベクトルのフーリエ変換を行います．

\Y = F^{(N)} ?cdot X,?]となります．



 ここで、\(F^{(N)}_{jk}=\exp(-2pi i j k/N)\)、\(i=sqrt{-1}\)とします。

N個の要素を持つ1次元ベクトルのフーリエ変換を逆変換します。

\♪♪♪♪♪〜X'= ?? (F^{(N)})\(1/N) ????? ) ????? )



 ここで、F^*=\left(F^{(N)})-\textrm{Im}(F^{(N)})\right)^T\)

M x N の行列の 2 次元フーリエ変換を進めます。

Y = F^{(M)} \cdot X \cdot F^{(N)}\[Y = F^{(M)} \cdot X ?cdot F^{(N)}\]となります。





M×Nの行列の2次元フーリエ変換を逆にします。

\♪♪♪♪♪♪〜♪ X'= ♪ ♪ left (F^{(M)})Y\\\\\♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪\実データ（シングルチャンネル）の場合、フーリエ変換の出力スペクトルや逆フーリエ変換の入力スペクトルは、CCS（complex-conjugate-symmetrical）というパック形式で表現できます。これはIPL(Intel* Image Processing Library)から拝借したものです。2次元CCSスペクトルはこんな感じです。Re Y_{0,0} & Re Y_{0,1} & Im Y_{0,1} & Re Y_{0,2} & Im Y_{0,2} & ????? ) Re Y_{0,N/2-1} & Im Y_{0,N/2-1} & Re Y_{0,N/2} ????? ) Re Y_{1,0} & Re Y_{1,1} & Im Y_{1,1} & Re Y_{1,2} & Im Y_{1,2} & ????? & Re Y_{1,N/2-1} & Im Y_{1,N/2-1} & Re Y_{1,N/2} ????? Im Y_{1,0} & Re Y_{2,1} & Im Y_{2,1} & Re Y_{2,2} & Im Y_{2,2} & \\ & Re Y_{2,N/2-1} & Im Y_{2,N/2-1} & Im Y_{1,N/2} \\\Re Y_{M/2-1,0} & Re Y_{M-3,1} & Im Y_{M-3,1} & \\\\N/2} ¶ Im Y_{M/2-1,0} & Re Y_{M-2,1} & Im Y_{M-2,1} & ¶hdotsfor{3} & Re Y_{M-2,N/2-1} & Im Y_{M-2,N/2-1}& Im Y_{M/2-1,N/2} \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\そこで，この関数は，フラグと入力配列のサイズに応じて処理モードを選択します： DFT_ROWS がセットされている場合，あるいは入力配列が1行あるいは1列の場合，この関数は，行列の各行に対して1次元の順変換あるいは逆変換を行います．それ以外の場合は，2次元変換を行います．

入力配列が実数で，DFT_INVERSE がセットされていない場合，この関数は 1 次元または 2 次元の順変換を行います。

DFT_COMPLEX_OUTPUT がセットされている場合，入力と同じサイズの複素行列が出力されます．

DFT_COMPLEX_OUTPUT がセットされていない場合，出力は入力と同じサイズの実数行列です．2次元変換の場合は，上記のようなパック形式を使用します。1つの1次元変換の場合，上述の行列の最初の行のようになります。複数の1次元変換の場合（DFT_ROWS フラグを利用した場合），出力行列の各行は，上述の行列の最初の行のようになります．





入力配列が複素数で，かつ DFT_INVERSE や DFT_REAL_OUTPUT がセットされていない場合，出力は入力と同じサイズの複素数配列になります．この関数は，フラグ DFT_INVERSE と DFT_ROWS に応じて，入力配列全体，あるいは入力配列の各行に対して，個別に 1 次元または 2 次元の順変換，逆変換を行います。

DFT_INVERSEがセットされていて，入力配列が実数の場合，あるいは複素数だがDFT_REAL_OUTPUTがセットされている場合，出力は入力と同じサイズの実数配列になります。この関数は，フラグ DFT_INVERSE と DFT_ROWS に応じて，入力配列全体，あるいは各行に対して，1次元あるいは2次元の逆変換を行います．DFT_SCALE がセットされている場合は，変換後にスケーリングが行われます．しかし，効率的に処理されるのは，そのサイズが小さな素数（現在の実装では，2，3，5）の積で因数分解できる配列だけです．このような効率的なDFTサイズは，getOptimalDFTSizeメソッドを用いて計算することができます．以下のサンプルは，2つの2次元実数配列のDFTベースの畳み込みを計算する方法を示しています： void convolveDFT(InputArray A, InputArray B, OutputArray C){ // 必要に応じて出力配列を再配置する C.create(abs(A.rows - B.rows)+1, abs(A.cols - B.cols)+1, A.type()); Size dftSize; // DFT 変換のサイズを計算する dftSize.width = getOptimalDFTSize(A.cols + B.cols - 1); dftSize.height = getOptimalDFTSize(A.rows + B.rows - 1); // 一時的なバッファを確保し，0 で初期化する Mat tempA(dftSize, A.type(), Scalar::all(0)); Mat tempB(dftSize, B.type(), Scalar::all(0)); // A と B をそれぞれ tempA と tempB の左上隅にコピーします． Mat roiA(tempA, Rect(0,0,A.cols,A.rows)); A.copyTo(roiA); Mat roiB(tempB, Rect(0,0,B.cols,B.rows)); B.copyTo(roiB); // パディングされた A & B をインプレースで変換します． // 高速処理のために "nonzeroRows" ヒントを利用します dft(tempA, tempA, 0, A.rows); dft(tempB, tempB, 0, B.rows); // スペクトルを乗算します．    // すべての結果行が非ゼロになるとしても， // 最初の C.rows だけが必要なので， // nonzeroRows == C.rows を渡します． dft(tempA, tempA, DFT_INVERSE + DFT_SCALE, C.rows); // ここで，結果を C にコピーします．copyTo(C); // すべての一時バッファは自動的に解放されます}fragmentこのサンプルを最適化するために，以下の方法を考えます： nonzeroRows != 0 が順変換の呼び出しに渡され，A と B はそれぞれ tempA と tempB の左上隅にコピーされるので，tempA と tempB 全体をクリアする必要はありません．tempA.cols - A.cols ( tempB.cols - B.cols ) の右端の列をクリアするだけでよいのです。

このDFTベースの畳み込みは，特にBがAよりもかなり小さい場合やその逆の場合には，大きな配列全体に適用する必要はありません．その代わりに，部分的に畳み込みを計算することができます．そのためには，出力配列Cを複数のタイルに分割する必要があります．各タイルについて、そのタイルでコンボリューションを計算するために、AとBのどの部分が必要かを推定します。Cのタイルが小さすぎると、繰り返し作業が発生するため、速度が大きく低下します。究極的には、Cの各タイルが1ピクセルの場合、このアルゴリズムは、ナイーブコンボリューションアルゴリズムと同等になる。タイルが大きすぎると、一時的な配列であるtempAとtempBが大きくなりすぎ、また、キャッシュの局所性が悪くなるため、速度が低下してしまいます。つまり、中間に最適なタイルサイズがあるのです。

C の異なるタイルが並行して計算され，その結果，畳み込みが部分的に行われるのであれば，ループをスレッド化することができます．上記の改良点はすべて matchTemplate と filter2D に実装されています．以上の改良点はすべてmatchTemplateとfilter2Dに実装されていますので，これらを使用すれば，上記の理論的に最適な実装よりもさらに優れた性能を得ることができます．ただし，この2つの関数は，実際には畳み込みではなく相互相関を計算しているので，flip.Noteを使って，2番目の畳み込みオペランドBを縦横に反転させる必要があります．

離散フーリエ変換を用いた例は、opencv_source_code/samples/cpp/dft.cppにあります。

(Python) dft 機能を使って Wiener デコンボリューションを行う例は opencv_source/samples/python/deconvolution.py にあります。

(Python) フーリエ画像の象限を並べ替える例は、opencv_source/samples/python/dft.pyにあります。

元関数名(C#): core_dft
元DLLエクスポート名: core_dft
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_dft(cv::_InputArray *src, cv::_OutputArray *dst, int flags, int nonzeroRows)
{
    BEGIN_WRAP
    cv::dft(*src, *dst, flags, nonzeroRows);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_idft
[32/64bit] 1次元または2次元配列の離散フーリエ変換の逆変換を求めます。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int flags
p4 = int : int nonzeroRows
%inst
idft(src, dst, flags) は， dft(src, dst, flags | DFT_INVERSE) と同等です．注意 dft と idft のいずれも，デフォルトでは結果をスケーリングしません．参照：odft, dct, idct, mulSpectrums, getOptimalDFTSize

元関数名(C#): core_idft
元DLLエクスポート名: core_idft
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_idft(cv::_InputArray *src, cv::_OutputArray *dst, int flags, int nonzeroRows)
{
    BEGIN_WRAP
    cv::idft(*src, *dst, flags, nonzeroRows);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_dct
[32/64bit] 1次元あるいは2次元の配列に対して，離散コサイン変換（順変換，逆変換）を行います．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int flags
%inst
関数 cv::dct は，1次元あるいは2次元の浮動小数点型配列に対して，離散コサイン変換（DCT）を行います： N 個の要素を持つ 1 次元ベクトルに対するコサイン変換．

\Y = C^{(N)} \cdot X\] となります．



 ここで

\[C^{(N)}_{jk}= \sqrt{\alpha_j/N}\C^{(N)}_{jk}= C^{(N)}_{jk}= C^{(N)}_{jk}= C^{(N)}_{k+1)j}{2N}\右）になります。］



 となり、j > 0では、\\0=1\、\\j=2?となります。

N個の要素を持つ1次元ベクトルの逆コサイン変換です。

\♪ X = ♪ left (C^{(N)})\¶X = ¶left (C^{(N)} ¶right )^{-1} ¶cdot Y = ¶left (C^{(N)} ¶right )^T ¶C\♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪］



 (C^{(N)}\)は直交行列なので、\(C^{(N)})(C^{(N)}\\left(C^{(N)}\right)^T = I\) )

M x N 行列の2次元コサイン変換を行います。

\Y = C^{(N)} \cdot X \cdot left (C^{(N)} \right )^T\]となります。





M×N行列の逆2次元コサイン変換です。

\この関数は，入力配列のフラグとサイズを考慮して処理モードを決定します： (flags & DCT_INVERSE) == 0 の場合，この関数は 1 次元または 2 次元の順変換を行います。それ以外の場合は，1次元または2次元の逆変換を行います。

(flags & DCT_ROWS) != 0 の場合，この関数は各行に対して1次元変換を行います。

配列が1つの列，あるいは1つの行である場合，この関数は1次元の変換を行います。

注意現在のdctは，偶数サイズの配列（2, 4, 6 ...）をサポートしています．データ解析や近似のために，必要に応じて配列をパディングすることができます．また，関数の性能は，配列のサイズに大きく依存し，単調ではありません（ getOptimalDFTSize を参照してください）．現在の実装では，サイズ N のベクトルに対する DCT は，サイズ N/2 のベクトルに対する DFT を介して計算されます．したがって，最適な DCT サイズ N1 >= N は次のように計算されます： size_t getOptimalDCTSize(size_t N) { return 2*getOptimalDFTSize((N+1)/2); }N1 = getOptimalDCTSize(N);See alsodft , getOptimalDFTSize , idct

元関数名(C#): core_dct
元DLLエクスポート名: core_dct
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_dct(cv::_InputArray *src, cv::_OutputArray *dst, int flags)
{
    BEGIN_WRAP
    cv::dct(*src, *dst, flags); 
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_idct
[32/64bit] 1次元あるいは2次元配列の離散コサイン変換の逆変換を求めます．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int flags
%inst
idct(src, dst, flags) は， dct(src, dst, flags | DCT_INVERSE) と同等です． 以下もご参照ください：odct, dft, idft, getOptimalDFTSize

元関数名(C#): core_idct
元DLLエクスポート名: core_idct
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_idct(cv::_InputArray *src, cv::_OutputArray *dst, int flags)
{
    BEGIN_WRAP
    cv::idct(*src, *dst, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_mulSpectrums
[32/64bit] 2つのフーリエ・スペクトルの要素毎の乗算を行います．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr a
p2 = sptr : IntPtr b
p3 = sptr : IntPtr c
p4 = int : int flags
p5 = int : int conjB
%inst
関数 cv::mulSpectrums は，実数または複素数のフーリエ変換の結果である，CCSパックされた2つの行列または複素数行列の要素毎の乗算を行います．この関数は， dft や idft と共に，2つの配列の畳み込み（ conjB=false を渡す）や相関（ conjB=true を渡す）を高速に計算するために利用されます．配列が複素数の場合，単純に（要素毎に）2番目の配列要素の共役を掛け合わせます．配列が実数の場合は，CCSパックされていると仮定されます（詳細は dft を参照してください）．

元関数名(C#): core_mulSpectrums
元DLLエクスポート名: core_mulSpectrums
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_mulSpectrums(cv::_InputArray *a, cv::_InputArray *b, cv::_OutputArray *c, int flags, int conjB)
{
    BEGIN_WRAP
    cv::mulSpectrums(*a, *b, *c, flags, conjB != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_getOptimalDFTSize
[32/64bit] 与えられたベクトルサイズに対する最適な DFT サイズを返します．
%prm
p1,p2
p1 = int : int vecsize
p2 = var : out int returnValue
%inst
DFTの性能は，ベクトルサイズの単調な関数ではありません．そのため，2つの配列の畳み込みを計算したり，配列のスペクトル分析を行ったりする場合は，通常，入力データをゼロで埋めて，元の配列よりも高速に変換できる少し大きな配列を得ることが有効です．サイズが2の累乗（2，4，8，16，32，...）である配列は，最も高速に処理できます．関数 cv::getOptimalDFTSize は，サイズ N のベクトルの DFT を効率的に処理できるような， vecsize 以上の最小の数 N を返します．現在の実装では，N = 2 ^p^ * 3 ^q^ * 5 ^r^ for some integer p, q, r.この関数は， vecsize が大きすぎる（INT_MAX に非常に近い）場合，負の値を返します．この関数は，DCT変換のための最適なベクトルサイズを推定するために直接利用することはできませんが（現在のDCT実装は，偶数サイズのベクトルしかサポートしていないので）， getOptimalDFTSize((vecsize+1)/2)*2 のように簡単に処理することができます．

元関数名(C#): core_getOptimalDFTSize
元DLLエクスポート名: core_getOptimalDFTSize
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_getOptimalDFTSize(int vecsize, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::getOptimalDFTSize(vecsize);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_theRNG_get
[32/64bit] cv::RNG::state 変数を取得します
%prm
p1
p1 = var : out ulong returnValue
%inst



元関数名(C#): core_theRNG_get
元DLLエクスポート名: core_theRNG_get
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_theRNG_get(uint64 *returnValue)
{
    BEGIN_WRAP
    cv::RNG &amp;rng = cv::theRNG();
    *returnValue = rng.state;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_theRNG_set
[32/64bit] cv::RNG::state 変数に格納します
%prm
p1
p1 = ARGS_ULONG : ulong returnValue
%inst



元関数名(C#): core_theRNG_set
元DLLエクスポート名: core_theRNG_set
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_theRNG_set(uint64 value)
{
    BEGIN_WRAP
    cv::theRNG().state = value;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_randu_InputArray
[32/64bit] 一様分散された単一の乱数または乱数配列を生成します。
%prm
p1,p2,p3
p1 = sptr : IntPtr dst
p2 = sptr : IntPtr low
p3 = sptr : IntPtr high
%inst
この関数の非テンプレート版は，指定された範囲の一様分布乱数で行列 dst を埋めます：??? -? ????RNG, randn, theRNGExamples: samples/cpp/cout_mat.cpp, samples/cpp/falecolor.cpp.

元関数名(C#): core_randu_InputArray
元DLLエクスポート名: core_randu_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_randu_InputArray(cv::_InputOutputArray *dst, cv::_InputArray *low, cv::_InputArray *high)
{
    BEGIN_WRAP
    cv::randu(*dst, *low, *high);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_randu_Scalar
[32bit] 一様分散された単一の乱数または乱数配列を生成します。
%prm
p1,p2,p3
p1 = sptr : IntPtr dst
p2 = ARGS_SCALAR : Scalar low
p3 = ARGS_SCALAR : Scalar high
%inst
この関数の非テンプレート版は，指定された範囲の一様分布乱数で行列 dst を埋めます：??? -? ????RNG, randn, theRNGExamples: samples/cpp/cout_mat.cpp, samples/cpp/falecolor.cpp.

元関数名(C#): core_randu_Scalar
元DLLエクスポート名: core_randu_Scalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_randu_Scalar(cv::_InputOutputArray *dst, MyCvScalar low, MyCvScalar high)
{
    BEGIN_WRAP
    cv::randu(*dst, cpp(low), cpp(high));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_randu_Scalar
[64bit] 一様分散された単一の乱数または乱数配列を生成します。
%prm
p1,p2,p3
p1 = sptr : IntPtr dst
p2 = var : Scalar low
p3 = var : Scalar high
%inst
この関数の非テンプレート版は，指定された範囲の一様分布乱数で行列 dst を埋めます：??? -? ????RNG, randn, theRNGExamples: samples/cpp/cout_mat.cpp, samples/cpp/falecolor.cpp.

元関数名(C#): core_randu_Scalar
元DLLエクスポート名: core_randu_Scalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_randu_Scalar(cv::_InputOutputArray *dst, MyCvScalar low, MyCvScalar high)
{
    BEGIN_WRAP
    cv::randu(*dst, cpp(low), cpp(high));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_randn_InputArray
[32/64bit] 配列を正規分布した乱数で埋めます．
%prm
p1,p2,p3
p1 = sptr : IntPtr dst
p2 = sptr : IntPtr mean
p3 = sptr : IntPtr stddev
%inst
関数 cv::randn は，指定された平均ベクトルと標準偏差行列を持つ正規分布乱数で行列 dst を埋めます．生成された乱数は，出力配列のデータ型の値域に合うようにクリップされます．RNG, randuExamples: samples/cpp/kalman.cpp も参照してください．

元関数名(C#): core_randn_InputArray
元DLLエクスポート名: core_randn_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_randn_InputArray(cv::_InputOutputArray *dst, cv::_InputArray *mean, cv::_InputArray *stddev)
{
    BEGIN_WRAP
    cv::randn(*dst, *mean, *stddev);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_randn_Scalar
[32bit] 配列を正規分布した乱数で埋めます．
%prm
p1,p2,p3
p1 = sptr : IntPtr dst
p2 = ARGS_SCALAR : Scalar mean
p3 = ARGS_SCALAR : Scalar stddev
%inst
関数 cv::randn は，指定された平均ベクトルと標準偏差行列を持つ正規分布乱数で行列 dst を埋めます．生成された乱数は，出力配列のデータ型の値域に合うようにクリップされます．RNG, randuExamples: samples/cpp/kalman.cpp も参照してください．

元関数名(C#): core_randn_Scalar
元DLLエクスポート名: core_randn_Scalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_randn_Scalar(cv::_InputOutputArray *dst, MyCvScalar mean, MyCvScalar stddev)
{
    BEGIN_WRAP
    cv::randn(*dst, cpp(mean), cpp(stddev));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_randn_Scalar
[64bit] 配列を正規分布した乱数で埋めます．
%prm
p1,p2,p3
p1 = sptr : IntPtr dst
p2 = var : Scalar mean
p3 = var : Scalar stddev
%inst
関数 cv::randn は，指定された平均ベクトルと標準偏差行列を持つ正規分布乱数で行列 dst を埋めます．生成された乱数は，出力配列のデータ型の値域に合うようにクリップされます．RNG, randuExamples: samples/cpp/kalman.cpp も参照してください．

元関数名(C#): core_randn_Scalar
元DLLエクスポート名: core_randn_Scalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_randn_Scalar(cv::_InputOutputArray *dst, MyCvScalar mean, MyCvScalar stddev)
{
    BEGIN_WRAP
    cv::randn(*dst, cpp(mean), cpp(stddev));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_randShuffle
[32/64bit] 配列の要素をランダムにシャッフルします。
%prm
p1,p2,p3
p1 = sptr : IntPtr dst
p2 = double : double iterFactor
p3 = var : ref ulong rng
%inst
関数 cv::randShuffle は，指定された1次元配列に対して，ランダムに要素のペアを選び，それらを入れ替えることでシャッフルを行います．このようなスワップ操作の回数は， dst.rows*dst.cols*iterFactor となります．RNG, sortExamples: modules/shape/samples/shape_example.cpp, samples/cpp/kmeans.cpp も参照してください．

元関数名(C#): core_randShuffle
元DLLエクスポート名: core_randShuffle
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_randShuffle(cv::_InputOutputArray *dst, double iterFactor, uint64 *rng)
{
    BEGIN_WRAP
    cv::RNG rng0;
    cv::randShuffle(*dst, iterFactor, &amp;rng0);
    *rng = rng0.state;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_kmeans
[32bit] クラスタの中心を見つけ、入力されたサンプルをそのクラスタの周りにグループ化します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr data
p2 = int : int k
p3 = sptr : IntPtr bestLabels
p4 = ARGS_TERMCRITERIA : TermCriteria criteria
p5 = int : int attempts
p6 = int : int flags
p7 = sptr : IntPtr centers
p8 = var : out double returnValue
%inst
関数 kmeans は，k-means アルゴリズムを実装しています．これは， cluster_count 個のクラスタの中心を見つけ，そのクラスタの周りに入力サンプルをグループ化するものです．出力として，Samples行列のSamples(i^{th}\)行に格納されているサンプルの0ベースのクラスタインデックスが含まれています．

(Python) K-means クラスタリングの例は、opencv_source_code/samples/python/kmeans.pyExamples: samples/cpp/kmeans.cpp にあります。

元関数名(C#): core_kmeans
元DLLエクスポート名: core_kmeans
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_kmeans(
    cv::_InputArray *data, int k, cv::_InputOutputArray *bestLabels,
    MyCvTermCriteria criteria, int attempts, int flags, cv::_OutputArray *centers, 
    double* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::kmeans(*data, k, *bestLabels, cpp(criteria), attempts, flags, entity(centers));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_kmeans
[64bit] クラスタの中心を見つけ、入力されたサンプルをそのクラスタの周りにグループ化します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr data
p2 = int : int k
p3 = sptr : IntPtr bestLabels
p4 = var : TermCriteria criteria
p5 = int : int attempts
p6 = int : int flags
p7 = sptr : IntPtr centers
p8 = var : out double returnValue
%inst
関数 kmeans は，k-means アルゴリズムを実装しています．これは， cluster_count 個のクラスタの中心を見つけ，そのクラスタの周りに入力サンプルをグループ化するものです．出力として，Samples行列のSamples(i^{th}\)行に格納されているサンプルの0ベースのクラスタインデックスが含まれています．

(Python) K-means クラスタリングの例は、opencv_source_code/samples/python/kmeans.pyExamples: samples/cpp/kmeans.cpp にあります。

元関数名(C#): core_kmeans
元DLLエクスポート名: core_kmeans
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_kmeans(
    cv::_InputArray *data, int k, cv::_InputOutputArray *bestLabels,
    MyCvTermCriteria criteria, int attempts, int flags, cv::_OutputArray *centers, 
    double* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::kmeans(*data, k, *bestLabels, cpp(criteria), attempts, flags, entity(centers));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_cubeRoot
[32/64bit] 引数の立方根を計算します。
%prm
p1,p2
p1 = float : float val
p2 = var : out float returnValue
%inst
cubeRoot関数は，\(\sqrt[3]{\texttt{val}}\)を計算します。負の引数は正しく処理されます。NaN，Infは処理されません。精度は、単精度データの最大可能精度に近づきます。

元関数名(C#): core_cubeRoot
元DLLエクスポート名: core_cubeRoot
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_cubeRoot(float val, float* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::cubeRoot(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_fastAtan2
[32/64bit] 2次元ベクトルの角度を度単位で計算します。
%prm
p1,p2,p3
p1 = float : float y
p2 = float : float x
p3 = var : out float returnValue
%inst
関数 fastAtan2 は，入力された 2 次元ベクトルの角度を全範囲にわたって計算します．角度の単位は度で，0度から360度の範囲で変化します．精度は約0.3度です。

元関数名(C#): core_fastAtan2
元DLLエクスポート名: core_fastAtan2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_fastAtan2(float y, float x, float* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::fastAtan2(y, x);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core

%index
core_Algorithm_write
[32/64bit] アルゴリズムのパラメータを，ファイルストレージに保存します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr fs
%inst
cv::FlannBasedMatcher, cv::DescriptorMatcher, cv::face::FaceRecognizer, cv::optflow::GPCForest< T >, cv::bioinspired::Retina, cv::line_descriptor::BinaryDescriptor, cv...で再実装されています．:Feature2D, cv::optflow::GPCTree, cv::bioinspired::TransientAreasSegmentationModule, cv::legacy::Tracker, cv::saliency::StaticSaliencySpectralResidual, and cv::face::BasicFaceRecognizer.

元関数名(C#): core_Algorithm_write
元DLLエクスポート名: core_Algorithm_write
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Algorithm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Algorithm_write(cv::Algorithm *obj, cv::FileStorage *fs)
{
    BEGIN_WRAP
    obj-&amp;gt;write(*fs);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Algorithm

%index
core_Algorithm_read
[32/64bit] ファイルストレージからアルゴリズムパラメータを読み込みます．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr fn
%inst
cv::FlannBasedMatcher, cv::DescriptorMatcher, cv::face::FaceRecognizer, cv::optflow::GPCForest< T >, cv::line_descriptor::BinaryDescriptor, cv::Feature2D, cv::optflow::GPCTree, cv::legacy::Tracker, cv::saliency::StaticSaliencySpectralResidual, and cv::face::BasicFaceRecognizer.

元関数名(C#): core_Algorithm_read
元DLLエクスポート名: core_Algorithm_read
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Algorithm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Algorithm_read(cv::Algorithm *obj, cv::FileNode *fn)
{
    BEGIN_WRAP
    obj-&amp;gt;read(*fn);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Algorithm

%index
core_Algorithm_empty
[32/64bit] アルゴリズムが空の場合（例えば，最初の頃や読み込みに失敗した後など）は，真を返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
cv::DescriptorMatcher, cv::face::FaceRecognizer, cv::ml::StatModel, cv::Feature2D, cv::BaseCascadeClassifier, cv::cuda::DescriptorMatcher, cv. で再実装されました．:quality::QualityPSNR, cv::quality::QualityBase, cv::face::BasicFaceRecognizer, cv::quality::QualityGMSD, cv::quality::QualitySSIM, そして cv::quality::QualityMSE.

元関数名(C#): core_Algorithm_empty
元DLLエクスポート名: core_Algorithm_empty
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Algorithm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Algorithm_empty(cv::Algorithm *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;empty() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Algorithm

%index
core_Algorithm_save
[32/64bit] アルゴリズムをファイルに保存します．このメソッドを動作させるためには，派生クラスが Algorithm::write(FileStorage& fs) を実装する必要があります．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = str : string filename
%inst
元関数名(C#): core_Algorithm_save
元DLLエクスポート名: core_Algorithm_save
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Algorithm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Algorithm_save(cv::Algorithm *obj, const char *filename)
{
    BEGIN_WRAP
    obj-&amp;gt;save(filename);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Algorithm

%index
core_Algorithm_getDefaultName
[32/64bit] core_Algorithm_getDefaultName
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr buf
%inst
元関数名(C#): core_Algorithm_getDefaultName
元DLLエクスポート名: core_Algorithm_getDefaultName
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Algorithm.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Algorithm_getDefaultName(cv::Algorithm *obj, std::string *buf)
{
    BEGIN_WRAP
    buf-&amp;gt;assign(obj-&amp;gt;getDefaultName());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Algorithm

%index
core_PCA_new1
[32/64bit] cv::PCA のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst
主成分分析を行います。

このクラスは、ベクトルの集合に対する特別な基底を計算するために使用されます。基底は、入力されたベクトルの集合から計算された共分散行列の固有ベクトルで構成されます。PCA クラスは，基底によって定義された新しい座標空間との間で，ベクトルを変換することもできます．通常，この新しい座標系では，元の集合からの各ベクトル（およびそのようなベクトルの任意の線形結合）は，共分散行列の最大の固有値の固有ベクトルに対応する最初の数個の成分を取ることによって，非常に正確に近似することができます．幾何学的には、共分散行列の支配的な固有値に対応するいくつかの固有ベクトルによって形成される部分空間へのベクトルの投影を計算することを意味します。そして、通常、このような投影は、元のベクトルに非常に近いものになります。つまり、高次元空間の元のベクトルを、部分空間に投影されたベクトルの座標からなるずっと短いベクトルで表すことができるのです。このような変換は、Karhunen-Loeve変換（KLT）とも呼ばれます。http://en.wikipedia.org/wiki/Principal_component_analysis 参照

下のサンプルは，2つの行列を受け取る関数です．1つ目の関数は，PCAの計算に使用されるベクトルの集合（1つのベクトルにつき1行）を格納します．2つ目の関数は，もう1つの「テスト」用のベクトルセット（1つのベクトルにつき1行）を格納します．まず，これらのベクトルは PCA によって圧縮され，次に再構成されます．そして，再構成誤差ノルムが計算され，各ベクトルに対して出力されます．


元関数名(C#): core_PCA_new1
元DLLエクスポート名: core_PCA_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCA_new1(cv::PCA **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::PCA;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_PCA_new2
[32/64bit] cv::PCA のインスタンスを生成します
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr data
p2 = sptr : IntPtr mean
p3 = int : int flags
p4 = int : int maxComponents
p5 = var : out IntPtr returnValue
%inst
主成分分析を行います。

このクラスは、ベクトルの集合に対する特別な基底を計算するために使用されます。基底は、入力されたベクトルの集合から計算された共分散行列の固有ベクトルで構成されます。PCA クラスは，基底によって定義された新しい座標空間との間で，ベクトルを変換することもできます．通常，この新しい座標系では，元の集合からの各ベクトル（およびそのようなベクトルの任意の線形結合）は，共分散行列の最大の固有値の固有ベクトルに対応する最初の数個の成分を取ることによって，非常に正確に近似することができます．幾何学的には、共分散行列の支配的な固有値に対応するいくつかの固有ベクトルによって形成される部分空間へのベクトルの投影を計算することを意味します。そして、通常、このような投影は、元のベクトルに非常に近いものになります。つまり、高次元空間の元のベクトルを、部分空間に投影されたベクトルの座標からなるずっと短いベクトルで表すことができるのです。このような変換は、Karhunen-Loeve変換（KLT）とも呼ばれます。http://en.wikipedia.org/wiki/Principal_component_analysis 参照

下のサンプルは，2つの行列を受け取る関数です．1つ目の関数は，PCAの計算に使用されるベクトルの集合（1つのベクトルにつき1行）を格納します．2つ目の関数は，もう1つの「テスト」用のベクトルセット（1つのベクトルにつき1行）を格納します．まず，これらのベクトルは PCA によって圧縮され，次に再構成されます．そして，再構成誤差ノルムが計算され，各ベクトルに対して出力されます．


元関数名(C#): core_PCA_new2
元DLLエクスポート名: core_PCA_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCA_new2(cv::_InputArray *data, cv::_InputArray *mean, int flags, int maxComponents, cv::PCA **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::PCA(*data, *mean, flags, maxComponents);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_PCA_new3
[32/64bit] cv::PCA のインスタンスを生成します
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr data
p2 = sptr : IntPtr mean
p3 = int : int flags
p4 = double : double retainedVariance
p5 = var : out IntPtr returnValue
%inst
主成分分析を行います。

このクラスは、ベクトルの集合に対する特別な基底を計算するために使用されます。基底は、入力されたベクトルの集合から計算された共分散行列の固有ベクトルで構成されます。PCA クラスは，基底によって定義された新しい座標空間との間で，ベクトルを変換することもできます．通常，この新しい座標系では，元の集合からの各ベクトル（およびそのようなベクトルの任意の線形結合）は，共分散行列の最大の固有値の固有ベクトルに対応する最初の数個の成分を取ることによって，非常に正確に近似することができます．幾何学的には、共分散行列の支配的な固有値に対応するいくつかの固有ベクトルによって形成される部分空間へのベクトルの投影を計算することを意味します。そして、通常、このような投影は、元のベクトルに非常に近いものになります。つまり、高次元空間の元のベクトルを、部分空間に投影されたベクトルの座標からなるずっと短いベクトルで表すことができるのです。このような変換は、Karhunen-Loeve変換（KLT）とも呼ばれます。http://en.wikipedia.org/wiki/Principal_component_analysis 参照

下のサンプルは，2つの行列を受け取る関数です．1つ目の関数は，PCAの計算に使用されるベクトルの集合（1つのベクトルにつき1行）を格納します．2つ目の関数は，もう1つの「テスト」用のベクトルセット（1つのベクトルにつき1行）を格納します．まず，これらのベクトルは PCA によって圧縮され，次に再構成されます．そして，再構成誤差ノルムが計算され，各ベクトルに対して出力されます．

using namespace cv;PCA compressPCA(const Mat& pcaset, int maxComponents, const Mat& testset, Mat& compressed){ PCA pca(pcaset, // データを渡す Mat(), // 事前に計算された平均ベクトルを持っていないので， // PCA エンジンに計算させます PCA::DATA_AS_ROW, // ベクトルが // 行列の行として格納されていることを示します // （ベクトルが // 行列の列である場合は PCA::DATA_AS_COL を利用してください） maxComponents // 保持する主成分の数を指定します ); // テストデータがない場合は，計算された基底を返すだけで，すぐに利用できます if( !testset.data ) return pca; CV_Assert( testset.cols == pcaset.cols ); compressed.create(testset.rows, maxComponents, testset.type()); Mat reconstructed; for( int i = 0; i < testset.rows; i++ ) { Mat vec = testset.row(i), coeffs = compressed.row(i), reconstructed; // ベクトルを圧縮し，その結果を // 出力行列の i 番目の行に格納します． pca.project(vec, coeffs); // そして，それを再構成します． pca.backProject(coeffs, reconstructed); // そして，その誤差を測定します．関連項目：ocalcCovarMatrix, mulTransposed, SVD, dft, dct

例: samples/cpp/pca.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp.


元関数名(C#): core_PCA_new3
元DLLエクスポート名: core_PCA_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCA_new3(cv::_InputArray *data, cv::_InputArray *mean, int flags, double retainedVariance, cv::PCA **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::PCA(*data, *mean, flags, retainedVariance);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_PCA_delete
[32/64bit] cv::PCA のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
主成分分析を行います。

このクラスは、ベクトルの集合に対する特別な基底を計算するために使用されます。基底は、入力されたベクトルの集合から計算された共分散行列の固有ベクトルで構成されます。PCA クラスは，基底によって定義された新しい座標空間との間で，ベクトルを変換することもできます．通常，この新しい座標系では，元の集合からの各ベクトル（およびそのようなベクトルの任意の線形結合）は，共分散行列の最大の固有値の固有ベクトルに対応する最初の数個の成分を取ることによって，非常に正確に近似することができます．幾何学的には、共分散行列の支配的な固有値に対応するいくつかの固有ベクトルによって形成される部分空間へのベクトルの投影を計算することを意味します。そして、通常、このような投影は、元のベクトルに非常に近いものになります。つまり、高次元空間の元のベクトルを、部分空間に投影されたベクトルの座標からなるずっと短いベクトルで表すことができるのです。このような変換は、Karhunen-Loeve変換（KLT）とも呼ばれます。http://en.wikipedia.org/wiki/Principal_component_analysis 参照

下のサンプルは，2つの行列を受け取る関数です．1つ目の関数は，PCAの計算に使用されるベクトルの集合（1つのベクトルにつき1行）を格納します．2つ目の関数は，もう1つの「テスト」用のベクトルセット（1つのベクトルにつき1行）を格納します．まず，これらのベクトルは PCA によって圧縮され，次に再構成されます．そして，再構成誤差ノルムが計算され，各ベクトルに対して出力されます．

using namespace cv;PCA compressPCA(const Mat& pcaset, int maxComponents, const Mat& testset, Mat& compressed){ PCA pca(pcaset, // データを渡す Mat(), // 事前に計算された平均ベクトルを持っていないので， // PCA エンジンに計算させます PCA::DATA_AS_ROW, // ベクトルが // 行列の行として格納されていることを示します // （ベクトルが // 行列の列である場合は PCA::DATA_AS_COL を利用してください） maxComponents // 保持する主成分の数を指定します ); // テストデータがない場合は，計算された基底を返すだけで，すぐに利用できます if( !testset.data ) return pca; CV_Assert( testset.cols == pcaset.cols ); compressed.create(testset.rows, maxComponents, testset.type()); Mat reconstructed; for( int i = 0; i < testset.rows; i++ ) { Mat vec = testset.row(i), coeffs = compressed.row(i), reconstructed; // ベクトルを圧縮し，その結果を // 出力行列の i 番目の行に格納します． pca.project(vec, coeffs); // そして，それを再構成します． pca.backProject(coeffs, reconstructed); // そして，その誤差を測定します．関連項目：ocalcCovarMatrix, mulTransposed, SVD, dft, dct

例: samples/cpp/pca.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp.


元関数名(C#): core_PCA_delete
元DLLエクスポート名: core_PCA_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCA_delete(cv::PCA *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_PCA_operatorThis
[32/64bit] core_PCA_operatorThis
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr data
p3 = sptr : IntPtr mean
p4 = int : int flags
p5 = int : int maxComponents
%inst
元関数名(C#): core_PCA_operatorThis
元DLLエクスポート名: core_PCA_operatorThis
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCA_operatorThis(cv::PCA *obj, cv::_InputArray *data, cv::_InputArray *mean, int flags, int maxComponents)
{
    BEGIN_WRAP
    (*obj)(*data, *mean, flags, maxComponents);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_PCA_computeVar
[32/64bit] core_PCA_computeVar
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr data
p3 = sptr : IntPtr mean
p4 = int : int flags
p5 = double : double retainedVariance
%inst
元関数名(C#): core_PCA_computeVar
元DLLエクスポート名: core_PCA_computeVar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCA_computeVar(cv::PCA *obj, cv::_InputArray *data, cv::_InputArray *mean, int flags, double retainedVariance)
{
    BEGIN_WRAP
    (*obj)(*data, *mean, flags, retainedVariance);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_PCA_project1
[32/64bit] ベクトルを主成分部分空間に投射します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr vec
p3 = var : out IntPtr returnValue
%inst
これらのメソッドは，1 つ以上のベクトルを主成分部分空間に射影します．各ベクトルの射影は，主成分基底の係数で表されます．このメソッドの第 1 の形式は，第 2 の形式が結果に書き込む行列を返します．したがって，第1の形式は式の一部として使用でき，第2の形式は処理ループの中でより効率的に使用できます．例：samples/cpp/pca.cpp.

元関数名(C#): core_PCA_project1
元DLLエクスポート名: core_PCA_project1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCA_project1(cv::PCA *obj, cv::_InputArray *vec, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto ret = obj-&amp;gt;project(*vec);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_PCA_project2
[32/64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr vec
p3 = sptr : IntPtr result
%inst
元関数名(C#): core_PCA_project2
元DLLエクスポート名: core_PCA_project2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCA_project2(cv::PCA *obj, cv::_InputArray *vec, cv::_OutputArray *result)
{
    BEGIN_WRAP
    obj-&amp;gt;project(*vec, *result);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_PCA_backProject1
[32/64bit] ベクトルをそのPC投影から再構成します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr vec
p3 = var : out IntPtr returnValue
%inst
これらのメソッドは，PCA::project の逆の操作です．これらのメソッドは，投影されたベクトルのPC座標を取り，元のベクトルを再構成します．すべての主成分が保持されていない限り，再構成されたベクトルは元のベクトルとは異なります．しかし，成分数が十分に多ければ，その差は小さくなります（それでも，元のベクトルの次元数よりはずっと小さいです）．例：samples/cpp/pca.cpp.PCAを使用しています．

元関数名(C#): core_PCA_backProject1
元DLLエクスポート名: core_PCA_backProject1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCA_backProject1(cv::PCA *obj, cv::_InputArray *vec, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto ret = obj-&amp;gt;backProject(*vec);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_PCA_backProject2
[32/64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr vec
p3 = sptr : IntPtr result
%inst
元関数名(C#): core_PCA_backProject2
元DLLエクスポート名: core_PCA_backProject2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCA_backProject2(cv::PCA *obj, cv::_InputArray *vec, cv::_OutputArray *result)
{
    BEGIN_WRAP
    obj-&amp;gt;backProject(*vec, *result);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_PCA_eigenvectors
[32/64bit] cv::PCA::eigenvectors 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
共分散行列の固有ベクトル


元関数名(C#): core_PCA_eigenvectors
元DLLエクスポート名: core_PCA_eigenvectors
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCA_eigenvectors(cv::PCA *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(obj-&amp;gt;eigenvectors);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_PCA_eigenvalues
[32/64bit] cv::PCA::eigenvalues 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
共分散行列の固有値


元関数名(C#): core_PCA_eigenvalues
元DLLエクスポート名: core_PCA_eigenvalues
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCA_eigenvalues(cv::PCA *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(obj-&amp;gt;eigenvalues);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_PCA_mean
[32/64bit] cv::PCA::mean 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
投影前に減算され，バックプロジェクション後に加算される平均値．


元関数名(C#): core_PCA_mean
元DLLエクスポート名: core_PCA_mean
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCA_mean(cv::PCA *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(obj-&amp;gt;mean);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_PCA_write
[32/64bit] PCA オブジェクトの書き込み
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr fs
%inst
固有値 固有ベクトルと平均値を指定された FileStorage に書き込みます．

元関数名(C#): core_PCA_write
元DLLエクスポート名: core_PCA_write
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCA_write(cv::PCA *obj, cv::FileStorage *fs)
{
    BEGIN_WRAP
    obj-&amp;gt;write(*fs);
    END_WRAP    
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_PCA_read
[32/64bit] PCA オブジェクトの読み込み
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr fn
%inst
固有値，固有ベクトル，平均値を指定した FileNode から読み込みます．

元関数名(C#): core_PCA_read
元DLLエクスポート名: core_PCA_read
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_PCA_read(cv::PCA *obj, cv::FileNode *fn)
{
    BEGIN_WRAP
    obj-&amp;gt;read(*fn);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_RNG_fill
[32/64bit] 配列を乱数で埋めます．
%prm
p1,p2,p3,p4,p5,p6
p1 = var : ref ulong state
p2 = sptr : IntPtr mat
p3 = int : int distType
p4 = sptr : IntPtr a
p5 = sptr : IntPtr b
p6 = int : int saturateRange
%inst
それぞれのメソッドは，指定された分布からのランダムな値で行列を埋めます．新しい数値が生成されると，それに応じて RNG の状態が更新されます．マルチチャンネル画像の場合，各チャンネルは独立に埋められます．つまり，RNGは，非対角共分散行列を持つ多次元ガウス分布から直接サンプルを生成することはできません．そのため，このメソッドは，平均が0で共分散行列が等比級数である多次元標準ガウス分布からサンプルを生成し，それをtransformを用いて変換することで，指定したガウス分布からサンプルを得ることができます．

元関数名(C#): core_RNG_fill
元DLLエクスポート名: core_RNG_fill
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_RNG_fill(uint64 *state, cv::_InputOutputArray *mat, int distType, cv::_InputArray *a, cv::_InputArray *b, int saturateRange)
{
    BEGIN_WRAP
    cv::RNG rng(*state);
    rng.fill(*mat, distType, *a, *b, saturateRange != 0);
    *state = rng.state;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_RNG_gaussian
[32/64bit] ガウス分布からサンプリングされた次の乱数を返します。
%prm
p1,p2,p3
p1 = var : ref ulong state
p2 = double : double sigma
p3 = var : out double returnValue
%inst
このメソッドは，MWCアルゴリズムを用いて状態を変換し，ガウス分布N(0,sigma)から次の乱数を返します．つまり，返される乱数の平均値は0で，標準偏差は指定されたsigmaとなります．

元関数名(C#): core_RNG_gaussian
元DLLエクスポート名: core_RNG_gaussian
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_RNG_gaussian(uint64 *state, double sigma, double *returnValue)
{
    BEGIN_WRAP
    cv::RNG rng(*state);
    *returnValue = rng.gaussian(sigma);
    *state = rng.state;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_SVD_new1
[32/64bit] cv::SVD のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst
特異値分解。

浮動小数点型の行列の特異値分解を計算するためのクラスです．特異値分解は，最小二乗問題，過小決定された連立方程式，行列の反転，条件数の計算などに利用されます．

行列の条件数や行列式の絶対値を計算したい場合は，u と vt は必要ありません．flags=SVD::NO_UV|...を渡すことができます．もう1つのフラグ SVD::FULL_UV は，フルサイズの u と vt を計算しなければならないことを示しますが，ほとんどの場合は必要ありません．

関連項目： 反転, 解決, 固有値, 行列式


元関数名(C#): core_SVD_new1
元DLLエクスポート名: core_SVD_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SVD_new1(cv::SVD **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::SVD;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_SVD_new2
[32/64bit] cv::SVD のインスタンスを生成します
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = int : int flags
p3 = var : out IntPtr returnValue
%inst
特異値分解。

浮動小数点型の行列の特異値分解を計算するためのクラスです．特異値分解は，最小二乗問題，過小決定された連立方程式，行列の反転，条件数の計算などに利用されます．

行列の条件数や行列式の絶対値を計算したい場合は，u と vt は必要ありません．flags=SVD::NO_UV|...を渡すことができます．もう1つのフラグ SVD::FULL_UV は，フルサイズの u と vt を計算しなければならないことを示しますが，ほとんどの場合は必要ありません．

関連項目： 反転, 解決, 固有値, 行列式


元関数名(C#): core_SVD_new2
元DLLエクスポート名: core_SVD_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SVD_new2(cv::_InputArray *src, int flags, cv::SVD **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::SVD(*src, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_SVD_delete
[32/64bit] cv::SVD のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
特異値分解。

浮動小数点型の行列の特異値分解を計算するためのクラスです．特異値分解は，最小二乗問題，過小決定された連立方程式，行列の反転，条件数の計算などに利用されます．

行列の条件数や行列式の絶対値を計算したい場合は，u と vt は必要ありません．flags=SVD::NO_UV|...を渡すことができます．もう1つのフラグ SVD::FULL_UV は，フルサイズの u と vt を計算しなければならないことを示しますが，ほとんどの場合は必要ありません．

関連項目： 反転, 解決, 固有値, 行列式


元関数名(C#): core_SVD_delete
元DLLエクスポート名: core_SVD_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SVD_delete(cv::SVD *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_SVD_operatorThis
[32/64bit] core_SVD_operatorThis
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr src
p3 = int : int flags
%inst
元関数名(C#): core_SVD_operatorThis
元DLLエクスポート名: core_SVD_operatorThis
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SVD_operatorThis(cv::SVD *obj, cv::_InputArray *src, int flags)
{
    BEGIN_WRAP
    (*obj)(*src, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_SVD_backSubst
[32/64bit] 特異値後退代入を行います。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr rhs
p3 = sptr : IntPtr dst
%inst
このメソッドは，指定された右辺の後退代入を計算します：\[texttt{x} = \tt{vt}.^T ?ag( ????? )^{-1} ?????????♪♪♪♪♪〜\Smilax china (species of sarsaparilla)NoteExplicit SVD with further back substitution is only meaning that you need to solve many linear systems with the same left-hand side (for example, src ).1つの連立方程式（複数の rhs がすぐに得られる可能性がある）を解くだけならば，単に solve を呼び出して，DECOMP_SVD を渡してください．これは，まったく同じことを行います．

元関数名(C#): core_SVD_backSubst
元DLLエクスポート名: core_SVD_backSubst
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SVD_backSubst(cv::SVD *obj, cv::_InputArray *rhs, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    obj-&amp;gt;backSubst(*rhs, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_SVD_static_compute1
[32/64bit] 行列を分解し，その結果をユーザが提供する行列に格納します
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = sptr : IntPtr w
p3 = sptr : IntPtr u
p4 = sptr : IntPtr vt
p5 = int : int flags
%inst
これらのメソッド/関数は，行列の SVD を行います．SVD::SVD コンストラクタや SVD::operator() とは異なり，ユーザが提供する行列に結果が格納されます．

元関数名(C#): core_SVD_static_compute1
元DLLエクスポート名: core_SVD_static_compute1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SVD_static_compute1(cv::_InputArray *src, cv::_OutputArray *w,
                                                cv::_OutputArray *u, cv::_OutputArray *vt, int flags)
{
    BEGIN_WRAP
    cv::SVD::compute(*src, *w, *u, *vt, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_SVD_static_compute2
[32/64bit] これは，利便性のために提供されるオーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです． 行列の特異値を計算します．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr w
p3 = int : int flags
%inst
元関数名(C#): core_SVD_static_compute2
元DLLエクスポート名: core_SVD_static_compute2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SVD_static_compute2(cv::_InputArray *src, cv::_OutputArray *w, int flags)
{
    BEGIN_WRAP
    cv::SVD::compute(*src, *w, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_SVD_static_backSubst
[32/64bit] 後方置換の実行
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr w
p2 = sptr : IntPtr u
p3 = sptr : IntPtr vt
p4 = sptr : IntPtr rhs
p5 = sptr : IntPtr dst
%inst
元関数名(C#): core_SVD_static_backSubst
元DLLエクスポート名: core_SVD_static_backSubst
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SVD_static_backSubst(cv::_InputArray *w, cv::_InputArray *u,
                                                 cv::_InputArray *vt, cv::_InputArray *rhs, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::SVD::backSubst(*w, *u, *vt, *rhs, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_SVD_static_solveZ
[32/64bit] 決定されていない特異な連立方程式を解く
%prm
p1,p2
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
%inst
このメソッドは，特異連立方程式 A*x = 0 の単位長さの解 x を求めます．A の階数に応じて，解が存在しない場合，1つの解が存在する場合，無限の解が存在する場合があります．一般的に、このアルゴリズムは次のような問題を解きます：??? -? ??? "dst = ???" "x: ??? -? ???" "src: ???" "x: ??? -? ???

元関数名(C#): core_SVD_static_solveZ
元DLLエクスポート名: core_SVD_static_solveZ
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SVD_static_solveZ(cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::SVD::solveZ(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_SVD_u
[32/64bit] cv::SVD::u 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): core_SVD_u
元DLLエクスポート名: core_SVD_u
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SVD_u(cv::SVD *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(obj-&amp;gt;u);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_SVD_w
[32/64bit] cv::SVD::w 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): core_SVD_w
元DLLエクスポート名: core_SVD_w
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SVD_w(cv::SVD *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(obj-&amp;gt;w);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_SVD_vt
[32/64bit] cv::SVD::vt 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): core_SVD_vt
元DLLエクスポート名: core_SVD_vt
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SVD_vt(cv::SVD *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(obj-&amp;gt;vt);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_LDA_new1
[32/64bit] cv::LDA のインスタンスを生成します
%prm
p1,p2
p1 = int : int numComponents
p2 = var : out IntPtr returnValue
%inst
Linear Discriminant Analysisの略。

Todo:document this class


元関数名(C#): core_LDA_new1
元DLLエクスポート名: core_LDA_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_LDA_new1(int num_components, cv::LDA **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::LDA(num_components);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_LDA_new2
[32/64bit] cv::LDA のインスタンスを生成します
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr labels
p3 = int : int numComponents
p4 = var : out IntPtr returnValue
%inst
Linear Discriminant Analysisの略。

Todo:document this class


元関数名(C#): core_LDA_new2
元DLLエクスポート名: core_LDA_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_LDA_new2(cv::_InputArray *src, cv::_InputArray *labels, int num_components, cv::LDA **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::LDA(*src, *labels, num_components);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_LDA_delete
[32/64bit] cv::LDA のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
Linear Discriminant Analysisの略。

Todo:document this class


元関数名(C#): core_LDA_delete
元DLLエクスポート名: core_LDA_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_LDA_delete(cv::LDA *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_LDA_save_String
[32/64bit] このオブジェクトを指定されたファイル名にシリアル化します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
%inst
元関数名(C#): core_LDA_save_String
元DLLエクスポート名: core_LDA_save_String
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_LDA_save_String(cv::LDA *obj, const char *filename)
{
    BEGIN_WRAP
    obj-&amp;gt;save(filename);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_LDA_load_String
[32/64bit] 与えられたファイル名からこのオブジェクトをデシリアライズします。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
%inst
元関数名(C#): core_LDA_load_String
元DLLエクスポート名: core_LDA_load_String
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_LDA_load_String(cv::LDA *obj, const char *filename)
{
    BEGIN_WRAP
    obj-&amp;gt;load(filename);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_LDA_save_FileStorage
[32/64bit] このオブジェクトを指定されたファイル名にシリアル化します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr fs
%inst
元関数名(C#): core_LDA_save_FileStorage
元DLLエクスポート名: core_LDA_save_FileStorage
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_LDA_save_FileStorage(cv::LDA *obj, cv::FileStorage *fs)
{
    BEGIN_WRAP
    obj-&amp;gt;save(*fs);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_LDA_load_FileStorage
[32/64bit] 与えられたファイル名からこのオブジェクトをデシリアライズします。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr node
%inst
元関数名(C#): core_LDA_load_FileStorage
元DLLエクスポート名: core_LDA_load_FileStorage
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_LDA_load_FileStorage(cv::LDA *obj, cv::FileStorage *node)
{
    BEGIN_WRAP
    obj-&amp;gt;load(*node);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_LDA_compute
[32/64bit] src (row aligned) と labels のデータの判別式を計算します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr src
p3 = sptr : IntPtr labels
%inst
元関数名(C#): core_LDA_compute
元DLLエクスポート名: core_LDA_compute
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_LDA_compute(cv::LDA *obj, cv::_InputArray *src, cv::_InputArray *labels)
{
    BEGIN_WRAP
    obj-&amp;gt;compute(*src, *labels);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_LDA_project
[32/64bit] src は，1つまたは複数の行整列されたサンプルです．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr src
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_LDA_project
元DLLエクスポート名: core_LDA_project
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_LDA_project(cv::LDA *obj, cv::_InputArray *src, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto mat = obj-&amp;gt;project(*src);
    *returnValue = new cv::Mat(mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_LDA_reconstruct
[32/64bit] LDA 部分空間から投影データを再構成します． src は，1つまたは複数の行がアラインメントされた投影データです．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr src
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_LDA_reconstruct
元DLLエクスポート名: core_LDA_reconstruct
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_LDA_reconstruct(cv::LDA *obj, cv::_InputArray *src, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto mat = obj-&amp;gt;reconstruct(*src);
    *returnValue = new cv::Mat(mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_LDA_eigenvectors
[32/64bit] この LDA の固有ベクトルを返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_LDA_eigenvectors
元DLLエクスポート名: core_LDA_eigenvectors
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_LDA_eigenvectors(cv::LDA *obj, cv::Mat **returnValue)
{ 
    BEGIN_WRAP
    const auto mat = obj-&amp;gt;eigenvectors();
    *returnValue = new cv::Mat(mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_LDA_eigenvalues
[32/64bit] LDA の固有値を返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_LDA_eigenvalues
元DLLエクスポート名: core_LDA_eigenvalues
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_LDA_eigenvalues(cv::LDA *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto mat = obj-&amp;gt;eigenvalues();
    *returnValue = new cv::Mat(mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_LDA_subspaceProject
[32/64bit] core_LDA_subspaceProject
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr w
p2 = sptr : IntPtr mean
p3 = sptr : IntPtr src
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_LDA_subspaceProject
元DLLエクスポート名: core_LDA_subspaceProject
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_LDA_subspaceProject(cv::_InputArray *W, cv::_InputArray *mean, cv::_InputArray *src, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto mat = cv::LDA::subspaceProject(*W, *mean, *src);
    *returnValue = new cv::Mat(mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_LDA_subspaceReconstruct
[32/64bit] core_LDA_subspaceReconstruct
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr w
p2 = sptr : IntPtr mean
p3 = sptr : IntPtr src
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_LDA_subspaceReconstruct
元DLLエクスポート名: core_LDA_subspaceReconstruct
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Classes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_LDA_subspaceReconstruct(cv::_InputArray *W, cv::_InputArray *mean, cv::_InputArray *src, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto mat = cv::LDA::subspaceReconstruct(*W, *mean, *src);
    *returnValue = new cv::Mat(mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Classes

%index
core_FileNode_new1
[32/64bit] cv::FileNode のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst
ファイルストレージノードクラス．

このノードは，読み込みのために開かれたファイルストレージの各要素を格納するために使用されます．XML/YAMLファイルが読み込まれると，まずそれが解析され，ノードの階層的なコレクションとしてメモリに格納されます．各ノードは、1つの数値や文字列を含む「リーフ」であったり、他のノードのコレクションであったりします。各要素が名前を持ち、名前でアクセスされる名前付きコレクション（マッピング）と、要素が名前を持たずインデックスでアクセスされる順序付きコレクション（シーケンス）があります。ファイルノードのタイプは、FileNode::type メソッドを使用して決定できます。

ファイルノードは、読み取り用にオープンされたファイルストレージをナビゲートするためにのみ使用されることに注意してください。ファイルノードは、読み込み用にオープンされたファイルストレージをナビゲートするためにのみ使用され、書き込み用にオープンされたファイルストレージでは、書き込んだ後にデータはメモリに保存されません。

例：samples/cpp/filestorage.cpp.


元関数名(C#): core_FileNode_new1
元DLLエクスポート名: core_FileNode_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_new1(cv::FileNode **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::FileNode();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_delete
[32/64bit] cv::FileNode のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr node
%inst
ファイルストレージノードクラス．

このノードは，読み込みのために開かれたファイルストレージの各要素を格納するために使用されます．XML/YAMLファイルが読み込まれると，まずそれが解析され，ノードの階層的なコレクションとしてメモリに格納されます．各ノードは、1つの数値や文字列を含む「リーフ」であったり、他のノードのコレクションであったりします。各要素が名前を持ち、名前でアクセスされる名前付きコレクション（マッピング）と、要素が名前を持たずインデックスでアクセスされる順序付きコレクション（シーケンス）があります。ファイルノードのタイプは、FileNode::type メソッドを使用して決定できます。

ファイルノードは、読み取り用にオープンされたファイルストレージをナビゲートするためにのみ使用されることに注意してください。ファイルノードは、読み込み用にオープンされたファイルストレージをナビゲートするためにのみ使用され、書き込み用にオープンされたファイルストレージでは、書き込んだ後にデータはメモリに保存されません。

例：samples/cpp/filestorage.cpp.


元関数名(C#): core_FileNode_delete
元DLLエクスポート名: core_FileNode_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_delete(cv::FileNode *node)
{
    BEGIN_WRAP
    delete node;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_operatorThis_byString
[32/64bit] core_FileNode_operatorThis_byString
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string nodeName
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_FileNode_operatorThis_byString
元DLLエクスポート名: core_FileNode_operatorThis_byString
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_operatorThis_byString(cv::FileNode *obj, const char *nodeName, cv::FileNode **returnValue)
{
    BEGIN_WRAP
    const auto ret = (*obj)[nodeName];
    *returnValue = new cv::FileNode(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_operatorThis_byInt
[32/64bit] core_FileNode_operatorThis_byInt
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = int : int i
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_FileNode_operatorThis_byInt
元DLLエクスポート名: core_FileNode_operatorThis_byInt
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_operatorThis_byInt(cv::FileNode *obj, int i, cv::FileNode **returnValue)
{
    BEGIN_WRAP
    const auto ret = (*obj)[i];
    *returnValue = new cv::FileNode(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_type
[32/64bit] ノードのタイプを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
例：samples/cpp/filestorage.cpp.

元関数名(C#): core_FileNode_type
元DLLエクスポート名: core_FileNode_type
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_type(cv::FileNode *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;type();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_empty
[32/64bit] ノードが空の場合はtrueを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
例：samples/cpp/filestorage.cpp.

元関数名(C#): core_FileNode_empty
元DLLエクスポート名: core_FileNode_empty
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_empty(cv::FileNode *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;empty() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_isNone
[32/64bit] ノードが "none "オブジェクトの場合はtrueを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): core_FileNode_isNone
元DLLエクスポート名: core_FileNode_isNone
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_isNone(cv::FileNode *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;isNone() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_isSeq
[32/64bit] ノードがシーケンスの場合はtrueを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): core_FileNode_isSeq
元DLLエクスポート名: core_FileNode_isSeq
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_isSeq(cv::FileNode *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;isSeq() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_isMap
[32/64bit] ノードがマッピングの場合はtrueを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): core_FileNode_isMap
元DLLエクスポート名: core_FileNode_isMap
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_isMap(cv::FileNode *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;isMap() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_isInt
[32/64bit] ノードが整数の場合はtrueを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): core_FileNode_isInt
元DLLエクスポート名: core_FileNode_isInt
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_isInt(cv::FileNode *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;isInt() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_isReal
[32/64bit] ノードが浮動小数点数の場合はtrueを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): core_FileNode_isReal
元DLLエクスポート名: core_FileNode_isReal
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_isReal(cv::FileNode *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;isReal() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_isString
[32/64bit] ノードがテキスト文字列の場合はtrueを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): core_FileNode_isString
元DLLエクスポート名: core_FileNode_isString
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_isString(cv::FileNode *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;isString() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_isNamed
[32/64bit] ノードに名前がある場合はtrueを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): core_FileNode_isNamed
元DLLエクスポート名: core_FileNode_isNamed
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_isNamed(cv::FileNode *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;isNamed() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_name
[32/64bit] ノードの名前を返します。ノードに名前がない場合は、空の文字列を返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr buf
%inst
元関数名(C#): core_FileNode_name
元DLLエクスポート名: core_FileNode_name
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_name(cv::FileNode *obj, std::string *buf)
{
    BEGIN_WRAP
    buf-&amp;gt;assign(obj-&amp;gt;name());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_size
[32/64bit] ノードがシーケンスやマッピングの場合は要素数を，そうでない場合は1を返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_FileNode_size
元DLLエクスポート名: core_FileNode_size
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_size(cv::FileNode *obj, size_t *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;size();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_toInt
[32/64bit] core_FileNode_toInt
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): core_FileNode_toInt
元DLLエクスポート名: core_FileNode_toInt
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_toInt(cv::FileNode *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = static_cast&amp;lt;int&amp;gt;(*obj);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_toFloat
[32/64bit] core_FileNode_toFloat
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): core_FileNode_toFloat
元DLLエクスポート名: core_FileNode_toFloat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_toFloat(cv::FileNode *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = static_cast&amp;lt;float&amp;gt;(*obj);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_toDouble
[32/64bit] core_FileNode_toDouble
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): core_FileNode_toDouble
元DLLエクスポート名: core_FileNode_toDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_toDouble(cv::FileNode *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = static_cast&amp;lt;double&amp;gt;(*obj);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_toString
[32/64bit] core_FileNode_toString
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr buf
%inst
元関数名(C#): core_FileNode_toString
元DLLエクスポート名: core_FileNode_toString
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_toString(cv::FileNode *obj, std::string *buf)
{
    BEGIN_WRAP
    buf-&amp;gt;assign(*obj);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_toMat
[32/64bit] core_FileNode_toMat
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr m
%inst
元関数名(C#): core_FileNode_toMat
元DLLエクスポート名: core_FileNode_toMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_toMat(cv::FileNode *obj, cv::Mat *m)
{
    BEGIN_WRAP
    (*obj) &amp;gt;&amp;gt; (*m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_begin
[32/64bit] 最初のノード要素を指すイテレータを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
例：samples/cpp/filestorage.cpp.

元関数名(C#): core_FileNode_begin
元DLLエクスポート名: core_FileNode_begin
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_begin(cv::FileNode *obj, cv::FileNodeIterator **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::FileNodeIterator(obj-&amp;gt;begin());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_end
[32/64bit] 最後のノード要素の次の要素を指し示すイテレータを返す
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
例：samples/cpp/filestorage.cpp.

元関数名(C#): core_FileNode_end
元DLLエクスポート名: core_FileNode_end
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_end(cv::FileNode *obj, cv::FileNodeIterator **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::FileNodeIterator(obj-&amp;gt;end());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_readRaw
[32/64bit] ノードの要素を指定されたフォーマットでバッファに読み込みます。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string fmt
p3 = sptr : IntPtr vec
p4 = sptr : IntPtr len
%inst
通常は，この方法ではなく，演算子 >> を使った方が便利です．

元関数名(C#): core_FileNode_readRaw
元DLLエクスポート名: core_FileNode_readRaw
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_readRaw(cv::FileNode *obj, const char *fmt, uchar* vec, size_t len)
{
    BEGIN_WRAP
    obj-&amp;gt;readRaw(fmt, vec, len);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_int
[32/64bit] core_FileNode_read_int
%prm
p1,p2,p3
p1 = sptr : IntPtr node
p2 = var : out int value
p3 = int : int defaultValue
%inst
元関数名(C#): core_FileNode_read_int
元DLLエクスポート名: core_FileNode_read_int
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_int(cv::FileNode *node, int *value, int default_value)
{
    BEGIN_WRAP
    int temp;
    cv::read(*node, temp, default_value);
    *value = temp;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_float
[32/64bit] core_FileNode_read_float
%prm
p1,p2,p3
p1 = sptr : IntPtr node
p2 = var : out float value
p3 = float : float defaultValue
%inst
元関数名(C#): core_FileNode_read_float
元DLLエクスポート名: core_FileNode_read_float
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_float(cv::FileNode *node, float *value, float default_value)
{
    BEGIN_WRAP
    float temp;
    cv::read(*node, temp, default_value);
    *value = temp;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_double
[32/64bit] core_FileNode_read_double
%prm
p1,p2,p3
p1 = sptr : IntPtr node
p2 = var : out double value
p3 = double : double defaultValue
%inst
元関数名(C#): core_FileNode_read_double
元DLLエクスポート名: core_FileNode_read_double
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_double(cv::FileNode *node, double *value, double default_value)
{
    BEGIN_WRAP
    double temp;
    cv::read(*node, temp, default_value);
    *value = temp;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_String
[32/64bit] core_FileNode_read_String
%prm
p1,p2,p3
p1 = sptr : IntPtr node
p2 = sptr : IntPtr value
p3 = str : [MarshalAs(UnmanagedType.LPStr)] string? defaultValue
%inst
元関数名(C#): core_FileNode_read_String
元DLLエクスポート名: core_FileNode_read_String
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_String(cv::FileNode *node, std::string *value, const char *default_value)
{
    BEGIN_WRAP
    cv::String str;
    cv::read(*node, str, (default_value == nullptr) ? cv::String() : cv::String(default_value));
    value-&amp;gt;assign(str);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Mat
[32/64bit] core_FileNode_read_Mat
%prm
p1,p2,p3
p1 = sptr : IntPtr node
p2 = sptr : IntPtr mat
p3 = sptr : IntPtr defaultMat
%inst
元関数名(C#): core_FileNode_read_Mat
元DLLエクスポート名: core_FileNode_read_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Mat(cv::FileNode *node, cv::Mat *mat, cv::Mat *default_mat)
{
    BEGIN_WRAP
    cv::read(*node, *mat, entity(default_mat));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_SparseMat
[32/64bit] core_FileNode_read_SparseMat
%prm
p1,p2,p3
p1 = sptr : IntPtr node
p2 = sptr : IntPtr mat
p3 = sptr : IntPtr defaultMat
%inst
元関数名(C#): core_FileNode_read_SparseMat
元DLLエクスポート名: core_FileNode_read_SparseMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_SparseMat(cv::FileNode *node, cv::SparseMat *mat, cv::SparseMat *default_mat)
{
    BEGIN_WRAP
    cv::read(*node, *mat, entity(default_mat));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_vectorOfKeyPoint
[32/64bit] core_FileNode_read_vectorOfKeyPoint
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = sptr : IntPtr keypoints
%inst
元関数名(C#): core_FileNode_read_vectorOfKeyPoint
元DLLエクスポート名: core_FileNode_read_vectorOfKeyPoint
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_vectorOfKeyPoint(cv::FileNode *node, std::vector&amp;lt;cv::KeyPoint&amp;gt; *keypoints)
{
    BEGIN_WRAP
    cv::read(*node, *keypoints);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_vectorOfDMatch
[32/64bit] core_FileNode_read_vectorOfDMatch
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = sptr : IntPtr matches
%inst
元関数名(C#): core_FileNode_read_vectorOfDMatch
元DLLエクスポート名: core_FileNode_read_vectorOfDMatch
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_vectorOfDMatch(cv::FileNode *node, std::vector&amp;lt;cv::DMatch&amp;gt; *matches)
{
    BEGIN_WRAP
    cv::read(*node, *matches);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Range
[32/64bit] core_FileNode_read_Range
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Range returnValue
%inst
元関数名(C#): core_FileNode_read_Range
元DLLエクスポート名: core_FileNode_read_Range
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Range(cv::FileNode *node, MyCvSlice *returnValue)
{
    BEGIN_WRAP
    cv::Range ret;
    (*node) &amp;gt;&amp;gt; ret;
    *returnValue = c(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_KeyPoint
[32/64bit] core_FileNode_read_KeyPoint
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out KeyPoint returnValue
%inst
元関数名(C#): core_FileNode_read_KeyPoint
元DLLエクスポート名: core_FileNode_read_KeyPoint
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_KeyPoint(cv::FileNode *node, MyKeyPoint *returnValue)
{   
    BEGIN_WRAP 
    cv::KeyPoint ret;
    (*node) &amp;gt;&amp;gt; ret;
    *returnValue = c(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_DMatch
[32/64bit] core_FileNode_read_DMatch
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out DMatch returnValue
%inst
元関数名(C#): core_FileNode_read_DMatch
元DLLエクスポート名: core_FileNode_read_DMatch
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_DMatch(cv::FileNode *node, MyDMatch *returnValue)
{
    BEGIN_WRAP
    cv::DMatch ret;
    (*node) &amp;gt;&amp;gt; ret;
    *returnValue = c(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Point2i
[32/64bit] core_FileNode_read_Point2i
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Point returnValue
%inst
元関数名(C#): core_FileNode_read_Point2i
元DLLエクスポート名: core_FileNode_read_Point2i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Point2i(cv::FileNode *node, MyCvPoint *returnValue)
{
    BEGIN_WRAP
    cv::Point2i ret;
    (*node) &amp;gt;&amp;gt; ret;
    *returnValue = MyCvPoint{ ret.x, ret.y };
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Point2f
[32/64bit] core_FileNode_read_Point2f
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Point2f returnValue
%inst
元関数名(C#): core_FileNode_read_Point2f
元DLLエクスポート名: core_FileNode_read_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Point2f(cv::FileNode *node, MyCvPoint2D32f *returnValue)
{
    BEGIN_WRAP
    cv::Point2f ret;
    (*node) &amp;gt;&amp;gt; ret;
    *returnValue = MyCvPoint2D32f{ ret.x, ret.y };
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Point2d
[32/64bit] core_FileNode_read_Point2d
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Point2d returnValue
%inst
元関数名(C#): core_FileNode_read_Point2d
元DLLエクスポート名: core_FileNode_read_Point2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Point2d(cv::FileNode *node, MyCvPoint2D64f *returnValue)
{
    BEGIN_WRAP
    cv::Point2d ret;
    (*node) &amp;gt;&amp;gt; ret;
    *returnValue = MyCvPoint2D64f{ ret.x, ret.y };
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Point3i
[32/64bit] core_FileNode_read_Point3i
%prm
p1,p2
p1 = sptr : IntPtr nod
p2 = var : out Point3i returnValue
%inst
元関数名(C#): core_FileNode_read_Point3i
元DLLエクスポート名: core_FileNode_read_Point3i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Point3i(cv::FileNode *node, MyCvPoint3D32i *returnValue)
{
    BEGIN_WRAP
    cv::Point3i ret;
    (*node) &amp;gt;&amp;gt; ret;
    *returnValue = MyCvPoint3D32i{ ret.x, ret.y, ret.z };
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Point3f
[32/64bit] core_FileNode_read_Point3f
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Point3f returnValue
%inst
元関数名(C#): core_FileNode_read_Point3f
元DLLエクスポート名: core_FileNode_read_Point3f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Point3f(cv::FileNode *node, MyCvPoint3D32f *returnValue)
{
    BEGIN_WRAP
    cv::Point3f ret;
    (*node) &amp;gt;&amp;gt; ret;
    *returnValue = MyCvPoint3D32f{ ret.x, ret.y, ret.z };
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Point3d
[32/64bit] core_FileNode_read_Point3d
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Point3d returnValue
%inst
元関数名(C#): core_FileNode_read_Point3d
元DLLエクスポート名: core_FileNode_read_Point3d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Point3d(cv::FileNode *node, MyCvPoint3D64f *returnValue)
{
    BEGIN_WRAP
    cv::Point3d ret;
    (*node) &amp;gt;&amp;gt; ret;
    *returnValue = MyCvPoint3D64f{ ret.x, ret.y, ret.z };
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Size2i
[32/64bit] core_FileNode_read_Size2i
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Size returnValue
%inst
元関数名(C#): core_FileNode_read_Size2i
元DLLエクスポート名: core_FileNode_read_Size2i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Size2i(cv::FileNode *node, MyCvSize *returnValue)
{
    BEGIN_WRAP
    cv::Size2i ret;
    (*node) &amp;gt;&amp;gt; ret;
    *returnValue = MyCvSize{ ret.width, ret.height };
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Size2f
[32/64bit] core_FileNode_read_Size2f
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Size2f returnValue
%inst
元関数名(C#): core_FileNode_read_Size2f
元DLLエクスポート名: core_FileNode_read_Size2f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Size2f(cv::FileNode *node, MyCvSize2D32f *returnValue)
{
    BEGIN_WRAP
    cv::Size2f ret;
    (*node) &amp;gt;&amp;gt; ret;
    *returnValue = MyCvSize2D32f{ ret.width, ret.height };
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Size2d
[32/64bit] core_FileNode_read_Size2d
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Size2d returnValue
%inst
元関数名(C#): core_FileNode_read_Size2d
元DLLエクスポート名: core_FileNode_read_Size2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Size2d(cv::FileNode *node, MyCvSize2D64f *returnValue)
{
    BEGIN_WRAP
    cv::Size2d ret;
    (*node) &amp;gt;&amp;gt; ret;
    *returnValue = MyCvSize2D64f{ ret.width, ret.height };
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Rect2i
[32/64bit] core_FileNode_read_Rect2i
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Rect returnValue
%inst
元関数名(C#): core_FileNode_read_Rect2i
元DLLエクスポート名: core_FileNode_read_Rect2i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Rect2i(cv::FileNode *node, MyCvRect *returnValue)
{
    BEGIN_WRAP
    cv::Rect2i ret;
    (*node) &amp;gt;&amp;gt; ret;
    *returnValue = MyCvRect{ ret.x, ret.y, ret.width, ret.height };
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Rect2f
[32/64bit] core_FileNode_read_Rect2f
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Rect2f returnValue
%inst
元関数名(C#): core_FileNode_read_Rect2f
元DLLエクスポート名: core_FileNode_read_Rect2f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Rect2f(cv::FileNode *node, MyCvRect2D32f *returnValue)
{
    BEGIN_WRAP
    cv::Rect2f ret;
    (*node) &amp;gt;&amp;gt; ret;
    *returnValue = MyCvRect2D32f{ ret.x, ret.y, ret.width, ret.height };
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Rect2d
[32/64bit] core_FileNode_read_Rect2d
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Rect2d returnValue
%inst
元関数名(C#): core_FileNode_read_Rect2d
元DLLエクスポート名: core_FileNode_read_Rect2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Rect2d(cv::FileNode *node, MyCvRect2D64f *returnValue)
{
    BEGIN_WRAP
    cv::Rect2d ret;
    (*node) &amp;gt;&amp;gt; ret;
    *returnValue = MyCvRect2D64f{ ret.x, ret.y, ret.width, ret.height };
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Scalar
[32/64bit] core_FileNode_read_Scalar
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Scalar returnValue
%inst
元関数名(C#): core_FileNode_read_Scalar
元DLLエクスポート名: core_FileNode_read_Scalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Scalar(cv::FileNode *node, MyCvScalar *returnValue)
{
    BEGIN_WRAP
    cv::Scalar s;
    (*node) &amp;gt;&amp;gt; s;
    *returnValue = MyCvScalar{};
    returnValue-&amp;gt;val[0] = s.val[0];
    returnValue-&amp;gt;val[1] = s.val[1];
    returnValue-&amp;gt;val[2] = s.val[2];
    returnValue-&amp;gt;val[3] = s.val[3];
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec2i
[32/64bit] core_FileNode_read_Vec2i
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec2i returnValue
%inst
元関数名(C#): core_FileNode_read_Vec2i
元DLLエクスポート名: core_FileNode_read_Vec2i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec2i(cv::FileNode *node, CvVec2i *returnValue) { BEGIN_WRAP cv::Vec2i v; (*node) &amp;gt;&amp;gt; v; CvVec2i ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec3i
[32/64bit] core_FileNode_read_Vec3i
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec3i returnValue
%inst
元関数名(C#): core_FileNode_read_Vec3i
元DLLエクスポート名: core_FileNode_read_Vec3i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec3i(cv::FileNode *node, CvVec3i *returnValue) { BEGIN_WRAP cv::Vec3i v; (*node) &amp;gt;&amp;gt; v; CvVec3i ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec4i
[32/64bit] core_FileNode_read_Vec4i
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec4i returnValue
%inst
元関数名(C#): core_FileNode_read_Vec4i
元DLLエクスポート名: core_FileNode_read_Vec4i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec4i(cv::FileNode *node, CvVec4i *returnValue) { BEGIN_WRAP cv::Vec4i v; (*node) &amp;gt;&amp;gt; v; CvVec4i ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec6i
[32/64bit] core_FileNode_read_Vec6i
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec6i returnValue
%inst
元関数名(C#): core_FileNode_read_Vec6i
元DLLエクスポート名: core_FileNode_read_Vec6i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec6i(cv::FileNode *node, CvVec6i *returnValue) { BEGIN_WRAP cv::Vec6i v; (*node) &amp;gt;&amp;gt; v; CvVec6i ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec2d
[32/64bit] core_FileNode_read_Vec2d
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec2d returnValue
%inst
元関数名(C#): core_FileNode_read_Vec2d
元DLLエクスポート名: core_FileNode_read_Vec2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec2d(cv::FileNode *node, CvVec2d *returnValue) { BEGIN_WRAP cv::Vec2d v; (*node) &amp;gt;&amp;gt; v; CvVec2d ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec3d
[32/64bit] core_FileNode_read_Vec3d
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec3d returnValue
%inst
元関数名(C#): core_FileNode_read_Vec3d
元DLLエクスポート名: core_FileNode_read_Vec3d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec3d(cv::FileNode *node, CvVec3d *returnValue) { BEGIN_WRAP cv::Vec3d v; (*node) &amp;gt;&amp;gt; v; CvVec3d ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec4d
[32/64bit] core_FileNode_read_Vec4d
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec4d returnValue
%inst
元関数名(C#): core_FileNode_read_Vec4d
元DLLエクスポート名: core_FileNode_read_Vec4d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec4d(cv::FileNode *node, CvVec4d *returnValue) { BEGIN_WRAP cv::Vec4d v; (*node) &amp;gt;&amp;gt; v; CvVec4d ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec6d
[32/64bit] core_FileNode_read_Vec6d
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec6d returnValue
%inst
元関数名(C#): core_FileNode_read_Vec6d
元DLLエクスポート名: core_FileNode_read_Vec6d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec6d(cv::FileNode *node, CvVec6d *returnValue) { BEGIN_WRAP cv::Vec6d v; (*node) &amp;gt;&amp;gt; v; CvVec6d ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec2f
[32/64bit] core_FileNode_read_Vec2f
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec2f returnValue
%inst
元関数名(C#): core_FileNode_read_Vec2f
元DLLエクスポート名: core_FileNode_read_Vec2f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec2f(cv::FileNode *node, CvVec2f *returnValue) { BEGIN_WRAP cv::Vec2f v; (*node) &amp;gt;&amp;gt; v; CvVec2f ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec3f
[32/64bit] core_FileNode_read_Vec3f
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec3f returnValue
%inst
元関数名(C#): core_FileNode_read_Vec3f
元DLLエクスポート名: core_FileNode_read_Vec3f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec3f(cv::FileNode *node, CvVec3f *returnValue) { BEGIN_WRAP cv::Vec3f v; (*node) &amp;gt;&amp;gt; v; CvVec3f ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec4f
[32/64bit] core_FileNode_read_Vec4f
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec4f returnValue
%inst
元関数名(C#): core_FileNode_read_Vec4f
元DLLエクスポート名: core_FileNode_read_Vec4f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec4f(cv::FileNode *node, CvVec4f *returnValue) { BEGIN_WRAP cv::Vec4f v; (*node) &amp;gt;&amp;gt; v; CvVec4f ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec6f
[32/64bit] core_FileNode_read_Vec6f
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec6f returnValue
%inst
元関数名(C#): core_FileNode_read_Vec6f
元DLLエクスポート名: core_FileNode_read_Vec6f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec6f(cv::FileNode *node, CvVec6f *returnValue) { BEGIN_WRAP cv::Vec6f v; (*node) &amp;gt;&amp;gt; v; CvVec6f ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec2b
[32/64bit] core_FileNode_read_Vec2b
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec2b returnValue
%inst
元関数名(C#): core_FileNode_read_Vec2b
元DLLエクスポート名: core_FileNode_read_Vec2b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec2b(cv::FileNode *node, CvVec2b *returnValue) { BEGIN_WRAP cv::Vec2b v; (*node) &amp;gt;&amp;gt; v; CvVec2b ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec3b
[32/64bit] core_FileNode_read_Vec3b
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec3b returnValue
%inst
元関数名(C#): core_FileNode_read_Vec3b
元DLLエクスポート名: core_FileNode_read_Vec3b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec3b(cv::FileNode *node, CvVec3b *returnValue) { BEGIN_WRAP cv::Vec3b v; (*node) &amp;gt;&amp;gt; v; CvVec3b ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec4b
[32/64bit] core_FileNode_read_Vec4b
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec4b returnValue
%inst
元関数名(C#): core_FileNode_read_Vec4b
元DLLエクスポート名: core_FileNode_read_Vec4b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec4b(cv::FileNode *node, CvVec4b *returnValue) { BEGIN_WRAP cv::Vec4b v; (*node) &amp;gt;&amp;gt; v; CvVec4b ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec6b
[32/64bit] core_FileNode_read_Vec6b
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec6b returnValue
%inst
元関数名(C#): core_FileNode_read_Vec6b
元DLLエクスポート名: core_FileNode_read_Vec6b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec6b(cv::FileNode *node, CvVec6b *returnValue) { BEGIN_WRAP cv::Vec6b v; (*node) &amp;gt;&amp;gt; v; CvVec6b ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec2s
[32/64bit] core_FileNode_read_Vec2s
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec2s returnValue
%inst
元関数名(C#): core_FileNode_read_Vec2s
元DLLエクスポート名: core_FileNode_read_Vec2s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec2s(cv::FileNode *node, CvVec2s *returnValue) { BEGIN_WRAP cv::Vec2s v; (*node) &amp;gt;&amp;gt; v; CvVec2s ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec3s
[32/64bit] core_FileNode_read_Vec3s
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec3s returnValue
%inst
元関数名(C#): core_FileNode_read_Vec3s
元DLLエクスポート名: core_FileNode_read_Vec3s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec3s(cv::FileNode *node, CvVec3s *returnValue) { BEGIN_WRAP cv::Vec3s v; (*node) &amp;gt;&amp;gt; v; CvVec3s ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec4s
[32/64bit] core_FileNode_read_Vec4s
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec4s returnValue
%inst
元関数名(C#): core_FileNode_read_Vec4s
元DLLエクスポート名: core_FileNode_read_Vec4s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec4s(cv::FileNode *node, CvVec4s *returnValue) { BEGIN_WRAP cv::Vec4s v; (*node) &amp;gt;&amp;gt; v; CvVec4s ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec6s
[32/64bit] core_FileNode_read_Vec6s
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec6s returnValue
%inst
元関数名(C#): core_FileNode_read_Vec6s
元DLLエクスポート名: core_FileNode_read_Vec6s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec6s(cv::FileNode *node, CvVec6s *returnValue) { BEGIN_WRAP cv::Vec6s v; (*node) &amp;gt;&amp;gt; v; CvVec6s ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec2w
[32/64bit] core_FileNode_read_Vec2w
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec2w returnValue
%inst
元関数名(C#): core_FileNode_read_Vec2w
元DLLエクスポート名: core_FileNode_read_Vec2w
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec2w(cv::FileNode *node, CvVec2w *returnValue) { BEGIN_WRAP cv::Vec2w v; (*node) &amp;gt;&amp;gt; v; CvVec2w ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec3w
[32/64bit] core_FileNode_read_Vec3w
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec3w returnValue
%inst
元関数名(C#): core_FileNode_read_Vec3w
元DLLエクスポート名: core_FileNode_read_Vec3w
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec3w(cv::FileNode *node, CvVec3w *returnValue) { BEGIN_WRAP cv::Vec3w v; (*node) &amp;gt;&amp;gt; v; CvVec3w ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec4w
[32/64bit] core_FileNode_read_Vec4w
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec4w returnValue
%inst
元関数名(C#): core_FileNode_read_Vec4w
元DLLエクスポート名: core_FileNode_read_Vec4w
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec4w(cv::FileNode *node, CvVec4w *returnValue) { BEGIN_WRAP cv::Vec4w v; (*node) &amp;gt;&amp;gt; v; CvVec4w ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNode_read_Vec6w
[32/64bit] core_FileNode_read_Vec6w
%prm
p1,p2
p1 = sptr : IntPtr node
p2 = var : out Vec6w returnValue
%inst
元関数名(C#): core_FileNode_read_Vec6w
元DLLエクスポート名: core_FileNode_read_Vec6w
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNode.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNode_read_Vec6w(cv::FileNode *node, CvVec6w *returnValue) { BEGIN_WRAP cv::Vec6w v; (*node) &amp;gt;&amp;gt; v; CvVec6w ret; std::copy(std::begin(v.val), std::end(v.val), std::begin(ret.val)); *returnValue = ret; END_WRAP }

</pre>
}html
%group
NativeMethods_core_FileNode

%index
core_FileNodeIterator_new1
[32/64bit] cv::FileNodeIterator のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst
シーケンスやマッピングの反復処理に使用されます。

標準的なSTLの記法で、node.begin()、node.end()はシーケンスの始まりと終わりを表し、nodeに格納されます。冒頭のデータ読み込みサンプルをご覧ください。

例：samples/cpp/filestorage.cpp.


元関数名(C#): core_FileNodeIterator_new1
元DLLエクスポート名: core_FileNodeIterator_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNodeIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNodeIterator_new1(cv::FileNodeIterator **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::FileNodeIterator;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNodeIterator

%index
core_FileNodeIterator_delete
[32/64bit] cv::FileNodeIterator のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
シーケンスやマッピングの反復処理に使用されます。

標準的なSTLの記法で、node.begin()、node.end()はシーケンスの始まりと終わりを表し、nodeに格納されます。冒頭のデータ読み込みサンプルをご覧ください。

例：samples/cpp/filestorage.cpp.


元関数名(C#): core_FileNodeIterator_delete
元DLLエクスポート名: core_FileNodeIterator_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNodeIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNodeIterator_delete(cv::FileNodeIterator *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNodeIterator

%index
core_FileNodeIterator_operatorAsterisk
[32/64bit] core_FileNodeIterator_operatorAsterisk
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_FileNodeIterator_operatorAsterisk
元DLLエクスポート名: core_FileNodeIterator_operatorAsterisk
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNodeIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNodeIterator_operatorAsterisk(cv::FileNodeIterator *obj, cv::FileNode **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::FileNode(*(*obj));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNodeIterator

%index
core_FileNodeIterator_operatorIncrement
[32/64bit] core_FileNodeIterator_operatorIncrement
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): core_FileNodeIterator_operatorIncrement
元DLLエクスポート名: core_FileNodeIterator_operatorIncrement
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNodeIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNodeIterator_operatorIncrement(cv::FileNodeIterator *obj, int *returnValue)
{
    BEGIN_WRAP
    const size_t prev_remaining = obj-&amp;gt;remaining(); 
    ++(*obj);
    *returnValue = (prev_remaining == obj-&amp;gt;remaining()) ? 0 : 1;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNodeIterator

%index
core_FileNodeIterator_operatorPlusEqual
[32/64bit] core_FileNodeIterator_operatorPlusEqual
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = int : int ofs
p3 = var : out int returnValue
%inst
元関数名(C#): core_FileNodeIterator_operatorPlusEqual
元DLLエクスポート名: core_FileNodeIterator_operatorPlusEqual
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNodeIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNodeIterator_operatorPlusEqual(cv::FileNodeIterator *obj, int ofs, int *returnValue)
{
    BEGIN_WRAP
    const size_t prev_remaining = obj-&amp;gt;remaining();
    (*obj) += ofs;
    *returnValue = (prev_remaining == obj-&amp;gt;remaining()) ? 0 : 1;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNodeIterator

%index
core_FileNodeIterator_readRaw
[32/64bit] ノードの要素を指定されたフォーマットでバッファに読み込みます。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string fmt
p3 = sptr : IntPtr vec
p4 = sptr : IntPtr maxCount
%inst
通常は，この方法ではなく，演算子 >> を使った方が便利です．

元関数名(C#): core_FileNodeIterator_readRaw
元DLLエクスポート名: core_FileNodeIterator_readRaw
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNodeIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNodeIterator_readRaw(
    cv::FileNodeIterator *obj, const char *fmt, uchar* vec, size_t maxCount)
{
    BEGIN_WRAP
    obj-&amp;gt;readRaw(fmt, vec, maxCount);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNodeIterator

%index
core_FileNodeIterator_operatorEqual
[32/64bit] core_FileNodeIterator_operatorEqual
%prm
p1,p2,p3
p1 = sptr : IntPtr it1
p2 = sptr : IntPtr it2
p3 = var : out int returnValue
%inst
元関数名(C#): core_FileNodeIterator_operatorEqual
元DLLエクスポート名: core_FileNodeIterator_operatorEqual
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNodeIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNodeIterator_operatorEqual(cv::FileNodeIterator *it1, cv::FileNodeIterator *it2, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ((*it1) == (*it2)) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNodeIterator

%index
core_FileNodeIterator_operatorMinus
[32/64bit] core_FileNodeIterator_operatorMinus
%prm
p1,p2,p3
p1 = sptr : IntPtr it1
p2 = sptr : IntPtr it2
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_FileNodeIterator_operatorMinus
元DLLエクスポート名: core_FileNodeIterator_operatorMinus
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNodeIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNodeIterator_operatorMinus(cv::FileNodeIterator *it1, cv::FileNodeIterator *it2, ptrdiff_t *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*it1) - (*it2);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNodeIterator

%index
core_FileNodeIterator_operatorLessThan
[32/64bit] core_FileNodeIterator_operatorLessThan
%prm
p1,p2,p3
p1 = sptr : IntPtr it1
p2 = sptr : IntPtr it2
p3 = var : out int returnValue
%inst
元関数名(C#): core_FileNodeIterator_operatorLessThan
元DLLエクスポート名: core_FileNodeIterator_operatorLessThan
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileNodeIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileNodeIterator_operatorLessThan(cv::FileNodeIterator *it1, cv::FileNodeIterator *it2, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*it1) &amp;lt; (*it2);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileNodeIterator

%index
core_FileStorage_new1
[32/64bit] cv::FileStorage のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst
XML/YAML/JSON形式のファイル保存クラスで、ファイルへのデータの書き込みや読み出しに必要な情報をすべてカプセル化しています。

例：samples/cpp/filestorage.cpp、samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp、samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp、samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp。


元関数名(C#): core_FileStorage_new1
元DLLエクスポート名: core_FileStorage_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_new1(cv::FileStorage **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::FileStorage;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_new2
[32/64bit] cv::FileStorage のインスタンスを生成します
%prm
p1,p2,p3,p4
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string source
p2 = int : int flags
p3 = str : [MarshalAs(UnmanagedType.LPStr)] string? encoding
p4 = var : out IntPtr returnValue
%inst
XML/YAML/JSON形式のファイル保存クラスで、ファイルへのデータの書き込みや読み出しに必要な情報をすべてカプセル化しています。

例：samples/cpp/filestorage.cpp、samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp、samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp、samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp。


元関数名(C#): core_FileStorage_new2
元DLLエクスポート名: core_FileStorage_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_new2(const char *source, int flags, const char *encoding, cv::FileStorage **returnValue)
{
    BEGIN_WRAP
    std::string encodingStr;
    if (encoding != nullptr)
        encodingStr = std::string(encoding);
    *returnValue = new cv::FileStorage(source, flags, encodingStr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_delete
[32/64bit] cv::FileStorage のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
XML/YAML/JSON形式のファイル保存クラスで、ファイルへのデータの書き込みや読み出しに必要な情報をすべてカプセル化しています。

例：samples/cpp/filestorage.cpp、samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp、samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp、samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp。


元関数名(C#): core_FileStorage_delete
元DLLエクスポート名: core_FileStorage_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_delete(cv::FileStorage *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_open
[32/64bit] ファイルを開きます。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
p3 = int : int flags
p4 = str : [MarshalAs(UnmanagedType.LPStr)] string? encoding
p5 = var : out int returnValue
%inst
FileStorage::FileStorageのパラメータの説明を参照してください。このメソッドは，ファイルをオープンする前にFileStorage::releaseを呼び出します。

元関数名(C#): core_FileStorage_open
元DLLエクスポート名: core_FileStorage_open
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_open(cv::FileStorage *obj,
                                 const char *filename, int flags, const char *encoding, int *returnValue)
{
    BEGIN_WRAP
    std::string encodingStr;
    if (encoding != nullptr)
        encodingStr = std::string(encoding);
    *returnValue = obj-&amp;gt;open(filename, flags, encodingStr) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_isOpened
[32/64bit] ファイルが開かれているかどうかをチェックします。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
例：samples/cpp/filestorage.cpp.

元関数名(C#): core_FileStorage_isOpened
元DLLエクスポート名: core_FileStorage_isOpened
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_isOpened(cv::FileStorage *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;isOpened() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_releaseAndGetString
[32/64bit] ファイルを閉じ、すべてのメモリバッファを解放します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr outString
%inst
このメソッドは、ストレージに対するすべての I/O 操作が終了した後に呼び出します。ストレージがデータ書き込み用にオープンされていて、FileStorage::WRITEが指定されている場合サンプル: samples/cpp/filestorage.cpp.

元関数名(C#): core_FileStorage_releaseAndGetString
元DLLエクスポート名: core_FileStorage_releaseAndGetString
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_releaseAndGetString(
    cv::FileStorage* obj, std::string * outString)
{
    BEGIN_WRAP
    outString-&amp;gt;assign(obj-&amp;gt;releaseAndGetString());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_getFirstTopLevelNode
[32/64bit] トップレベルのマッピングの最初の要素を返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_FileStorage_getFirstTopLevelNode
元DLLエクスポート名: core_FileStorage_getFirstTopLevelNode
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_getFirstTopLevelNode(cv::FileStorage *obj, cv::FileNode **returnValue)
{
    BEGIN_WRAP
    const auto node = obj-&amp;gt;getFirstTopLevelNode();
    *returnValue = new cv::FileNode(node);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_root
[32/64bit] トップレベルのマッピングを返します。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = int : int streamIdx
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_FileStorage_root
元DLLエクスポート名: core_FileStorage_root
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_root(cv::FileStorage *obj, int streamIdx, cv::FileNode **returnValue)
{
    BEGIN_WRAP
    const auto node = obj-&amp;gt;root(streamIdx);
    *returnValue = new cv::FileNode(node);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_indexer
[32/64bit] core_FileStorage_indexer
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string nodeName
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_FileStorage_indexer
元DLLエクスポート名: core_FileStorage_indexer
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_indexer(cv::FileStorage *obj, const char *nodeName, cv::FileNode **returnValue)
{
    BEGIN_WRAP
    const auto node = (*obj)[nodeName];
    *returnValue = new cv::FileNode(node);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_writeRaw
[32/64bit] 複数の数値を書き込みます。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string fmt
p3 = sptr : IntPtr vec
p4 = sptr : IntPtr len
%inst
現在書き込まれている構造体に，指定された形式の1つまたは複数の数値を書き込みます。通常は，この方法ではなく，演算子 << を使った方が便利です。

元関数名(C#): core_FileStorage_writeRaw
元DLLエクスポート名: core_FileStorage_writeRaw
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_writeRaw(cv::FileStorage *obj, const char *fmt, const uchar *vec, size_t len)
{
    BEGIN_WRAP
    obj-&amp;gt;writeRaw(fmt, vec, len);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_writeComment
[32/64bit] コメントを書き込みます。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string comment
p3 = int : int append
%inst
この関数は、ファイルストレージにコメントを書き込みます。ストレージが読み込まれると、コメントはスキップされます。

元関数名(C#): core_FileStorage_writeComment
元DLLエクスポート名: core_FileStorage_writeComment
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_writeComment(cv::FileStorage *obj, const char *comment, int append)
{
    BEGIN_WRAP
    obj-&amp;gt;writeComment(comment, append != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_getDefaultObjectName
[32/64bit] 指定されたファイル名に対する正規化されたオブジェクト名を返します。
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
p2 = sptr : IntPtr buf
%inst
元関数名(C#): core_FileStorage_getDefaultObjectName
元DLLエクスポート名: core_FileStorage_getDefaultObjectName
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_getDefaultObjectName(const char *filename, std::string *buf)
{
    BEGIN_WRAP
    buf-&amp;gt;assign(cv::FileStorage::getDefaultObjectName(filename));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_elname
[32/64bit] cv::FileStorage::elname 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr returnValue
%inst



元関数名(C#): core_FileStorage_elname
元DLLエクスポート名: core_FileStorage_elname
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_elname(cv::FileStorage *obj, std::string *returnValue)
{
    BEGIN_WRAP
    returnValue-&amp;gt;assign(obj-&amp;gt;elname);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_startWriteStruct
[32/64bit] 入れ子構造（シーケンスやマッピング）の書き込みを開始します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string name
p3 = int : int flags
p4 = str : [MarshalAs(UnmanagedType.LPStr)] string typeName
%inst
元関数名(C#): core_FileStorage_startWriteStruct
元DLLエクスポート名: core_FileStorage_startWriteStruct
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_startWriteStruct(
    cv::FileStorage *obj, const char* name, int flags, const char *typeName)
{
    BEGIN_WRAP
    obj-&amp;gt;startWriteStruct(name, flags, typeName);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_endWriteStruct
[32/64bit] ネストされた構造体の書き込みを終了します（startWriteStruct()とペアにする必要があります）。
%prm
p1
p1 = sptr : IntPtr obj
%inst
元関数名(C#): core_FileStorage_endWriteStruct
元DLLエクスポート名: core_FileStorage_endWriteStruct
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_endWriteStruct(    cv::FileStorage *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;endWriteStruct();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_state
[32/64bit] cv::FileStorage::state 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): core_FileStorage_state
元DLLエクスポート名: core_FileStorage_state
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_state(cv::FileStorage *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;state;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_write_int
[32/64bit] core_FileStorage_write_int
%prm
p1,p2,p3
p1 = sptr : IntPtr fs
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string name
p3 = int : int value
%inst
元関数名(C#): core_FileStorage_write_int
元DLLエクスポート名: core_FileStorage_write_int
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_write_int(cv::FileStorage *fs, const char *name, int value)
{
    BEGIN_WRAP
    cv::write(*fs, cv::String(name), value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_write_float
[32/64bit] core_FileStorage_write_float
%prm
p1,p2,p3
p1 = sptr : IntPtr fs
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string name
p3 = float : float value
%inst
元関数名(C#): core_FileStorage_write_float
元DLLエクスポート名: core_FileStorage_write_float
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_write_float(cv::FileStorage *fs, const char *name, float value)
{
    BEGIN_WRAP
    cv::write(*fs, cv::String(name), value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_write_double
[32/64bit] core_FileStorage_write_double
%prm
p1,p2,p3
p1 = sptr : IntPtr fs
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string name
p3 = double : double value
%inst
元関数名(C#): core_FileStorage_write_double
元DLLエクスポート名: core_FileStorage_write_double
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_write_double(cv::FileStorage *fs, const char *name, double value)
{
    BEGIN_WRAP
    cv::write(*fs, cv::String(name), value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_write_String
[32/64bit] core_FileStorage_write_String
%prm
p1,p2,p3
p1 = sptr : IntPtr fs
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string name
p3 = str : [MarshalAs(UnmanagedType.LPStr)] string value
%inst
元関数名(C#): core_FileStorage_write_String
元DLLエクスポート名: core_FileStorage_write_String
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_write_String(cv::FileStorage *fs, const char *name, const char *value)
{
    BEGIN_WRAP
    cv::write(*fs, cv::String(name), value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_write_Mat
[32/64bit] core_FileStorage_write_Mat
%prm
p1,p2,p3
p1 = sptr : IntPtr fs
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string name
p3 = sptr : IntPtr value
%inst
元関数名(C#): core_FileStorage_write_Mat
元DLLエクスポート名: core_FileStorage_write_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_write_Mat(cv::FileStorage *fs, const char *name, const cv::Mat *value)
{
    BEGIN_WRAP
    cv::write(*fs, cv::String(name), *value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_write_SparseMat
[32/64bit] core_FileStorage_write_SparseMat
%prm
p1,p2,p3
p1 = sptr : IntPtr fs
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string name
p3 = sptr : IntPtr value
%inst
元関数名(C#): core_FileStorage_write_SparseMat
元DLLエクスポート名: core_FileStorage_write_SparseMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_write_SparseMat(cv::FileStorage *fs, const char *name, const cv::SparseMat *value)
{
    BEGIN_WRAP
    cv::write(*fs, cv::String(name), *value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_write_vectorOfKeyPoint
[32/64bit] core_FileStorage_write_vectorOfKeyPoint
%prm
p1,p2,p3
p1 = sptr : IntPtr fs
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string name
p3 = sptr : IntPtr value
%inst
元関数名(C#): core_FileStorage_write_vectorOfKeyPoint
元DLLエクスポート名: core_FileStorage_write_vectorOfKeyPoint
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_write_vectorOfKeyPoint(cv::FileStorage *fs, const char *name, const std::vector&amp;lt;cv::KeyPoint&amp;gt; *value)
{
    BEGIN_WRAP
    cv::write(*fs, cv::String(name), *value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_write_vectorOfDMatch
[32/64bit] core_FileStorage_write_vectorOfDMatch
%prm
p1,p2,p3
p1 = sptr : IntPtr fs
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string name
p3 = sptr : IntPtr value
%inst
元関数名(C#): core_FileStorage_write_vectorOfDMatch
元DLLエクスポート名: core_FileStorage_write_vectorOfDMatch
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_write_vectorOfDMatch(cv::FileStorage *fs, const char *name, const std::vector&amp;lt;cv::DMatch&amp;gt; *value)
{
    BEGIN_WRAP
    cv::write(*fs, cv::String(name), *value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_writeScalar_int
[32/64bit] core_FileStorage_writeScalar_int
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = int : int value
%inst
元関数名(C#): core_FileStorage_writeScalar_int
元DLLエクスポート名: core_FileStorage_writeScalar_int
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_writeScalar_int(cv::FileStorage *fs, int value)
{
    BEGIN_WRAP
    cv::writeScalar(*fs, value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_writeScalar_float
[32/64bit] core_FileStorage_writeScalar_float
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = float : float value
%inst
元関数名(C#): core_FileStorage_writeScalar_float
元DLLエクスポート名: core_FileStorage_writeScalar_float
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_writeScalar_float(cv::FileStorage *fs, float value)
{
    BEGIN_WRAP
    cv::writeScalar(*fs, value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_writeScalar_double
[32/64bit] core_FileStorage_writeScalar_double
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = double : double value
%inst
元関数名(C#): core_FileStorage_writeScalar_double
元DLLエクスポート名: core_FileStorage_writeScalar_double
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_writeScalar_double(cv::FileStorage *fs, double value)
{
    BEGIN_WRAP
    cv::writeScalar(*fs, value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_writeScalar_String
[32/64bit] core_FileStorage_writeScalar_String
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string value
%inst
元関数名(C#): core_FileStorage_writeScalar_String
元DLLエクスポート名: core_FileStorage_writeScalar_String
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_writeScalar_String(cv::FileStorage *fs, const char *value)
{
    BEGIN_WRAP
    cv::writeScalar(*fs, cv::String(value));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_String
[32/64bit] core_FileStorage_shift_String
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string val
%inst
元関数名(C#): core_FileStorage_shift_String
元DLLエクスポート名: core_FileStorage_shift_String
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_String(cv::FileStorage *fs, const char *val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_int
[32/64bit] core_FileStorage_shift_int
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = int : int val
%inst
元関数名(C#): core_FileStorage_shift_int
元DLLエクスポート名: core_FileStorage_shift_int
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_int(cv::FileStorage *fs, int val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_float
[32/64bit] core_FileStorage_shift_float
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = float : float val
%inst
元関数名(C#): core_FileStorage_shift_float
元DLLエクスポート名: core_FileStorage_shift_float
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_float(cv::FileStorage *fs, float val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_double
[32/64bit] core_FileStorage_shift_double
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = double : double val
%inst
元関数名(C#): core_FileStorage_shift_double
元DLLエクスポート名: core_FileStorage_shift_double
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_double(cv::FileStorage *fs, double val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Mat
[32/64bit] core_FileStorage_shift_Mat
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = sptr : IntPtr val
%inst
元関数名(C#): core_FileStorage_shift_Mat
元DLLエクスポート名: core_FileStorage_shift_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Mat(cv::FileStorage *fs, cv::Mat *val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; *val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_SparseMat
[32/64bit] core_FileStorage_shift_SparseMat
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = sptr : IntPtr val
%inst
元関数名(C#): core_FileStorage_shift_SparseMat
元DLLエクスポート名: core_FileStorage_shift_SparseMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_SparseMat(cv::FileStorage *fs, cv::SparseMat *val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; *val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Range
[32/64bit] core_FileStorage_shift_Range
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_RANGE : Range val
%inst
元関数名(C#): core_FileStorage_shift_Range
元DLLエクスポート名: core_FileStorage_shift_Range
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Range(cv::FileStorage *fs, MyCvSlice val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cpp(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_KeyPoint
[32bit] core_FileStorage_shift_KeyPoint
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_KEYPOINT : KeyPoint val
%inst
元関数名(C#): core_FileStorage_shift_KeyPoint
元DLLエクスポート名: core_FileStorage_shift_KeyPoint
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_KeyPoint(cv::FileStorage *fs, cv::KeyPoint val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_KeyPoint
[64bit] core_FileStorage_shift_KeyPoint
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : KeyPoint val
%inst
元関数名(C#): core_FileStorage_shift_KeyPoint
元DLLエクスポート名: core_FileStorage_shift_KeyPoint
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_KeyPoint(cv::FileStorage *fs, cv::KeyPoint val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_DMatch
[32bit] core_FileStorage_shift_DMatch
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_DMATCH : DMatch val
%inst
元関数名(C#): core_FileStorage_shift_DMatch
元DLLエクスポート名: core_FileStorage_shift_DMatch
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_DMatch(cv::FileStorage *fs, cv::DMatch val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_DMatch
[64bit] core_FileStorage_shift_DMatch
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : DMatch val
%inst
元関数名(C#): core_FileStorage_shift_DMatch
元DLLエクスポート名: core_FileStorage_shift_DMatch
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_DMatch(cv::FileStorage *fs, cv::DMatch val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_vectorOfKeyPoint
[32/64bit] core_FileStorage_shift_vectorOfKeyPoint
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = sptr : IntPtr val
%inst
元関数名(C#): core_FileStorage_shift_vectorOfKeyPoint
元DLLエクスポート名: core_FileStorage_shift_vectorOfKeyPoint
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_vectorOfKeyPoint(cv::FileStorage *fs, std::vector&amp;lt;cv::KeyPoint&amp;gt; *val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; *val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_vectorOfDMatch
[32/64bit] core_FileStorage_shift_vectorOfDMatch
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = sptr : IntPtr val
%inst
元関数名(C#): core_FileStorage_shift_vectorOfDMatch
元DLLエクスポート名: core_FileStorage_shift_vectorOfDMatch
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_vectorOfDMatch(cv::FileStorage *fs, std::vector&amp;lt;cv::DMatch&amp;gt; *val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; *val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Point2i
[32/64bit] core_FileStorage_shift_Point2i
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_POINT : Point val
%inst
元関数名(C#): core_FileStorage_shift_Point2i
元DLLエクスポート名: core_FileStorage_shift_Point2i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Point2i(cv::FileStorage *fs, MyCvPoint val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Point2i(val.x, val.y);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Point2f
[32/64bit] core_FileStorage_shift_Point2f
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_POINT2F : Point2f val
%inst
元関数名(C#): core_FileStorage_shift_Point2f
元DLLエクスポート名: core_FileStorage_shift_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Point2f(cv::FileStorage *fs, MyCvPoint2D32f val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Point2f(val.x, val.y);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Point2d
[32bit] core_FileStorage_shift_Point2d
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_POINT2D : Point2d val
%inst
元関数名(C#): core_FileStorage_shift_Point2d
元DLLエクスポート名: core_FileStorage_shift_Point2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Point2d(cv::FileStorage *fs, MyCvPoint2D64f val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Point2d(val.x, val.y);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Point2d
[64bit] core_FileStorage_shift_Point2d
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Point2d val
%inst
元関数名(C#): core_FileStorage_shift_Point2d
元DLLエクスポート名: core_FileStorage_shift_Point2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Point2d(cv::FileStorage *fs, MyCvPoint2D64f val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Point2d(val.x, val.y);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Point3i
[32bit] core_FileStorage_shift_Point3i
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_POINT3I : Point3i val
%inst
元関数名(C#): core_FileStorage_shift_Point3i
元DLLエクスポート名: core_FileStorage_shift_Point3i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Point3i(cv::FileStorage *fs, MyCvPoint3D32i val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Point3i(val.x, val.y, val.z);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Point3i
[64bit] core_FileStorage_shift_Point3i
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Point3i val
%inst
元関数名(C#): core_FileStorage_shift_Point3i
元DLLエクスポート名: core_FileStorage_shift_Point3i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Point3i(cv::FileStorage *fs, MyCvPoint3D32i val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Point3i(val.x, val.y, val.z);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Point3f
[32bit] core_FileStorage_shift_Point3f
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_POINT3F : Point3f val
%inst
元関数名(C#): core_FileStorage_shift_Point3f
元DLLエクスポート名: core_FileStorage_shift_Point3f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Point3f(cv::FileStorage *fs, MyCvPoint3D32f val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Point3f(val.x, val.y, val.z);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Point3f
[64bit] core_FileStorage_shift_Point3f
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Point3f val
%inst
元関数名(C#): core_FileStorage_shift_Point3f
元DLLエクスポート名: core_FileStorage_shift_Point3f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Point3f(cv::FileStorage *fs, MyCvPoint3D32f val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Point3f(val.x, val.y, val.z);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Point3d
[32bit] core_FileStorage_shift_Point3d
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_POINT3D : Point3d val
%inst
元関数名(C#): core_FileStorage_shift_Point3d
元DLLエクスポート名: core_FileStorage_shift_Point3d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Point3d(cv::FileStorage *fs, MyCvPoint3D64f val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Point3d(val.x, val.y, val.z);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Point3d
[64bit] core_FileStorage_shift_Point3d
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Point3d val
%inst
元関数名(C#): core_FileStorage_shift_Point3d
元DLLエクスポート名: core_FileStorage_shift_Point3d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Point3d(cv::FileStorage *fs, MyCvPoint3D64f val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Point3d(val.x, val.y, val.z);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Size2i
[32/64bit] core_FileStorage_shift_Size2i
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_SIZE : Size val
%inst
元関数名(C#): core_FileStorage_shift_Size2i
元DLLエクスポート名: core_FileStorage_shift_Size2i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Size2i(cv::FileStorage *fs, MyCvSize val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Size2i(val.width, val.height);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Size2f
[32/64bit] core_FileStorage_shift_Size2f
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_SIZE2F : Size2f val
%inst
元関数名(C#): core_FileStorage_shift_Size2f
元DLLエクスポート名: core_FileStorage_shift_Size2f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Size2f(cv::FileStorage *fs, MyCvSize2D32f val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Size2f(val.width, val.height);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Size2d
[32bit] core_FileStorage_shift_Size2d
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_SIZE2D : Size2d val
%inst
元関数名(C#): core_FileStorage_shift_Size2d
元DLLエクスポート名: core_FileStorage_shift_Size2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Size2d(cv::FileStorage *fs, MyCvSize2D64f val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Size2d(val.width, val.height);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Size2d
[64bit] core_FileStorage_shift_Size2d
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Size2d val
%inst
元関数名(C#): core_FileStorage_shift_Size2d
元DLLエクスポート名: core_FileStorage_shift_Size2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Size2d(cv::FileStorage *fs, MyCvSize2D64f val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Size2d(val.width, val.height);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Rect2i
[32bit] core_FileStorage_shift_Rect2i
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_RECT : Rect val
%inst
元関数名(C#): core_FileStorage_shift_Rect2i
元DLLエクスポート名: core_FileStorage_shift_Rect2i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Rect2i(cv::FileStorage *fs, MyCvRect val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Rect2i(val.x, val.y, val.width, val.height);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Rect2i
[64bit] core_FileStorage_shift_Rect2i
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Rect val
%inst
元関数名(C#): core_FileStorage_shift_Rect2i
元DLLエクスポート名: core_FileStorage_shift_Rect2i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Rect2i(cv::FileStorage *fs, MyCvRect val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Rect2i(val.x, val.y, val.width, val.height);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Rect2f
[32bit] core_FileStorage_shift_Rect2f
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_RECT2F : Rect2f val
%inst
元関数名(C#): core_FileStorage_shift_Rect2f
元DLLエクスポート名: core_FileStorage_shift_Rect2f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Rect2f(cv::FileStorage *fs, MyCvRect2D32f val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Rect2f(val.x, val.y, val.width, val.height);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Rect2f
[64bit] core_FileStorage_shift_Rect2f
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Rect2f val
%inst
元関数名(C#): core_FileStorage_shift_Rect2f
元DLLエクスポート名: core_FileStorage_shift_Rect2f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Rect2f(cv::FileStorage *fs, MyCvRect2D32f val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Rect2f(val.x, val.y, val.width, val.height);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Rect2d
[32bit] core_FileStorage_shift_Rect2d
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_RECT2D : Rect2d val
%inst
元関数名(C#): core_FileStorage_shift_Rect2d
元DLLエクスポート名: core_FileStorage_shift_Rect2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Rect2d(cv::FileStorage *fs, MyCvRect2D64f val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Rect2d(val.x, val.y, val.width, val.height);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Rect2d
[64bit] core_FileStorage_shift_Rect2d
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Rect2d val
%inst
元関数名(C#): core_FileStorage_shift_Rect2d
元DLLエクスポート名: core_FileStorage_shift_Rect2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Rect2d(cv::FileStorage *fs, MyCvRect2D64f val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Rect2d(val.x, val.y, val.width, val.height);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Scalar
[32bit] core_FileStorage_shift_Scalar
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_SCALAR : Scalar val
%inst
元関数名(C#): core_FileStorage_shift_Scalar
元DLLエクスポート名: core_FileStorage_shift_Scalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Scalar(cv::FileStorage *fs, MyCvScalar val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cpp(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Scalar
[64bit] core_FileStorage_shift_Scalar
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Scalar val
%inst
元関数名(C#): core_FileStorage_shift_Scalar
元DLLエクスポート名: core_FileStorage_shift_Scalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Scalar(cv::FileStorage *fs, MyCvScalar val)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cpp(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec2i
[32/64bit] core_FileStorage_shift_Vec2i
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC2I : Vec2i val
%inst
元関数名(C#): core_FileStorage_shift_Vec2i
元DLLエクスポート名: core_FileStorage_shift_Vec2i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec2i(cv::FileStorage *fs, CvVec2i v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec2i(v.val[0], v.val[1]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec3i
[32bit] core_FileStorage_shift_Vec3i
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC3I : Vec3i val
%inst
元関数名(C#): core_FileStorage_shift_Vec3i
元DLLエクスポート名: core_FileStorage_shift_Vec3i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec3i(cv::FileStorage *fs, CvVec3i v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec3i(v.val[0], v.val[1], v.val[2]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec3i
[64bit] core_FileStorage_shift_Vec3i
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Vec3i val
%inst
元関数名(C#): core_FileStorage_shift_Vec3i
元DLLエクスポート名: core_FileStorage_shift_Vec3i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec3i(cv::FileStorage *fs, CvVec3i v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec3i(v.val[0], v.val[1], v.val[2]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec4i
[32bit] core_FileStorage_shift_Vec4i
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC4I : Vec4i val
%inst
元関数名(C#): core_FileStorage_shift_Vec4i
元DLLエクスポート名: core_FileStorage_shift_Vec4i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec4i(cv::FileStorage *fs, CvVec4i v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec4i(v.val[0], v.val[1], v.val[2], v.val[3]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec4i
[64bit] core_FileStorage_shift_Vec4i
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Vec4i val
%inst
元関数名(C#): core_FileStorage_shift_Vec4i
元DLLエクスポート名: core_FileStorage_shift_Vec4i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec4i(cv::FileStorage *fs, CvVec4i v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec4i(v.val[0], v.val[1], v.val[2], v.val[3]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec6i
[32bit] core_FileStorage_shift_Vec6i
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC6I : Vec6i val
%inst
元関数名(C#): core_FileStorage_shift_Vec6i
元DLLエクスポート名: core_FileStorage_shift_Vec6i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec6i(cv::FileStorage *fs, CvVec6i v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec6i(v.val[0], v.val[1], v.val[2], v.val[3], v.val[4], v.val[5]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec6i
[64bit] core_FileStorage_shift_Vec6i
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Vec6i val
%inst
元関数名(C#): core_FileStorage_shift_Vec6i
元DLLエクスポート名: core_FileStorage_shift_Vec6i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec6i(cv::FileStorage *fs, CvVec6i v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec6i(v.val[0], v.val[1], v.val[2], v.val[3], v.val[4], v.val[5]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec2d
[32bit] core_FileStorage_shift_Vec2d
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC2D : Vec2d val
%inst
元関数名(C#): core_FileStorage_shift_Vec2d
元DLLエクスポート名: core_FileStorage_shift_Vec2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec2d(cv::FileStorage *fs, CvVec2d v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec2d(v.val[0], v.val[1]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec2d
[64bit] core_FileStorage_shift_Vec2d
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Vec2d val
%inst
元関数名(C#): core_FileStorage_shift_Vec2d
元DLLエクスポート名: core_FileStorage_shift_Vec2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec2d(cv::FileStorage *fs, CvVec2d v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec2d(v.val[0], v.val[1]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec3d
[32bit] core_FileStorage_shift_Vec3d
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC3D : Vec3d val
%inst
元関数名(C#): core_FileStorage_shift_Vec3d
元DLLエクスポート名: core_FileStorage_shift_Vec3d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec3d(cv::FileStorage *fs, CvVec3d v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec3d(v.val[0], v.val[1], v.val[2]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec3d
[64bit] core_FileStorage_shift_Vec3d
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Vec3d val
%inst
元関数名(C#): core_FileStorage_shift_Vec3d
元DLLエクスポート名: core_FileStorage_shift_Vec3d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec3d(cv::FileStorage *fs, CvVec3d v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec3d(v.val[0], v.val[1], v.val[2]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec4d
[32bit] core_FileStorage_shift_Vec4d
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC4D : Vec4d val
%inst
元関数名(C#): core_FileStorage_shift_Vec4d
元DLLエクスポート名: core_FileStorage_shift_Vec4d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec4d(cv::FileStorage *fs, CvVec4d v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec4d(v.val[0], v.val[1], v.val[2], v.val[3]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec4d
[64bit] core_FileStorage_shift_Vec4d
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Vec4d val
%inst
元関数名(C#): core_FileStorage_shift_Vec4d
元DLLエクスポート名: core_FileStorage_shift_Vec4d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec4d(cv::FileStorage *fs, CvVec4d v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec4d(v.val[0], v.val[1], v.val[2], v.val[3]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec6d
[32bit] core_FileStorage_shift_Vec6d
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC6D : Vec6d val
%inst
元関数名(C#): core_FileStorage_shift_Vec6d
元DLLエクスポート名: core_FileStorage_shift_Vec6d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec6d(cv::FileStorage *fs, CvVec6d v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec6d(v.val[0], v.val[1], v.val[2], v.val[3], v.val[4], v.val[5]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec6d
[64bit] core_FileStorage_shift_Vec6d
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Vec6d val
%inst
元関数名(C#): core_FileStorage_shift_Vec6d
元DLLエクスポート名: core_FileStorage_shift_Vec6d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec6d(cv::FileStorage *fs, CvVec6d v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec6d(v.val[0], v.val[1], v.val[2], v.val[3], v.val[4], v.val[5]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec2f
[32/64bit] core_FileStorage_shift_Vec2f
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC2F : Vec2f val
%inst
元関数名(C#): core_FileStorage_shift_Vec2f
元DLLエクスポート名: core_FileStorage_shift_Vec2f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec2f(cv::FileStorage *fs, CvVec2f v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec2f(v.val[0], v.val[1]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec3f
[32bit] core_FileStorage_shift_Vec3f
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC3F : Vec3f val
%inst
元関数名(C#): core_FileStorage_shift_Vec3f
元DLLエクスポート名: core_FileStorage_shift_Vec3f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec3f(cv::FileStorage *fs, CvVec3f v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec3f(v.val[0], v.val[1], v.val[2]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec3f
[64bit] core_FileStorage_shift_Vec3f
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Vec3f val
%inst
元関数名(C#): core_FileStorage_shift_Vec3f
元DLLエクスポート名: core_FileStorage_shift_Vec3f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec3f(cv::FileStorage *fs, CvVec3f v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec3f(v.val[0], v.val[1], v.val[2]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec4f
[32bit] core_FileStorage_shift_Vec4f
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC4F : Vec4f val
%inst
元関数名(C#): core_FileStorage_shift_Vec4f
元DLLエクスポート名: core_FileStorage_shift_Vec4f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec4f(cv::FileStorage *fs, CvVec4f v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec4f(v.val[0], v.val[1], v.val[2], v.val[3]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec4f
[64bit] core_FileStorage_shift_Vec4f
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Vec4f val
%inst
元関数名(C#): core_FileStorage_shift_Vec4f
元DLLエクスポート名: core_FileStorage_shift_Vec4f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec4f(cv::FileStorage *fs, CvVec4f v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec4f(v.val[0], v.val[1], v.val[2], v.val[3]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec6f
[32bit] core_FileStorage_shift_Vec6f
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC6F : Vec6f val
%inst
元関数名(C#): core_FileStorage_shift_Vec6f
元DLLエクスポート名: core_FileStorage_shift_Vec6f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec6f(cv::FileStorage *fs, CvVec6f v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec6f(v.val[0], v.val[1], v.val[2], v.val[3], v.val[4], v.val[5]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec6f
[64bit] core_FileStorage_shift_Vec6f
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Vec6f val
%inst
元関数名(C#): core_FileStorage_shift_Vec6f
元DLLエクスポート名: core_FileStorage_shift_Vec6f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec6f(cv::FileStorage *fs, CvVec6f v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec6f(v.val[0], v.val[1], v.val[2], v.val[3], v.val[4], v.val[5]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec2b
[32bit] core_FileStorage_shift_Vec2b
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC2B : Vec2b val
%inst
元関数名(C#): core_FileStorage_shift_Vec2b
元DLLエクスポート名: core_FileStorage_shift_Vec2b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec2b(cv::FileStorage *fs, CvVec2b v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec2b(v.val[0], v.val[1]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec2b
[64bit] core_FileStorage_shift_Vec2b
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = int : Vec2b val
%inst
元関数名(C#): core_FileStorage_shift_Vec2b
元DLLエクスポート名: core_FileStorage_shift_Vec2b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec2b(cv::FileStorage *fs, CvVec2b v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec2b(v.val[0], v.val[1]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec3b
[32bit] core_FileStorage_shift_Vec3b
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC3B : Vec3b val
%inst
元関数名(C#): core_FileStorage_shift_Vec3b
元DLLエクスポート名: core_FileStorage_shift_Vec3b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec3b(cv::FileStorage *fs, CvVec3b v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec3b(v.val[0], v.val[1], v.val[2]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec3b
[64bit] core_FileStorage_shift_Vec3b
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = int : Vec3b val
%inst
元関数名(C#): core_FileStorage_shift_Vec3b
元DLLエクスポート名: core_FileStorage_shift_Vec3b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec3b(cv::FileStorage *fs, CvVec3b v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec3b(v.val[0], v.val[1], v.val[2]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec4b
[32bit] core_FileStorage_shift_Vec4b
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC4B : Vec4b val
%inst
元関数名(C#): core_FileStorage_shift_Vec4b
元DLLエクスポート名: core_FileStorage_shift_Vec4b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec4b(cv::FileStorage *fs, CvVec4b v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec4b(v.val[0], v.val[1], v.val[2], v.val[3]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec4b
[64bit] core_FileStorage_shift_Vec4b
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = int : Vec4b val
%inst
元関数名(C#): core_FileStorage_shift_Vec4b
元DLLエクスポート名: core_FileStorage_shift_Vec4b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec4b(cv::FileStorage *fs, CvVec4b v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec4b(v.val[0], v.val[1], v.val[2], v.val[3]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec6b
[32/64bit] core_FileStorage_shift_Vec6b
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC6B : Vec6b val
%inst
元関数名(C#): core_FileStorage_shift_Vec6b
元DLLエクスポート名: core_FileStorage_shift_Vec6b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec6b(cv::FileStorage *fs, CvVec6b v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec6b(v.val[0], v.val[1], v.val[2], v.val[3], v.val[4], v.val[5]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec2s
[32bit] core_FileStorage_shift_Vec2s
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC2S : Vec2s val
%inst
元関数名(C#): core_FileStorage_shift_Vec2s
元DLLエクスポート名: core_FileStorage_shift_Vec2s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec2s(cv::FileStorage *fs, CvVec2s v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec2s(v.val[0], v.val[1]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec2s
[64bit] core_FileStorage_shift_Vec2s
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = int : Vec2s val
%inst
元関数名(C#): core_FileStorage_shift_Vec2s
元DLLエクスポート名: core_FileStorage_shift_Vec2s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec2s(cv::FileStorage *fs, CvVec2s v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec2s(v.val[0], v.val[1]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec3s
[32/64bit] core_FileStorage_shift_Vec3s
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC3S : Vec3s val
%inst
元関数名(C#): core_FileStorage_shift_Vec3s
元DLLエクスポート名: core_FileStorage_shift_Vec3s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec3s(cv::FileStorage *fs, CvVec3s v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec3s(v.val[0], v.val[1], v.val[2]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec4s
[32/64bit] core_FileStorage_shift_Vec4s
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC4S : Vec4s val
%inst
元関数名(C#): core_FileStorage_shift_Vec4s
元DLLエクスポート名: core_FileStorage_shift_Vec4s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec4s(cv::FileStorage *fs, CvVec4s v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec4s(v.val[0], v.val[1], v.val[2], v.val[3]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec6s
[32bit] core_FileStorage_shift_Vec6s
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC6S : Vec6s val
%inst
元関数名(C#): core_FileStorage_shift_Vec6s
元DLLエクスポート名: core_FileStorage_shift_Vec6s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec6s(cv::FileStorage *fs, CvVec6s v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec6s(v.val[0], v.val[1], v.val[2], v.val[3], v.val[4], v.val[5]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec6s
[64bit] core_FileStorage_shift_Vec6s
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Vec6s val
%inst
元関数名(C#): core_FileStorage_shift_Vec6s
元DLLエクスポート名: core_FileStorage_shift_Vec6s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec6s(cv::FileStorage *fs, CvVec6s v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec6s(v.val[0], v.val[1], v.val[2], v.val[3], v.val[4], v.val[5]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec2w
[32bit] core_FileStorage_shift_Vec2w
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC2W : Vec2w val
%inst
元関数名(C#): core_FileStorage_shift_Vec2w
元DLLエクスポート名: core_FileStorage_shift_Vec2w
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec2w(cv::FileStorage *fs, CvVec2w v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec2w(v.val[0], v.val[1]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec2w
[64bit] core_FileStorage_shift_Vec2w
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = int : Vec2w val
%inst
元関数名(C#): core_FileStorage_shift_Vec2w
元DLLエクスポート名: core_FileStorage_shift_Vec2w
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec2w(cv::FileStorage *fs, CvVec2w v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec2w(v.val[0], v.val[1]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec3w
[32/64bit] core_FileStorage_shift_Vec3w
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC3W : Vec3w val
%inst
元関数名(C#): core_FileStorage_shift_Vec3w
元DLLエクスポート名: core_FileStorage_shift_Vec3w
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec3w(cv::FileStorage *fs, CvVec3w v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec3w(v.val[0], v.val[1], v.val[2]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec4w
[32/64bit] core_FileStorage_shift_Vec4w
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC4W : Vec4w val
%inst
元関数名(C#): core_FileStorage_shift_Vec4w
元DLLエクスポート名: core_FileStorage_shift_Vec4w
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec4w(cv::FileStorage *fs, CvVec4w v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec4w(v.val[0], v.val[1], v.val[2], v.val[3]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec6w
[32bit] core_FileStorage_shift_Vec6w
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = ARGS_VEC6W : Vec6w val
%inst
元関数名(C#): core_FileStorage_shift_Vec6w
元DLLエクスポート名: core_FileStorage_shift_Vec6w
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec6w(cv::FileStorage *fs, CvVec6w v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec6w(v.val[0], v.val[1], v.val[2], v.val[3], v.val[4], v.val[5]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_FileStorage_shift_Vec6w
[64bit] core_FileStorage_shift_Vec6w
%prm
p1,p2
p1 = sptr : IntPtr fs
p2 = var : Vec6w val
%inst
元関数名(C#): core_FileStorage_shift_Vec6w
元DLLエクスポート名: core_FileStorage_shift_Vec6w
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_FileStorage.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_FileStorage_shift_Vec6w(cv::FileStorage *fs, CvVec6w v)
{
    BEGIN_WRAP
    (*fs) &amp;lt;&amp;lt; cv::Vec6w(v.val[0], v.val[1], v.val[2], v.val[3], v.val[4], v.val[5]);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_FileStorage

%index
core_InputArray_new_byMat
[32/64bit] cv::_InputArray のインスタンスを生成します
%prm
p1,p2
p1 = sptr : IntPtr mat
p2 = var : out IntPtr returnValue
%inst
これは，OpenCVの関数に読み取り専用の入力配列を渡すための，プロキシクラスです．

これは次のように定義されます： typedef const _InputArray& InputArray; ここで _InputArray は， Mat, Mat_<T>, Matx<T, m, n>, std::vector<T>, std::vector<std::vector<T> >, std::vector<Mat>, std::vector<Mat_<T> >, UMat, std::vector<UMat> または double から構成されるクラスです．また，行列式から構築することもできます．

これはほとんどが実装レベルのクラスであり，そのインターフェースは将来のバージョンで変更される可能性があるので，ここでは詳細な説明を省略します．しかし、いくつかの重要な点を覚えておく必要があります。



リファレンスマニュアルや OpenCV のソースコードで，InputArray を受け取る関数を見かけることがありますが，これは，実際に Mat, Matx, vector<T> などを渡すことができることを意味します（上記の完全なリストを参照してください）．(完全なリストは上を参照してください）．

オプションの入力引数．入力配列の一部が空の場合は， cv::noArray() を渡してください（あるいは，以前のように単に cv::Mat() を渡しても構いません）．

このクラスは，パラメータを渡すためだけに設計されています．つまり，通常は，クラスのメンバやローカル変数，グローバル変数をこの型で宣言してはいけません．

複数の型の配列を操作できる独自の関数やクラスメソッドを設計したい場合は，それぞれのパラメータに InputArray（または OutputArray）を利用します．関数内では _InputArray::getMat() メソッドを使用して、（データをコピーせずに）配列の行列ヘッダを作成する必要があります。_InputArray::kind() は、Mat と vector<> などを区別するために利用できますが、通常は必要ありません。



ここでは，InputArray : std::vector<Point2f> vec;// 点または円for( int i = 0; i < 30; i++ ) vec.push_back(Point2f((float)(100 + 30*cos(i*CV_PI*2/5)), (float)(100 - 30*sin(i*CV_PI*2/5))));cv::transform(vec, vec, cv::Matx23f(0.707, -0.707, 10, 0.707, 0.707, 20)); つまり，点を含む STL ベクトルを作成し，Matx<float, 2, 3> インスタンスとしてインラインで作成された 2x3 行列を用いて，そのベクトルにインプレースのアフィン変換を行います．

以下は，このような関数の実装方法です（簡単にするために，内部のアサーション文に従って，非常に特殊なケースを実装しています）： void myAffineTransform(InputArray _src, OutputArray _dst, InputArray _m){ // 入力配列に対する Mat ヘッダを取得します．これは， _src や _m が行列表現でない限り， // O(1) の処理です．    Mat src = _src.getMat(), m = _m.getMat(); CV_Assert( src.type() == CV_32FC2 && m.type() == CV_32F && m.size() == Size(3, 2) ); // 出力配列を適切なサイズと型になるように [再]作成します．    // Mat の場合は Mat::create を，STL vector の場合は vector::resize を呼び出します．    _dst.create(src.size(), src.type()); Mat dst = _dst.getMat(); for( int i = 0; i < src.rows; i++ ) for( int j = 0; j < src.cols; j++ ) { Point2f pt = src.at<Point2f>(i, j); dst.at<Point2f>(i, j) = Point2f(m.at<float>(0, 0)*pt.x + m.at<float>(0, 1)*pt.y + m.at<float>(0, 2), m.at<float>(1, 0)*pt.x + m.at<float>(1, 1)*pt.y + m.at<float>(1, 2)); }}。typedef InputArray InputArrayOfArrays; これは、ベクトルのベクトル、または行列のベクトルのいずれかである関数の引数を表します。Python/Javaなどのラッパーを適切に生成するためには、別のシノニムが必要です。関数の実装レベルでは、これらの使用方法は似ていますが、_InputArray::getMat(idx)は、外側のベクトルの idx 番目のコンポーネントのヘッダを取得するために使用し、_InputArray::size().area() は、外側のベクトルのコンポーネント（ベクトル/行列）の数を求めるために使用します。

一般に，サポートされる型は cv::Mat 型に限られます．それ以外の型は禁止されています．しかし，場合によっては， cv::KeyPoint や cv::DMatch などの配列のような，一般的ではないカスタムの Mat 型の受け渡しをサポートする必要があります．このデータは，画像データとして解釈されたり，通常の cv::Mat のように何らかの処理が行われたりすることはありません．このようなカスタムタイプを渡すには， rawIn() / rawOut() / rawInOut() ラッパーを利用してください．カスタムタイプは，Mat と互換性のある CV_8UC<N> 個の値（N = sizeof(T), N <= CV_CN_MAX）としてラッピングされます．

例：samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp．


元関数名(C#): core_InputArray_new_byMat
元DLLエクスポート名: core_InputArray_new_byMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_new_byMat(cv::Mat *mat, cv::_InputArray **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::_InputArray(*mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_new_byUMat
[32/64bit] cv::_InputArray のインスタンスを生成します
%prm
p1,p2
p1 = sptr : IntPtr mat
p2 = var : out IntPtr returnValue
%inst
これは，OpenCVの関数に読み取り専用の入力配列を渡すための，プロキシクラスです．

これは次のように定義されます： typedef const _InputArray& InputArray; ここで _InputArray は， Mat, Mat_<T>, Matx<T, m, n>, std::vector<T>, std::vector<std::vector<T> >, std::vector<Mat>, std::vector<Mat_<T> >, UMat, std::vector<UMat> または double から構成されるクラスです．また，行列式から構築することもできます．

これはほとんどが実装レベルのクラスであり，そのインターフェースは将来のバージョンで変更される可能性があるので，ここでは詳細な説明を省略します．しかし、いくつかの重要な点を覚えておく必要があります。



リファレンスマニュアルや OpenCV のソースコードで，InputArray を受け取る関数を見かけることがありますが，これは，実際に Mat, Matx, vector<T> などを渡すことができることを意味します（上記の完全なリストを参照してください）．(完全なリストは上を参照してください）．

オプションの入力引数．入力配列の一部が空の場合は， cv::noArray() を渡してください（あるいは，以前のように単に cv::Mat() を渡しても構いません）．

このクラスは，パラメータを渡すためだけに設計されています．つまり，通常は，クラスのメンバやローカル変数，グローバル変数をこの型で宣言してはいけません．

複数の型の配列を操作できる独自の関数やクラスメソッドを設計したい場合は，それぞれのパラメータに InputArray（または OutputArray）を利用します．関数内では _InputArray::getMat() メソッドを使用して、（データをコピーせずに）配列の行列ヘッダを作成する必要があります。_InputArray::kind() は、Mat と vector<> などを区別するために利用できますが、通常は必要ありません。



ここでは，InputArray : std::vector<Point2f> vec;// 点または円for( int i = 0; i < 30; i++ ) vec.push_back(Point2f((float)(100 + 30*cos(i*CV_PI*2/5)), (float)(100 - 30*sin(i*CV_PI*2/5))));cv::transform(vec, vec, cv::Matx23f(0.707, -0.707, 10, 0.707, 0.707, 20)); つまり，点を含む STL ベクトルを作成し，Matx<float, 2, 3> インスタンスとしてインラインで作成された 2x3 行列を用いて，そのベクトルにインプレースのアフィン変換を行います．

以下は，このような関数の実装方法です（簡単にするために，内部のアサーション文に従って，非常に特殊なケースを実装しています）： void myAffineTransform(InputArray _src, OutputArray _dst, InputArray _m){ // 入力配列に対する Mat ヘッダを取得します．これは， _src や _m が行列表現でない限り， // O(1) の処理です．    Mat src = _src.getMat(), m = _m.getMat(); CV_Assert( src.type() == CV_32FC2 && m.type() == CV_32F && m.size() == Size(3, 2) ); // 出力配列を適切なサイズと型になるように [再]作成します．    // Mat の場合は Mat::create を，STL vector の場合は vector::resize を呼び出します．    _dst.create(src.size(), src.type()); Mat dst = _dst.getMat(); for( int i = 0; i < src.rows; i++ ) for( int j = 0; j < src.cols; j++ ) { Point2f pt = src.at<Point2f>(i, j); dst.at<Point2f>(i, j) = Point2f(m.at<float>(0, 0)*pt.x + m.at<float>(0, 1)*pt.y + m.at<float>(0, 2), m.at<float>(1, 0)*pt.x + m.at<float>(1, 1)*pt.y + m.at<float>(1, 2)); }}。typedef InputArray InputArrayOfArrays; これは、ベクトルのベクトル、または行列のベクトルのいずれかである関数の引数を表します。Python/Javaなどのラッパーを適切に生成するためには、別のシノニムが必要です。関数の実装レベルでは、これらの使用方法は似ていますが、_InputArray::getMat(idx)は、外側のベクトルの idx 番目のコンポーネントのヘッダを取得するために使用し、_InputArray::size().area() は、外側のベクトルのコンポーネント（ベクトル/行列）の数を求めるために使用します。

一般に，サポートされる型は cv::Mat 型に限られます．それ以外の型は禁止されています．しかし，場合によっては， cv::KeyPoint や cv::DMatch などの配列のような，一般的ではないカスタムの Mat 型の受け渡しをサポートする必要があります．このデータは，画像データとして解釈されたり，通常の cv::Mat のように何らかの処理が行われたりすることはありません．このようなカスタムタイプを渡すには， rawIn() / rawOut() / rawInOut() ラッパーを利用してください．カスタムタイプは，Mat と互換性のある CV_8UC<N> 個の値（N = sizeof(T), N <= CV_CN_MAX）としてラッピングされます．

例：samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp．


元関数名(C#): core_InputArray_new_byUMat
元DLLエクスポート名: core_InputArray_new_byUMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_new_byUMat(cv::UMat* mat, cv::_InputArray** returnValue)
{
    BEGIN_WRAP
        * returnValue = new cv::_InputArray(*mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_new_byMatExpr
[32/64bit] cv::_InputArray のインスタンスを生成します
%prm
p1,p2
p1 = sptr : IntPtr mat
p2 = var : out IntPtr returnValue
%inst
これは，OpenCVの関数に読み取り専用の入力配列を渡すための，プロキシクラスです．

これは次のように定義されます： typedef const _InputArray& InputArray; ここで _InputArray は， Mat, Mat_<T>, Matx<T, m, n>, std::vector<T>, std::vector<std::vector<T> >, std::vector<Mat>, std::vector<Mat_<T> >, UMat, std::vector<UMat> または double から構成されるクラスです．また，行列式から構築することもできます．

これはほとんどが実装レベルのクラスであり，そのインターフェースは将来のバージョンで変更される可能性があるので，ここでは詳細な説明を省略します．しかし、いくつかの重要な点を覚えておく必要があります。



リファレンスマニュアルや OpenCV のソースコードで，InputArray を受け取る関数を見かけることがありますが，これは，実際に Mat, Matx, vector<T> などを渡すことができることを意味します（上記の完全なリストを参照してください）．(完全なリストは上を参照してください）．

オプションの入力引数．入力配列の一部が空の場合は， cv::noArray() を渡してください（あるいは，以前のように単に cv::Mat() を渡しても構いません）．

このクラスは，パラメータを渡すためだけに設計されています．つまり，通常は，クラスのメンバやローカル変数，グローバル変数をこの型で宣言してはいけません．

複数の型の配列を操作できる独自の関数やクラスメソッドを設計したい場合は，それぞれのパラメータに InputArray（または OutputArray）を利用します．関数内では _InputArray::getMat() メソッドを使用して、（データをコピーせずに）配列の行列ヘッダを作成する必要があります。_InputArray::kind() は、Mat と vector<> などを区別するために利用できますが、通常は必要ありません。



ここでは，InputArray : std::vector<Point2f> vec;// 点または円for( int i = 0; i < 30; i++ ) vec.push_back(Point2f((float)(100 + 30*cos(i*CV_PI*2/5)), (float)(100 - 30*sin(i*CV_PI*2/5))));cv::transform(vec, vec, cv::Matx23f(0.707, -0.707, 10, 0.707, 0.707, 20)); つまり，点を含む STL ベクトルを作成し，Matx<float, 2, 3> インスタンスとしてインラインで作成された 2x3 行列を用いて，そのベクトルにインプレースのアフィン変換を行います．

以下は，このような関数の実装方法です（簡単にするために，内部のアサーション文に従って，非常に特殊なケースを実装しています）： void myAffineTransform(InputArray _src, OutputArray _dst, InputArray _m){ // 入力配列に対する Mat ヘッダを取得します．これは， _src や _m が行列表現でない限り， // O(1) の処理です．    Mat src = _src.getMat(), m = _m.getMat(); CV_Assert( src.type() == CV_32FC2 && m.type() == CV_32F && m.size() == Size(3, 2) ); // 出力配列を適切なサイズと型になるように [再]作成します．    // Mat の場合は Mat::create を，STL vector の場合は vector::resize を呼び出します．    _dst.create(src.size(), src.type()); Mat dst = _dst.getMat(); for( int i = 0; i < src.rows; i++ ) for( int j = 0; j < src.cols; j++ ) { Point2f pt = src.at<Point2f>(i, j); dst.at<Point2f>(i, j) = Point2f(m.at<float>(0, 0)*pt.x + m.at<float>(0, 1)*pt.y + m.at<float>(0, 2), m.at<float>(1, 0)*pt.x + m.at<float>(1, 1)*pt.y + m.at<float>(1, 2)); }}。typedef InputArray InputArrayOfArrays; これは、ベクトルのベクトル、または行列のベクトルのいずれかである関数の引数を表します。Python/Javaなどのラッパーを適切に生成するためには、別のシノニムが必要です。関数の実装レベルでは、これらの使用方法は似ていますが、_InputArray::getMat(idx)は、外側のベクトルの idx 番目のコンポーネントのヘッダを取得するために使用し、_InputArray::size().area() は、外側のベクトルのコンポーネント（ベクトル/行列）の数を求めるために使用します。

一般に，サポートされる型は cv::Mat 型に限られます．それ以外の型は禁止されています．しかし，場合によっては， cv::KeyPoint や cv::DMatch などの配列のような，一般的ではないカスタムの Mat 型の受け渡しをサポートする必要があります．このデータは，画像データとして解釈されたり，通常の cv::Mat のように何らかの処理が行われたりすることはありません．このようなカスタムタイプを渡すには， rawIn() / rawOut() / rawInOut() ラッパーを利用してください．カスタムタイプは，Mat と互換性のある CV_8UC<N> 個の値（N = sizeof(T), N <= CV_CN_MAX）としてラッピングされます．

例：samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp．


元関数名(C#): core_InputArray_new_byMatExpr
元DLLエクスポート名: core_InputArray_new_byMatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_new_byMatExpr(cv::MatExpr *expr, cv::_InputArray **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::_InputArray(*expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_new_byScalar
[32bit] cv::_InputArray のインスタンスを生成します
%prm
p1,p2,p3
p1 = ARGS_SCALAR : Scalar val
p2 = var : out IntPtr handle
p3 = var : out IntPtr returnValue
%inst
これは，OpenCVの関数に読み取り専用の入力配列を渡すための，プロキシクラスです．

これは次のように定義されます： typedef const _InputArray& InputArray; ここで _InputArray は， Mat, Mat_<T>, Matx<T, m, n>, std::vector<T>, std::vector<std::vector<T> >, std::vector<Mat>, std::vector<Mat_<T> >, UMat, std::vector<UMat> または double から構成されるクラスです．また，行列式から構築することもできます．

これはほとんどが実装レベルのクラスであり，そのインターフェースは将来のバージョンで変更される可能性があるので，ここでは詳細な説明を省略します．しかし、いくつかの重要な点を覚えておく必要があります。



リファレンスマニュアルや OpenCV のソースコードで，InputArray を受け取る関数を見かけることがありますが，これは，実際に Mat, Matx, vector<T> などを渡すことができることを意味します（上記の完全なリストを参照してください）．(完全なリストは上を参照してください）．

オプションの入力引数．入力配列の一部が空の場合は， cv::noArray() を渡してください（あるいは，以前のように単に cv::Mat() を渡しても構いません）．

このクラスは，パラメータを渡すためだけに設計されています．つまり，通常は，クラスのメンバやローカル変数，グローバル変数をこの型で宣言してはいけません．

複数の型の配列を操作できる独自の関数やクラスメソッドを設計したい場合は，それぞれのパラメータに InputArray（または OutputArray）を利用します．関数内では _InputArray::getMat() メソッドを使用して、（データをコピーせずに）配列の行列ヘッダを作成する必要があります。_InputArray::kind() は、Mat と vector<> などを区別するために利用できますが、通常は必要ありません。



ここでは，InputArray : std::vector<Point2f> vec;// 点または円for( int i = 0; i < 30; i++ ) vec.push_back(Point2f((float)(100 + 30*cos(i*CV_PI*2/5)), (float)(100 - 30*sin(i*CV_PI*2/5))));cv::transform(vec, vec, cv::Matx23f(0.707, -0.707, 10, 0.707, 0.707, 20)); つまり，点を含む STL ベクトルを作成し，Matx<float, 2, 3> インスタンスとしてインラインで作成された 2x3 行列を用いて，そのベクトルにインプレースのアフィン変換を行います．

以下は，このような関数の実装方法です（簡単にするために，内部のアサーション文に従って，非常に特殊なケースを実装しています）： void myAffineTransform(InputArray _src, OutputArray _dst, InputArray _m){ // 入力配列に対する Mat ヘッダを取得します．これは， _src や _m が行列表現でない限り， // O(1) の処理です．    Mat src = _src.getMat(), m = _m.getMat(); CV_Assert( src.type() == CV_32FC2 && m.type() == CV_32F && m.size() == Size(3, 2) ); // 出力配列を適切なサイズと型になるように [再]作成します．    // Mat の場合は Mat::create を，STL vector の場合は vector::resize を呼び出します．    _dst.create(src.size(), src.type()); Mat dst = _dst.getMat(); for( int i = 0; i < src.rows; i++ ) for( int j = 0; j < src.cols; j++ ) { Point2f pt = src.at<Point2f>(i, j); dst.at<Point2f>(i, j) = Point2f(m.at<float>(0, 0)*pt.x + m.at<float>(0, 1)*pt.y + m.at<float>(0, 2), m.at<float>(1, 0)*pt.x + m.at<float>(1, 1)*pt.y + m.at<float>(1, 2)); }}。typedef InputArray InputArrayOfArrays; これは、ベクトルのベクトル、または行列のベクトルのいずれかである関数の引数を表します。Python/Javaなどのラッパーを適切に生成するためには、別のシノニムが必要です。関数の実装レベルでは、これらの使用方法は似ていますが、_InputArray::getMat(idx)は、外側のベクトルの idx 番目のコンポーネントのヘッダを取得するために使用し、_InputArray::size().area() は、外側のベクトルのコンポーネント（ベクトル/行列）の数を求めるために使用します。

一般に，サポートされる型は cv::Mat 型に限られます．それ以外の型は禁止されています．しかし，場合によっては， cv::KeyPoint や cv::DMatch などの配列のような，一般的ではないカスタムの Mat 型の受け渡しをサポートする必要があります．このデータは，画像データとして解釈されたり，通常の cv::Mat のように何らかの処理が行われたりすることはありません．このようなカスタムタイプを渡すには， rawIn() / rawOut() / rawInOut() ラッパーを利用してください．カスタムタイプは，Mat と互換性のある CV_8UC<N> 個の値（N = sizeof(T), N <= CV_CN_MAX）としてラッピングされます．

例：samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp．


元関数名(C#): core_InputArray_new_byScalar
元DLLエクスポート名: core_InputArray_new_byScalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_new_byScalar(MyCvScalar s, cv::Scalar **handle, cv::_InputArray **returnValue)
{
    BEGIN_WRAP
    *handle = new cv::Scalar(s.val[0], s.val[1], s.val[2], s.val[3]);
    *returnValue = new cv::_InputArray(**handle);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_new_byScalar
[64bit] cv::_InputArray のインスタンスを生成します
%prm
p1,p2,p3
p1 = var : Scalar val
p2 = var : out IntPtr handle
p3 = var : out IntPtr returnValue
%inst
これは，OpenCVの関数に読み取り専用の入力配列を渡すための，プロキシクラスです．

これは次のように定義されます： typedef const _InputArray& InputArray; ここで _InputArray は， Mat, Mat_<T>, Matx<T, m, n>, std::vector<T>, std::vector<std::vector<T> >, std::vector<Mat>, std::vector<Mat_<T> >, UMat, std::vector<UMat> または double から構成されるクラスです．また，行列式から構築することもできます．

これはほとんどが実装レベルのクラスであり，そのインターフェースは将来のバージョンで変更される可能性があるので，ここでは詳細な説明を省略します．しかし、いくつかの重要な点を覚えておく必要があります。



リファレンスマニュアルや OpenCV のソースコードで，InputArray を受け取る関数を見かけることがありますが，これは，実際に Mat, Matx, vector<T> などを渡すことができることを意味します（上記の完全なリストを参照してください）．(完全なリストは上を参照してください）．

オプションの入力引数．入力配列の一部が空の場合は， cv::noArray() を渡してください（あるいは，以前のように単に cv::Mat() を渡しても構いません）．

このクラスは，パラメータを渡すためだけに設計されています．つまり，通常は，クラスのメンバやローカル変数，グローバル変数をこの型で宣言してはいけません．

複数の型の配列を操作できる独自の関数やクラスメソッドを設計したい場合は，それぞれのパラメータに InputArray（または OutputArray）を利用します．関数内では _InputArray::getMat() メソッドを使用して、（データをコピーせずに）配列の行列ヘッダを作成する必要があります。_InputArray::kind() は、Mat と vector<> などを区別するために利用できますが、通常は必要ありません。



ここでは，InputArray : std::vector<Point2f> vec;// 点または円for( int i = 0; i < 30; i++ ) vec.push_back(Point2f((float)(100 + 30*cos(i*CV_PI*2/5)), (float)(100 - 30*sin(i*CV_PI*2/5))));cv::transform(vec, vec, cv::Matx23f(0.707, -0.707, 10, 0.707, 0.707, 20)); つまり，点を含む STL ベクトルを作成し，Matx<float, 2, 3> インスタンスとしてインラインで作成された 2x3 行列を用いて，そのベクトルにインプレースのアフィン変換を行います．

以下は，このような関数の実装方法です（簡単にするために，内部のアサーション文に従って，非常に特殊なケースを実装しています）： void myAffineTransform(InputArray _src, OutputArray _dst, InputArray _m){ // 入力配列に対する Mat ヘッダを取得します．これは， _src や _m が行列表現でない限り， // O(1) の処理です．    Mat src = _src.getMat(), m = _m.getMat(); CV_Assert( src.type() == CV_32FC2 && m.type() == CV_32F && m.size() == Size(3, 2) ); // 出力配列を適切なサイズと型になるように [再]作成します．    // Mat の場合は Mat::create を，STL vector の場合は vector::resize を呼び出します．    _dst.create(src.size(), src.type()); Mat dst = _dst.getMat(); for( int i = 0; i < src.rows; i++ ) for( int j = 0; j < src.cols; j++ ) { Point2f pt = src.at<Point2f>(i, j); dst.at<Point2f>(i, j) = Point2f(m.at<float>(0, 0)*pt.x + m.at<float>(0, 1)*pt.y + m.at<float>(0, 2), m.at<float>(1, 0)*pt.x + m.at<float>(1, 1)*pt.y + m.at<float>(1, 2)); }}。typedef InputArray InputArrayOfArrays; これは、ベクトルのベクトル、または行列のベクトルのいずれかである関数の引数を表します。Python/Javaなどのラッパーを適切に生成するためには、別のシノニムが必要です。関数の実装レベルでは、これらの使用方法は似ていますが、_InputArray::getMat(idx)は、外側のベクトルの idx 番目のコンポーネントのヘッダを取得するために使用し、_InputArray::size().area() は、外側のベクトルのコンポーネント（ベクトル/行列）の数を求めるために使用します。

一般に，サポートされる型は cv::Mat 型に限られます．それ以外の型は禁止されています．しかし，場合によっては， cv::KeyPoint や cv::DMatch などの配列のような，一般的ではないカスタムの Mat 型の受け渡しをサポートする必要があります．このデータは，画像データとして解釈されたり，通常の cv::Mat のように何らかの処理が行われたりすることはありません．このようなカスタムタイプを渡すには， rawIn() / rawOut() / rawInOut() ラッパーを利用してください．カスタムタイプは，Mat と互換性のある CV_8UC<N> 個の値（N = sizeof(T), N <= CV_CN_MAX）としてラッピングされます．

例：samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp．


元関数名(C#): core_InputArray_new_byScalar
元DLLエクスポート名: core_InputArray_new_byScalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_new_byScalar(MyCvScalar s, cv::Scalar **handle, cv::_InputArray **returnValue)
{
    BEGIN_WRAP
    *handle = new cv::Scalar(s.val[0], s.val[1], s.val[2], s.val[3]);
    *returnValue = new cv::_InputArray(**handle);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_new_byDouble
[32/64bit] cv::_InputArray のインスタンスを生成します
%prm
p1,p2
p1 = sptr : IntPtr valPointer
p2 = var : out IntPtr returnValue
%inst
これは，OpenCVの関数に読み取り専用の入力配列を渡すための，プロキシクラスです．

これは次のように定義されます： typedef const _InputArray& InputArray; ここで _InputArray は， Mat, Mat_<T>, Matx<T, m, n>, std::vector<T>, std::vector<std::vector<T> >, std::vector<Mat>, std::vector<Mat_<T> >, UMat, std::vector<UMat> または double から構成されるクラスです．また，行列式から構築することもできます．

これはほとんどが実装レベルのクラスであり，そのインターフェースは将来のバージョンで変更される可能性があるので，ここでは詳細な説明を省略します．しかし、いくつかの重要な点を覚えておく必要があります。



リファレンスマニュアルや OpenCV のソースコードで，InputArray を受け取る関数を見かけることがありますが，これは，実際に Mat, Matx, vector<T> などを渡すことができることを意味します（上記の完全なリストを参照してください）．(完全なリストは上を参照してください）．

オプションの入力引数．入力配列の一部が空の場合は， cv::noArray() を渡してください（あるいは，以前のように単に cv::Mat() を渡しても構いません）．

このクラスは，パラメータを渡すためだけに設計されています．つまり，通常は，クラスのメンバやローカル変数，グローバル変数をこの型で宣言してはいけません．

複数の型の配列を操作できる独自の関数やクラスメソッドを設計したい場合は，それぞれのパラメータに InputArray（または OutputArray）を利用します．関数内では _InputArray::getMat() メソッドを使用して、（データをコピーせずに）配列の行列ヘッダを作成する必要があります。_InputArray::kind() は、Mat と vector<> などを区別するために利用できますが、通常は必要ありません。



ここでは，InputArray : std::vector<Point2f> vec;// 点または円for( int i = 0; i < 30; i++ ) vec.push_back(Point2f((float)(100 + 30*cos(i*CV_PI*2/5)), (float)(100 - 30*sin(i*CV_PI*2/5))));cv::transform(vec, vec, cv::Matx23f(0.707, -0.707, 10, 0.707, 0.707, 20)); つまり，点を含む STL ベクトルを作成し，Matx<float, 2, 3> インスタンスとしてインラインで作成された 2x3 行列を用いて，そのベクトルにインプレースのアフィン変換を行います．

以下は，このような関数の実装方法です（簡単にするために，内部のアサーション文に従って，非常に特殊なケースを実装しています）： void myAffineTransform(InputArray _src, OutputArray _dst, InputArray _m){ // 入力配列に対する Mat ヘッダを取得します．これは， _src や _m が行列表現でない限り， // O(1) の処理です．    Mat src = _src.getMat(), m = _m.getMat(); CV_Assert( src.type() == CV_32FC2 && m.type() == CV_32F && m.size() == Size(3, 2) ); // 出力配列を適切なサイズと型になるように [再]作成します．    // Mat の場合は Mat::create を，STL vector の場合は vector::resize を呼び出します．    _dst.create(src.size(), src.type()); Mat dst = _dst.getMat(); for( int i = 0; i < src.rows; i++ ) for( int j = 0; j < src.cols; j++ ) { Point2f pt = src.at<Point2f>(i, j); dst.at<Point2f>(i, j) = Point2f(m.at<float>(0, 0)*pt.x + m.at<float>(0, 1)*pt.y + m.at<float>(0, 2), m.at<float>(1, 0)*pt.x + m.at<float>(1, 1)*pt.y + m.at<float>(1, 2)); }}。typedef InputArray InputArrayOfArrays; これは、ベクトルのベクトル、または行列のベクトルのいずれかである関数の引数を表します。Python/Javaなどのラッパーを適切に生成するためには、別のシノニムが必要です。関数の実装レベルでは、これらの使用方法は似ていますが、_InputArray::getMat(idx)は、外側のベクトルの idx 番目のコンポーネントのヘッダを取得するために使用し、_InputArray::size().area() は、外側のベクトルのコンポーネント（ベクトル/行列）の数を求めるために使用します。

一般に，サポートされる型は cv::Mat 型に限られます．それ以外の型は禁止されています．しかし，場合によっては， cv::KeyPoint や cv::DMatch などの配列のような，一般的ではないカスタムの Mat 型の受け渡しをサポートする必要があります．このデータは，画像データとして解釈されたり，通常の cv::Mat のように何らかの処理が行われたりすることはありません．このようなカスタムタイプを渡すには， rawIn() / rawOut() / rawInOut() ラッパーを利用してください．カスタムタイプは，Mat と互換性のある CV_8UC<N> 個の値（N = sizeof(T), N <= CV_CN_MAX）としてラッピングされます．

例：samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp．


元関数名(C#): core_InputArray_new_byDouble
元DLLエクスポート名: core_InputArray_new_byDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_new_byDouble(double *handle, cv::_InputArray **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::_InputArray(*handle);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_new_byVectorOfMat
[32/64bit] cv::_InputArray のインスタンスを生成します
%prm
p1,p2
p1 = sptr : IntPtr vector
p2 = var : out IntPtr returnValue
%inst
これは，OpenCVの関数に読み取り専用の入力配列を渡すための，プロキシクラスです．

これは次のように定義されます： typedef const _InputArray& InputArray; ここで _InputArray は， Mat, Mat_<T>, Matx<T, m, n>, std::vector<T>, std::vector<std::vector<T> >, std::vector<Mat>, std::vector<Mat_<T> >, UMat, std::vector<UMat> または double から構成されるクラスです．また，行列式から構築することもできます．

これはほとんどが実装レベルのクラスであり，そのインターフェースは将来のバージョンで変更される可能性があるので，ここでは詳細な説明を省略します．しかし、いくつかの重要な点を覚えておく必要があります。



リファレンスマニュアルや OpenCV のソースコードで，InputArray を受け取る関数を見かけることがありますが，これは，実際に Mat, Matx, vector<T> などを渡すことができることを意味します（上記の完全なリストを参照してください）．(完全なリストは上を参照してください）．

オプションの入力引数．入力配列の一部が空の場合は， cv::noArray() を渡してください（あるいは，以前のように単に cv::Mat() を渡しても構いません）．

このクラスは，パラメータを渡すためだけに設計されています．つまり，通常は，クラスのメンバやローカル変数，グローバル変数をこの型で宣言してはいけません．

複数の型の配列を操作できる独自の関数やクラスメソッドを設計したい場合は，それぞれのパラメータに InputArray（または OutputArray）を利用します．関数内では _InputArray::getMat() メソッドを使用して、（データをコピーせずに）配列の行列ヘッダを作成する必要があります。_InputArray::kind() は、Mat と vector<> などを区別するために利用できますが、通常は必要ありません。



ここでは，InputArray : std::vector<Point2f> vec;// 点または円for( int i = 0; i < 30; i++ ) vec.push_back(Point2f((float)(100 + 30*cos(i*CV_PI*2/5)), (float)(100 - 30*sin(i*CV_PI*2/5))));cv::transform(vec, vec, cv::Matx23f(0.707, -0.707, 10, 0.707, 0.707, 20)); つまり，点を含む STL ベクトルを作成し，Matx<float, 2, 3> インスタンスとしてインラインで作成された 2x3 行列を用いて，そのベクトルにインプレースのアフィン変換を行います．

以下は，このような関数の実装方法です（簡単にするために，内部のアサーション文に従って，非常に特殊なケースを実装しています）： void myAffineTransform(InputArray _src, OutputArray _dst, InputArray _m){ // 入力配列に対する Mat ヘッダを取得します．これは， _src や _m が行列表現でない限り， // O(1) の処理です．    Mat src = _src.getMat(), m = _m.getMat(); CV_Assert( src.type() == CV_32FC2 && m.type() == CV_32F && m.size() == Size(3, 2) ); // 出力配列を適切なサイズと型になるように [再]作成します．    // Mat の場合は Mat::create を，STL vector の場合は vector::resize を呼び出します．    _dst.create(src.size(), src.type()); Mat dst = _dst.getMat(); for( int i = 0; i < src.rows; i++ ) for( int j = 0; j < src.cols; j++ ) { Point2f pt = src.at<Point2f>(i, j); dst.at<Point2f>(i, j) = Point2f(m.at<float>(0, 0)*pt.x + m.at<float>(0, 1)*pt.y + m.at<float>(0, 2), m.at<float>(1, 0)*pt.x + m.at<float>(1, 1)*pt.y + m.at<float>(1, 2)); }}。typedef InputArray InputArrayOfArrays; これは、ベクトルのベクトル、または行列のベクトルのいずれかである関数の引数を表します。Python/Javaなどのラッパーを適切に生成するためには、別のシノニムが必要です。関数の実装レベルでは、これらの使用方法は似ていますが、_InputArray::getMat(idx)は、外側のベクトルの idx 番目のコンポーネントのヘッダを取得するために使用し、_InputArray::size().area() は、外側のベクトルのコンポーネント（ベクトル/行列）の数を求めるために使用します。

一般に，サポートされる型は cv::Mat 型に限られます．それ以外の型は禁止されています．しかし，場合によっては， cv::KeyPoint や cv::DMatch などの配列のような，一般的ではないカスタムの Mat 型の受け渡しをサポートする必要があります．このデータは，画像データとして解釈されたり，通常の cv::Mat のように何らかの処理が行われたりすることはありません．このようなカスタムタイプを渡すには， rawIn() / rawOut() / rawInOut() ラッパーを利用してください．カスタムタイプは，Mat と互換性のある CV_8UC<N> 個の値（N = sizeof(T), N <= CV_CN_MAX）としてラッピングされます．

例：samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp．


元関数名(C#): core_InputArray_new_byVectorOfMat
元DLLエクスポート名: core_InputArray_new_byVectorOfMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_new_byVectorOfMat(std::vector&amp;lt;cv::Mat&amp;gt; *vector, cv::_InputArray **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::_InputArray(*vector);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_new_byVecb
[32/64bit] cv::_InputArray のインスタンスを生成します
%prm
p1,p2,p3
p1 = sptr : IntPtr vec
p2 = int : int n
p3 = var : out IntPtr returnValue
%inst
これは，OpenCVの関数に読み取り専用の入力配列を渡すための，プロキシクラスです．

これは次のように定義されます： typedef const _InputArray& InputArray; ここで _InputArray は， Mat, Mat_<T>, Matx<T, m, n>, std::vector<T>, std::vector<std::vector<T> >, std::vector<Mat>, std::vector<Mat_<T> >, UMat, std::vector<UMat> または double から構成されるクラスです．また，行列式から構築することもできます．

これはほとんどが実装レベルのクラスであり，そのインターフェースは将来のバージョンで変更される可能性があるので，ここでは詳細な説明を省略します．しかし、いくつかの重要な点を覚えておく必要があります。



リファレンスマニュアルや OpenCV のソースコードで，InputArray を受け取る関数を見かけることがありますが，これは，実際に Mat, Matx, vector<T> などを渡すことができることを意味します（上記の完全なリストを参照してください）．(完全なリストは上を参照してください）．

オプションの入力引数．入力配列の一部が空の場合は， cv::noArray() を渡してください（あるいは，以前のように単に cv::Mat() を渡しても構いません）．

このクラスは，パラメータを渡すためだけに設計されています．つまり，通常は，クラスのメンバやローカル変数，グローバル変数をこの型で宣言してはいけません．

複数の型の配列を操作できる独自の関数やクラスメソッドを設計したい場合は，それぞれのパラメータに InputArray（または OutputArray）を利用します．関数内では _InputArray::getMat() メソッドを使用して、（データをコピーせずに）配列の行列ヘッダを作成する必要があります。_InputArray::kind() は、Mat と vector<> などを区別するために利用できますが、通常は必要ありません。



ここでは，InputArray : std::vector<Point2f> vec;// 点または円for( int i = 0; i < 30; i++ ) vec.push_back(Point2f((float)(100 + 30*cos(i*CV_PI*2/5)), (float)(100 - 30*sin(i*CV_PI*2/5))));cv::transform(vec, vec, cv::Matx23f(0.707, -0.707, 10, 0.707, 0.707, 20)); つまり，点を含む STL ベクトルを作成し，Matx<float, 2, 3> インスタンスとしてインラインで作成された 2x3 行列を用いて，そのベクトルにインプレースのアフィン変換を行います．

以下は，このような関数の実装方法です（簡単にするために，内部のアサーション文に従って，非常に特殊なケースを実装しています）： void myAffineTransform(InputArray _src, OutputArray _dst, InputArray _m){ // 入力配列に対する Mat ヘッダを取得します．これは， _src や _m が行列表現でない限り， // O(1) の処理です．    Mat src = _src.getMat(), m = _m.getMat(); CV_Assert( src.type() == CV_32FC2 && m.type() == CV_32F && m.size() == Size(3, 2) ); // 出力配列を適切なサイズと型になるように [再]作成します．    // Mat の場合は Mat::create を，STL vector の場合は vector::resize を呼び出します．    _dst.create(src.size(), src.type()); Mat dst = _dst.getMat(); for( int i = 0; i < src.rows; i++ ) for( int j = 0; j < src.cols; j++ ) { Point2f pt = src.at<Point2f>(i, j); dst.at<Point2f>(i, j) = Point2f(m.at<float>(0, 0)*pt.x + m.at<float>(0, 1)*pt.y + m.at<float>(0, 2), m.at<float>(1, 0)*pt.x + m.at<float>(1, 1)*pt.y + m.at<float>(1, 2)); }}。typedef InputArray InputArrayOfArrays; これは、ベクトルのベクトル、または行列のベクトルのいずれかである関数の引数を表します。Python/Javaなどのラッパーを適切に生成するためには、別のシノニムが必要です。関数の実装レベルでは、これらの使用方法は似ていますが、_InputArray::getMat(idx)は、外側のベクトルの idx 番目のコンポーネントのヘッダを取得するために使用し、_InputArray::size().area() は、外側のベクトルのコンポーネント（ベクトル/行列）の数を求めるために使用します。

一般に，サポートされる型は cv::Mat 型に限られます．それ以外の型は禁止されています．しかし，場合によっては， cv::KeyPoint や cv::DMatch などの配列のような，一般的ではないカスタムの Mat 型の受け渡しをサポートする必要があります．このデータは，画像データとして解釈されたり，通常の cv::Mat のように何らかの処理が行われたりすることはありません．このようなカスタムタイプを渡すには， rawIn() / rawOut() / rawInOut() ラッパーを利用してください．カスタムタイプは，Mat と互換性のある CV_8UC<N> 個の値（N = sizeof(T), N <= CV_CN_MAX）としてラッピングされます．

例：samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp．


元関数名(C#): core_InputArray_new_byVecb
元DLLエクスポート名: core_InputArray_new_byVecb
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_new_byVecb(uchar *vec, int n, cv::_InputArray **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::_InputArray(vec, n);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_new_byVecs
[32/64bit] cv::_InputArray のインスタンスを生成します
%prm
p1,p2,p3
p1 = sptr : IntPtr vec
p2 = int : int n
p3 = var : out IntPtr returnValue
%inst
これは，OpenCVの関数に読み取り専用の入力配列を渡すための，プロキシクラスです．

これは次のように定義されます： typedef const _InputArray& InputArray; ここで _InputArray は， Mat, Mat_<T>, Matx<T, m, n>, std::vector<T>, std::vector<std::vector<T> >, std::vector<Mat>, std::vector<Mat_<T> >, UMat, std::vector<UMat> または double から構成されるクラスです．また，行列式から構築することもできます．

これはほとんどが実装レベルのクラスであり，そのインターフェースは将来のバージョンで変更される可能性があるので，ここでは詳細な説明を省略します．しかし、いくつかの重要な点を覚えておく必要があります。



リファレンスマニュアルや OpenCV のソースコードで，InputArray を受け取る関数を見かけることがありますが，これは，実際に Mat, Matx, vector<T> などを渡すことができることを意味します（上記の完全なリストを参照してください）．(完全なリストは上を参照してください）．

オプションの入力引数．入力配列の一部が空の場合は， cv::noArray() を渡してください（あるいは，以前のように単に cv::Mat() を渡しても構いません）．

このクラスは，パラメータを渡すためだけに設計されています．つまり，通常は，クラスのメンバやローカル変数，グローバル変数をこの型で宣言してはいけません．

複数の型の配列を操作できる独自の関数やクラスメソッドを設計したい場合は，それぞれのパラメータに InputArray（または OutputArray）を利用します．関数内では _InputArray::getMat() メソッドを使用して、（データをコピーせずに）配列の行列ヘッダを作成する必要があります。_InputArray::kind() は、Mat と vector<> などを区別するために利用できますが、通常は必要ありません。



ここでは，InputArray : std::vector<Point2f> vec;// 点または円for( int i = 0; i < 30; i++ ) vec.push_back(Point2f((float)(100 + 30*cos(i*CV_PI*2/5)), (float)(100 - 30*sin(i*CV_PI*2/5))));cv::transform(vec, vec, cv::Matx23f(0.707, -0.707, 10, 0.707, 0.707, 20)); つまり，点を含む STL ベクトルを作成し，Matx<float, 2, 3> インスタンスとしてインラインで作成された 2x3 行列を用いて，そのベクトルにインプレースのアフィン変換を行います．

以下は，このような関数の実装方法です（簡単にするために，内部のアサーション文に従って，非常に特殊なケースを実装しています）： void myAffineTransform(InputArray _src, OutputArray _dst, InputArray _m){ // 入力配列に対する Mat ヘッダを取得します．これは， _src や _m が行列表現でない限り， // O(1) の処理です．    Mat src = _src.getMat(), m = _m.getMat(); CV_Assert( src.type() == CV_32FC2 && m.type() == CV_32F && m.size() == Size(3, 2) ); // 出力配列を適切なサイズと型になるように [再]作成します．    // Mat の場合は Mat::create を，STL vector の場合は vector::resize を呼び出します．    _dst.create(src.size(), src.type()); Mat dst = _dst.getMat(); for( int i = 0; i < src.rows; i++ ) for( int j = 0; j < src.cols; j++ ) { Point2f pt = src.at<Point2f>(i, j); dst.at<Point2f>(i, j) = Point2f(m.at<float>(0, 0)*pt.x + m.at<float>(0, 1)*pt.y + m.at<float>(0, 2), m.at<float>(1, 0)*pt.x + m.at<float>(1, 1)*pt.y + m.at<float>(1, 2)); }}。typedef InputArray InputArrayOfArrays; これは、ベクトルのベクトル、または行列のベクトルのいずれかである関数の引数を表します。Python/Javaなどのラッパーを適切に生成するためには、別のシノニムが必要です。関数の実装レベルでは、これらの使用方法は似ていますが、_InputArray::getMat(idx)は、外側のベクトルの idx 番目のコンポーネントのヘッダを取得するために使用し、_InputArray::size().area() は、外側のベクトルのコンポーネント（ベクトル/行列）の数を求めるために使用します。

一般に，サポートされる型は cv::Mat 型に限られます．それ以外の型は禁止されています．しかし，場合によっては， cv::KeyPoint や cv::DMatch などの配列のような，一般的ではないカスタムの Mat 型の受け渡しをサポートする必要があります．このデータは，画像データとして解釈されたり，通常の cv::Mat のように何らかの処理が行われたりすることはありません．このようなカスタムタイプを渡すには， rawIn() / rawOut() / rawInOut() ラッパーを利用してください．カスタムタイプは，Mat と互換性のある CV_8UC<N> 個の値（N = sizeof(T), N <= CV_CN_MAX）としてラッピングされます．

例：samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp．


元関数名(C#): core_InputArray_new_byVecs
元DLLエクスポート名: core_InputArray_new_byVecs
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_new_byVecs(short *vec, int n, cv::_InputArray **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::_InputArray(vec, n);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_new_byVecw
[32/64bit] cv::_InputArray のインスタンスを生成します
%prm
p1,p2,p3
p1 = sptr : IntPtr vec
p2 = int : int n
p3 = var : out IntPtr returnValue
%inst
これは，OpenCVの関数に読み取り専用の入力配列を渡すための，プロキシクラスです．

これは次のように定義されます： typedef const _InputArray& InputArray; ここで _InputArray は， Mat, Mat_<T>, Matx<T, m, n>, std::vector<T>, std::vector<std::vector<T> >, std::vector<Mat>, std::vector<Mat_<T> >, UMat, std::vector<UMat> または double から構成されるクラスです．また，行列式から構築することもできます．

これはほとんどが実装レベルのクラスであり，そのインターフェースは将来のバージョンで変更される可能性があるので，ここでは詳細な説明を省略します．しかし、いくつかの重要な点を覚えておく必要があります。



リファレンスマニュアルや OpenCV のソースコードで，InputArray を受け取る関数を見かけることがありますが，これは，実際に Mat, Matx, vector<T> などを渡すことができることを意味します（上記の完全なリストを参照してください）．(完全なリストは上を参照してください）．

オプションの入力引数．入力配列の一部が空の場合は， cv::noArray() を渡してください（あるいは，以前のように単に cv::Mat() を渡しても構いません）．

このクラスは，パラメータを渡すためだけに設計されています．つまり，通常は，クラスのメンバやローカル変数，グローバル変数をこの型で宣言してはいけません．

複数の型の配列を操作できる独自の関数やクラスメソッドを設計したい場合は，それぞれのパラメータに InputArray（または OutputArray）を利用します．関数内では _InputArray::getMat() メソッドを使用して、（データをコピーせずに）配列の行列ヘッダを作成する必要があります。_InputArray::kind() は、Mat と vector<> などを区別するために利用できますが、通常は必要ありません。



ここでは，InputArray : std::vector<Point2f> vec;// 点または円for( int i = 0; i < 30; i++ ) vec.push_back(Point2f((float)(100 + 30*cos(i*CV_PI*2/5)), (float)(100 - 30*sin(i*CV_PI*2/5))));cv::transform(vec, vec, cv::Matx23f(0.707, -0.707, 10, 0.707, 0.707, 20)); つまり，点を含む STL ベクトルを作成し，Matx<float, 2, 3> インスタンスとしてインラインで作成された 2x3 行列を用いて，そのベクトルにインプレースのアフィン変換を行います．

以下は，このような関数の実装方法です（簡単にするために，内部のアサーション文に従って，非常に特殊なケースを実装しています）： void myAffineTransform(InputArray _src, OutputArray _dst, InputArray _m){ // 入力配列に対する Mat ヘッダを取得します．これは， _src や _m が行列表現でない限り， // O(1) の処理です．    Mat src = _src.getMat(), m = _m.getMat(); CV_Assert( src.type() == CV_32FC2 && m.type() == CV_32F && m.size() == Size(3, 2) ); // 出力配列を適切なサイズと型になるように [再]作成します．    // Mat の場合は Mat::create を，STL vector の場合は vector::resize を呼び出します．    _dst.create(src.size(), src.type()); Mat dst = _dst.getMat(); for( int i = 0; i < src.rows; i++ ) for( int j = 0; j < src.cols; j++ ) { Point2f pt = src.at<Point2f>(i, j); dst.at<Point2f>(i, j) = Point2f(m.at<float>(0, 0)*pt.x + m.at<float>(0, 1)*pt.y + m.at<float>(0, 2), m.at<float>(1, 0)*pt.x + m.at<float>(1, 1)*pt.y + m.at<float>(1, 2)); }}。typedef InputArray InputArrayOfArrays; これは、ベクトルのベクトル、または行列のベクトルのいずれかである関数の引数を表します。Python/Javaなどのラッパーを適切に生成するためには、別のシノニムが必要です。関数の実装レベルでは、これらの使用方法は似ていますが、_InputArray::getMat(idx)は、外側のベクトルの idx 番目のコンポーネントのヘッダを取得するために使用し、_InputArray::size().area() は、外側のベクトルのコンポーネント（ベクトル/行列）の数を求めるために使用します。

一般に，サポートされる型は cv::Mat 型に限られます．それ以外の型は禁止されています．しかし，場合によっては， cv::KeyPoint や cv::DMatch などの配列のような，一般的ではないカスタムの Mat 型の受け渡しをサポートする必要があります．このデータは，画像データとして解釈されたり，通常の cv::Mat のように何らかの処理が行われたりすることはありません．このようなカスタムタイプを渡すには， rawIn() / rawOut() / rawInOut() ラッパーを利用してください．カスタムタイプは，Mat と互換性のある CV_8UC<N> 個の値（N = sizeof(T), N <= CV_CN_MAX）としてラッピングされます．

例：samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp．


元関数名(C#): core_InputArray_new_byVecw
元DLLエクスポート名: core_InputArray_new_byVecw
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_new_byVecw(ushort *vec, int n, cv::_InputArray **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::_InputArray(vec, n);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_new_byVeci
[32/64bit] cv::_InputArray のインスタンスを生成します
%prm
p1,p2,p3
p1 = sptr : IntPtr vec
p2 = int : int n
p3 = var : out IntPtr returnValue
%inst
これは，OpenCVの関数に読み取り専用の入力配列を渡すための，プロキシクラスです．

これは次のように定義されます： typedef const _InputArray& InputArray; ここで _InputArray は， Mat, Mat_<T>, Matx<T, m, n>, std::vector<T>, std::vector<std::vector<T> >, std::vector<Mat>, std::vector<Mat_<T> >, UMat, std::vector<UMat> または double から構成されるクラスです．また，行列式から構築することもできます．

これはほとんどが実装レベルのクラスであり，そのインターフェースは将来のバージョンで変更される可能性があるので，ここでは詳細な説明を省略します．しかし、いくつかの重要な点を覚えておく必要があります。



リファレンスマニュアルや OpenCV のソースコードで，InputArray を受け取る関数を見かけることがありますが，これは，実際に Mat, Matx, vector<T> などを渡すことができることを意味します（上記の完全なリストを参照してください）．(完全なリストは上を参照してください）．

オプションの入力引数．入力配列の一部が空の場合は， cv::noArray() を渡してください（あるいは，以前のように単に cv::Mat() を渡しても構いません）．

このクラスは，パラメータを渡すためだけに設計されています．つまり，通常は，クラスのメンバやローカル変数，グローバル変数をこの型で宣言してはいけません．

複数の型の配列を操作できる独自の関数やクラスメソッドを設計したい場合は，それぞれのパラメータに InputArray（または OutputArray）を利用します．関数内では _InputArray::getMat() メソッドを使用して、（データをコピーせずに）配列の行列ヘッダを作成する必要があります。_InputArray::kind() は、Mat と vector<> などを区別するために利用できますが、通常は必要ありません。



ここでは，InputArray : std::vector<Point2f> vec;// 点または円for( int i = 0; i < 30; i++ ) vec.push_back(Point2f((float)(100 + 30*cos(i*CV_PI*2/5)), (float)(100 - 30*sin(i*CV_PI*2/5))));cv::transform(vec, vec, cv::Matx23f(0.707, -0.707, 10, 0.707, 0.707, 20)); つまり，点を含む STL ベクトルを作成し，Matx<float, 2, 3> インスタンスとしてインラインで作成された 2x3 行列を用いて，そのベクトルにインプレースのアフィン変換を行います．

以下は，このような関数の実装方法です（簡単にするために，内部のアサーション文に従って，非常に特殊なケースを実装しています）： void myAffineTransform(InputArray _src, OutputArray _dst, InputArray _m){ // 入力配列に対する Mat ヘッダを取得します．これは， _src や _m が行列表現でない限り， // O(1) の処理です．    Mat src = _src.getMat(), m = _m.getMat(); CV_Assert( src.type() == CV_32FC2 && m.type() == CV_32F && m.size() == Size(3, 2) ); // 出力配列を適切なサイズと型になるように [再]作成します．    // Mat の場合は Mat::create を，STL vector の場合は vector::resize を呼び出します．    _dst.create(src.size(), src.type()); Mat dst = _dst.getMat(); for( int i = 0; i < src.rows; i++ ) for( int j = 0; j < src.cols; j++ ) { Point2f pt = src.at<Point2f>(i, j); dst.at<Point2f>(i, j) = Point2f(m.at<float>(0, 0)*pt.x + m.at<float>(0, 1)*pt.y + m.at<float>(0, 2), m.at<float>(1, 0)*pt.x + m.at<float>(1, 1)*pt.y + m.at<float>(1, 2)); }}。typedef InputArray InputArrayOfArrays; これは、ベクトルのベクトル、または行列のベクトルのいずれかである関数の引数を表します。Python/Javaなどのラッパーを適切に生成するためには、別のシノニムが必要です。関数の実装レベルでは、これらの使用方法は似ていますが、_InputArray::getMat(idx)は、外側のベクトルの idx 番目のコンポーネントのヘッダを取得するために使用し、_InputArray::size().area() は、外側のベクトルのコンポーネント（ベクトル/行列）の数を求めるために使用します。

一般に，サポートされる型は cv::Mat 型に限られます．それ以外の型は禁止されています．しかし，場合によっては， cv::KeyPoint や cv::DMatch などの配列のような，一般的ではないカスタムの Mat 型の受け渡しをサポートする必要があります．このデータは，画像データとして解釈されたり，通常の cv::Mat のように何らかの処理が行われたりすることはありません．このようなカスタムタイプを渡すには， rawIn() / rawOut() / rawInOut() ラッパーを利用してください．カスタムタイプは，Mat と互換性のある CV_8UC<N> 個の値（N = sizeof(T), N <= CV_CN_MAX）としてラッピングされます．

例：samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp．


元関数名(C#): core_InputArray_new_byVeci
元DLLエクスポート名: core_InputArray_new_byVeci
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_new_byVeci(int *vec, int n, cv::_InputArray **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::_InputArray(vec, n);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_new_byVecf
[32/64bit] cv::_InputArray のインスタンスを生成します
%prm
p1,p2,p3
p1 = sptr : IntPtr vec
p2 = int : int n
p3 = var : out IntPtr returnValue
%inst
これは，OpenCVの関数に読み取り専用の入力配列を渡すための，プロキシクラスです．

これは次のように定義されます： typedef const _InputArray& InputArray; ここで _InputArray は， Mat, Mat_<T>, Matx<T, m, n>, std::vector<T>, std::vector<std::vector<T> >, std::vector<Mat>, std::vector<Mat_<T> >, UMat, std::vector<UMat> または double から構成されるクラスです．また，行列式から構築することもできます．

これはほとんどが実装レベルのクラスであり，そのインターフェースは将来のバージョンで変更される可能性があるので，ここでは詳細な説明を省略します．しかし、いくつかの重要な点を覚えておく必要があります。



リファレンスマニュアルや OpenCV のソースコードで，InputArray を受け取る関数を見かけることがありますが，これは，実際に Mat, Matx, vector<T> などを渡すことができることを意味します（上記の完全なリストを参照してください）．(完全なリストは上を参照してください）．

オプションの入力引数．入力配列の一部が空の場合は， cv::noArray() を渡してください（あるいは，以前のように単に cv::Mat() を渡しても構いません）．

このクラスは，パラメータを渡すためだけに設計されています．つまり，通常は，クラスのメンバやローカル変数，グローバル変数をこの型で宣言してはいけません．

複数の型の配列を操作できる独自の関数やクラスメソッドを設計したい場合は，それぞれのパラメータに InputArray（または OutputArray）を利用します．関数内では _InputArray::getMat() メソッドを使用して、（データをコピーせずに）配列の行列ヘッダを作成する必要があります。_InputArray::kind() は、Mat と vector<> などを区別するために利用できますが、通常は必要ありません。



ここでは，InputArray : std::vector<Point2f> vec;// 点または円for( int i = 0; i < 30; i++ ) vec.push_back(Point2f((float)(100 + 30*cos(i*CV_PI*2/5)), (float)(100 - 30*sin(i*CV_PI*2/5))));cv::transform(vec, vec, cv::Matx23f(0.707, -0.707, 10, 0.707, 0.707, 20)); つまり，点を含む STL ベクトルを作成し，Matx<float, 2, 3> インスタンスとしてインラインで作成された 2x3 行列を用いて，そのベクトルにインプレースのアフィン変換を行います．

以下は，このような関数の実装方法です（簡単にするために，内部のアサーション文に従って，非常に特殊なケースを実装しています）： void myAffineTransform(InputArray _src, OutputArray _dst, InputArray _m){ // 入力配列に対する Mat ヘッダを取得します．これは， _src や _m が行列表現でない限り， // O(1) の処理です．    Mat src = _src.getMat(), m = _m.getMat(); CV_Assert( src.type() == CV_32FC2 && m.type() == CV_32F && m.size() == Size(3, 2) ); // 出力配列を適切なサイズと型になるように [再]作成します．    // Mat の場合は Mat::create を，STL vector の場合は vector::resize を呼び出します．    _dst.create(src.size(), src.type()); Mat dst = _dst.getMat(); for( int i = 0; i < src.rows; i++ ) for( int j = 0; j < src.cols; j++ ) { Point2f pt = src.at<Point2f>(i, j); dst.at<Point2f>(i, j) = Point2f(m.at<float>(0, 0)*pt.x + m.at<float>(0, 1)*pt.y + m.at<float>(0, 2), m.at<float>(1, 0)*pt.x + m.at<float>(1, 1)*pt.y + m.at<float>(1, 2)); }}。typedef InputArray InputArrayOfArrays; これは、ベクトルのベクトル、または行列のベクトルのいずれかである関数の引数を表します。Python/Javaなどのラッパーを適切に生成するためには、別のシノニムが必要です。関数の実装レベルでは、これらの使用方法は似ていますが、_InputArray::getMat(idx)は、外側のベクトルの idx 番目のコンポーネントのヘッダを取得するために使用し、_InputArray::size().area() は、外側のベクトルのコンポーネント（ベクトル/行列）の数を求めるために使用します。

一般に，サポートされる型は cv::Mat 型に限られます．それ以外の型は禁止されています．しかし，場合によっては， cv::KeyPoint や cv::DMatch などの配列のような，一般的ではないカスタムの Mat 型の受け渡しをサポートする必要があります．このデータは，画像データとして解釈されたり，通常の cv::Mat のように何らかの処理が行われたりすることはありません．このようなカスタムタイプを渡すには， rawIn() / rawOut() / rawInOut() ラッパーを利用してください．カスタムタイプは，Mat と互換性のある CV_8UC<N> 個の値（N = sizeof(T), N <= CV_CN_MAX）としてラッピングされます．

例：samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp．


元関数名(C#): core_InputArray_new_byVecf
元DLLエクスポート名: core_InputArray_new_byVecf
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_new_byVecf(float *vec, int n, cv::_InputArray **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::_InputArray(vec, n);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_new_byVecd
[32/64bit] cv::_InputArray のインスタンスを生成します
%prm
p1,p2,p3
p1 = sptr : IntPtr vec
p2 = int : int n
p3 = var : out IntPtr returnValue
%inst
これは，OpenCVの関数に読み取り専用の入力配列を渡すための，プロキシクラスです．

これは次のように定義されます： typedef const _InputArray& InputArray; ここで _InputArray は， Mat, Mat_<T>, Matx<T, m, n>, std::vector<T>, std::vector<std::vector<T> >, std::vector<Mat>, std::vector<Mat_<T> >, UMat, std::vector<UMat> または double から構成されるクラスです．また，行列式から構築することもできます．

これはほとんどが実装レベルのクラスであり，そのインターフェースは将来のバージョンで変更される可能性があるので，ここでは詳細な説明を省略します．しかし、いくつかの重要な点を覚えておく必要があります。



リファレンスマニュアルや OpenCV のソースコードで，InputArray を受け取る関数を見かけることがありますが，これは，実際に Mat, Matx, vector<T> などを渡すことができることを意味します（上記の完全なリストを参照してください）．(完全なリストは上を参照してください）．

オプションの入力引数．入力配列の一部が空の場合は， cv::noArray() を渡してください（あるいは，以前のように単に cv::Mat() を渡しても構いません）．

このクラスは，パラメータを渡すためだけに設計されています．つまり，通常は，クラスのメンバやローカル変数，グローバル変数をこの型で宣言してはいけません．

複数の型の配列を操作できる独自の関数やクラスメソッドを設計したい場合は，それぞれのパラメータに InputArray（または OutputArray）を利用します．関数内では _InputArray::getMat() メソッドを使用して、（データをコピーせずに）配列の行列ヘッダを作成する必要があります。_InputArray::kind() は、Mat と vector<> などを区別するために利用できますが、通常は必要ありません。



ここでは，InputArray : std::vector<Point2f> vec;// 点または円for( int i = 0; i < 30; i++ ) vec.push_back(Point2f((float)(100 + 30*cos(i*CV_PI*2/5)), (float)(100 - 30*sin(i*CV_PI*2/5))));cv::transform(vec, vec, cv::Matx23f(0.707, -0.707, 10, 0.707, 0.707, 20)); つまり，点を含む STL ベクトルを作成し，Matx<float, 2, 3> インスタンスとしてインラインで作成された 2x3 行列を用いて，そのベクトルにインプレースのアフィン変換を行います．

以下は，このような関数の実装方法です（簡単にするために，内部のアサーション文に従って，非常に特殊なケースを実装しています）： void myAffineTransform(InputArray _src, OutputArray _dst, InputArray _m){ // 入力配列に対する Mat ヘッダを取得します．これは， _src や _m が行列表現でない限り， // O(1) の処理です．    Mat src = _src.getMat(), m = _m.getMat(); CV_Assert( src.type() == CV_32FC2 && m.type() == CV_32F && m.size() == Size(3, 2) ); // 出力配列を適切なサイズと型になるように [再]作成します．    // Mat の場合は Mat::create を，STL vector の場合は vector::resize を呼び出します．    _dst.create(src.size(), src.type()); Mat dst = _dst.getMat(); for( int i = 0; i < src.rows; i++ ) for( int j = 0; j < src.cols; j++ ) { Point2f pt = src.at<Point2f>(i, j); dst.at<Point2f>(i, j) = Point2f(m.at<float>(0, 0)*pt.x + m.at<float>(0, 1)*pt.y + m.at<float>(0, 2), m.at<float>(1, 0)*pt.x + m.at<float>(1, 1)*pt.y + m.at<float>(1, 2)); }}。typedef InputArray InputArrayOfArrays; これは、ベクトルのベクトル、または行列のベクトルのいずれかである関数の引数を表します。Python/Javaなどのラッパーを適切に生成するためには、別のシノニムが必要です。関数の実装レベルでは、これらの使用方法は似ていますが、_InputArray::getMat(idx)は、外側のベクトルの idx 番目のコンポーネントのヘッダを取得するために使用し、_InputArray::size().area() は、外側のベクトルのコンポーネント（ベクトル/行列）の数を求めるために使用します。

一般に，サポートされる型は cv::Mat 型に限られます．それ以外の型は禁止されています．しかし，場合によっては， cv::KeyPoint や cv::DMatch などの配列のような，一般的ではないカスタムの Mat 型の受け渡しをサポートする必要があります．このデータは，画像データとして解釈されたり，通常の cv::Mat のように何らかの処理が行われたりすることはありません．このようなカスタムタイプを渡すには， rawIn() / rawOut() / rawInOut() ラッパーを利用してください．カスタムタイプは，Mat と互換性のある CV_8UC<N> 個の値（N = sizeof(T), N <= CV_CN_MAX）としてラッピングされます．

例：samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp．


元関数名(C#): core_InputArray_new_byVecd
元DLLエクスポート名: core_InputArray_new_byVecd
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_new_byVecd(double *vec, int n, cv::_InputArray **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::_InputArray(vec, n);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_delete
[32/64bit] cv::_InputArray のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ia
%inst
これは，OpenCVの関数に読み取り専用の入力配列を渡すための，プロキシクラスです．

これは次のように定義されます： typedef const _InputArray& InputArray; ここで _InputArray は， Mat, Mat_<T>, Matx<T, m, n>, std::vector<T>, std::vector<std::vector<T> >, std::vector<Mat>, std::vector<Mat_<T> >, UMat, std::vector<UMat> または double から構成されるクラスです．また，行列式から構築することもできます．

これはほとんどが実装レベルのクラスであり，そのインターフェースは将来のバージョンで変更される可能性があるので，ここでは詳細な説明を省略します．しかし、いくつかの重要な点を覚えておく必要があります。



リファレンスマニュアルや OpenCV のソースコードで，InputArray を受け取る関数を見かけることがありますが，これは，実際に Mat, Matx, vector<T> などを渡すことができることを意味します（上記の完全なリストを参照してください）．(完全なリストは上を参照してください）．

オプションの入力引数．入力配列の一部が空の場合は， cv::noArray() を渡してください（あるいは，以前のように単に cv::Mat() を渡しても構いません）．

このクラスは，パラメータを渡すためだけに設計されています．つまり，通常は，クラスのメンバやローカル変数，グローバル変数をこの型で宣言してはいけません．

複数の型の配列を操作できる独自の関数やクラスメソッドを設計したい場合は，それぞれのパラメータに InputArray（または OutputArray）を利用します．関数内では _InputArray::getMat() メソッドを使用して、（データをコピーせずに）配列の行列ヘッダを作成する必要があります。_InputArray::kind() は、Mat と vector<> などを区別するために利用できますが、通常は必要ありません。



ここでは，InputArray : std::vector<Point2f> vec;// 点または円for( int i = 0; i < 30; i++ ) vec.push_back(Point2f((float)(100 + 30*cos(i*CV_PI*2/5)), (float)(100 - 30*sin(i*CV_PI*2/5))));cv::transform(vec, vec, cv::Matx23f(0.707, -0.707, 10, 0.707, 0.707, 20)); つまり，点を含む STL ベクトルを作成し，Matx<float, 2, 3> インスタンスとしてインラインで作成された 2x3 行列を用いて，そのベクトルにインプレースのアフィン変換を行います．

以下は，このような関数の実装方法です（簡単にするために，内部のアサーション文に従って，非常に特殊なケースを実装しています）： void myAffineTransform(InputArray _src, OutputArray _dst, InputArray _m){ // 入力配列に対する Mat ヘッダを取得します．これは， _src や _m が行列表現でない限り， // O(1) の処理です．    Mat src = _src.getMat(), m = _m.getMat(); CV_Assert( src.type() == CV_32FC2 && m.type() == CV_32F && m.size() == Size(3, 2) ); // 出力配列を適切なサイズと型になるように [再]作成します．    // Mat の場合は Mat::create を，STL vector の場合は vector::resize を呼び出します．    _dst.create(src.size(), src.type()); Mat dst = _dst.getMat(); for( int i = 0; i < src.rows; i++ ) for( int j = 0; j < src.cols; j++ ) { Point2f pt = src.at<Point2f>(i, j); dst.at<Point2f>(i, j) = Point2f(m.at<float>(0, 0)*pt.x + m.at<float>(0, 1)*pt.y + m.at<float>(0, 2), m.at<float>(1, 0)*pt.x + m.at<float>(1, 1)*pt.y + m.at<float>(1, 2)); }}。typedef InputArray InputArrayOfArrays; これは、ベクトルのベクトル、または行列のベクトルのいずれかである関数の引数を表します。Python/Javaなどのラッパーを適切に生成するためには、別のシノニムが必要です。関数の実装レベルでは、これらの使用方法は似ていますが、_InputArray::getMat(idx)は、外側のベクトルの idx 番目のコンポーネントのヘッダを取得するために使用し、_InputArray::size().area() は、外側のベクトルのコンポーネント（ベクトル/行列）の数を求めるために使用します。

一般に，サポートされる型は cv::Mat 型に限られます．それ以外の型は禁止されています．しかし，場合によっては， cv::KeyPoint や cv::DMatch などの配列のような，一般的ではないカスタムの Mat 型の受け渡しをサポートする必要があります．このデータは，画像データとして解釈されたり，通常の cv::Mat のように何らかの処理が行われたりすることはありません．このようなカスタムタイプを渡すには， rawIn() / rawOut() / rawInOut() ラッパーを利用してください．カスタムタイプは，Mat と互換性のある CV_8UC<N> 個の値（N = sizeof(T), N <= CV_CN_MAX）としてラッピングされます．

例：samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp．


元関数名(C#): core_InputArray_delete
元DLLエクスポート名: core_InputArray_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_delete(cv::_InputArray *ia)
{
    BEGIN_WRAP
    delete ia;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_delete_withScalar
[32/64bit] cv::_InputArray のインスタンスを破棄します
%prm
p1,p2
p1 = sptr : IntPtr ia
p2 = sptr : IntPtr handle
%inst
これは，OpenCVの関数に読み取り専用の入力配列を渡すための，プロキシクラスです．

これは次のように定義されます： typedef const _InputArray& InputArray; ここで _InputArray は， Mat, Mat_<T>, Matx<T, m, n>, std::vector<T>, std::vector<std::vector<T> >, std::vector<Mat>, std::vector<Mat_<T> >, UMat, std::vector<UMat> または double から構成されるクラスです．また，行列式から構築することもできます．

これはほとんどが実装レベルのクラスであり，そのインターフェースは将来のバージョンで変更される可能性があるので，ここでは詳細な説明を省略します．しかし、いくつかの重要な点を覚えておく必要があります。



リファレンスマニュアルや OpenCV のソースコードで，InputArray を受け取る関数を見かけることがありますが，これは，実際に Mat, Matx, vector<T> などを渡すことができることを意味します（上記の完全なリストを参照してください）．(完全なリストは上を参照してください）．

オプションの入力引数．入力配列の一部が空の場合は， cv::noArray() を渡してください（あるいは，以前のように単に cv::Mat() を渡しても構いません）．

このクラスは，パラメータを渡すためだけに設計されています．つまり，通常は，クラスのメンバやローカル変数，グローバル変数をこの型で宣言してはいけません．

複数の型の配列を操作できる独自の関数やクラスメソッドを設計したい場合は，それぞれのパラメータに InputArray（または OutputArray）を利用します．関数内では _InputArray::getMat() メソッドを使用して、（データをコピーせずに）配列の行列ヘッダを作成する必要があります。_InputArray::kind() は、Mat と vector<> などを区別するために利用できますが、通常は必要ありません。



ここでは，InputArray : std::vector<Point2f> vec;// 点または円for( int i = 0; i < 30; i++ ) vec.push_back(Point2f((float)(100 + 30*cos(i*CV_PI*2/5)), (float)(100 - 30*sin(i*CV_PI*2/5))));cv::transform(vec, vec, cv::Matx23f(0.707, -0.707, 10, 0.707, 0.707, 20)); つまり，点を含む STL ベクトルを作成し，Matx<float, 2, 3> インスタンスとしてインラインで作成された 2x3 行列を用いて，そのベクトルにインプレースのアフィン変換を行います．

以下は，このような関数の実装方法です（簡単にするために，内部のアサーション文に従って，非常に特殊なケースを実装しています）： void myAffineTransform(InputArray _src, OutputArray _dst, InputArray _m){ // 入力配列に対する Mat ヘッダを取得します．これは， _src や _m が行列表現でない限り， // O(1) の処理です．    Mat src = _src.getMat(), m = _m.getMat(); CV_Assert( src.type() == CV_32FC2 && m.type() == CV_32F && m.size() == Size(3, 2) ); // 出力配列を適切なサイズと型になるように [再]作成します．    // Mat の場合は Mat::create を，STL vector の場合は vector::resize を呼び出します．    _dst.create(src.size(), src.type()); Mat dst = _dst.getMat(); for( int i = 0; i < src.rows; i++ ) for( int j = 0; j < src.cols; j++ ) { Point2f pt = src.at<Point2f>(i, j); dst.at<Point2f>(i, j) = Point2f(m.at<float>(0, 0)*pt.x + m.at<float>(0, 1)*pt.y + m.at<float>(0, 2), m.at<float>(1, 0)*pt.x + m.at<float>(1, 1)*pt.y + m.at<float>(1, 2)); }}。typedef InputArray InputArrayOfArrays; これは、ベクトルのベクトル、または行列のベクトルのいずれかである関数の引数を表します。Python/Javaなどのラッパーを適切に生成するためには、別のシノニムが必要です。関数の実装レベルでは、これらの使用方法は似ていますが、_InputArray::getMat(idx)は、外側のベクトルの idx 番目のコンポーネントのヘッダを取得するために使用し、_InputArray::size().area() は、外側のベクトルのコンポーネント（ベクトル/行列）の数を求めるために使用します。

一般に，サポートされる型は cv::Mat 型に限られます．それ以外の型は禁止されています．しかし，場合によっては， cv::KeyPoint や cv::DMatch などの配列のような，一般的ではないカスタムの Mat 型の受け渡しをサポートする必要があります．このデータは，画像データとして解釈されたり，通常の cv::Mat のように何らかの処理が行われたりすることはありません．このようなカスタムタイプを渡すには， rawIn() / rawOut() / rawInOut() ラッパーを利用してください．カスタムタイプは，Mat と互換性のある CV_8UC<N> 個の値（N = sizeof(T), N <= CV_CN_MAX）としてラッピングされます．

例：samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp．


元関数名(C#): core_InputArray_delete_withScalar
元DLLエクスポート名: core_InputArray_delete_withScalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_delete_withScalar(cv::_InputArray *ia, cv::Scalar *handle)
{
    BEGIN_WRAP
    delete ia;
    delete handle;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_getMat
[32/64bit] 例：samples/cpp/pca.cpp．
%prm
p1,p2,p3
p1 = sptr : IntPtr ia
p2 = int : int idx
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_InputArray_getMat
元DLLエクスポート名: core_InputArray_getMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_getMat(cv::_InputArray *ia, int idx, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(ia-&amp;gt;getMat(idx));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_getUMat
[32/64bit] core_InputArray_getUMat
%prm
p1,p2,p3
p1 = sptr : IntPtr ia
p2 = int : int idx
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_InputArray_getUMat
元DLLエクスポート名: core_InputArray_getUMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_getUMat(cv::_InputArray* ia, int idx, cv::UMat** returnValue)
{
    BEGIN_WRAP
    * returnValue = new cv::UMat(ia-&amp;gt;getUMat(idx));
    END_WRAP
    
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_getMatVector
[32/64bit] core_InputArray_getMatVector
%prm
p1,p2
p1 = sptr : IntPtr ia
p2 = sptr : IntPtr mv
%inst
元関数名(C#): core_InputArray_getMatVector
元DLLエクスポート名: core_InputArray_getMatVector
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_getMatVector(cv::_InputArray *ia, std::vector&amp;lt;cv::Mat&amp;gt; *mv)
{
    BEGIN_WRAP
    ia-&amp;gt;getMatVector(*mv);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_getFlags
[32/64bit] core_InputArray_getFlags
%prm
p1,p2
p1 = sptr : IntPtr ia
p2 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_getFlags
元DLLエクスポート名: core_InputArray_getFlags
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_getFlags(cv::_InputArray *ia, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;getFlags();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_getObj
[32/64bit] core_InputArray_getObj
%prm
p1,p2
p1 = sptr : IntPtr ia
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_InputArray_getObj
元DLLエクスポート名: core_InputArray_getObj
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_getObj(cv::_InputArray *ia, void **returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;getObj();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_getSz
[32/64bit] core_InputArray_getSz
%prm
p1,p2
p1 = sptr : IntPtr ia
p2 = var : out Size returnValue
%inst
元関数名(C#): core_InputArray_getSz
元DLLエクスポート名: core_InputArray_getSz
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_getSz(cv::_InputArray *ia, MyCvSize *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(ia-&amp;gt;getSz());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_kind
[32/64bit] core_InputArray_kind
%prm
p1,p2
p1 = sptr : IntPtr ia
p2 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_kind
元DLLエクスポート名: core_InputArray_kind
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_kind(cv::_InputArray *ia, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;kind();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_dims
[32/64bit] core_InputArray_dims
%prm
p1,p2,p3
p1 = sptr : IntPtr ia
p2 = int : int i
p3 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_dims
元DLLエクスポート名: core_InputArray_dims
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_dims(cv::_InputArray *ia, int i, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;dims(i);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_cols
[32/64bit] core_InputArray_cols
%prm
p1,p2,p3
p1 = sptr : IntPtr ia
p2 = int : int i
p3 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_cols
元DLLエクスポート名: core_InputArray_cols
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_cols(cv::_InputArray *ia, int i, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;cols(i);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_rows
[32/64bit] core_InputArray_rows
%prm
p1,p2,p3
p1 = sptr : IntPtr ia
p2 = int : int i
p3 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_rows
元DLLエクスポート名: core_InputArray_rows
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_rows(cv::_InputArray *ia, int i, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;rows(i);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_size
[32/64bit] core_InputArray_size
%prm
p1,p2,p3
p1 = sptr : IntPtr ia
p2 = int : int i
p3 = var : out Size returnValue
%inst
元関数名(C#): core_InputArray_size
元DLLエクスポート名: core_InputArray_size
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_size(cv::_InputArray *ia, int i, MyCvSize *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(ia-&amp;gt;size(i));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_sizend
[32/64bit] core_InputArray_sizend
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr ia
p2 = var : int[] sz
p3 = int : int i
p4 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_sizend
元DLLエクスポート名: core_InputArray_sizend
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_sizend(cv::_InputArray *ia, int* sz, int i, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;sizend(sz, i);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_sameSize
[32/64bit] core_InputArray_sameSize
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = sptr : IntPtr target
p3 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_sameSize
元DLLエクスポート名: core_InputArray_sameSize
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_sameSize(cv::_InputArray *self, cv::_InputArray * target, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;sameSize(*target) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_total
[32/64bit] core_InputArray_total
%prm
p1,p2,p3
p1 = sptr : IntPtr ia
p2 = int : int i
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_InputArray_total
元DLLエクスポート名: core_InputArray_total
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_total(cv::_InputArray *ia, int i, size_t *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;total(i);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_type
[32/64bit] core_InputArray_type
%prm
p1,p2,p3
p1 = sptr : IntPtr ia
p2 = int : int i
p3 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_type
元DLLエクスポート名: core_InputArray_type
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_type(cv::_InputArray *ia, int i, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;type(i);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_depth
[32/64bit] core_InputArray_depth
%prm
p1,p2,p3
p1 = sptr : IntPtr ia
p2 = int : int i
p3 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_depth
元DLLエクスポート名: core_InputArray_depth
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_depth(cv::_InputArray *ia, int i, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;depth(i);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_channels
[32/64bit] core_InputArray_channels
%prm
p1,p2,p3
p1 = sptr : IntPtr ia
p2 = int : int i
p3 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_channels
元DLLエクスポート名: core_InputArray_channels
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_channels(cv::_InputArray *ia, int i, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;channels(i);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_isContinuous
[32/64bit] core_InputArray_isContinuous
%prm
p1,p2,p3
p1 = sptr : IntPtr ia
p2 = int : int i
p3 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_isContinuous
元DLLエクスポート名: core_InputArray_isContinuous
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_isContinuous(cv::_InputArray *ia, int i, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;isContinuous(i) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_isSubmatrix
[32/64bit] core_InputArray_isSubmatrix
%prm
p1,p2,p3
p1 = sptr : IntPtr ia
p2 = int : int i
p3 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_isSubmatrix
元DLLエクスポート名: core_InputArray_isSubmatrix
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_isSubmatrix(cv::_InputArray *ia, int i, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;isSubmatrix(i) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_empty
[32/64bit] core_InputArray_empty
%prm
p1,p2
p1 = sptr : IntPtr ia
p2 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_empty
元DLLエクスポート名: core_InputArray_empty
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_empty(cv::_InputArray *ia, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;empty() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_copyTo1
[32/64bit] core_InputArray_copyTo1
%prm
p1,p2
p1 = sptr : IntPtr ia
p2 = sptr : IntPtr arr
%inst
元関数名(C#): core_InputArray_copyTo1
元DLLエクスポート名: core_InputArray_copyTo1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_copyTo1(cv::_InputArray *ia, cv::_OutputArray *arr)
{
    BEGIN_WRAP
    ia-&amp;gt;copyTo(*arr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_copyTo2
[32/64bit] core_InputArray_copyTo2
%prm
p1,p2,p3
p1 = sptr : IntPtr ia
p2 = sptr : IntPtr arr
p3 = sptr : IntPtr mask
%inst
元関数名(C#): core_InputArray_copyTo2
元DLLエクスポート名: core_InputArray_copyTo2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_copyTo2(cv::_InputArray *ia, cv::_OutputArray *arr, cv::_InputArray *mask)
{
    BEGIN_WRAP
    ia-&amp;gt;copyTo(*arr, *mask);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_offset
[32/64bit] core_InputArray_offset
%prm
p1,p2,p3
p1 = sptr : IntPtr ia
p2 = int : int i
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_InputArray_offset
元DLLエクスポート名: core_InputArray_offset
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_offset(cv::_InputArray *ia, int i, size_t *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;offset(i);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_step
[32/64bit] core_InputArray_step
%prm
p1,p2,p3
p1 = sptr : IntPtr ia
p2 = int : int i
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_InputArray_step
元DLLエクスポート名: core_InputArray_step
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_step(cv::_InputArray *ia, int i, size_t *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;step(i);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_isMat
[32/64bit] core_InputArray_isMat
%prm
p1,p2
p1 = sptr : IntPtr ia
p2 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_isMat
元DLLエクスポート名: core_InputArray_isMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_isMat(cv::_InputArray *ia, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;isMat() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_isUMat
[32/64bit] core_InputArray_isUMat
%prm
p1,p2
p1 = sptr : IntPtr ia
p2 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_isUMat
元DLLエクスポート名: core_InputArray_isUMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_isUMat(cv::_InputArray *ia, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;isUMat() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_isMatVector
[32/64bit] core_InputArray_isMatVector
%prm
p1,p2
p1 = sptr : IntPtr ia
p2 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_isMatVector
元DLLエクスポート名: core_InputArray_isMatVector
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_isMatVector(cv::_InputArray *ia, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;isMatVector() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_isUMatVector
[32/64bit] core_InputArray_isUMatVector
%prm
p1,p2
p1 = sptr : IntPtr ia
p2 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_isUMatVector
元DLLエクスポート名: core_InputArray_isUMatVector
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_isUMatVector(cv::_InputArray *ia, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;isUMatVector() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_isMatx
[32/64bit] core_InputArray_isMatx
%prm
p1,p2
p1 = sptr : IntPtr ia
p2 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_isMatx
元DLLエクスポート名: core_InputArray_isMatx
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_isMatx(cv::_InputArray *ia, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;isMatx() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_isVector
[32/64bit] core_InputArray_isVector
%prm
p1,p2
p1 = sptr : IntPtr ia
p2 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_isVector
元DLLエクスポート名: core_InputArray_isVector
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_isVector(cv::_InputArray *ia, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;isVector() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_InputArray_isGpuMatVector
[32/64bit] core_InputArray_isGpuMatVector
%prm
p1,p2
p1 = sptr : IntPtr ia
p2 = var : out int returnValue
%inst
元関数名(C#): core_InputArray_isGpuMatVector
元DLLエクスポート名: core_InputArray_isGpuMatVector
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_InputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_InputArray_isGpuMatVector(cv::_InputArray *ia, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = ia-&amp;gt;isGpuMatVector() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_InputArray

%index
core_Mat_sizeof
[32/64bit] core_Mat_sizeof
%prm

%inst
元関数名(C#): core_Mat_sizeof
元DLLエクスポート名: core_Mat_sizeof
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(uint64) core_Mat_sizeof()
{
    return sizeof(cv::Mat);
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_new1
[32/64bit] cv::Mat のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst
n-dimensional dense array クラス

 クラス Mat は，シングルチャンネルまたはマルチチャンネルの，n-dimensional dense 数値配列を表します．これは，実数または複素数のベクトルや行列，グレースケールやカラーの画像，ボクセルボリューム，ベクトルフィールド，点群，テンソル，ヒストグラム（ただし，非常に高次元のヒストグラムは， SparseMat に格納した方が良いかもしれません）を格納するために利用できます．配列 M のデータレイアウトは，配列 M.step[] によって定義されており，要素 ?((i_0,...,i_{M.dims-1})?)のアドレスは，次のように計算されます： ?((i_k<M.size[k]?))

\Addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ...+ M.step[M.dims-1]*i_{M.dims-1}\]



 2次元配列の場合，上の式は次のようになります．

\Addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\]」となります。



 M.step[i] >= M.step[i+1] (実際には、M.step[i] >= M.step[i+1]*M.size[i+1] ) であることに注意してください。つまり，2次元の行列は行ごとに，3次元の行列は面ごとに，それぞれ格納されているということです．M.step[M.dims-1] は最小で，常に要素サイズ M.elemSize() と等しくなります．

つまり，Mat のデータレイアウトは，Numpy (ndarray) や Win32 (independent device bitmaps) などの標準的なツールキットや SDK で提供されている密な配列タイプの大半，つまり，ピクセルの位置を計算するのにステップ（またはストライド）を利用するあらゆる配列と互換性があります．この互換性により，ユーザが割り当てたデータの Mat ヘッダを作成し，OpenCV の関数を使ってその場で処理することができます．

Mat オブジェクトを作成するには，様々な方法があります．最も一般的な方法を以下に示します．



create(nrows, ncols, type) メソッドや，類似の Mat(nrows, ncols, type[, fillValue]) コンストラクタを利用します．type は， cvCreateMat メソッドと同じ意味を持ちます．例えば， CV_8UC1 は 8 ビットシングルチャンネル配列を意味し， CV_32FC2 は 2 チャンネル（複素数）浮動小数点型配列を意味します．// 1+3 で埋め尽くされた 7x7 の複素行列を作成します。j.Mat M(7,7,CV_32FC2,Scalar(1,3));// そして今度は，M を 100x60 の 15 チャンネル 8 ビット行列に変えます。 // 古い内容は解放されます。M.create(100,60,CV_8UC(15)); 本章のイントロダクションで述べたように， create() は，現在の配列の形状や型が指定されたものと異なる場合にのみ，新しい配列を確保します．

多次元の配列を作成します。// 100x100x100 の 8 ビット配列を作成しますint sz[] = {100, 100, 100};Mat bigCube(3, sz, CV_8U, Scalar::all(0)); Mat のコンストラクタに次元数 =1 を渡していますが，作成される配列は列数が 1 の 2 次元になります．

右辺に配列や式が存在する可能性がある場合は，コピーコンストラクタや代入演算子を利用します（後述）．導入部で述べたように，配列の代入は，ヘッダのコピーと参照カウンタの増加だけなので，O(1) の処理です．Mat::clone() メソッドを利用すれば，必要な時に配列の完全な（深い）コピーを得ることができます．

別の配列の一部に対するヘッダを作成します．それは，1 つの行，1 つの列，複数の行，複数の列，配列中の矩形領域（代数学ではマイナーと呼ばれます），または対角線のいずれかです．このような操作も，新しいヘッダが同じデータを参照するため，O(1)となります．この機能を使って，実際に配列の一部を変更することができます．例えば// 5 番目の行に 3 を掛けたものを 3 番目の行に追加するM.row(3) = M.row(3) + M.row(5)*3;// 7 番目の列を 1 番目の列にコピーする// M.col(1) = M.col(7); // これは動作しませんMat M1 = M.col(1);M.col(7).copyTo(M1);// 320x240 の新しい imageMat img(Size(320,240),CV_8UC3);// ROIMat roi(img, Rect(10,10,100,100));// ROI を (0,255,0) (RGB 空間では緑) で埋める．// オリジナルの 320x240 の画像が変更されます． roi = Scalar(0,255,0); 追加の datastart および dataend メンバにより， locateROI() を用いて，メインコンテナ配列内の相対的なサブアレイの位置を計算することができます．Mat A = Mat::eye(10, 10, CV_32S);// A の列，1 (including) から 3 (exclusive) を抽出します．Mat B = A(Range::all(), Range(1, 3));// B の行，5 (including) から 9 (exclusive) を抽出します．locateROI(size, ofs);// size は (width=10,height=10) となり，ofs は (x=1, y=5) 行列全体の場合と同様に，深いコピーが必要な場合は，抽出された部分行列の clone() メソッドを利用します．

ユーザが割り当てたデータのヘッダを作成します。以下のようにすると便利です．

OpenCV を用いて，「外部」のデータを処理します（例えば，DirectShow* のフィルタや，gstreamer の処理モジュールを実装する場合など）．例えば，以下のようになります．Mat process_video_frame(const unsigned char* pixels, int width, int height, int step){ // 入力バッファをラップします． Mat img(height, width, CV_8UC3, (unsigned char*)pixels, step); Mat result; GaussianBlur(img, result, Size(7, 7), 1.5, 1.5); return result;}．

double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};Mat M = Mat(3, 3, CV_64F, m).inv();





MATLAB スタイルの配列初期化子，zeros(), ones(), eye() などを利用します．// 倍精度の単位行列を作成し，それを M.M += Mat::eye(M.rows, M.cols, CV_64F) に追加します．

コンマで区切られたイニシャライザを利用します．// 3x3 の倍精度単位行列を作成します。Mat M = (Mat_<double>(3,3) << 1, 0, 0, 1, 0, 0, 1); この方法では，まず適切なパラメータを指定して Mat クラスのコンストラクタを呼び出し，次に << 演算子の後に定数，変数，式などのコンマで区切られた値を置くだけです．また，コンパイルエラーを避けるために，余分な括弧が必要であることにも注意してください．



配列が作成されると、参照カウントの仕組みによって自動的に管理されます。配列のヘッダがユーザが割り当てたデータの上に構築されている場合は，そのデータを自分で処理する必要があります．配列データは、誰からも指されなくなると解放されます。配列デストラクタが呼ばれる前に，配列ヘッダが指し示すデータを解放したい場合は， Mat::release() を利用してください．

配列クラスについて次に学ぶべき重要なことは，要素へのアクセスです．このマニュアルでは，各配列要素のアドレスを計算する方法を既に説明しました．通常は，コード内で直接その式を使う必要はありません．配列要素の型（メソッド Mat::type() を用いて取得できます）を知っていれば，2 次元配列の要素 \(M_{ij}\) に，次のようにアクセスできます．M.at<double>(i,j) += 1.f; M は倍精度浮動小数点型配列であると仮定します．M.at<double>(i,j) += 1.f; Mは倍精度の浮動小数点配列であると仮定しています。

2 次元配列の行全体を処理する必要がある場合，最も効率的な方法は，最初に行へのポインタを取得し，次に C の単純な演算子 [] を使用することです： // 正の行列要素の総和を求めます // （M が倍精度の行列であると仮定して）double sum=0;for(int i = 0; i < M. .rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < M.cols; j++) sum += std::max(Mi[j], 0.);}．上の例のように，実際には配列の形状に依存しない演算もあります．このような演算は，配列の要素を1つずつ処理するだけです（あるいは，配列の加算など，同じ座標を持つ複数の配列の要素を処理することもあります）．このような操作を「要素ワイズ」と呼びます。すべての入出力配列が連続しているかどうか，つまり，各行の終わりに隙間がないかどうかをチェックすることは意味があります．もしそうであれば，それらを長い1つの行として処理します．// 最適化された正の行列要素の和を求めるtdouble sum=0;int cols = M.cols, rows = M.rows;if(M.isContinuous()){ cols *= rows; rows = 1;}for(int i = 0; i < rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < cols; j++) sum += std::max(Mi[j], 0.);}．連続した行列の場合，外側のループ本体は1回しか実行されません．そのため，オーバーヘッドが小さくなり，特に小さな行列の場合には顕著です．

最後に，連続した行の間のギャップをスキップすることができる STL スタイルのイテレータを紹介します．// 正の行列要素の総和を計算する，イテレータベースのバリアントdouble sum=0;MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();for(; it != it_end; ++it) sum += std::max(*it, 0.); 行列イテレータは，ランダムアクセスイテレータなので，std::sort() を含む，あらゆる STL アルゴリズムに渡すことができます．

注釈matrix Expressions and arithmetic see MatExpr

例： fld_lines.cpp，modules/shape/samples/shape_example.cpp，samples/cpp/camshiftdemo.cpp，samples/cpp/connected_components.cpp，samples/cpp/contours2.cpp，samples/cpp/convexhull.cpp，samples/cpp/cout_mat.cpp，samples/cpp/create_mask.cpp，samples/cpp/demhist.cpp，samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/filestorage.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/intersectExample.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp，samples/cpp/laplace.cpp，samples/cpp/lkdemo.cpp，samples/cpp/minarea.cpp，samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp，samples/cpp/polar_transforms.cpp，samples/cpp/segment_objects.cpp，samples/cpp/squares.cpp，samples/cpp/stitching.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/cpp/tutorial_code/videoio/video-write/video-write.cpp, samples/cpp/videowriter_basic.cpp, samples/cpp/warpPerspective_demo.cpp, samples/cpp/watershed.cpp, samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, samples/dnn/openpose.cpp, samples/dnn/segmentation.cpp, samples/dnn/text_detection.cpp, and samples/tapi/squares.cpp.


元関数名(C#): core_Mat_new1
元DLLエクスポート名: core_Mat_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_new1(cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_new2
[32/64bit] cv::Mat のインスタンスを生成します
%prm
p1,p2,p3,p4
p1 = int : int rows
p2 = int : int cols
p3 = int : int type
p4 = var : out IntPtr returnValue
%inst
n-dimensional dense array クラス

 クラス Mat は，シングルチャンネルまたはマルチチャンネルの，n-dimensional dense 数値配列を表します．これは，実数または複素数のベクトルや行列，グレースケールやカラーの画像，ボクセルボリューム，ベクトルフィールド，点群，テンソル，ヒストグラム（ただし，非常に高次元のヒストグラムは， SparseMat に格納した方が良いかもしれません）を格納するために利用できます．配列 M のデータレイアウトは，配列 M.step[] によって定義されており，要素 ?((i_0,...,i_{M.dims-1})?)のアドレスは，次のように計算されます： ?((i_k<M.size[k]?))

\Addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ...+ M.step[M.dims-1]*i_{M.dims-1}\]



 2次元配列の場合，上の式は次のようになります．

\Addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\]」となります。



 M.step[i] >= M.step[i+1] (実際には、M.step[i] >= M.step[i+1]*M.size[i+1] ) であることに注意してください。つまり，2次元の行列は行ごとに，3次元の行列は面ごとに，それぞれ格納されているということです．M.step[M.dims-1] は最小で，常に要素サイズ M.elemSize() と等しくなります．

つまり，Mat のデータレイアウトは，Numpy (ndarray) や Win32 (independent device bitmaps) などの標準的なツールキットや SDK で提供されている密な配列タイプの大半，つまり，ピクセルの位置を計算するのにステップ（またはストライド）を利用するあらゆる配列と互換性があります．この互換性により，ユーザが割り当てたデータの Mat ヘッダを作成し，OpenCV の関数を使ってその場で処理することができます．

Mat オブジェクトを作成するには，様々な方法があります．最も一般的な方法を以下に示します．



create(nrows, ncols, type) メソッドや，類似の Mat(nrows, ncols, type[, fillValue]) コンストラクタを利用します．type は， cvCreateMat メソッドと同じ意味を持ちます．例えば， CV_8UC1 は 8 ビットシングルチャンネル配列を意味し， CV_32FC2 は 2 チャンネル（複素数）浮動小数点型配列を意味します．// 1+3 で埋め尽くされた 7x7 の複素行列を作成します。j.Mat M(7,7,CV_32FC2,Scalar(1,3));// そして今度は，M を 100x60 の 15 チャンネル 8 ビット行列に変えます。 // 古い内容は解放されます。M.create(100,60,CV_8UC(15)); 本章のイントロダクションで述べたように， create() は，現在の配列の形状や型が指定されたものと異なる場合にのみ，新しい配列を確保します．

多次元の配列を作成します。// 100x100x100 の 8 ビット配列を作成しますint sz[] = {100, 100, 100};Mat bigCube(3, sz, CV_8U, Scalar::all(0)); Mat のコンストラクタに次元数 =1 を渡していますが，作成される配列は列数が 1 の 2 次元になります．

右辺に配列や式が存在する可能性がある場合は，コピーコンストラクタや代入演算子を利用します（後述）．導入部で述べたように，配列の代入は，ヘッダのコピーと参照カウンタの増加だけなので，O(1) の処理です．Mat::clone() メソッドを利用すれば，必要な時に配列の完全な（深い）コピーを得ることができます．

別の配列の一部に対するヘッダを作成します．それは，1 つの行，1 つの列，複数の行，複数の列，配列中の矩形領域（代数学ではマイナーと呼ばれます），または対角線のいずれかです．このような操作も，新しいヘッダが同じデータを参照するため，O(1)となります．この機能を使って，実際に配列の一部を変更することができます．例えば// 5 番目の行に 3 を掛けたものを 3 番目の行に追加するM.row(3) = M.row(3) + M.row(5)*3;// 7 番目の列を 1 番目の列にコピーする// M.col(1) = M.col(7); // これは動作しませんMat M1 = M.col(1);M.col(7).copyTo(M1);// 320x240 の新しい imageMat img(Size(320,240),CV_8UC3);// ROIMat roi(img, Rect(10,10,100,100));// ROI を (0,255,0) (RGB 空間では緑) で埋める．// オリジナルの 320x240 の画像が変更されます． roi = Scalar(0,255,0); 追加の datastart および dataend メンバにより， locateROI() を用いて，メインコンテナ配列内の相対的なサブアレイの位置を計算することができます．Mat A = Mat::eye(10, 10, CV_32S);// A の列，1 (including) から 3 (exclusive) を抽出します．Mat B = A(Range::all(), Range(1, 3));// B の行，5 (including) から 9 (exclusive) を抽出します．locateROI(size, ofs);// size は (width=10,height=10) となり，ofs は (x=1, y=5) 行列全体の場合と同様に，深いコピーが必要な場合は，抽出された部分行列の clone() メソッドを利用します．

ユーザが割り当てたデータのヘッダを作成します。以下のようにすると便利です．

OpenCV を用いて，「外部」のデータを処理します（例えば，DirectShow* のフィルタや，gstreamer の処理モジュールを実装する場合など）．例えば，以下のようになります．Mat process_video_frame(const unsigned char* pixels, int width, int height, int step){ // 入力バッファをラップします． Mat img(height, width, CV_8UC3, (unsigned char*)pixels, step); Mat result; GaussianBlur(img, result, Size(7, 7), 1.5, 1.5); return result;}．

double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};Mat M = Mat(3, 3, CV_64F, m).inv();





MATLAB スタイルの配列初期化子，zeros(), ones(), eye() などを利用します．// 倍精度の単位行列を作成し，それを M.M += Mat::eye(M.rows, M.cols, CV_64F) に追加します．

コンマで区切られたイニシャライザを利用します．// 3x3 の倍精度単位行列を作成します。Mat M = (Mat_<double>(3,3) << 1, 0, 0, 1, 0, 0, 1); この方法では，まず適切なパラメータを指定して Mat クラスのコンストラクタを呼び出し，次に << 演算子の後に定数，変数，式などのコンマで区切られた値を置くだけです．また，コンパイルエラーを避けるために，余分な括弧が必要であることにも注意してください．



配列が作成されると、参照カウントの仕組みによって自動的に管理されます。配列のヘッダがユーザが割り当てたデータの上に構築されている場合は，そのデータを自分で処理する必要があります．配列データは、誰からも指されなくなると解放されます。配列デストラクタが呼ばれる前に，配列ヘッダが指し示すデータを解放したい場合は， Mat::release() を利用してください．

配列クラスについて次に学ぶべき重要なことは，要素へのアクセスです．このマニュアルでは，各配列要素のアドレスを計算する方法を既に説明しました．通常は，コード内で直接その式を使う必要はありません．配列要素の型（メソッド Mat::type() を用いて取得できます）を知っていれば，2 次元配列の要素 \(M_{ij}\) に，次のようにアクセスできます．M.at<double>(i,j) += 1.f; M は倍精度浮動小数点型配列であると仮定します．M.at<double>(i,j) += 1.f; Mは倍精度の浮動小数点配列であると仮定しています。

2 次元配列の行全体を処理する必要がある場合，最も効率的な方法は，最初に行へのポインタを取得し，次に C の単純な演算子 [] を使用することです： // 正の行列要素の総和を求めます // （M が倍精度の行列であると仮定して）double sum=0;for(int i = 0; i < M. .rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < M.cols; j++) sum += std::max(Mi[j], 0.);}．上の例のように，実際には配列の形状に依存しない演算もあります．このような演算は，配列の要素を1つずつ処理するだけです（あるいは，配列の加算など，同じ座標を持つ複数の配列の要素を処理することもあります）．このような操作を「要素ワイズ」と呼びます。すべての入出力配列が連続しているかどうか，つまり，各行の終わりに隙間がないかどうかをチェックすることは意味があります．もしそうであれば，それらを長い1つの行として処理します．// 最適化された正の行列要素の和を求めるtdouble sum=0;int cols = M.cols, rows = M.rows;if(M.isContinuous()){ cols *= rows; rows = 1;}for(int i = 0; i < rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < cols; j++) sum += std::max(Mi[j], 0.);}．連続した行列の場合，外側のループ本体は1回しか実行されません．そのため，オーバーヘッドが小さくなり，特に小さな行列の場合には顕著です．

最後に，連続した行の間のギャップをスキップすることができる STL スタイルのイテレータを紹介します．// 正の行列要素の総和を計算する，イテレータベースのバリアントdouble sum=0;MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();for(; it != it_end; ++it) sum += std::max(*it, 0.); 行列イテレータは，ランダムアクセスイテレータなので，std::sort() を含む，あらゆる STL アルゴリズムに渡すことができます．

注釈matrix Expressions and arithmetic see MatExpr

例： fld_lines.cpp，modules/shape/samples/shape_example.cpp，samples/cpp/camshiftdemo.cpp，samples/cpp/connected_components.cpp，samples/cpp/contours2.cpp，samples/cpp/convexhull.cpp，samples/cpp/cout_mat.cpp，samples/cpp/create_mask.cpp，samples/cpp/demhist.cpp，samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/filestorage.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/intersectExample.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp，samples/cpp/laplace.cpp，samples/cpp/lkdemo.cpp，samples/cpp/minarea.cpp，samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp，samples/cpp/polar_transforms.cpp，samples/cpp/segment_objects.cpp，samples/cpp/squares.cpp，samples/cpp/stitching.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/cpp/tutorial_code/videoio/video-write/video-write.cpp, samples/cpp/videowriter_basic.cpp, samples/cpp/warpPerspective_demo.cpp, samples/cpp/watershed.cpp, samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, samples/dnn/openpose.cpp, samples/dnn/segmentation.cpp, samples/dnn/text_detection.cpp, and samples/tapi/squares.cpp.


元関数名(C#): core_Mat_new2
元DLLエクスポート名: core_Mat_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_new2(int rows, int cols, int type, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(rows, cols, type); 
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_new3
[32bit] cv::Mat のインスタンスを生成します
%prm
p1,p2,p3,p4,p5
p1 = int : int rows
p2 = int : int cols
p3 = int : int type
p4 = ARGS_SCALAR : Scalar scalar
p5 = var : out IntPtr returnValue
%inst
n-dimensional dense array クラス

 クラス Mat は，シングルチャンネルまたはマルチチャンネルの，n-dimensional dense 数値配列を表します．これは，実数または複素数のベクトルや行列，グレースケールやカラーの画像，ボクセルボリューム，ベクトルフィールド，点群，テンソル，ヒストグラム（ただし，非常に高次元のヒストグラムは， SparseMat に格納した方が良いかもしれません）を格納するために利用できます．配列 M のデータレイアウトは，配列 M.step[] によって定義されており，要素 ?((i_0,...,i_{M.dims-1})?)のアドレスは，次のように計算されます： ?((i_k<M.size[k]?))

\Addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ...+ M.step[M.dims-1]*i_{M.dims-1}\]



 2次元配列の場合，上の式は次のようになります．

\Addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\]」となります。



 M.step[i] >= M.step[i+1] (実際には、M.step[i] >= M.step[i+1]*M.size[i+1] ) であることに注意してください。つまり，2次元の行列は行ごとに，3次元の行列は面ごとに，それぞれ格納されているということです．M.step[M.dims-1] は最小で，常に要素サイズ M.elemSize() と等しくなります．

つまり，Mat のデータレイアウトは，Numpy (ndarray) や Win32 (independent device bitmaps) などの標準的なツールキットや SDK で提供されている密な配列タイプの大半，つまり，ピクセルの位置を計算するのにステップ（またはストライド）を利用するあらゆる配列と互換性があります．この互換性により，ユーザが割り当てたデータの Mat ヘッダを作成し，OpenCV の関数を使ってその場で処理することができます．

Mat オブジェクトを作成するには，様々な方法があります．最も一般的な方法を以下に示します．



create(nrows, ncols, type) メソッドや，類似の Mat(nrows, ncols, type[, fillValue]) コンストラクタを利用します．type は， cvCreateMat メソッドと同じ意味を持ちます．例えば， CV_8UC1 は 8 ビットシングルチャンネル配列を意味し， CV_32FC2 は 2 チャンネル（複素数）浮動小数点型配列を意味します．// 1+3 で埋め尽くされた 7x7 の複素行列を作成します。j.Mat M(7,7,CV_32FC2,Scalar(1,3));// そして今度は，M を 100x60 の 15 チャンネル 8 ビット行列に変えます。 // 古い内容は解放されます。M.create(100,60,CV_8UC(15)); 本章のイントロダクションで述べたように， create() は，現在の配列の形状や型が指定されたものと異なる場合にのみ，新しい配列を確保します．

多次元の配列を作成します。// 100x100x100 の 8 ビット配列を作成しますint sz[] = {100, 100, 100};Mat bigCube(3, sz, CV_8U, Scalar::all(0)); Mat のコンストラクタに次元数 =1 を渡していますが，作成される配列は列数が 1 の 2 次元になります．

右辺に配列や式が存在する可能性がある場合は，コピーコンストラクタや代入演算子を利用します（後述）．導入部で述べたように，配列の代入は，ヘッダのコピーと参照カウンタの増加だけなので，O(1) の処理です．Mat::clone() メソッドを利用すれば，必要な時に配列の完全な（深い）コピーを得ることができます．

別の配列の一部に対するヘッダを作成します．それは，1 つの行，1 つの列，複数の行，複数の列，配列中の矩形領域（代数学ではマイナーと呼ばれます），または対角線のいずれかです．このような操作も，新しいヘッダが同じデータを参照するため，O(1)となります．この機能を使って，実際に配列の一部を変更することができます．例えば// 5 番目の行に 3 を掛けたものを 3 番目の行に追加するM.row(3) = M.row(3) + M.row(5)*3;// 7 番目の列を 1 番目の列にコピーする// M.col(1) = M.col(7); // これは動作しませんMat M1 = M.col(1);M.col(7).copyTo(M1);// 320x240 の新しい imageMat img(Size(320,240),CV_8UC3);// ROIMat roi(img, Rect(10,10,100,100));// ROI を (0,255,0) (RGB 空間では緑) で埋める．// オリジナルの 320x240 の画像が変更されます． roi = Scalar(0,255,0); 追加の datastart および dataend メンバにより， locateROI() を用いて，メインコンテナ配列内の相対的なサブアレイの位置を計算することができます．Mat A = Mat::eye(10, 10, CV_32S);// A の列，1 (including) から 3 (exclusive) を抽出します．Mat B = A(Range::all(), Range(1, 3));// B の行，5 (including) から 9 (exclusive) を抽出します．locateROI(size, ofs);// size は (width=10,height=10) となり，ofs は (x=1, y=5) 行列全体の場合と同様に，深いコピーが必要な場合は，抽出された部分行列の clone() メソッドを利用します．

ユーザが割り当てたデータのヘッダを作成します。以下のようにすると便利です．

OpenCV を用いて，「外部」のデータを処理します（例えば，DirectShow* のフィルタや，gstreamer の処理モジュールを実装する場合など）．例えば，以下のようになります．Mat process_video_frame(const unsigned char* pixels, int width, int height, int step){ // 入力バッファをラップします． Mat img(height, width, CV_8UC3, (unsigned char*)pixels, step); Mat result; GaussianBlur(img, result, Size(7, 7), 1.5, 1.5); return result;}．

double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};Mat M = Mat(3, 3, CV_64F, m).inv();





MATLAB スタイルの配列初期化子，zeros(), ones(), eye() などを利用します．// 倍精度の単位行列を作成し，それを M.M += Mat::eye(M.rows, M.cols, CV_64F) に追加します．

コンマで区切られたイニシャライザを利用します．// 3x3 の倍精度単位行列を作成します。Mat M = (Mat_<double>(3,3) << 1, 0, 0, 1, 0, 0, 1); この方法では，まず適切なパラメータを指定して Mat クラスのコンストラクタを呼び出し，次に << 演算子の後に定数，変数，式などのコンマで区切られた値を置くだけです．また，コンパイルエラーを避けるために，余分な括弧が必要であることにも注意してください．



配列が作成されると、参照カウントの仕組みによって自動的に管理されます。配列のヘッダがユーザが割り当てたデータの上に構築されている場合は，そのデータを自分で処理する必要があります．配列データは、誰からも指されなくなると解放されます。配列デストラクタが呼ばれる前に，配列ヘッダが指し示すデータを解放したい場合は， Mat::release() を利用してください．

配列クラスについて次に学ぶべき重要なことは，要素へのアクセスです．このマニュアルでは，各配列要素のアドレスを計算する方法を既に説明しました．通常は，コード内で直接その式を使う必要はありません．配列要素の型（メソッド Mat::type() を用いて取得できます）を知っていれば，2 次元配列の要素 \(M_{ij}\) に，次のようにアクセスできます．M.at<double>(i,j) += 1.f; M は倍精度浮動小数点型配列であると仮定します．M.at<double>(i,j) += 1.f; Mは倍精度の浮動小数点配列であると仮定しています。

2 次元配列の行全体を処理する必要がある場合，最も効率的な方法は，最初に行へのポインタを取得し，次に C の単純な演算子 [] を使用することです： // 正の行列要素の総和を求めます // （M が倍精度の行列であると仮定して）double sum=0;for(int i = 0; i < M. .rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < M.cols; j++) sum += std::max(Mi[j], 0.);}．上の例のように，実際には配列の形状に依存しない演算もあります．このような演算は，配列の要素を1つずつ処理するだけです（あるいは，配列の加算など，同じ座標を持つ複数の配列の要素を処理することもあります）．このような操作を「要素ワイズ」と呼びます。すべての入出力配列が連続しているかどうか，つまり，各行の終わりに隙間がないかどうかをチェックすることは意味があります．もしそうであれば，それらを長い1つの行として処理します．// 最適化された正の行列要素の和を求めるtdouble sum=0;int cols = M.cols, rows = M.rows;if(M.isContinuous()){ cols *= rows; rows = 1;}for(int i = 0; i < rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < cols; j++) sum += std::max(Mi[j], 0.);}．連続した行列の場合，外側のループ本体は1回しか実行されません．そのため，オーバーヘッドが小さくなり，特に小さな行列の場合には顕著です．

最後に，連続した行の間のギャップをスキップすることができる STL スタイルのイテレータを紹介します．// 正の行列要素の総和を計算する，イテレータベースのバリアントdouble sum=0;MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();for(; it != it_end; ++it) sum += std::max(*it, 0.); 行列イテレータは，ランダムアクセスイテレータなので，std::sort() を含む，あらゆる STL アルゴリズムに渡すことができます．

注釈matrix Expressions and arithmetic see MatExpr

例： fld_lines.cpp，modules/shape/samples/shape_example.cpp，samples/cpp/camshiftdemo.cpp，samples/cpp/connected_components.cpp，samples/cpp/contours2.cpp，samples/cpp/convexhull.cpp，samples/cpp/cout_mat.cpp，samples/cpp/create_mask.cpp，samples/cpp/demhist.cpp，samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/filestorage.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/intersectExample.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp，samples/cpp/laplace.cpp，samples/cpp/lkdemo.cpp，samples/cpp/minarea.cpp，samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp，samples/cpp/polar_transforms.cpp，samples/cpp/segment_objects.cpp，samples/cpp/squares.cpp，samples/cpp/stitching.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/cpp/tutorial_code/videoio/video-write/video-write.cpp, samples/cpp/videowriter_basic.cpp, samples/cpp/warpPerspective_demo.cpp, samples/cpp/watershed.cpp, samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, samples/dnn/openpose.cpp, samples/dnn/segmentation.cpp, samples/dnn/text_detection.cpp, and samples/tapi/squares.cpp.


元関数名(C#): core_Mat_new3
元DLLエクスポート名: core_Mat_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_new3(int rows, int cols, int type, MyCvScalar scalar, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(rows, cols, type, cpp(scalar));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_new3
[64bit] cv::Mat のインスタンスを生成します
%prm
p1,p2,p3,p4,p5
p1 = int : int rows
p2 = int : int cols
p3 = int : int type
p4 = var : Scalar scalar
p5 = var : out IntPtr returnValue
%inst
n-dimensional dense array クラス

 クラス Mat は，シングルチャンネルまたはマルチチャンネルの，n-dimensional dense 数値配列を表します．これは，実数または複素数のベクトルや行列，グレースケールやカラーの画像，ボクセルボリューム，ベクトルフィールド，点群，テンソル，ヒストグラム（ただし，非常に高次元のヒストグラムは， SparseMat に格納した方が良いかもしれません）を格納するために利用できます．配列 M のデータレイアウトは，配列 M.step[] によって定義されており，要素 ?((i_0,...,i_{M.dims-1})?)のアドレスは，次のように計算されます： ?((i_k<M.size[k]?))

\Addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ...+ M.step[M.dims-1]*i_{M.dims-1}\]



 2次元配列の場合，上の式は次のようになります．

\Addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\]」となります。



 M.step[i] >= M.step[i+1] (実際には、M.step[i] >= M.step[i+1]*M.size[i+1] ) であることに注意してください。つまり，2次元の行列は行ごとに，3次元の行列は面ごとに，それぞれ格納されているということです．M.step[M.dims-1] は最小で，常に要素サイズ M.elemSize() と等しくなります．

つまり，Mat のデータレイアウトは，Numpy (ndarray) や Win32 (independent device bitmaps) などの標準的なツールキットや SDK で提供されている密な配列タイプの大半，つまり，ピクセルの位置を計算するのにステップ（またはストライド）を利用するあらゆる配列と互換性があります．この互換性により，ユーザが割り当てたデータの Mat ヘッダを作成し，OpenCV の関数を使ってその場で処理することができます．

Mat オブジェクトを作成するには，様々な方法があります．最も一般的な方法を以下に示します．



create(nrows, ncols, type) メソッドや，類似の Mat(nrows, ncols, type[, fillValue]) コンストラクタを利用します．type は， cvCreateMat メソッドと同じ意味を持ちます．例えば， CV_8UC1 は 8 ビットシングルチャンネル配列を意味し， CV_32FC2 は 2 チャンネル（複素数）浮動小数点型配列を意味します．// 1+3 で埋め尽くされた 7x7 の複素行列を作成します。j.Mat M(7,7,CV_32FC2,Scalar(1,3));// そして今度は，M を 100x60 の 15 チャンネル 8 ビット行列に変えます。 // 古い内容は解放されます。M.create(100,60,CV_8UC(15)); 本章のイントロダクションで述べたように， create() は，現在の配列の形状や型が指定されたものと異なる場合にのみ，新しい配列を確保します．

多次元の配列を作成します。// 100x100x100 の 8 ビット配列を作成しますint sz[] = {100, 100, 100};Mat bigCube(3, sz, CV_8U, Scalar::all(0)); Mat のコンストラクタに次元数 =1 を渡していますが，作成される配列は列数が 1 の 2 次元になります．

右辺に配列や式が存在する可能性がある場合は，コピーコンストラクタや代入演算子を利用します（後述）．導入部で述べたように，配列の代入は，ヘッダのコピーと参照カウンタの増加だけなので，O(1) の処理です．Mat::clone() メソッドを利用すれば，必要な時に配列の完全な（深い）コピーを得ることができます．

別の配列の一部に対するヘッダを作成します．それは，1 つの行，1 つの列，複数の行，複数の列，配列中の矩形領域（代数学ではマイナーと呼ばれます），または対角線のいずれかです．このような操作も，新しいヘッダが同じデータを参照するため，O(1)となります．この機能を使って，実際に配列の一部を変更することができます．例えば// 5 番目の行に 3 を掛けたものを 3 番目の行に追加するM.row(3) = M.row(3) + M.row(5)*3;// 7 番目の列を 1 番目の列にコピーする// M.col(1) = M.col(7); // これは動作しませんMat M1 = M.col(1);M.col(7).copyTo(M1);// 320x240 の新しい imageMat img(Size(320,240),CV_8UC3);// ROIMat roi(img, Rect(10,10,100,100));// ROI を (0,255,0) (RGB 空間では緑) で埋める．// オリジナルの 320x240 の画像が変更されます． roi = Scalar(0,255,0); 追加の datastart および dataend メンバにより， locateROI() を用いて，メインコンテナ配列内の相対的なサブアレイの位置を計算することができます．Mat A = Mat::eye(10, 10, CV_32S);// A の列，1 (including) から 3 (exclusive) を抽出します．Mat B = A(Range::all(), Range(1, 3));// B の行，5 (including) から 9 (exclusive) を抽出します．locateROI(size, ofs);// size は (width=10,height=10) となり，ofs は (x=1, y=5) 行列全体の場合と同様に，深いコピーが必要な場合は，抽出された部分行列の clone() メソッドを利用します．

ユーザが割り当てたデータのヘッダを作成します。以下のようにすると便利です．

OpenCV を用いて，「外部」のデータを処理します（例えば，DirectShow* のフィルタや，gstreamer の処理モジュールを実装する場合など）．例えば，以下のようになります．Mat process_video_frame(const unsigned char* pixels, int width, int height, int step){ // 入力バッファをラップします． Mat img(height, width, CV_8UC3, (unsigned char*)pixels, step); Mat result; GaussianBlur(img, result, Size(7, 7), 1.5, 1.5); return result;}．

double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};Mat M = Mat(3, 3, CV_64F, m).inv();





MATLAB スタイルの配列初期化子，zeros(), ones(), eye() などを利用します．// 倍精度の単位行列を作成し，それを M.M += Mat::eye(M.rows, M.cols, CV_64F) に追加します．

コンマで区切られたイニシャライザを利用します．// 3x3 の倍精度単位行列を作成します。Mat M = (Mat_<double>(3,3) << 1, 0, 0, 1, 0, 0, 1); この方法では，まず適切なパラメータを指定して Mat クラスのコンストラクタを呼び出し，次に << 演算子の後に定数，変数，式などのコンマで区切られた値を置くだけです．また，コンパイルエラーを避けるために，余分な括弧が必要であることにも注意してください．



配列が作成されると、参照カウントの仕組みによって自動的に管理されます。配列のヘッダがユーザが割り当てたデータの上に構築されている場合は，そのデータを自分で処理する必要があります．配列データは、誰からも指されなくなると解放されます。配列デストラクタが呼ばれる前に，配列ヘッダが指し示すデータを解放したい場合は， Mat::release() を利用してください．

配列クラスについて次に学ぶべき重要なことは，要素へのアクセスです．このマニュアルでは，各配列要素のアドレスを計算する方法を既に説明しました．通常は，コード内で直接その式を使う必要はありません．配列要素の型（メソッド Mat::type() を用いて取得できます）を知っていれば，2 次元配列の要素 \(M_{ij}\) に，次のようにアクセスできます．M.at<double>(i,j) += 1.f; M は倍精度浮動小数点型配列であると仮定します．M.at<double>(i,j) += 1.f; Mは倍精度の浮動小数点配列であると仮定しています。

2 次元配列の行全体を処理する必要がある場合，最も効率的な方法は，最初に行へのポインタを取得し，次に C の単純な演算子 [] を使用することです： // 正の行列要素の総和を求めます // （M が倍精度の行列であると仮定して）double sum=0;for(int i = 0; i < M. .rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < M.cols; j++) sum += std::max(Mi[j], 0.);}．上の例のように，実際には配列の形状に依存しない演算もあります．このような演算は，配列の要素を1つずつ処理するだけです（あるいは，配列の加算など，同じ座標を持つ複数の配列の要素を処理することもあります）．このような操作を「要素ワイズ」と呼びます。すべての入出力配列が連続しているかどうか，つまり，各行の終わりに隙間がないかどうかをチェックすることは意味があります．もしそうであれば，それらを長い1つの行として処理します．// 最適化された正の行列要素の和を求めるtdouble sum=0;int cols = M.cols, rows = M.rows;if(M.isContinuous()){ cols *= rows; rows = 1;}for(int i = 0; i < rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < cols; j++) sum += std::max(Mi[j], 0.);}．連続した行列の場合，外側のループ本体は1回しか実行されません．そのため，オーバーヘッドが小さくなり，特に小さな行列の場合には顕著です．

最後に，連続した行の間のギャップをスキップすることができる STL スタイルのイテレータを紹介します．// 正の行列要素の総和を計算する，イテレータベースのバリアントdouble sum=0;MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();for(; it != it_end; ++it) sum += std::max(*it, 0.); 行列イテレータは，ランダムアクセスイテレータなので，std::sort() を含む，あらゆる STL アルゴリズムに渡すことができます．

注釈matrix Expressions and arithmetic see MatExpr

例： fld_lines.cpp，modules/shape/samples/shape_example.cpp，samples/cpp/camshiftdemo.cpp，samples/cpp/connected_components.cpp，samples/cpp/contours2.cpp，samples/cpp/convexhull.cpp，samples/cpp/cout_mat.cpp，samples/cpp/create_mask.cpp，samples/cpp/demhist.cpp，samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/filestorage.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/intersectExample.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp，samples/cpp/laplace.cpp，samples/cpp/lkdemo.cpp，samples/cpp/minarea.cpp，samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp，samples/cpp/polar_transforms.cpp，samples/cpp/segment_objects.cpp，samples/cpp/squares.cpp，samples/cpp/stitching.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/cpp/tutorial_code/videoio/video-write/video-write.cpp, samples/cpp/videowriter_basic.cpp, samples/cpp/warpPerspective_demo.cpp, samples/cpp/watershed.cpp, samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, samples/dnn/openpose.cpp, samples/dnn/segmentation.cpp, samples/dnn/text_detection.cpp, and samples/tapi/squares.cpp.


元関数名(C#): core_Mat_new3
元DLLエクスポート名: core_Mat_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_new3(int rows, int cols, int type, MyCvScalar scalar, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(rows, cols, type, cpp(scalar));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_new4
[32/64bit] cv::Mat のインスタンスを生成します
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr mat
p2 = ARGS_RANGE : Range rowRange
p3 = ARGS_RANGE : Range colRange
p4 = var : out IntPtr returnValue
%inst
n-dimensional dense array クラス

 クラス Mat は，シングルチャンネルまたはマルチチャンネルの，n-dimensional dense 数値配列を表します．これは，実数または複素数のベクトルや行列，グレースケールやカラーの画像，ボクセルボリューム，ベクトルフィールド，点群，テンソル，ヒストグラム（ただし，非常に高次元のヒストグラムは， SparseMat に格納した方が良いかもしれません）を格納するために利用できます．配列 M のデータレイアウトは，配列 M.step[] によって定義されており，要素 ?((i_0,...,i_{M.dims-1})?)のアドレスは，次のように計算されます： ?((i_k<M.size[k]?))

\Addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ...+ M.step[M.dims-1]*i_{M.dims-1}\]



 2次元配列の場合，上の式は次のようになります．

\Addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\]」となります。



 M.step[i] >= M.step[i+1] (実際には、M.step[i] >= M.step[i+1]*M.size[i+1] ) であることに注意してください。つまり，2次元の行列は行ごとに，3次元の行列は面ごとに，それぞれ格納されているということです．M.step[M.dims-1] は最小で，常に要素サイズ M.elemSize() と等しくなります．

つまり，Mat のデータレイアウトは，Numpy (ndarray) や Win32 (independent device bitmaps) などの標準的なツールキットや SDK で提供されている密な配列タイプの大半，つまり，ピクセルの位置を計算するのにステップ（またはストライド）を利用するあらゆる配列と互換性があります．この互換性により，ユーザが割り当てたデータの Mat ヘッダを作成し，OpenCV の関数を使ってその場で処理することができます．

Mat オブジェクトを作成するには，様々な方法があります．最も一般的な方法を以下に示します．



create(nrows, ncols, type) メソッドや，類似の Mat(nrows, ncols, type[, fillValue]) コンストラクタを利用します．type は， cvCreateMat メソッドと同じ意味を持ちます．例えば， CV_8UC1 は 8 ビットシングルチャンネル配列を意味し， CV_32FC2 は 2 チャンネル（複素数）浮動小数点型配列を意味します．// 1+3 で埋め尽くされた 7x7 の複素行列を作成します。j.Mat M(7,7,CV_32FC2,Scalar(1,3));// そして今度は，M を 100x60 の 15 チャンネル 8 ビット行列に変えます。 // 古い内容は解放されます。M.create(100,60,CV_8UC(15)); 本章のイントロダクションで述べたように， create() は，現在の配列の形状や型が指定されたものと異なる場合にのみ，新しい配列を確保します．

多次元の配列を作成します。// 100x100x100 の 8 ビット配列を作成しますint sz[] = {100, 100, 100};Mat bigCube(3, sz, CV_8U, Scalar::all(0)); Mat のコンストラクタに次元数 =1 を渡していますが，作成される配列は列数が 1 の 2 次元になります．

右辺に配列や式が存在する可能性がある場合は，コピーコンストラクタや代入演算子を利用します（後述）．導入部で述べたように，配列の代入は，ヘッダのコピーと参照カウンタの増加だけなので，O(1) の処理です．Mat::clone() メソッドを利用すれば，必要な時に配列の完全な（深い）コピーを得ることができます．

別の配列の一部に対するヘッダを作成します．それは，1 つの行，1 つの列，複数の行，複数の列，配列中の矩形領域（代数学ではマイナーと呼ばれます），または対角線のいずれかです．このような操作も，新しいヘッダが同じデータを参照するため，O(1)となります．この機能を使って，実際に配列の一部を変更することができます．例えば// 5 番目の行に 3 を掛けたものを 3 番目の行に追加するM.row(3) = M.row(3) + M.row(5)*3;// 7 番目の列を 1 番目の列にコピーする// M.col(1) = M.col(7); // これは動作しませんMat M1 = M.col(1);M.col(7).copyTo(M1);// 320x240 の新しい imageMat img(Size(320,240),CV_8UC3);// ROIMat roi(img, Rect(10,10,100,100));// ROI を (0,255,0) (RGB 空間では緑) で埋める．// オリジナルの 320x240 の画像が変更されます． roi = Scalar(0,255,0); 追加の datastart および dataend メンバにより， locateROI() を用いて，メインコンテナ配列内の相対的なサブアレイの位置を計算することができます．Mat A = Mat::eye(10, 10, CV_32S);// A の列，1 (including) から 3 (exclusive) を抽出します．Mat B = A(Range::all(), Range(1, 3));// B の行，5 (including) から 9 (exclusive) を抽出します．locateROI(size, ofs);// size は (width=10,height=10) となり，ofs は (x=1, y=5) 行列全体の場合と同様に，深いコピーが必要な場合は，抽出された部分行列の clone() メソッドを利用します．

ユーザが割り当てたデータのヘッダを作成します。以下のようにすると便利です．

OpenCV を用いて，「外部」のデータを処理します（例えば，DirectShow* のフィルタや，gstreamer の処理モジュールを実装する場合など）．例えば，以下のようになります．Mat process_video_frame(const unsigned char* pixels, int width, int height, int step){ // 入力バッファをラップします． Mat img(height, width, CV_8UC3, (unsigned char*)pixels, step); Mat result; GaussianBlur(img, result, Size(7, 7), 1.5, 1.5); return result;}．

double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};Mat M = Mat(3, 3, CV_64F, m).inv();





MATLAB スタイルの配列初期化子，zeros(), ones(), eye() などを利用します．// 倍精度の単位行列を作成し，それを M.M += Mat::eye(M.rows, M.cols, CV_64F) に追加します．

コンマで区切られたイニシャライザを利用します．// 3x3 の倍精度単位行列を作成します。Mat M = (Mat_<double>(3,3) << 1, 0, 0, 1, 0, 0, 1); この方法では，まず適切なパラメータを指定して Mat クラスのコンストラクタを呼び出し，次に << 演算子の後に定数，変数，式などのコンマで区切られた値を置くだけです．また，コンパイルエラーを避けるために，余分な括弧が必要であることにも注意してください．



配列が作成されると、参照カウントの仕組みによって自動的に管理されます。配列のヘッダがユーザが割り当てたデータの上に構築されている場合は，そのデータを自分で処理する必要があります．配列データは、誰からも指されなくなると解放されます。配列デストラクタが呼ばれる前に，配列ヘッダが指し示すデータを解放したい場合は， Mat::release() を利用してください．

配列クラスについて次に学ぶべき重要なことは，要素へのアクセスです．このマニュアルでは，各配列要素のアドレスを計算する方法を既に説明しました．通常は，コード内で直接その式を使う必要はありません．配列要素の型（メソッド Mat::type() を用いて取得できます）を知っていれば，2 次元配列の要素 \(M_{ij}\) に，次のようにアクセスできます．M.at<double>(i,j) += 1.f; M は倍精度浮動小数点型配列であると仮定します．M.at<double>(i,j) += 1.f; Mは倍精度の浮動小数点配列であると仮定しています。

2 次元配列の行全体を処理する必要がある場合，最も効率的な方法は，最初に行へのポインタを取得し，次に C の単純な演算子 [] を使用することです： // 正の行列要素の総和を求めます // （M が倍精度の行列であると仮定して）double sum=0;for(int i = 0; i < M. .rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < M.cols; j++) sum += std::max(Mi[j], 0.);}．上の例のように，実際には配列の形状に依存しない演算もあります．このような演算は，配列の要素を1つずつ処理するだけです（あるいは，配列の加算など，同じ座標を持つ複数の配列の要素を処理することもあります）．このような操作を「要素ワイズ」と呼びます。すべての入出力配列が連続しているかどうか，つまり，各行の終わりに隙間がないかどうかをチェックすることは意味があります．もしそうであれば，それらを長い1つの行として処理します．// 最適化された正の行列要素の和を求めるtdouble sum=0;int cols = M.cols, rows = M.rows;if(M.isContinuous()){ cols *= rows; rows = 1;}for(int i = 0; i < rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < cols; j++) sum += std::max(Mi[j], 0.);}．連続した行列の場合，外側のループ本体は1回しか実行されません．そのため，オーバーヘッドが小さくなり，特に小さな行列の場合には顕著です．

最後に，連続した行の間のギャップをスキップすることができる STL スタイルのイテレータを紹介します．// 正の行列要素の総和を計算する，イテレータベースのバリアントdouble sum=0;MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();for(; it != it_end; ++it) sum += std::max(*it, 0.); 行列イテレータは，ランダムアクセスイテレータなので，std::sort() を含む，あらゆる STL アルゴリズムに渡すことができます．

注釈matrix Expressions and arithmetic see MatExpr

例： fld_lines.cpp，modules/shape/samples/shape_example.cpp，samples/cpp/camshiftdemo.cpp，samples/cpp/connected_components.cpp，samples/cpp/contours2.cpp，samples/cpp/convexhull.cpp，samples/cpp/cout_mat.cpp，samples/cpp/create_mask.cpp，samples/cpp/demhist.cpp，samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/filestorage.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/intersectExample.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp，samples/cpp/laplace.cpp，samples/cpp/lkdemo.cpp，samples/cpp/minarea.cpp，samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp，samples/cpp/polar_transforms.cpp，samples/cpp/segment_objects.cpp，samples/cpp/squares.cpp，samples/cpp/stitching.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/cpp/tutorial_code/videoio/video-write/video-write.cpp, samples/cpp/videowriter_basic.cpp, samples/cpp/warpPerspective_demo.cpp, samples/cpp/watershed.cpp, samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, samples/dnn/openpose.cpp, samples/dnn/segmentation.cpp, samples/dnn/text_detection.cpp, and samples/tapi/squares.cpp.


元関数名(C#): core_Mat_new4
元DLLエクスポート名: core_Mat_new4
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_new4(cv::Mat *mat, MyCvSlice rowRange, MyCvSlice colRange, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(*mat, cpp(rowRange), cpp(colRange));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_new5
[32/64bit] cv::Mat のインスタンスを生成します
%prm
p1,p2,p3
p1 = sptr : IntPtr mat
p2 = ARGS_RANGE : Range rowRange
p3 = var : out IntPtr returnValue
%inst
n-dimensional dense array クラス

 クラス Mat は，シングルチャンネルまたはマルチチャンネルの，n-dimensional dense 数値配列を表します．これは，実数または複素数のベクトルや行列，グレースケールやカラーの画像，ボクセルボリューム，ベクトルフィールド，点群，テンソル，ヒストグラム（ただし，非常に高次元のヒストグラムは， SparseMat に格納した方が良いかもしれません）を格納するために利用できます．配列 M のデータレイアウトは，配列 M.step[] によって定義されており，要素 ?((i_0,...,i_{M.dims-1})?)のアドレスは，次のように計算されます： ?((i_k<M.size[k]?))

\Addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ...+ M.step[M.dims-1]*i_{M.dims-1}\]



 2次元配列の場合，上の式は次のようになります．

\Addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\]」となります。



 M.step[i] >= M.step[i+1] (実際には、M.step[i] >= M.step[i+1]*M.size[i+1] ) であることに注意してください。つまり，2次元の行列は行ごとに，3次元の行列は面ごとに，それぞれ格納されているということです．M.step[M.dims-1] は最小で，常に要素サイズ M.elemSize() と等しくなります．

つまり，Mat のデータレイアウトは，Numpy (ndarray) や Win32 (independent device bitmaps) などの標準的なツールキットや SDK で提供されている密な配列タイプの大半，つまり，ピクセルの位置を計算するのにステップ（またはストライド）を利用するあらゆる配列と互換性があります．この互換性により，ユーザが割り当てたデータの Mat ヘッダを作成し，OpenCV の関数を使ってその場で処理することができます．

Mat オブジェクトを作成するには，様々な方法があります．最も一般的な方法を以下に示します．



create(nrows, ncols, type) メソッドや，類似の Mat(nrows, ncols, type[, fillValue]) コンストラクタを利用します．type は， cvCreateMat メソッドと同じ意味を持ちます．例えば， CV_8UC1 は 8 ビットシングルチャンネル配列を意味し， CV_32FC2 は 2 チャンネル（複素数）浮動小数点型配列を意味します．// 1+3 で埋め尽くされた 7x7 の複素行列を作成します。j.Mat M(7,7,CV_32FC2,Scalar(1,3));// そして今度は，M を 100x60 の 15 チャンネル 8 ビット行列に変えます。 // 古い内容は解放されます。M.create(100,60,CV_8UC(15)); 本章のイントロダクションで述べたように， create() は，現在の配列の形状や型が指定されたものと異なる場合にのみ，新しい配列を確保します．

多次元の配列を作成します。// 100x100x100 の 8 ビット配列を作成しますint sz[] = {100, 100, 100};Mat bigCube(3, sz, CV_8U, Scalar::all(0)); Mat のコンストラクタに次元数 =1 を渡していますが，作成される配列は列数が 1 の 2 次元になります．

右辺に配列や式が存在する可能性がある場合は，コピーコンストラクタや代入演算子を利用します（後述）．導入部で述べたように，配列の代入は，ヘッダのコピーと参照カウンタの増加だけなので，O(1) の処理です．Mat::clone() メソッドを利用すれば，必要な時に配列の完全な（深い）コピーを得ることができます．

別の配列の一部に対するヘッダを作成します．それは，1 つの行，1 つの列，複数の行，複数の列，配列中の矩形領域（代数学ではマイナーと呼ばれます），または対角線のいずれかです．このような操作も，新しいヘッダが同じデータを参照するため，O(1)となります．この機能を使って，実際に配列の一部を変更することができます．例えば// 5 番目の行に 3 を掛けたものを 3 番目の行に追加するM.row(3) = M.row(3) + M.row(5)*3;// 7 番目の列を 1 番目の列にコピーする// M.col(1) = M.col(7); // これは動作しませんMat M1 = M.col(1);M.col(7).copyTo(M1);// 320x240 の新しい imageMat img(Size(320,240),CV_8UC3);// ROIMat roi(img, Rect(10,10,100,100));// ROI を (0,255,0) (RGB 空間では緑) で埋める．// オリジナルの 320x240 の画像が変更されます． roi = Scalar(0,255,0); 追加の datastart および dataend メンバにより， locateROI() を用いて，メインコンテナ配列内の相対的なサブアレイの位置を計算することができます．Mat A = Mat::eye(10, 10, CV_32S);// A の列，1 (including) から 3 (exclusive) を抽出します．Mat B = A(Range::all(), Range(1, 3));// B の行，5 (including) から 9 (exclusive) を抽出します．locateROI(size, ofs);// size は (width=10,height=10) となり，ofs は (x=1, y=5) 行列全体の場合と同様に，深いコピーが必要な場合は，抽出された部分行列の clone() メソッドを利用します．

ユーザが割り当てたデータのヘッダを作成します。以下のようにすると便利です．

OpenCV を用いて，「外部」のデータを処理します（例えば，DirectShow* のフィルタや，gstreamer の処理モジュールを実装する場合など）．例えば，以下のようになります．Mat process_video_frame(const unsigned char* pixels, int width, int height, int step){ // 入力バッファをラップします． Mat img(height, width, CV_8UC3, (unsigned char*)pixels, step); Mat result; GaussianBlur(img, result, Size(7, 7), 1.5, 1.5); return result;}．

double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};Mat M = Mat(3, 3, CV_64F, m).inv();





MATLAB スタイルの配列初期化子，zeros(), ones(), eye() などを利用します．// 倍精度の単位行列を作成し，それを M.M += Mat::eye(M.rows, M.cols, CV_64F) に追加します．

コンマで区切られたイニシャライザを利用します．// 3x3 の倍精度単位行列を作成します。Mat M = (Mat_<double>(3,3) << 1, 0, 0, 1, 0, 0, 1); この方法では，まず適切なパラメータを指定して Mat クラスのコンストラクタを呼び出し，次に << 演算子の後に定数，変数，式などのコンマで区切られた値を置くだけです．また，コンパイルエラーを避けるために，余分な括弧が必要であることにも注意してください．



配列が作成されると、参照カウントの仕組みによって自動的に管理されます。配列のヘッダがユーザが割り当てたデータの上に構築されている場合は，そのデータを自分で処理する必要があります．配列データは、誰からも指されなくなると解放されます。配列デストラクタが呼ばれる前に，配列ヘッダが指し示すデータを解放したい場合は， Mat::release() を利用してください．

配列クラスについて次に学ぶべき重要なことは，要素へのアクセスです．このマニュアルでは，各配列要素のアドレスを計算する方法を既に説明しました．通常は，コード内で直接その式を使う必要はありません．配列要素の型（メソッド Mat::type() を用いて取得できます）を知っていれば，2 次元配列の要素 \(M_{ij}\) に，次のようにアクセスできます．M.at<double>(i,j) += 1.f; M は倍精度浮動小数点型配列であると仮定します．M.at<double>(i,j) += 1.f; Mは倍精度の浮動小数点配列であると仮定しています。

2 次元配列の行全体を処理する必要がある場合，最も効率的な方法は，最初に行へのポインタを取得し，次に C の単純な演算子 [] を使用することです： // 正の行列要素の総和を求めます // （M が倍精度の行列であると仮定して）double sum=0;for(int i = 0; i < M. .rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < M.cols; j++) sum += std::max(Mi[j], 0.);}．上の例のように，実際には配列の形状に依存しない演算もあります．このような演算は，配列の要素を1つずつ処理するだけです（あるいは，配列の加算など，同じ座標を持つ複数の配列の要素を処理することもあります）．このような操作を「要素ワイズ」と呼びます。すべての入出力配列が連続しているかどうか，つまり，各行の終わりに隙間がないかどうかをチェックすることは意味があります．もしそうであれば，それらを長い1つの行として処理します．// 最適化された正の行列要素の和を求めるtdouble sum=0;int cols = M.cols, rows = M.rows;if(M.isContinuous()){ cols *= rows; rows = 1;}for(int i = 0; i < rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < cols; j++) sum += std::max(Mi[j], 0.);}．連続した行列の場合，外側のループ本体は1回しか実行されません．そのため，オーバーヘッドが小さくなり，特に小さな行列の場合には顕著です．

最後に，連続した行の間のギャップをスキップすることができる STL スタイルのイテレータを紹介します．// 正の行列要素の総和を計算する，イテレータベースのバリアントdouble sum=0;MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();for(; it != it_end; ++it) sum += std::max(*it, 0.); 行列イテレータは，ランダムアクセスイテレータなので，std::sort() を含む，あらゆる STL アルゴリズムに渡すことができます．

注釈matrix Expressions and arithmetic see MatExpr

例： fld_lines.cpp，modules/shape/samples/shape_example.cpp，samples/cpp/camshiftdemo.cpp，samples/cpp/connected_components.cpp，samples/cpp/contours2.cpp，samples/cpp/convexhull.cpp，samples/cpp/cout_mat.cpp，samples/cpp/create_mask.cpp，samples/cpp/demhist.cpp，samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/filestorage.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/intersectExample.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp，samples/cpp/laplace.cpp，samples/cpp/lkdemo.cpp，samples/cpp/minarea.cpp，samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp，samples/cpp/polar_transforms.cpp，samples/cpp/segment_objects.cpp，samples/cpp/squares.cpp，samples/cpp/stitching.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/cpp/tutorial_code/videoio/video-write/video-write.cpp, samples/cpp/videowriter_basic.cpp, samples/cpp/warpPerspective_demo.cpp, samples/cpp/watershed.cpp, samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, samples/dnn/openpose.cpp, samples/dnn/segmentation.cpp, samples/dnn/text_detection.cpp, and samples/tapi/squares.cpp.


元関数名(C#): core_Mat_new5
元DLLエクスポート名: core_Mat_new5
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_new5(cv::Mat *mat, cv::Range rowRange, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(*mat, rowRange);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_new6
[32/64bit] cv::Mat のインスタンスを生成します
%prm
p1,p2,p3
p1 = sptr : IntPtr mat
p2 = var : [MarshalAs(UnmanagedType.LPArray)] Range[] rowRange
p3 = var : out IntPtr returnValue
%inst
n-dimensional dense array クラス

 クラス Mat は，シングルチャンネルまたはマルチチャンネルの，n-dimensional dense 数値配列を表します．これは，実数または複素数のベクトルや行列，グレースケールやカラーの画像，ボクセルボリューム，ベクトルフィールド，点群，テンソル，ヒストグラム（ただし，非常に高次元のヒストグラムは， SparseMat に格納した方が良いかもしれません）を格納するために利用できます．配列 M のデータレイアウトは，配列 M.step[] によって定義されており，要素 ?((i_0,...,i_{M.dims-1})?)のアドレスは，次のように計算されます： ?((i_k<M.size[k]?))

\Addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ...+ M.step[M.dims-1]*i_{M.dims-1}\]



 2次元配列の場合，上の式は次のようになります．

\Addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\]」となります。



 M.step[i] >= M.step[i+1] (実際には、M.step[i] >= M.step[i+1]*M.size[i+1] ) であることに注意してください。つまり，2次元の行列は行ごとに，3次元の行列は面ごとに，それぞれ格納されているということです．M.step[M.dims-1] は最小で，常に要素サイズ M.elemSize() と等しくなります．

つまり，Mat のデータレイアウトは，Numpy (ndarray) や Win32 (independent device bitmaps) などの標準的なツールキットや SDK で提供されている密な配列タイプの大半，つまり，ピクセルの位置を計算するのにステップ（またはストライド）を利用するあらゆる配列と互換性があります．この互換性により，ユーザが割り当てたデータの Mat ヘッダを作成し，OpenCV の関数を使ってその場で処理することができます．

Mat オブジェクトを作成するには，様々な方法があります．最も一般的な方法を以下に示します．



create(nrows, ncols, type) メソッドや，類似の Mat(nrows, ncols, type[, fillValue]) コンストラクタを利用します．type は， cvCreateMat メソッドと同じ意味を持ちます．例えば， CV_8UC1 は 8 ビットシングルチャンネル配列を意味し， CV_32FC2 は 2 チャンネル（複素数）浮動小数点型配列を意味します．// 1+3 で埋め尽くされた 7x7 の複素行列を作成します。j.Mat M(7,7,CV_32FC2,Scalar(1,3));// そして今度は，M を 100x60 の 15 チャンネル 8 ビット行列に変えます。 // 古い内容は解放されます。M.create(100,60,CV_8UC(15)); 本章のイントロダクションで述べたように， create() は，現在の配列の形状や型が指定されたものと異なる場合にのみ，新しい配列を確保します．

多次元の配列を作成します。// 100x100x100 の 8 ビット配列を作成しますint sz[] = {100, 100, 100};Mat bigCube(3, sz, CV_8U, Scalar::all(0)); Mat のコンストラクタに次元数 =1 を渡していますが，作成される配列は列数が 1 の 2 次元になります．

右辺に配列や式が存在する可能性がある場合は，コピーコンストラクタや代入演算子を利用します（後述）．導入部で述べたように，配列の代入は，ヘッダのコピーと参照カウンタの増加だけなので，O(1) の処理です．Mat::clone() メソッドを利用すれば，必要な時に配列の完全な（深い）コピーを得ることができます．

別の配列の一部に対するヘッダを作成します．それは，1 つの行，1 つの列，複数の行，複数の列，配列中の矩形領域（代数学ではマイナーと呼ばれます），または対角線のいずれかです．このような操作も，新しいヘッダが同じデータを参照するため，O(1)となります．この機能を使って，実際に配列の一部を変更することができます．例えば// 5 番目の行に 3 を掛けたものを 3 番目の行に追加するM.row(3) = M.row(3) + M.row(5)*3;// 7 番目の列を 1 番目の列にコピーする// M.col(1) = M.col(7); // これは動作しませんMat M1 = M.col(1);M.col(7).copyTo(M1);// 320x240 の新しい imageMat img(Size(320,240),CV_8UC3);// ROIMat roi(img, Rect(10,10,100,100));// ROI を (0,255,0) (RGB 空間では緑) で埋める．// オリジナルの 320x240 の画像が変更されます． roi = Scalar(0,255,0); 追加の datastart および dataend メンバにより， locateROI() を用いて，メインコンテナ配列内の相対的なサブアレイの位置を計算することができます．Mat A = Mat::eye(10, 10, CV_32S);// A の列，1 (including) から 3 (exclusive) を抽出します．Mat B = A(Range::all(), Range(1, 3));// B の行，5 (including) から 9 (exclusive) を抽出します．locateROI(size, ofs);// size は (width=10,height=10) となり，ofs は (x=1, y=5) 行列全体の場合と同様に，深いコピーが必要な場合は，抽出された部分行列の clone() メソッドを利用します．

ユーザが割り当てたデータのヘッダを作成します。以下のようにすると便利です．

OpenCV を用いて，「外部」のデータを処理します（例えば，DirectShow* のフィルタや，gstreamer の処理モジュールを実装する場合など）．例えば，以下のようになります．Mat process_video_frame(const unsigned char* pixels, int width, int height, int step){ // 入力バッファをラップします． Mat img(height, width, CV_8UC3, (unsigned char*)pixels, step); Mat result; GaussianBlur(img, result, Size(7, 7), 1.5, 1.5); return result;}．

double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};Mat M = Mat(3, 3, CV_64F, m).inv();





MATLAB スタイルの配列初期化子，zeros(), ones(), eye() などを利用します．// 倍精度の単位行列を作成し，それを M.M += Mat::eye(M.rows, M.cols, CV_64F) に追加します．

コンマで区切られたイニシャライザを利用します．// 3x3 の倍精度単位行列を作成します。Mat M = (Mat_<double>(3,3) << 1, 0, 0, 1, 0, 0, 1); この方法では，まず適切なパラメータを指定して Mat クラスのコンストラクタを呼び出し，次に << 演算子の後に定数，変数，式などのコンマで区切られた値を置くだけです．また，コンパイルエラーを避けるために，余分な括弧が必要であることにも注意してください．



配列が作成されると、参照カウントの仕組みによって自動的に管理されます。配列のヘッダがユーザが割り当てたデータの上に構築されている場合は，そのデータを自分で処理する必要があります．配列データは、誰からも指されなくなると解放されます。配列デストラクタが呼ばれる前に，配列ヘッダが指し示すデータを解放したい場合は， Mat::release() を利用してください．

配列クラスについて次に学ぶべき重要なことは，要素へのアクセスです．このマニュアルでは，各配列要素のアドレスを計算する方法を既に説明しました．通常は，コード内で直接その式を使う必要はありません．配列要素の型（メソッド Mat::type() を用いて取得できます）を知っていれば，2 次元配列の要素 \(M_{ij}\) に，次のようにアクセスできます．M.at<double>(i,j) += 1.f; M は倍精度浮動小数点型配列であると仮定します．M.at<double>(i,j) += 1.f; Mは倍精度の浮動小数点配列であると仮定しています。

2 次元配列の行全体を処理する必要がある場合，最も効率的な方法は，最初に行へのポインタを取得し，次に C の単純な演算子 [] を使用することです： // 正の行列要素の総和を求めます // （M が倍精度の行列であると仮定して）double sum=0;for(int i = 0; i < M. .rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < M.cols; j++) sum += std::max(Mi[j], 0.);}．上の例のように，実際には配列の形状に依存しない演算もあります．このような演算は，配列の要素を1つずつ処理するだけです（あるいは，配列の加算など，同じ座標を持つ複数の配列の要素を処理することもあります）．このような操作を「要素ワイズ」と呼びます。すべての入出力配列が連続しているかどうか，つまり，各行の終わりに隙間がないかどうかをチェックすることは意味があります．もしそうであれば，それらを長い1つの行として処理します．// 最適化された正の行列要素の和を求めるtdouble sum=0;int cols = M.cols, rows = M.rows;if(M.isContinuous()){ cols *= rows; rows = 1;}for(int i = 0; i < rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < cols; j++) sum += std::max(Mi[j], 0.);}．連続した行列の場合，外側のループ本体は1回しか実行されません．そのため，オーバーヘッドが小さくなり，特に小さな行列の場合には顕著です．

最後に，連続した行の間のギャップをスキップすることができる STL スタイルのイテレータを紹介します．// 正の行列要素の総和を計算する，イテレータベースのバリアントdouble sum=0;MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();for(; it != it_end; ++it) sum += std::max(*it, 0.); 行列イテレータは，ランダムアクセスイテレータなので，std::sort() を含む，あらゆる STL アルゴリズムに渡すことができます．

注釈matrix Expressions and arithmetic see MatExpr

例： fld_lines.cpp，modules/shape/samples/shape_example.cpp，samples/cpp/camshiftdemo.cpp，samples/cpp/connected_components.cpp，samples/cpp/contours2.cpp，samples/cpp/convexhull.cpp，samples/cpp/cout_mat.cpp，samples/cpp/create_mask.cpp，samples/cpp/demhist.cpp，samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/filestorage.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/intersectExample.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp，samples/cpp/laplace.cpp，samples/cpp/lkdemo.cpp，samples/cpp/minarea.cpp，samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp，samples/cpp/polar_transforms.cpp，samples/cpp/segment_objects.cpp，samples/cpp/squares.cpp，samples/cpp/stitching.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/cpp/tutorial_code/videoio/video-write/video-write.cpp, samples/cpp/videowriter_basic.cpp, samples/cpp/warpPerspective_demo.cpp, samples/cpp/watershed.cpp, samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, samples/dnn/openpose.cpp, samples/dnn/segmentation.cpp, samples/dnn/text_detection.cpp, and samples/tapi/squares.cpp.


元関数名(C#): core_Mat_new6
元DLLエクスポート名: core_Mat_new6
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_new6(cv::Mat *mat, cv::Range *ranges, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(*mat, ranges);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_new7
[32bit] cv::Mat のインスタンスを生成します
%prm
p1,p2,p3
p1 = sptr : IntPtr mat
p2 = ARGS_RECT : Rect roi
p3 = var : out IntPtr returnValue
%inst
n-dimensional dense array クラス

 クラス Mat は，シングルチャンネルまたはマルチチャンネルの，n-dimensional dense 数値配列を表します．これは，実数または複素数のベクトルや行列，グレースケールやカラーの画像，ボクセルボリューム，ベクトルフィールド，点群，テンソル，ヒストグラム（ただし，非常に高次元のヒストグラムは， SparseMat に格納した方が良いかもしれません）を格納するために利用できます．配列 M のデータレイアウトは，配列 M.step[] によって定義されており，要素 ?((i_0,...,i_{M.dims-1})?)のアドレスは，次のように計算されます： ?((i_k<M.size[k]?))

\Addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ...+ M.step[M.dims-1]*i_{M.dims-1}\]



 2次元配列の場合，上の式は次のようになります．

\Addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\]」となります。



 M.step[i] >= M.step[i+1] (実際には、M.step[i] >= M.step[i+1]*M.size[i+1] ) であることに注意してください。つまり，2次元の行列は行ごとに，3次元の行列は面ごとに，それぞれ格納されているということです．M.step[M.dims-1] は最小で，常に要素サイズ M.elemSize() と等しくなります．

つまり，Mat のデータレイアウトは，Numpy (ndarray) や Win32 (independent device bitmaps) などの標準的なツールキットや SDK で提供されている密な配列タイプの大半，つまり，ピクセルの位置を計算するのにステップ（またはストライド）を利用するあらゆる配列と互換性があります．この互換性により，ユーザが割り当てたデータの Mat ヘッダを作成し，OpenCV の関数を使ってその場で処理することができます．

Mat オブジェクトを作成するには，様々な方法があります．最も一般的な方法を以下に示します．



create(nrows, ncols, type) メソッドや，類似の Mat(nrows, ncols, type[, fillValue]) コンストラクタを利用します．type は， cvCreateMat メソッドと同じ意味を持ちます．例えば， CV_8UC1 は 8 ビットシングルチャンネル配列を意味し， CV_32FC2 は 2 チャンネル（複素数）浮動小数点型配列を意味します．// 1+3 で埋め尽くされた 7x7 の複素行列を作成します。j.Mat M(7,7,CV_32FC2,Scalar(1,3));// そして今度は，M を 100x60 の 15 チャンネル 8 ビット行列に変えます。 // 古い内容は解放されます。M.create(100,60,CV_8UC(15)); 本章のイントロダクションで述べたように， create() は，現在の配列の形状や型が指定されたものと異なる場合にのみ，新しい配列を確保します．

多次元の配列を作成します。// 100x100x100 の 8 ビット配列を作成しますint sz[] = {100, 100, 100};Mat bigCube(3, sz, CV_8U, Scalar::all(0)); Mat のコンストラクタに次元数 =1 を渡していますが，作成される配列は列数が 1 の 2 次元になります．

右辺に配列や式が存在する可能性がある場合は，コピーコンストラクタや代入演算子を利用します（後述）．導入部で述べたように，配列の代入は，ヘッダのコピーと参照カウンタの増加だけなので，O(1) の処理です．Mat::clone() メソッドを利用すれば，必要な時に配列の完全な（深い）コピーを得ることができます．

別の配列の一部に対するヘッダを作成します．それは，1 つの行，1 つの列，複数の行，複数の列，配列中の矩形領域（代数学ではマイナーと呼ばれます），または対角線のいずれかです．このような操作も，新しいヘッダが同じデータを参照するため，O(1)となります．この機能を使って，実際に配列の一部を変更することができます．例えば// 5 番目の行に 3 を掛けたものを 3 番目の行に追加するM.row(3) = M.row(3) + M.row(5)*3;// 7 番目の列を 1 番目の列にコピーする// M.col(1) = M.col(7); // これは動作しませんMat M1 = M.col(1);M.col(7).copyTo(M1);// 320x240 の新しい imageMat img(Size(320,240),CV_8UC3);// ROIMat roi(img, Rect(10,10,100,100));// ROI を (0,255,0) (RGB 空間では緑) で埋める．// オリジナルの 320x240 の画像が変更されます． roi = Scalar(0,255,0); 追加の datastart および dataend メンバにより， locateROI() を用いて，メインコンテナ配列内の相対的なサブアレイの位置を計算することができます．Mat A = Mat::eye(10, 10, CV_32S);// A の列，1 (including) から 3 (exclusive) を抽出します．Mat B = A(Range::all(), Range(1, 3));// B の行，5 (including) から 9 (exclusive) を抽出します．locateROI(size, ofs);// size は (width=10,height=10) となり，ofs は (x=1, y=5) 行列全体の場合と同様に，深いコピーが必要な場合は，抽出された部分行列の clone() メソッドを利用します．

ユーザが割り当てたデータのヘッダを作成します。以下のようにすると便利です．

OpenCV を用いて，「外部」のデータを処理します（例えば，DirectShow* のフィルタや，gstreamer の処理モジュールを実装する場合など）．例えば，以下のようになります．Mat process_video_frame(const unsigned char* pixels, int width, int height, int step){ // 入力バッファをラップします． Mat img(height, width, CV_8UC3, (unsigned char*)pixels, step); Mat result; GaussianBlur(img, result, Size(7, 7), 1.5, 1.5); return result;}．

double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};Mat M = Mat(3, 3, CV_64F, m).inv();





MATLAB スタイルの配列初期化子，zeros(), ones(), eye() などを利用します．// 倍精度の単位行列を作成し，それを M.M += Mat::eye(M.rows, M.cols, CV_64F) に追加します．

コンマで区切られたイニシャライザを利用します．// 3x3 の倍精度単位行列を作成します。Mat M = (Mat_<double>(3,3) << 1, 0, 0, 1, 0, 0, 1); この方法では，まず適切なパラメータを指定して Mat クラスのコンストラクタを呼び出し，次に << 演算子の後に定数，変数，式などのコンマで区切られた値を置くだけです．また，コンパイルエラーを避けるために，余分な括弧が必要であることにも注意してください．



配列が作成されると、参照カウントの仕組みによって自動的に管理されます。配列のヘッダがユーザが割り当てたデータの上に構築されている場合は，そのデータを自分で処理する必要があります．配列データは、誰からも指されなくなると解放されます。配列デストラクタが呼ばれる前に，配列ヘッダが指し示すデータを解放したい場合は， Mat::release() を利用してください．

配列クラスについて次に学ぶべき重要なことは，要素へのアクセスです．このマニュアルでは，各配列要素のアドレスを計算する方法を既に説明しました．通常は，コード内で直接その式を使う必要はありません．配列要素の型（メソッド Mat::type() を用いて取得できます）を知っていれば，2 次元配列の要素 \(M_{ij}\) に，次のようにアクセスできます．M.at<double>(i,j) += 1.f; M は倍精度浮動小数点型配列であると仮定します．M.at<double>(i,j) += 1.f; Mは倍精度の浮動小数点配列であると仮定しています。

2 次元配列の行全体を処理する必要がある場合，最も効率的な方法は，最初に行へのポインタを取得し，次に C の単純な演算子 [] を使用することです： // 正の行列要素の総和を求めます // （M が倍精度の行列であると仮定して）double sum=0;for(int i = 0; i < M. .rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < M.cols; j++) sum += std::max(Mi[j], 0.);}．上の例のように，実際には配列の形状に依存しない演算もあります．このような演算は，配列の要素を1つずつ処理するだけです（あるいは，配列の加算など，同じ座標を持つ複数の配列の要素を処理することもあります）．このような操作を「要素ワイズ」と呼びます。すべての入出力配列が連続しているかどうか，つまり，各行の終わりに隙間がないかどうかをチェックすることは意味があります．もしそうであれば，それらを長い1つの行として処理します．// 最適化された正の行列要素の和を求めるtdouble sum=0;int cols = M.cols, rows = M.rows;if(M.isContinuous()){ cols *= rows; rows = 1;}for(int i = 0; i < rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < cols; j++) sum += std::max(Mi[j], 0.);}．連続した行列の場合，外側のループ本体は1回しか実行されません．そのため，オーバーヘッドが小さくなり，特に小さな行列の場合には顕著です．

最後に，連続した行の間のギャップをスキップすることができる STL スタイルのイテレータを紹介します．// 正の行列要素の総和を計算する，イテレータベースのバリアントdouble sum=0;MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();for(; it != it_end; ++it) sum += std::max(*it, 0.); 行列イテレータは，ランダムアクセスイテレータなので，std::sort() を含む，あらゆる STL アルゴリズムに渡すことができます．

注釈matrix Expressions and arithmetic see MatExpr

例： fld_lines.cpp，modules/shape/samples/shape_example.cpp，samples/cpp/camshiftdemo.cpp，samples/cpp/connected_components.cpp，samples/cpp/contours2.cpp，samples/cpp/convexhull.cpp，samples/cpp/cout_mat.cpp，samples/cpp/create_mask.cpp，samples/cpp/demhist.cpp，samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/filestorage.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/intersectExample.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp，samples/cpp/laplace.cpp，samples/cpp/lkdemo.cpp，samples/cpp/minarea.cpp，samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp，samples/cpp/polar_transforms.cpp，samples/cpp/segment_objects.cpp，samples/cpp/squares.cpp，samples/cpp/stitching.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/cpp/tutorial_code/videoio/video-write/video-write.cpp, samples/cpp/videowriter_basic.cpp, samples/cpp/warpPerspective_demo.cpp, samples/cpp/watershed.cpp, samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, samples/dnn/openpose.cpp, samples/dnn/segmentation.cpp, samples/dnn/text_detection.cpp, and samples/tapi/squares.cpp.


元関数名(C#): core_Mat_new7
元DLLエクスポート名: core_Mat_new7
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_new7(cv::Mat *mat, MyCvRect roi, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(*mat, cpp(roi));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_new7
[64bit] cv::Mat のインスタンスを生成します
%prm
p1,p2,p3
p1 = sptr : IntPtr mat
p2 = var : Rect roi
p3 = var : out IntPtr returnValue
%inst
n-dimensional dense array クラス

 クラス Mat は，シングルチャンネルまたはマルチチャンネルの，n-dimensional dense 数値配列を表します．これは，実数または複素数のベクトルや行列，グレースケールやカラーの画像，ボクセルボリューム，ベクトルフィールド，点群，テンソル，ヒストグラム（ただし，非常に高次元のヒストグラムは， SparseMat に格納した方が良いかもしれません）を格納するために利用できます．配列 M のデータレイアウトは，配列 M.step[] によって定義されており，要素 ?((i_0,...,i_{M.dims-1})?)のアドレスは，次のように計算されます： ?((i_k<M.size[k]?))

\Addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ...+ M.step[M.dims-1]*i_{M.dims-1}\]



 2次元配列の場合，上の式は次のようになります．

\Addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\]」となります。



 M.step[i] >= M.step[i+1] (実際には、M.step[i] >= M.step[i+1]*M.size[i+1] ) であることに注意してください。つまり，2次元の行列は行ごとに，3次元の行列は面ごとに，それぞれ格納されているということです．M.step[M.dims-1] は最小で，常に要素サイズ M.elemSize() と等しくなります．

つまり，Mat のデータレイアウトは，Numpy (ndarray) や Win32 (independent device bitmaps) などの標準的なツールキットや SDK で提供されている密な配列タイプの大半，つまり，ピクセルの位置を計算するのにステップ（またはストライド）を利用するあらゆる配列と互換性があります．この互換性により，ユーザが割り当てたデータの Mat ヘッダを作成し，OpenCV の関数を使ってその場で処理することができます．

Mat オブジェクトを作成するには，様々な方法があります．最も一般的な方法を以下に示します．



create(nrows, ncols, type) メソッドや，類似の Mat(nrows, ncols, type[, fillValue]) コンストラクタを利用します．type は， cvCreateMat メソッドと同じ意味を持ちます．例えば， CV_8UC1 は 8 ビットシングルチャンネル配列を意味し， CV_32FC2 は 2 チャンネル（複素数）浮動小数点型配列を意味します．// 1+3 で埋め尽くされた 7x7 の複素行列を作成します。j.Mat M(7,7,CV_32FC2,Scalar(1,3));// そして今度は，M を 100x60 の 15 チャンネル 8 ビット行列に変えます。 // 古い内容は解放されます。M.create(100,60,CV_8UC(15)); 本章のイントロダクションで述べたように， create() は，現在の配列の形状や型が指定されたものと異なる場合にのみ，新しい配列を確保します．

多次元の配列を作成します。// 100x100x100 の 8 ビット配列を作成しますint sz[] = {100, 100, 100};Mat bigCube(3, sz, CV_8U, Scalar::all(0)); Mat のコンストラクタに次元数 =1 を渡していますが，作成される配列は列数が 1 の 2 次元になります．

右辺に配列や式が存在する可能性がある場合は，コピーコンストラクタや代入演算子を利用します（後述）．導入部で述べたように，配列の代入は，ヘッダのコピーと参照カウンタの増加だけなので，O(1) の処理です．Mat::clone() メソッドを利用すれば，必要な時に配列の完全な（深い）コピーを得ることができます．

別の配列の一部に対するヘッダを作成します．それは，1 つの行，1 つの列，複数の行，複数の列，配列中の矩形領域（代数学ではマイナーと呼ばれます），または対角線のいずれかです．このような操作も，新しいヘッダが同じデータを参照するため，O(1)となります．この機能を使って，実際に配列の一部を変更することができます．例えば// 5 番目の行に 3 を掛けたものを 3 番目の行に追加するM.row(3) = M.row(3) + M.row(5)*3;// 7 番目の列を 1 番目の列にコピーする// M.col(1) = M.col(7); // これは動作しませんMat M1 = M.col(1);M.col(7).copyTo(M1);// 320x240 の新しい imageMat img(Size(320,240),CV_8UC3);// ROIMat roi(img, Rect(10,10,100,100));// ROI を (0,255,0) (RGB 空間では緑) で埋める．// オリジナルの 320x240 の画像が変更されます． roi = Scalar(0,255,0); 追加の datastart および dataend メンバにより， locateROI() を用いて，メインコンテナ配列内の相対的なサブアレイの位置を計算することができます．Mat A = Mat::eye(10, 10, CV_32S);// A の列，1 (including) から 3 (exclusive) を抽出します．Mat B = A(Range::all(), Range(1, 3));// B の行，5 (including) から 9 (exclusive) を抽出します．locateROI(size, ofs);// size は (width=10,height=10) となり，ofs は (x=1, y=5) 行列全体の場合と同様に，深いコピーが必要な場合は，抽出された部分行列の clone() メソッドを利用します．

ユーザが割り当てたデータのヘッダを作成します。以下のようにすると便利です．

OpenCV を用いて，「外部」のデータを処理します（例えば，DirectShow* のフィルタや，gstreamer の処理モジュールを実装する場合など）．例えば，以下のようになります．Mat process_video_frame(const unsigned char* pixels, int width, int height, int step){ // 入力バッファをラップします． Mat img(height, width, CV_8UC3, (unsigned char*)pixels, step); Mat result; GaussianBlur(img, result, Size(7, 7), 1.5, 1.5); return result;}．

double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};Mat M = Mat(3, 3, CV_64F, m).inv();





MATLAB スタイルの配列初期化子，zeros(), ones(), eye() などを利用します．// 倍精度の単位行列を作成し，それを M.M += Mat::eye(M.rows, M.cols, CV_64F) に追加します．

コンマで区切られたイニシャライザを利用します．// 3x3 の倍精度単位行列を作成します。Mat M = (Mat_<double>(3,3) << 1, 0, 0, 1, 0, 0, 1); この方法では，まず適切なパラメータを指定して Mat クラスのコンストラクタを呼び出し，次に << 演算子の後に定数，変数，式などのコンマで区切られた値を置くだけです．また，コンパイルエラーを避けるために，余分な括弧が必要であることにも注意してください．



配列が作成されると、参照カウントの仕組みによって自動的に管理されます。配列のヘッダがユーザが割り当てたデータの上に構築されている場合は，そのデータを自分で処理する必要があります．配列データは、誰からも指されなくなると解放されます。配列デストラクタが呼ばれる前に，配列ヘッダが指し示すデータを解放したい場合は， Mat::release() を利用してください．

配列クラスについて次に学ぶべき重要なことは，要素へのアクセスです．このマニュアルでは，各配列要素のアドレスを計算する方法を既に説明しました．通常は，コード内で直接その式を使う必要はありません．配列要素の型（メソッド Mat::type() を用いて取得できます）を知っていれば，2 次元配列の要素 \(M_{ij}\) に，次のようにアクセスできます．M.at<double>(i,j) += 1.f; M は倍精度浮動小数点型配列であると仮定します．M.at<double>(i,j) += 1.f; Mは倍精度の浮動小数点配列であると仮定しています。

2 次元配列の行全体を処理する必要がある場合，最も効率的な方法は，最初に行へのポインタを取得し，次に C の単純な演算子 [] を使用することです： // 正の行列要素の総和を求めます // （M が倍精度の行列であると仮定して）double sum=0;for(int i = 0; i < M. .rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < M.cols; j++) sum += std::max(Mi[j], 0.);}．上の例のように，実際には配列の形状に依存しない演算もあります．このような演算は，配列の要素を1つずつ処理するだけです（あるいは，配列の加算など，同じ座標を持つ複数の配列の要素を処理することもあります）．このような操作を「要素ワイズ」と呼びます。すべての入出力配列が連続しているかどうか，つまり，各行の終わりに隙間がないかどうかをチェックすることは意味があります．もしそうであれば，それらを長い1つの行として処理します．// 最適化された正の行列要素の和を求めるtdouble sum=0;int cols = M.cols, rows = M.rows;if(M.isContinuous()){ cols *= rows; rows = 1;}for(int i = 0; i < rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < cols; j++) sum += std::max(Mi[j], 0.);}．連続した行列の場合，外側のループ本体は1回しか実行されません．そのため，オーバーヘッドが小さくなり，特に小さな行列の場合には顕著です．

最後に，連続した行の間のギャップをスキップすることができる STL スタイルのイテレータを紹介します．// 正の行列要素の総和を計算する，イテレータベースのバリアントdouble sum=0;MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();for(; it != it_end; ++it) sum += std::max(*it, 0.); 行列イテレータは，ランダムアクセスイテレータなので，std::sort() を含む，あらゆる STL アルゴリズムに渡すことができます．

注釈matrix Expressions and arithmetic see MatExpr

例： fld_lines.cpp，modules/shape/samples/shape_example.cpp，samples/cpp/camshiftdemo.cpp，samples/cpp/connected_components.cpp，samples/cpp/contours2.cpp，samples/cpp/convexhull.cpp，samples/cpp/cout_mat.cpp，samples/cpp/create_mask.cpp，samples/cpp/demhist.cpp，samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/filestorage.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/intersectExample.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp，samples/cpp/laplace.cpp，samples/cpp/lkdemo.cpp，samples/cpp/minarea.cpp，samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp，samples/cpp/polar_transforms.cpp，samples/cpp/segment_objects.cpp，samples/cpp/squares.cpp，samples/cpp/stitching.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/cpp/tutorial_code/videoio/video-write/video-write.cpp, samples/cpp/videowriter_basic.cpp, samples/cpp/warpPerspective_demo.cpp, samples/cpp/watershed.cpp, samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, samples/dnn/openpose.cpp, samples/dnn/segmentation.cpp, samples/dnn/text_detection.cpp, and samples/tapi/squares.cpp.


元関数名(C#): core_Mat_new7
元DLLエクスポート名: core_Mat_new7
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_new7(cv::Mat *mat, MyCvRect roi, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(*mat, cpp(roi));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_new8
[32/64bit] cv::Mat のインスタンスを生成します
%prm
p1,p2,p3,p4,p5,p6
p1 = int : int rows
p2 = int : int cols
p3 = int : int type
p4 = sptr : IntPtr data
p5 = sptr : IntPtr step
p6 = var : out IntPtr returnValue
%inst
n-dimensional dense array クラス

 クラス Mat は，シングルチャンネルまたはマルチチャンネルの，n-dimensional dense 数値配列を表します．これは，実数または複素数のベクトルや行列，グレースケールやカラーの画像，ボクセルボリューム，ベクトルフィールド，点群，テンソル，ヒストグラム（ただし，非常に高次元のヒストグラムは， SparseMat に格納した方が良いかもしれません）を格納するために利用できます．配列 M のデータレイアウトは，配列 M.step[] によって定義されており，要素 ?((i_0,...,i_{M.dims-1})?)のアドレスは，次のように計算されます： ?((i_k<M.size[k]?))

\Addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ...+ M.step[M.dims-1]*i_{M.dims-1}\]



 2次元配列の場合，上の式は次のようになります．

\Addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\]」となります。



 M.step[i] >= M.step[i+1] (実際には、M.step[i] >= M.step[i+1]*M.size[i+1] ) であることに注意してください。つまり，2次元の行列は行ごとに，3次元の行列は面ごとに，それぞれ格納されているということです．M.step[M.dims-1] は最小で，常に要素サイズ M.elemSize() と等しくなります．

つまり，Mat のデータレイアウトは，Numpy (ndarray) や Win32 (independent device bitmaps) などの標準的なツールキットや SDK で提供されている密な配列タイプの大半，つまり，ピクセルの位置を計算するのにステップ（またはストライド）を利用するあらゆる配列と互換性があります．この互換性により，ユーザが割り当てたデータの Mat ヘッダを作成し，OpenCV の関数を使ってその場で処理することができます．

Mat オブジェクトを作成するには，様々な方法があります．最も一般的な方法を以下に示します．



create(nrows, ncols, type) メソッドや，類似の Mat(nrows, ncols, type[, fillValue]) コンストラクタを利用します．type は， cvCreateMat メソッドと同じ意味を持ちます．例えば， CV_8UC1 は 8 ビットシングルチャンネル配列を意味し， CV_32FC2 は 2 チャンネル（複素数）浮動小数点型配列を意味します．// 1+3 で埋め尽くされた 7x7 の複素行列を作成します。j.Mat M(7,7,CV_32FC2,Scalar(1,3));// そして今度は，M を 100x60 の 15 チャンネル 8 ビット行列に変えます。 // 古い内容は解放されます。M.create(100,60,CV_8UC(15)); 本章のイントロダクションで述べたように， create() は，現在の配列の形状や型が指定されたものと異なる場合にのみ，新しい配列を確保します．

多次元の配列を作成します。// 100x100x100 の 8 ビット配列を作成しますint sz[] = {100, 100, 100};Mat bigCube(3, sz, CV_8U, Scalar::all(0)); Mat のコンストラクタに次元数 =1 を渡していますが，作成される配列は列数が 1 の 2 次元になります．

右辺に配列や式が存在する可能性がある場合は，コピーコンストラクタや代入演算子を利用します（後述）．導入部で述べたように，配列の代入は，ヘッダのコピーと参照カウンタの増加だけなので，O(1) の処理です．Mat::clone() メソッドを利用すれば，必要な時に配列の完全な（深い）コピーを得ることができます．

別の配列の一部に対するヘッダを作成します．それは，1 つの行，1 つの列，複数の行，複数の列，配列中の矩形領域（代数学ではマイナーと呼ばれます），または対角線のいずれかです．このような操作も，新しいヘッダが同じデータを参照するため，O(1)となります．この機能を使って，実際に配列の一部を変更することができます．例えば// 5 番目の行に 3 を掛けたものを 3 番目の行に追加するM.row(3) = M.row(3) + M.row(5)*3;// 7 番目の列を 1 番目の列にコピーする// M.col(1) = M.col(7); // これは動作しませんMat M1 = M.col(1);M.col(7).copyTo(M1);// 320x240 の新しい imageMat img(Size(320,240),CV_8UC3);// ROIMat roi(img, Rect(10,10,100,100));// ROI を (0,255,0) (RGB 空間では緑) で埋める．// オリジナルの 320x240 の画像が変更されます． roi = Scalar(0,255,0); 追加の datastart および dataend メンバにより， locateROI() を用いて，メインコンテナ配列内の相対的なサブアレイの位置を計算することができます．Mat A = Mat::eye(10, 10, CV_32S);// A の列，1 (including) から 3 (exclusive) を抽出します．Mat B = A(Range::all(), Range(1, 3));// B の行，5 (including) から 9 (exclusive) を抽出します．locateROI(size, ofs);// size は (width=10,height=10) となり，ofs は (x=1, y=5) 行列全体の場合と同様に，深いコピーが必要な場合は，抽出された部分行列の clone() メソッドを利用します．

ユーザが割り当てたデータのヘッダを作成します。以下のようにすると便利です．

OpenCV を用いて，「外部」のデータを処理します（例えば，DirectShow* のフィルタや，gstreamer の処理モジュールを実装する場合など）．例えば，以下のようになります．Mat process_video_frame(const unsigned char* pixels, int width, int height, int step){ // 入力バッファをラップします． Mat img(height, width, CV_8UC3, (unsigned char*)pixels, step); Mat result; GaussianBlur(img, result, Size(7, 7), 1.5, 1.5); return result;}．

double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};Mat M = Mat(3, 3, CV_64F, m).inv();





MATLAB スタイルの配列初期化子，zeros(), ones(), eye() などを利用します．// 倍精度の単位行列を作成し，それを M.M += Mat::eye(M.rows, M.cols, CV_64F) に追加します．

コンマで区切られたイニシャライザを利用します．// 3x3 の倍精度単位行列を作成します。Mat M = (Mat_<double>(3,3) << 1, 0, 0, 1, 0, 0, 1); この方法では，まず適切なパラメータを指定して Mat クラスのコンストラクタを呼び出し，次に << 演算子の後に定数，変数，式などのコンマで区切られた値を置くだけです．また，コンパイルエラーを避けるために，余分な括弧が必要であることにも注意してください．



配列が作成されると、参照カウントの仕組みによって自動的に管理されます。配列のヘッダがユーザが割り当てたデータの上に構築されている場合は，そのデータを自分で処理する必要があります．配列データは、誰からも指されなくなると解放されます。配列デストラクタが呼ばれる前に，配列ヘッダが指し示すデータを解放したい場合は， Mat::release() を利用してください．

配列クラスについて次に学ぶべき重要なことは，要素へのアクセスです．このマニュアルでは，各配列要素のアドレスを計算する方法を既に説明しました．通常は，コード内で直接その式を使う必要はありません．配列要素の型（メソッド Mat::type() を用いて取得できます）を知っていれば，2 次元配列の要素 \(M_{ij}\) に，次のようにアクセスできます．M.at<double>(i,j) += 1.f; M は倍精度浮動小数点型配列であると仮定します．M.at<double>(i,j) += 1.f; Mは倍精度の浮動小数点配列であると仮定しています。

2 次元配列の行全体を処理する必要がある場合，最も効率的な方法は，最初に行へのポインタを取得し，次に C の単純な演算子 [] を使用することです： // 正の行列要素の総和を求めます // （M が倍精度の行列であると仮定して）double sum=0;for(int i = 0; i < M. .rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < M.cols; j++) sum += std::max(Mi[j], 0.);}．上の例のように，実際には配列の形状に依存しない演算もあります．このような演算は，配列の要素を1つずつ処理するだけです（あるいは，配列の加算など，同じ座標を持つ複数の配列の要素を処理することもあります）．このような操作を「要素ワイズ」と呼びます。すべての入出力配列が連続しているかどうか，つまり，各行の終わりに隙間がないかどうかをチェックすることは意味があります．もしそうであれば，それらを長い1つの行として処理します．// 最適化された正の行列要素の和を求めるtdouble sum=0;int cols = M.cols, rows = M.rows;if(M.isContinuous()){ cols *= rows; rows = 1;}for(int i = 0; i < rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < cols; j++) sum += std::max(Mi[j], 0.);}．連続した行列の場合，外側のループ本体は1回しか実行されません．そのため，オーバーヘッドが小さくなり，特に小さな行列の場合には顕著です．

最後に，連続した行の間のギャップをスキップすることができる STL スタイルのイテレータを紹介します．// 正の行列要素の総和を計算する，イテレータベースのバリアントdouble sum=0;MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();for(; it != it_end; ++it) sum += std::max(*it, 0.); 行列イテレータは，ランダムアクセスイテレータなので，std::sort() を含む，あらゆる STL アルゴリズムに渡すことができます．

注釈matrix Expressions and arithmetic see MatExpr

例： fld_lines.cpp，modules/shape/samples/shape_example.cpp，samples/cpp/camshiftdemo.cpp，samples/cpp/connected_components.cpp，samples/cpp/contours2.cpp，samples/cpp/convexhull.cpp，samples/cpp/cout_mat.cpp，samples/cpp/create_mask.cpp，samples/cpp/demhist.cpp，samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/filestorage.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/intersectExample.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp，samples/cpp/laplace.cpp，samples/cpp/lkdemo.cpp，samples/cpp/minarea.cpp，samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp，samples/cpp/polar_transforms.cpp，samples/cpp/segment_objects.cpp，samples/cpp/squares.cpp，samples/cpp/stitching.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/cpp/tutorial_code/videoio/video-write/video-write.cpp, samples/cpp/videowriter_basic.cpp, samples/cpp/warpPerspective_demo.cpp, samples/cpp/watershed.cpp, samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, samples/dnn/openpose.cpp, samples/dnn/segmentation.cpp, samples/dnn/text_detection.cpp, and samples/tapi/squares.cpp.


元関数名(C#): core_Mat_new8
元DLLエクスポート名: core_Mat_new8
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_new8(int rows, int cols, int type, void* data, size_t step, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(rows, cols, type, data, step);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_new9
[32/64bit] cv::Mat のインスタンスを生成します
%prm
p1,p2,p3,p4,p5,p6
p1 = int : int ndims
p2 = var : [MarshalAs(UnmanagedType.LPArray)] int[] sizes
p3 = int : int type
p4 = sptr : IntPtr data
p5 = sptr : [MarshalAs(UnmanagedType.LPArray)] IntPtr[] steps
p6 = var : out IntPtr returnValue
%inst
n-dimensional dense array クラス

 クラス Mat は，シングルチャンネルまたはマルチチャンネルの，n-dimensional dense 数値配列を表します．これは，実数または複素数のベクトルや行列，グレースケールやカラーの画像，ボクセルボリューム，ベクトルフィールド，点群，テンソル，ヒストグラム（ただし，非常に高次元のヒストグラムは， SparseMat に格納した方が良いかもしれません）を格納するために利用できます．配列 M のデータレイアウトは，配列 M.step[] によって定義されており，要素 ?((i_0,...,i_{M.dims-1})?)のアドレスは，次のように計算されます： ?((i_k<M.size[k]?))

\Addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ...+ M.step[M.dims-1]*i_{M.dims-1}\]



 2次元配列の場合，上の式は次のようになります．

\Addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\]」となります。



 M.step[i] >= M.step[i+1] (実際には、M.step[i] >= M.step[i+1]*M.size[i+1] ) であることに注意してください。つまり，2次元の行列は行ごとに，3次元の行列は面ごとに，それぞれ格納されているということです．M.step[M.dims-1] は最小で，常に要素サイズ M.elemSize() と等しくなります．

つまり，Mat のデータレイアウトは，Numpy (ndarray) や Win32 (independent device bitmaps) などの標準的なツールキットや SDK で提供されている密な配列タイプの大半，つまり，ピクセルの位置を計算するのにステップ（またはストライド）を利用するあらゆる配列と互換性があります．この互換性により，ユーザが割り当てたデータの Mat ヘッダを作成し，OpenCV の関数を使ってその場で処理することができます．

Mat オブジェクトを作成するには，様々な方法があります．最も一般的な方法を以下に示します．



create(nrows, ncols, type) メソッドや，類似の Mat(nrows, ncols, type[, fillValue]) コンストラクタを利用します．type は， cvCreateMat メソッドと同じ意味を持ちます．例えば， CV_8UC1 は 8 ビットシングルチャンネル配列を意味し， CV_32FC2 は 2 チャンネル（複素数）浮動小数点型配列を意味します．// 1+3 で埋め尽くされた 7x7 の複素行列を作成します。j.Mat M(7,7,CV_32FC2,Scalar(1,3));// そして今度は，M を 100x60 の 15 チャンネル 8 ビット行列に変えます。 // 古い内容は解放されます。M.create(100,60,CV_8UC(15)); 本章のイントロダクションで述べたように， create() は，現在の配列の形状や型が指定されたものと異なる場合にのみ，新しい配列を確保します．

多次元の配列を作成します。// 100x100x100 の 8 ビット配列を作成しますint sz[] = {100, 100, 100};Mat bigCube(3, sz, CV_8U, Scalar::all(0)); Mat のコンストラクタに次元数 =1 を渡していますが，作成される配列は列数が 1 の 2 次元になります．

右辺に配列や式が存在する可能性がある場合は，コピーコンストラクタや代入演算子を利用します（後述）．導入部で述べたように，配列の代入は，ヘッダのコピーと参照カウンタの増加だけなので，O(1) の処理です．Mat::clone() メソッドを利用すれば，必要な時に配列の完全な（深い）コピーを得ることができます．

別の配列の一部に対するヘッダを作成します．それは，1 つの行，1 つの列，複数の行，複数の列，配列中の矩形領域（代数学ではマイナーと呼ばれます），または対角線のいずれかです．このような操作も，新しいヘッダが同じデータを参照するため，O(1)となります．この機能を使って，実際に配列の一部を変更することができます．例えば// 5 番目の行に 3 を掛けたものを 3 番目の行に追加するM.row(3) = M.row(3) + M.row(5)*3;// 7 番目の列を 1 番目の列にコピーする// M.col(1) = M.col(7); // これは動作しませんMat M1 = M.col(1);M.col(7).copyTo(M1);// 320x240 の新しい imageMat img(Size(320,240),CV_8UC3);// ROIMat roi(img, Rect(10,10,100,100));// ROI を (0,255,0) (RGB 空間では緑) で埋める．// オリジナルの 320x240 の画像が変更されます． roi = Scalar(0,255,0); 追加の datastart および dataend メンバにより， locateROI() を用いて，メインコンテナ配列内の相対的なサブアレイの位置を計算することができます．Mat A = Mat::eye(10, 10, CV_32S);// A の列，1 (including) から 3 (exclusive) を抽出します．Mat B = A(Range::all(), Range(1, 3));// B の行，5 (including) から 9 (exclusive) を抽出します．locateROI(size, ofs);// size は (width=10,height=10) となり，ofs は (x=1, y=5) 行列全体の場合と同様に，深いコピーが必要な場合は，抽出された部分行列の clone() メソッドを利用します．

ユーザが割り当てたデータのヘッダを作成します。以下のようにすると便利です．

OpenCV を用いて，「外部」のデータを処理します（例えば，DirectShow* のフィルタや，gstreamer の処理モジュールを実装する場合など）．例えば，以下のようになります．Mat process_video_frame(const unsigned char* pixels, int width, int height, int step){ // 入力バッファをラップします． Mat img(height, width, CV_8UC3, (unsigned char*)pixels, step); Mat result; GaussianBlur(img, result, Size(7, 7), 1.5, 1.5); return result;}．

double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};Mat M = Mat(3, 3, CV_64F, m).inv();





MATLAB スタイルの配列初期化子，zeros(), ones(), eye() などを利用します．// 倍精度の単位行列を作成し，それを M.M += Mat::eye(M.rows, M.cols, CV_64F) に追加します．

コンマで区切られたイニシャライザを利用します．// 3x3 の倍精度単位行列を作成します。Mat M = (Mat_<double>(3,3) << 1, 0, 0, 1, 0, 0, 1); この方法では，まず適切なパラメータを指定して Mat クラスのコンストラクタを呼び出し，次に << 演算子の後に定数，変数，式などのコンマで区切られた値を置くだけです．また，コンパイルエラーを避けるために，余分な括弧が必要であることにも注意してください．



配列が作成されると、参照カウントの仕組みによって自動的に管理されます。配列のヘッダがユーザが割り当てたデータの上に構築されている場合は，そのデータを自分で処理する必要があります．配列データは、誰からも指されなくなると解放されます。配列デストラクタが呼ばれる前に，配列ヘッダが指し示すデータを解放したい場合は， Mat::release() を利用してください．

配列クラスについて次に学ぶべき重要なことは，要素へのアクセスです．このマニュアルでは，各配列要素のアドレスを計算する方法を既に説明しました．通常は，コード内で直接その式を使う必要はありません．配列要素の型（メソッド Mat::type() を用いて取得できます）を知っていれば，2 次元配列の要素 \(M_{ij}\) に，次のようにアクセスできます．M.at<double>(i,j) += 1.f; M は倍精度浮動小数点型配列であると仮定します．M.at<double>(i,j) += 1.f; Mは倍精度の浮動小数点配列であると仮定しています。

2 次元配列の行全体を処理する必要がある場合，最も効率的な方法は，最初に行へのポインタを取得し，次に C の単純な演算子 [] を使用することです： // 正の行列要素の総和を求めます // （M が倍精度の行列であると仮定して）double sum=0;for(int i = 0; i < M. .rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < M.cols; j++) sum += std::max(Mi[j], 0.);}．上の例のように，実際には配列の形状に依存しない演算もあります．このような演算は，配列の要素を1つずつ処理するだけです（あるいは，配列の加算など，同じ座標を持つ複数の配列の要素を処理することもあります）．このような操作を「要素ワイズ」と呼びます。すべての入出力配列が連続しているかどうか，つまり，各行の終わりに隙間がないかどうかをチェックすることは意味があります．もしそうであれば，それらを長い1つの行として処理します．// 最適化された正の行列要素の和を求めるtdouble sum=0;int cols = M.cols, rows = M.rows;if(M.isContinuous()){ cols *= rows; rows = 1;}for(int i = 0; i < rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < cols; j++) sum += std::max(Mi[j], 0.);}．連続した行列の場合，外側のループ本体は1回しか実行されません．そのため，オーバーヘッドが小さくなり，特に小さな行列の場合には顕著です．

最後に，連続した行の間のギャップをスキップすることができる STL スタイルのイテレータを紹介します．// 正の行列要素の総和を計算する，イテレータベースのバリアントdouble sum=0;MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();for(; it != it_end; ++it) sum += std::max(*it, 0.); 行列イテレータは，ランダムアクセスイテレータなので，std::sort() を含む，あらゆる STL アルゴリズムに渡すことができます．

注釈matrix Expressions and arithmetic see MatExpr

例： fld_lines.cpp，modules/shape/samples/shape_example.cpp，samples/cpp/camshiftdemo.cpp，samples/cpp/connected_components.cpp，samples/cpp/contours2.cpp，samples/cpp/convexhull.cpp，samples/cpp/cout_mat.cpp，samples/cpp/create_mask.cpp，samples/cpp/demhist.cpp，samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/filestorage.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/intersectExample.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp，samples/cpp/laplace.cpp，samples/cpp/lkdemo.cpp，samples/cpp/minarea.cpp，samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp，samples/cpp/polar_transforms.cpp，samples/cpp/segment_objects.cpp，samples/cpp/squares.cpp，samples/cpp/stitching.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/cpp/tutorial_code/videoio/video-write/video-write.cpp, samples/cpp/videowriter_basic.cpp, samples/cpp/warpPerspective_demo.cpp, samples/cpp/watershed.cpp, samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, samples/dnn/openpose.cpp, samples/dnn/segmentation.cpp, samples/dnn/text_detection.cpp, and samples/tapi/squares.cpp.


元関数名(C#): core_Mat_new9
元DLLエクスポート名: core_Mat_new9
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_new9(int ndims, const int* sizes, int type, void* data, const size_t* steps, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(ndims, sizes, type, data, steps);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_new10
[32/64bit] cv::Mat のインスタンスを生成します
%prm
p1,p2,p3,p4
p1 = int : int ndims
p2 = var : [MarshalAs(UnmanagedType.LPArray)] int[] sizes
p3 = int : int type
p4 = var : out IntPtr returnValue
%inst
n-dimensional dense array クラス

 クラス Mat は，シングルチャンネルまたはマルチチャンネルの，n-dimensional dense 数値配列を表します．これは，実数または複素数のベクトルや行列，グレースケールやカラーの画像，ボクセルボリューム，ベクトルフィールド，点群，テンソル，ヒストグラム（ただし，非常に高次元のヒストグラムは， SparseMat に格納した方が良いかもしれません）を格納するために利用できます．配列 M のデータレイアウトは，配列 M.step[] によって定義されており，要素 ?((i_0,...,i_{M.dims-1})?)のアドレスは，次のように計算されます： ?((i_k<M.size[k]?))

\Addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ...+ M.step[M.dims-1]*i_{M.dims-1}\]



 2次元配列の場合，上の式は次のようになります．

\Addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\]」となります。



 M.step[i] >= M.step[i+1] (実際には、M.step[i] >= M.step[i+1]*M.size[i+1] ) であることに注意してください。つまり，2次元の行列は行ごとに，3次元の行列は面ごとに，それぞれ格納されているということです．M.step[M.dims-1] は最小で，常に要素サイズ M.elemSize() と等しくなります．

つまり，Mat のデータレイアウトは，Numpy (ndarray) や Win32 (independent device bitmaps) などの標準的なツールキットや SDK で提供されている密な配列タイプの大半，つまり，ピクセルの位置を計算するのにステップ（またはストライド）を利用するあらゆる配列と互換性があります．この互換性により，ユーザが割り当てたデータの Mat ヘッダを作成し，OpenCV の関数を使ってその場で処理することができます．

Mat オブジェクトを作成するには，様々な方法があります．最も一般的な方法を以下に示します．



create(nrows, ncols, type) メソッドや，類似の Mat(nrows, ncols, type[, fillValue]) コンストラクタを利用します．type は， cvCreateMat メソッドと同じ意味を持ちます．例えば， CV_8UC1 は 8 ビットシングルチャンネル配列を意味し， CV_32FC2 は 2 チャンネル（複素数）浮動小数点型配列を意味します．// 1+3 で埋め尽くされた 7x7 の複素行列を作成します。j.Mat M(7,7,CV_32FC2,Scalar(1,3));// そして今度は，M を 100x60 の 15 チャンネル 8 ビット行列に変えます。 // 古い内容は解放されます。M.create(100,60,CV_8UC(15)); 本章のイントロダクションで述べたように， create() は，現在の配列の形状や型が指定されたものと異なる場合にのみ，新しい配列を確保します．

多次元の配列を作成します。// 100x100x100 の 8 ビット配列を作成しますint sz[] = {100, 100, 100};Mat bigCube(3, sz, CV_8U, Scalar::all(0)); Mat のコンストラクタに次元数 =1 を渡していますが，作成される配列は列数が 1 の 2 次元になります．

右辺に配列や式が存在する可能性がある場合は，コピーコンストラクタや代入演算子を利用します（後述）．導入部で述べたように，配列の代入は，ヘッダのコピーと参照カウンタの増加だけなので，O(1) の処理です．Mat::clone() メソッドを利用すれば，必要な時に配列の完全な（深い）コピーを得ることができます．

別の配列の一部に対するヘッダを作成します．それは，1 つの行，1 つの列，複数の行，複数の列，配列中の矩形領域（代数学ではマイナーと呼ばれます），または対角線のいずれかです．このような操作も，新しいヘッダが同じデータを参照するため，O(1)となります．この機能を使って，実際に配列の一部を変更することができます．例えば// 5 番目の行に 3 を掛けたものを 3 番目の行に追加するM.row(3) = M.row(3) + M.row(5)*3;// 7 番目の列を 1 番目の列にコピーする// M.col(1) = M.col(7); // これは動作しませんMat M1 = M.col(1);M.col(7).copyTo(M1);// 320x240 の新しい imageMat img(Size(320,240),CV_8UC3);// ROIMat roi(img, Rect(10,10,100,100));// ROI を (0,255,0) (RGB 空間では緑) で埋める．// オリジナルの 320x240 の画像が変更されます． roi = Scalar(0,255,0); 追加の datastart および dataend メンバにより， locateROI() を用いて，メインコンテナ配列内の相対的なサブアレイの位置を計算することができます．Mat A = Mat::eye(10, 10, CV_32S);// A の列，1 (including) から 3 (exclusive) を抽出します．Mat B = A(Range::all(), Range(1, 3));// B の行，5 (including) から 9 (exclusive) を抽出します．locateROI(size, ofs);// size は (width=10,height=10) となり，ofs は (x=1, y=5) 行列全体の場合と同様に，深いコピーが必要な場合は，抽出された部分行列の clone() メソッドを利用します．

ユーザが割り当てたデータのヘッダを作成します。以下のようにすると便利です．

OpenCV を用いて，「外部」のデータを処理します（例えば，DirectShow* のフィルタや，gstreamer の処理モジュールを実装する場合など）．例えば，以下のようになります．Mat process_video_frame(const unsigned char* pixels, int width, int height, int step){ // 入力バッファをラップします． Mat img(height, width, CV_8UC3, (unsigned char*)pixels, step); Mat result; GaussianBlur(img, result, Size(7, 7), 1.5, 1.5); return result;}．

double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};Mat M = Mat(3, 3, CV_64F, m).inv();





MATLAB スタイルの配列初期化子，zeros(), ones(), eye() などを利用します．// 倍精度の単位行列を作成し，それを M.M += Mat::eye(M.rows, M.cols, CV_64F) に追加します．

コンマで区切られたイニシャライザを利用します．// 3x3 の倍精度単位行列を作成します。Mat M = (Mat_<double>(3,3) << 1, 0, 0, 1, 0, 0, 1); この方法では，まず適切なパラメータを指定して Mat クラスのコンストラクタを呼び出し，次に << 演算子の後に定数，変数，式などのコンマで区切られた値を置くだけです．また，コンパイルエラーを避けるために，余分な括弧が必要であることにも注意してください．



配列が作成されると、参照カウントの仕組みによって自動的に管理されます。配列のヘッダがユーザが割り当てたデータの上に構築されている場合は，そのデータを自分で処理する必要があります．配列データは、誰からも指されなくなると解放されます。配列デストラクタが呼ばれる前に，配列ヘッダが指し示すデータを解放したい場合は， Mat::release() を利用してください．

配列クラスについて次に学ぶべき重要なことは，要素へのアクセスです．このマニュアルでは，各配列要素のアドレスを計算する方法を既に説明しました．通常は，コード内で直接その式を使う必要はありません．配列要素の型（メソッド Mat::type() を用いて取得できます）を知っていれば，2 次元配列の要素 \(M_{ij}\) に，次のようにアクセスできます．M.at<double>(i,j) += 1.f; M は倍精度浮動小数点型配列であると仮定します．M.at<double>(i,j) += 1.f; Mは倍精度の浮動小数点配列であると仮定しています。

2 次元配列の行全体を処理する必要がある場合，最も効率的な方法は，最初に行へのポインタを取得し，次に C の単純な演算子 [] を使用することです： // 正の行列要素の総和を求めます // （M が倍精度の行列であると仮定して）double sum=0;for(int i = 0; i < M. .rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < M.cols; j++) sum += std::max(Mi[j], 0.);}．上の例のように，実際には配列の形状に依存しない演算もあります．このような演算は，配列の要素を1つずつ処理するだけです（あるいは，配列の加算など，同じ座標を持つ複数の配列の要素を処理することもあります）．このような操作を「要素ワイズ」と呼びます。すべての入出力配列が連続しているかどうか，つまり，各行の終わりに隙間がないかどうかをチェックすることは意味があります．もしそうであれば，それらを長い1つの行として処理します．// 最適化された正の行列要素の和を求めるtdouble sum=0;int cols = M.cols, rows = M.rows;if(M.isContinuous()){ cols *= rows; rows = 1;}for(int i = 0; i < rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < cols; j++) sum += std::max(Mi[j], 0.);}．連続した行列の場合，外側のループ本体は1回しか実行されません．そのため，オーバーヘッドが小さくなり，特に小さな行列の場合には顕著です．

最後に，連続した行の間のギャップをスキップすることができる STL スタイルのイテレータを紹介します．// 正の行列要素の総和を計算する，イテレータベースのバリアントdouble sum=0;MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();for(; it != it_end; ++it) sum += std::max(*it, 0.); 行列イテレータは，ランダムアクセスイテレータなので，std::sort() を含む，あらゆる STL アルゴリズムに渡すことができます．

注釈matrix Expressions and arithmetic see MatExpr

例： fld_lines.cpp，modules/shape/samples/shape_example.cpp，samples/cpp/camshiftdemo.cpp，samples/cpp/connected_components.cpp，samples/cpp/contours2.cpp，samples/cpp/convexhull.cpp，samples/cpp/cout_mat.cpp，samples/cpp/create_mask.cpp，samples/cpp/demhist.cpp，samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/filestorage.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/intersectExample.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp，samples/cpp/laplace.cpp，samples/cpp/lkdemo.cpp，samples/cpp/minarea.cpp，samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp，samples/cpp/polar_transforms.cpp，samples/cpp/segment_objects.cpp，samples/cpp/squares.cpp，samples/cpp/stitching.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/cpp/tutorial_code/videoio/video-write/video-write.cpp, samples/cpp/videowriter_basic.cpp, samples/cpp/warpPerspective_demo.cpp, samples/cpp/watershed.cpp, samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, samples/dnn/openpose.cpp, samples/dnn/segmentation.cpp, samples/dnn/text_detection.cpp, and samples/tapi/squares.cpp.


元関数名(C#): core_Mat_new10
元DLLエクスポート名: core_Mat_new10
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_new10(int ndims, int* sizes, int type, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(ndims, sizes, type);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_new11
[32bit] cv::Mat のインスタンスを生成します
%prm
p1,p2,p3,p4,p5
p1 = int : int ndims
p2 = var : [MarshalAs(UnmanagedType.LPArray)] int[] sizes
p3 = int : int type
p4 = ARGS_SCALAR : Scalar s
p5 = var : out IntPtr returnValue
%inst
n-dimensional dense array クラス

 クラス Mat は，シングルチャンネルまたはマルチチャンネルの，n-dimensional dense 数値配列を表します．これは，実数または複素数のベクトルや行列，グレースケールやカラーの画像，ボクセルボリューム，ベクトルフィールド，点群，テンソル，ヒストグラム（ただし，非常に高次元のヒストグラムは， SparseMat に格納した方が良いかもしれません）を格納するために利用できます．配列 M のデータレイアウトは，配列 M.step[] によって定義されており，要素 ?((i_0,...,i_{M.dims-1})?)のアドレスは，次のように計算されます： ?((i_k<M.size[k]?))

\Addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ...+ M.step[M.dims-1]*i_{M.dims-1}\]



 2次元配列の場合，上の式は次のようになります．

\Addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\]」となります。



 M.step[i] >= M.step[i+1] (実際には、M.step[i] >= M.step[i+1]*M.size[i+1] ) であることに注意してください。つまり，2次元の行列は行ごとに，3次元の行列は面ごとに，それぞれ格納されているということです．M.step[M.dims-1] は最小で，常に要素サイズ M.elemSize() と等しくなります．

つまり，Mat のデータレイアウトは，Numpy (ndarray) や Win32 (independent device bitmaps) などの標準的なツールキットや SDK で提供されている密な配列タイプの大半，つまり，ピクセルの位置を計算するのにステップ（またはストライド）を利用するあらゆる配列と互換性があります．この互換性により，ユーザが割り当てたデータの Mat ヘッダを作成し，OpenCV の関数を使ってその場で処理することができます．

Mat オブジェクトを作成するには，様々な方法があります．最も一般的な方法を以下に示します．



create(nrows, ncols, type) メソッドや，類似の Mat(nrows, ncols, type[, fillValue]) コンストラクタを利用します．type は， cvCreateMat メソッドと同じ意味を持ちます．例えば， CV_8UC1 は 8 ビットシングルチャンネル配列を意味し， CV_32FC2 は 2 チャンネル（複素数）浮動小数点型配列を意味します．// 1+3 で埋め尽くされた 7x7 の複素行列を作成します。j.Mat M(7,7,CV_32FC2,Scalar(1,3));// そして今度は，M を 100x60 の 15 チャンネル 8 ビット行列に変えます。 // 古い内容は解放されます。M.create(100,60,CV_8UC(15)); 本章のイントロダクションで述べたように， create() は，現在の配列の形状や型が指定されたものと異なる場合にのみ，新しい配列を確保します．

多次元の配列を作成します。// 100x100x100 の 8 ビット配列を作成しますint sz[] = {100, 100, 100};Mat bigCube(3, sz, CV_8U, Scalar::all(0)); Mat のコンストラクタに次元数 =1 を渡していますが，作成される配列は列数が 1 の 2 次元になります．

右辺に配列や式が存在する可能性がある場合は，コピーコンストラクタや代入演算子を利用します（後述）．導入部で述べたように，配列の代入は，ヘッダのコピーと参照カウンタの増加だけなので，O(1) の処理です．Mat::clone() メソッドを利用すれば，必要な時に配列の完全な（深い）コピーを得ることができます．

別の配列の一部に対するヘッダを作成します．それは，1 つの行，1 つの列，複数の行，複数の列，配列中の矩形領域（代数学ではマイナーと呼ばれます），または対角線のいずれかです．このような操作も，新しいヘッダが同じデータを参照するため，O(1)となります．この機能を使って，実際に配列の一部を変更することができます．例えば// 5 番目の行に 3 を掛けたものを 3 番目の行に追加するM.row(3) = M.row(3) + M.row(5)*3;// 7 番目の列を 1 番目の列にコピーする// M.col(1) = M.col(7); // これは動作しませんMat M1 = M.col(1);M.col(7).copyTo(M1);// 320x240 の新しい imageMat img(Size(320,240),CV_8UC3);// ROIMat roi(img, Rect(10,10,100,100));// ROI を (0,255,0) (RGB 空間では緑) で埋める．// オリジナルの 320x240 の画像が変更されます． roi = Scalar(0,255,0); 追加の datastart および dataend メンバにより， locateROI() を用いて，メインコンテナ配列内の相対的なサブアレイの位置を計算することができます．Mat A = Mat::eye(10, 10, CV_32S);// A の列，1 (including) から 3 (exclusive) を抽出します．Mat B = A(Range::all(), Range(1, 3));// B の行，5 (including) から 9 (exclusive) を抽出します．locateROI(size, ofs);// size は (width=10,height=10) となり，ofs は (x=1, y=5) 行列全体の場合と同様に，深いコピーが必要な場合は，抽出された部分行列の clone() メソッドを利用します．

ユーザが割り当てたデータのヘッダを作成します。以下のようにすると便利です．

OpenCV を用いて，「外部」のデータを処理します（例えば，DirectShow* のフィルタや，gstreamer の処理モジュールを実装する場合など）．例えば，以下のようになります．Mat process_video_frame(const unsigned char* pixels, int width, int height, int step){ // 入力バッファをラップします． Mat img(height, width, CV_8UC3, (unsigned char*)pixels, step); Mat result; GaussianBlur(img, result, Size(7, 7), 1.5, 1.5); return result;}．

double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};Mat M = Mat(3, 3, CV_64F, m).inv();





MATLAB スタイルの配列初期化子，zeros(), ones(), eye() などを利用します．// 倍精度の単位行列を作成し，それを M.M += Mat::eye(M.rows, M.cols, CV_64F) に追加します．

コンマで区切られたイニシャライザを利用します．// 3x3 の倍精度単位行列を作成します。Mat M = (Mat_<double>(3,3) << 1, 0, 0, 1, 0, 0, 1); この方法では，まず適切なパラメータを指定して Mat クラスのコンストラクタを呼び出し，次に << 演算子の後に定数，変数，式などのコンマで区切られた値を置くだけです．また，コンパイルエラーを避けるために，余分な括弧が必要であることにも注意してください．



配列が作成されると、参照カウントの仕組みによって自動的に管理されます。配列のヘッダがユーザが割り当てたデータの上に構築されている場合は，そのデータを自分で処理する必要があります．配列データは、誰からも指されなくなると解放されます。配列デストラクタが呼ばれる前に，配列ヘッダが指し示すデータを解放したい場合は， Mat::release() を利用してください．

配列クラスについて次に学ぶべき重要なことは，要素へのアクセスです．このマニュアルでは，各配列要素のアドレスを計算する方法を既に説明しました．通常は，コード内で直接その式を使う必要はありません．配列要素の型（メソッド Mat::type() を用いて取得できます）を知っていれば，2 次元配列の要素 \(M_{ij}\) に，次のようにアクセスできます．M.at<double>(i,j) += 1.f; M は倍精度浮動小数点型配列であると仮定します．M.at<double>(i,j) += 1.f; Mは倍精度の浮動小数点配列であると仮定しています。

2 次元配列の行全体を処理する必要がある場合，最も効率的な方法は，最初に行へのポインタを取得し，次に C の単純な演算子 [] を使用することです： // 正の行列要素の総和を求めます // （M が倍精度の行列であると仮定して）double sum=0;for(int i = 0; i < M. .rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < M.cols; j++) sum += std::max(Mi[j], 0.);}．上の例のように，実際には配列の形状に依存しない演算もあります．このような演算は，配列の要素を1つずつ処理するだけです（あるいは，配列の加算など，同じ座標を持つ複数の配列の要素を処理することもあります）．このような操作を「要素ワイズ」と呼びます。すべての入出力配列が連続しているかどうか，つまり，各行の終わりに隙間がないかどうかをチェックすることは意味があります．もしそうであれば，それらを長い1つの行として処理します．// 最適化された正の行列要素の和を求めるtdouble sum=0;int cols = M.cols, rows = M.rows;if(M.isContinuous()){ cols *= rows; rows = 1;}for(int i = 0; i < rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < cols; j++) sum += std::max(Mi[j], 0.);}．連続した行列の場合，外側のループ本体は1回しか実行されません．そのため，オーバーヘッドが小さくなり，特に小さな行列の場合には顕著です．

最後に，連続した行の間のギャップをスキップすることができる STL スタイルのイテレータを紹介します．// 正の行列要素の総和を計算する，イテレータベースのバリアントdouble sum=0;MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();for(; it != it_end; ++it) sum += std::max(*it, 0.); 行列イテレータは，ランダムアクセスイテレータなので，std::sort() を含む，あらゆる STL アルゴリズムに渡すことができます．

注釈matrix Expressions and arithmetic see MatExpr

例： fld_lines.cpp，modules/shape/samples/shape_example.cpp，samples/cpp/camshiftdemo.cpp，samples/cpp/connected_components.cpp，samples/cpp/contours2.cpp，samples/cpp/convexhull.cpp，samples/cpp/cout_mat.cpp，samples/cpp/create_mask.cpp，samples/cpp/demhist.cpp，samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/filestorage.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/intersectExample.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp，samples/cpp/laplace.cpp，samples/cpp/lkdemo.cpp，samples/cpp/minarea.cpp，samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp，samples/cpp/polar_transforms.cpp，samples/cpp/segment_objects.cpp，samples/cpp/squares.cpp，samples/cpp/stitching.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/cpp/tutorial_code/videoio/video-write/video-write.cpp, samples/cpp/videowriter_basic.cpp, samples/cpp/warpPerspective_demo.cpp, samples/cpp/watershed.cpp, samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, samples/dnn/openpose.cpp, samples/dnn/segmentation.cpp, samples/dnn/text_detection.cpp, and samples/tapi/squares.cpp.


元関数名(C#): core_Mat_new11
元DLLエクスポート名: core_Mat_new11
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_new11(int ndims, int* sizes, int type, MyCvScalar s, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(ndims, sizes, type, cpp(s));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_new11
[64bit] cv::Mat のインスタンスを生成します
%prm
p1,p2,p3,p4,p5
p1 = int : int ndims
p2 = var : [MarshalAs(UnmanagedType.LPArray)] int[] sizes
p3 = int : int type
p4 = var : Scalar s
p5 = var : out IntPtr returnValue
%inst
n-dimensional dense array クラス

 クラス Mat は，シングルチャンネルまたはマルチチャンネルの，n-dimensional dense 数値配列を表します．これは，実数または複素数のベクトルや行列，グレースケールやカラーの画像，ボクセルボリューム，ベクトルフィールド，点群，テンソル，ヒストグラム（ただし，非常に高次元のヒストグラムは， SparseMat に格納した方が良いかもしれません）を格納するために利用できます．配列 M のデータレイアウトは，配列 M.step[] によって定義されており，要素 ?((i_0,...,i_{M.dims-1})?)のアドレスは，次のように計算されます： ?((i_k<M.size[k]?))

\Addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ...+ M.step[M.dims-1]*i_{M.dims-1}\]



 2次元配列の場合，上の式は次のようになります．

\Addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\]」となります。



 M.step[i] >= M.step[i+1] (実際には、M.step[i] >= M.step[i+1]*M.size[i+1] ) であることに注意してください。つまり，2次元の行列は行ごとに，3次元の行列は面ごとに，それぞれ格納されているということです．M.step[M.dims-1] は最小で，常に要素サイズ M.elemSize() と等しくなります．

つまり，Mat のデータレイアウトは，Numpy (ndarray) や Win32 (independent device bitmaps) などの標準的なツールキットや SDK で提供されている密な配列タイプの大半，つまり，ピクセルの位置を計算するのにステップ（またはストライド）を利用するあらゆる配列と互換性があります．この互換性により，ユーザが割り当てたデータの Mat ヘッダを作成し，OpenCV の関数を使ってその場で処理することができます．

Mat オブジェクトを作成するには，様々な方法があります．最も一般的な方法を以下に示します．



create(nrows, ncols, type) メソッドや，類似の Mat(nrows, ncols, type[, fillValue]) コンストラクタを利用します．type は， cvCreateMat メソッドと同じ意味を持ちます．例えば， CV_8UC1 は 8 ビットシングルチャンネル配列を意味し， CV_32FC2 は 2 チャンネル（複素数）浮動小数点型配列を意味します．// 1+3 で埋め尽くされた 7x7 の複素行列を作成します。j.Mat M(7,7,CV_32FC2,Scalar(1,3));// そして今度は，M を 100x60 の 15 チャンネル 8 ビット行列に変えます。 // 古い内容は解放されます。M.create(100,60,CV_8UC(15)); 本章のイントロダクションで述べたように， create() は，現在の配列の形状や型が指定されたものと異なる場合にのみ，新しい配列を確保します．

多次元の配列を作成します。// 100x100x100 の 8 ビット配列を作成しますint sz[] = {100, 100, 100};Mat bigCube(3, sz, CV_8U, Scalar::all(0)); Mat のコンストラクタに次元数 =1 を渡していますが，作成される配列は列数が 1 の 2 次元になります．

右辺に配列や式が存在する可能性がある場合は，コピーコンストラクタや代入演算子を利用します（後述）．導入部で述べたように，配列の代入は，ヘッダのコピーと参照カウンタの増加だけなので，O(1) の処理です．Mat::clone() メソッドを利用すれば，必要な時に配列の完全な（深い）コピーを得ることができます．

別の配列の一部に対するヘッダを作成します．それは，1 つの行，1 つの列，複数の行，複数の列，配列中の矩形領域（代数学ではマイナーと呼ばれます），または対角線のいずれかです．このような操作も，新しいヘッダが同じデータを参照するため，O(1)となります．この機能を使って，実際に配列の一部を変更することができます．例えば// 5 番目の行に 3 を掛けたものを 3 番目の行に追加するM.row(3) = M.row(3) + M.row(5)*3;// 7 番目の列を 1 番目の列にコピーする// M.col(1) = M.col(7); // これは動作しませんMat M1 = M.col(1);M.col(7).copyTo(M1);// 320x240 の新しい imageMat img(Size(320,240),CV_8UC3);// ROIMat roi(img, Rect(10,10,100,100));// ROI を (0,255,0) (RGB 空間では緑) で埋める．// オリジナルの 320x240 の画像が変更されます． roi = Scalar(0,255,0); 追加の datastart および dataend メンバにより， locateROI() を用いて，メインコンテナ配列内の相対的なサブアレイの位置を計算することができます．Mat A = Mat::eye(10, 10, CV_32S);// A の列，1 (including) から 3 (exclusive) を抽出します．Mat B = A(Range::all(), Range(1, 3));// B の行，5 (including) から 9 (exclusive) を抽出します．locateROI(size, ofs);// size は (width=10,height=10) となり，ofs は (x=1, y=5) 行列全体の場合と同様に，深いコピーが必要な場合は，抽出された部分行列の clone() メソッドを利用します．

ユーザが割り当てたデータのヘッダを作成します。以下のようにすると便利です．

OpenCV を用いて，「外部」のデータを処理します（例えば，DirectShow* のフィルタや，gstreamer の処理モジュールを実装する場合など）．例えば，以下のようになります．Mat process_video_frame(const unsigned char* pixels, int width, int height, int step){ // 入力バッファをラップします． Mat img(height, width, CV_8UC3, (unsigned char*)pixels, step); Mat result; GaussianBlur(img, result, Size(7, 7), 1.5, 1.5); return result;}．

double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};Mat M = Mat(3, 3, CV_64F, m).inv();





MATLAB スタイルの配列初期化子，zeros(), ones(), eye() などを利用します．// 倍精度の単位行列を作成し，それを M.M += Mat::eye(M.rows, M.cols, CV_64F) に追加します．

コンマで区切られたイニシャライザを利用します．// 3x3 の倍精度単位行列を作成します。Mat M = (Mat_<double>(3,3) << 1, 0, 0, 1, 0, 0, 1); この方法では，まず適切なパラメータを指定して Mat クラスのコンストラクタを呼び出し，次に << 演算子の後に定数，変数，式などのコンマで区切られた値を置くだけです．また，コンパイルエラーを避けるために，余分な括弧が必要であることにも注意してください．



配列が作成されると、参照カウントの仕組みによって自動的に管理されます。配列のヘッダがユーザが割り当てたデータの上に構築されている場合は，そのデータを自分で処理する必要があります．配列データは、誰からも指されなくなると解放されます。配列デストラクタが呼ばれる前に，配列ヘッダが指し示すデータを解放したい場合は， Mat::release() を利用してください．

配列クラスについて次に学ぶべき重要なことは，要素へのアクセスです．このマニュアルでは，各配列要素のアドレスを計算する方法を既に説明しました．通常は，コード内で直接その式を使う必要はありません．配列要素の型（メソッド Mat::type() を用いて取得できます）を知っていれば，2 次元配列の要素 \(M_{ij}\) に，次のようにアクセスできます．M.at<double>(i,j) += 1.f; M は倍精度浮動小数点型配列であると仮定します．M.at<double>(i,j) += 1.f; Mは倍精度の浮動小数点配列であると仮定しています。

2 次元配列の行全体を処理する必要がある場合，最も効率的な方法は，最初に行へのポインタを取得し，次に C の単純な演算子 [] を使用することです： // 正の行列要素の総和を求めます // （M が倍精度の行列であると仮定して）double sum=0;for(int i = 0; i < M. .rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < M.cols; j++) sum += std::max(Mi[j], 0.);}．上の例のように，実際には配列の形状に依存しない演算もあります．このような演算は，配列の要素を1つずつ処理するだけです（あるいは，配列の加算など，同じ座標を持つ複数の配列の要素を処理することもあります）．このような操作を「要素ワイズ」と呼びます。すべての入出力配列が連続しているかどうか，つまり，各行の終わりに隙間がないかどうかをチェックすることは意味があります．もしそうであれば，それらを長い1つの行として処理します．// 最適化された正の行列要素の和を求めるtdouble sum=0;int cols = M.cols, rows = M.rows;if(M.isContinuous()){ cols *= rows; rows = 1;}for(int i = 0; i < rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < cols; j++) sum += std::max(Mi[j], 0.);}．連続した行列の場合，外側のループ本体は1回しか実行されません．そのため，オーバーヘッドが小さくなり，特に小さな行列の場合には顕著です．

最後に，連続した行の間のギャップをスキップすることができる STL スタイルのイテレータを紹介します．// 正の行列要素の総和を計算する，イテレータベースのバリアントdouble sum=0;MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();for(; it != it_end; ++it) sum += std::max(*it, 0.); 行列イテレータは，ランダムアクセスイテレータなので，std::sort() を含む，あらゆる STL アルゴリズムに渡すことができます．

注釈matrix Expressions and arithmetic see MatExpr

例： fld_lines.cpp，modules/shape/samples/shape_example.cpp，samples/cpp/camshiftdemo.cpp，samples/cpp/connected_components.cpp，samples/cpp/contours2.cpp，samples/cpp/convexhull.cpp，samples/cpp/cout_mat.cpp，samples/cpp/create_mask.cpp，samples/cpp/demhist.cpp，samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/filestorage.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/intersectExample.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp，samples/cpp/laplace.cpp，samples/cpp/lkdemo.cpp，samples/cpp/minarea.cpp，samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp，samples/cpp/polar_transforms.cpp，samples/cpp/segment_objects.cpp，samples/cpp/squares.cpp，samples/cpp/stitching.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/cpp/tutorial_code/videoio/video-write/video-write.cpp, samples/cpp/videowriter_basic.cpp, samples/cpp/warpPerspective_demo.cpp, samples/cpp/watershed.cpp, samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, samples/dnn/openpose.cpp, samples/dnn/segmentation.cpp, samples/dnn/text_detection.cpp, and samples/tapi/squares.cpp.


元関数名(C#): core_Mat_new11
元DLLエクスポート名: core_Mat_new11
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_new11(int ndims, int* sizes, int type, MyCvScalar s, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(ndims, sizes, type, cpp(s));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_new12
[32/64bit] cv::Mat のインスタンスを生成します
%prm
p1,p2
p1 = sptr : IntPtr mat
p2 = var : out IntPtr returnValue
%inst
n-dimensional dense array クラス

 クラス Mat は，シングルチャンネルまたはマルチチャンネルの，n-dimensional dense 数値配列を表します．これは，実数または複素数のベクトルや行列，グレースケールやカラーの画像，ボクセルボリューム，ベクトルフィールド，点群，テンソル，ヒストグラム（ただし，非常に高次元のヒストグラムは， SparseMat に格納した方が良いかもしれません）を格納するために利用できます．配列 M のデータレイアウトは，配列 M.step[] によって定義されており，要素 ?((i_0,...,i_{M.dims-1})?)のアドレスは，次のように計算されます： ?((i_k<M.size[k]?))

\Addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ...+ M.step[M.dims-1]*i_{M.dims-1}\]



 2次元配列の場合，上の式は次のようになります．

\Addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\]」となります。



 M.step[i] >= M.step[i+1] (実際には、M.step[i] >= M.step[i+1]*M.size[i+1] ) であることに注意してください。つまり，2次元の行列は行ごとに，3次元の行列は面ごとに，それぞれ格納されているということです．M.step[M.dims-1] は最小で，常に要素サイズ M.elemSize() と等しくなります．

つまり，Mat のデータレイアウトは，Numpy (ndarray) や Win32 (independent device bitmaps) などの標準的なツールキットや SDK で提供されている密な配列タイプの大半，つまり，ピクセルの位置を計算するのにステップ（またはストライド）を利用するあらゆる配列と互換性があります．この互換性により，ユーザが割り当てたデータの Mat ヘッダを作成し，OpenCV の関数を使ってその場で処理することができます．

Mat オブジェクトを作成するには，様々な方法があります．最も一般的な方法を以下に示します．



create(nrows, ncols, type) メソッドや，類似の Mat(nrows, ncols, type[, fillValue]) コンストラクタを利用します．type は， cvCreateMat メソッドと同じ意味を持ちます．例えば， CV_8UC1 は 8 ビットシングルチャンネル配列を意味し， CV_32FC2 は 2 チャンネル（複素数）浮動小数点型配列を意味します．// 1+3 で埋め尽くされた 7x7 の複素行列を作成します。j.Mat M(7,7,CV_32FC2,Scalar(1,3));// そして今度は，M を 100x60 の 15 チャンネル 8 ビット行列に変えます。 // 古い内容は解放されます。M.create(100,60,CV_8UC(15)); 本章のイントロダクションで述べたように， create() は，現在の配列の形状や型が指定されたものと異なる場合にのみ，新しい配列を確保します．

多次元の配列を作成します。// 100x100x100 の 8 ビット配列を作成しますint sz[] = {100, 100, 100};Mat bigCube(3, sz, CV_8U, Scalar::all(0)); Mat のコンストラクタに次元数 =1 を渡していますが，作成される配列は列数が 1 の 2 次元になります．

右辺に配列や式が存在する可能性がある場合は，コピーコンストラクタや代入演算子を利用します（後述）．導入部で述べたように，配列の代入は，ヘッダのコピーと参照カウンタの増加だけなので，O(1) の処理です．Mat::clone() メソッドを利用すれば，必要な時に配列の完全な（深い）コピーを得ることができます．

別の配列の一部に対するヘッダを作成します．それは，1 つの行，1 つの列，複数の行，複数の列，配列中の矩形領域（代数学ではマイナーと呼ばれます），または対角線のいずれかです．このような操作も，新しいヘッダが同じデータを参照するため，O(1)となります．この機能を使って，実際に配列の一部を変更することができます．例えば// 5 番目の行に 3 を掛けたものを 3 番目の行に追加するM.row(3) = M.row(3) + M.row(5)*3;// 7 番目の列を 1 番目の列にコピーする// M.col(1) = M.col(7); // これは動作しませんMat M1 = M.col(1);M.col(7).copyTo(M1);// 320x240 の新しい imageMat img(Size(320,240),CV_8UC3);// ROIMat roi(img, Rect(10,10,100,100));// ROI を (0,255,0) (RGB 空間では緑) で埋める．// オリジナルの 320x240 の画像が変更されます． roi = Scalar(0,255,0); 追加の datastart および dataend メンバにより， locateROI() を用いて，メインコンテナ配列内の相対的なサブアレイの位置を計算することができます．Mat A = Mat::eye(10, 10, CV_32S);// A の列，1 (including) から 3 (exclusive) を抽出します．Mat B = A(Range::all(), Range(1, 3));// B の行，5 (including) から 9 (exclusive) を抽出します．locateROI(size, ofs);// size は (width=10,height=10) となり，ofs は (x=1, y=5) 行列全体の場合と同様に，深いコピーが必要な場合は，抽出された部分行列の clone() メソッドを利用します．

ユーザが割り当てたデータのヘッダを作成します。以下のようにすると便利です．

OpenCV を用いて，「外部」のデータを処理します（例えば，DirectShow* のフィルタや，gstreamer の処理モジュールを実装する場合など）．例えば，以下のようになります．Mat process_video_frame(const unsigned char* pixels, int width, int height, int step){ // 入力バッファをラップします． Mat img(height, width, CV_8UC3, (unsigned char*)pixels, step); Mat result; GaussianBlur(img, result, Size(7, 7), 1.5, 1.5); return result;}．

double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};Mat M = Mat(3, 3, CV_64F, m).inv();





MATLAB スタイルの配列初期化子，zeros(), ones(), eye() などを利用します．// 倍精度の単位行列を作成し，それを M.M += Mat::eye(M.rows, M.cols, CV_64F) に追加します．

コンマで区切られたイニシャライザを利用します．// 3x3 の倍精度単位行列を作成します。Mat M = (Mat_<double>(3,3) << 1, 0, 0, 1, 0, 0, 1); この方法では，まず適切なパラメータを指定して Mat クラスのコンストラクタを呼び出し，次に << 演算子の後に定数，変数，式などのコンマで区切られた値を置くだけです．また，コンパイルエラーを避けるために，余分な括弧が必要であることにも注意してください．



配列が作成されると、参照カウントの仕組みによって自動的に管理されます。配列のヘッダがユーザが割り当てたデータの上に構築されている場合は，そのデータを自分で処理する必要があります．配列データは、誰からも指されなくなると解放されます。配列デストラクタが呼ばれる前に，配列ヘッダが指し示すデータを解放したい場合は， Mat::release() を利用してください．

配列クラスについて次に学ぶべき重要なことは，要素へのアクセスです．このマニュアルでは，各配列要素のアドレスを計算する方法を既に説明しました．通常は，コード内で直接その式を使う必要はありません．配列要素の型（メソッド Mat::type() を用いて取得できます）を知っていれば，2 次元配列の要素 \(M_{ij}\) に，次のようにアクセスできます．M.at<double>(i,j) += 1.f; M は倍精度浮動小数点型配列であると仮定します．M.at<double>(i,j) += 1.f; Mは倍精度の浮動小数点配列であると仮定しています。

2 次元配列の行全体を処理する必要がある場合，最も効率的な方法は，最初に行へのポインタを取得し，次に C の単純な演算子 [] を使用することです： // 正の行列要素の総和を求めます // （M が倍精度の行列であると仮定して）double sum=0;for(int i = 0; i < M. .rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < M.cols; j++) sum += std::max(Mi[j], 0.);}．上の例のように，実際には配列の形状に依存しない演算もあります．このような演算は，配列の要素を1つずつ処理するだけです（あるいは，配列の加算など，同じ座標を持つ複数の配列の要素を処理することもあります）．このような操作を「要素ワイズ」と呼びます。すべての入出力配列が連続しているかどうか，つまり，各行の終わりに隙間がないかどうかをチェックすることは意味があります．もしそうであれば，それらを長い1つの行として処理します．// 最適化された正の行列要素の和を求めるtdouble sum=0;int cols = M.cols, rows = M.rows;if(M.isContinuous()){ cols *= rows; rows = 1;}for(int i = 0; i < rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < cols; j++) sum += std::max(Mi[j], 0.);}．連続した行列の場合，外側のループ本体は1回しか実行されません．そのため，オーバーヘッドが小さくなり，特に小さな行列の場合には顕著です．

最後に，連続した行の間のギャップをスキップすることができる STL スタイルのイテレータを紹介します．// 正の行列要素の総和を計算する，イテレータベースのバリアントdouble sum=0;MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();for(; it != it_end; ++it) sum += std::max(*it, 0.); 行列イテレータは，ランダムアクセスイテレータなので，std::sort() を含む，あらゆる STL アルゴリズムに渡すことができます．

注釈matrix Expressions and arithmetic see MatExpr

例： fld_lines.cpp，modules/shape/samples/shape_example.cpp，samples/cpp/camshiftdemo.cpp，samples/cpp/connected_components.cpp，samples/cpp/contours2.cpp，samples/cpp/convexhull.cpp，samples/cpp/cout_mat.cpp，samples/cpp/create_mask.cpp，samples/cpp/demhist.cpp，samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/filestorage.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/intersectExample.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp，samples/cpp/laplace.cpp，samples/cpp/lkdemo.cpp，samples/cpp/minarea.cpp，samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp，samples/cpp/polar_transforms.cpp，samples/cpp/segment_objects.cpp，samples/cpp/squares.cpp，samples/cpp/stitching.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/cpp/tutorial_code/videoio/video-write/video-write.cpp, samples/cpp/videowriter_basic.cpp, samples/cpp/warpPerspective_demo.cpp, samples/cpp/watershed.cpp, samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, samples/dnn/openpose.cpp, samples/dnn/segmentation.cpp, samples/dnn/text_detection.cpp, and samples/tapi/squares.cpp.


元関数名(C#): core_Mat_new12
元DLLエクスポート名: core_Mat_new12
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_new12(cv::Mat *mat, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(*mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_delete
[32/64bit] cv::Mat のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr mat
%inst
n-dimensional dense array クラス

 クラス Mat は，シングルチャンネルまたはマルチチャンネルの，n-dimensional dense 数値配列を表します．これは，実数または複素数のベクトルや行列，グレースケールやカラーの画像，ボクセルボリューム，ベクトルフィールド，点群，テンソル，ヒストグラム（ただし，非常に高次元のヒストグラムは， SparseMat に格納した方が良いかもしれません）を格納するために利用できます．配列 M のデータレイアウトは，配列 M.step[] によって定義されており，要素 ?((i_0,...,i_{M.dims-1})?)のアドレスは，次のように計算されます： ?((i_k<M.size[k]?))

\Addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ...+ M.step[M.dims-1]*i_{M.dims-1}\]



 2次元配列の場合，上の式は次のようになります．

\Addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\]」となります。



 M.step[i] >= M.step[i+1] (実際には、M.step[i] >= M.step[i+1]*M.size[i+1] ) であることに注意してください。つまり，2次元の行列は行ごとに，3次元の行列は面ごとに，それぞれ格納されているということです．M.step[M.dims-1] は最小で，常に要素サイズ M.elemSize() と等しくなります．

つまり，Mat のデータレイアウトは，Numpy (ndarray) や Win32 (independent device bitmaps) などの標準的なツールキットや SDK で提供されている密な配列タイプの大半，つまり，ピクセルの位置を計算するのにステップ（またはストライド）を利用するあらゆる配列と互換性があります．この互換性により，ユーザが割り当てたデータの Mat ヘッダを作成し，OpenCV の関数を使ってその場で処理することができます．

Mat オブジェクトを作成するには，様々な方法があります．最も一般的な方法を以下に示します．



create(nrows, ncols, type) メソッドや，類似の Mat(nrows, ncols, type[, fillValue]) コンストラクタを利用します．type は， cvCreateMat メソッドと同じ意味を持ちます．例えば， CV_8UC1 は 8 ビットシングルチャンネル配列を意味し， CV_32FC2 は 2 チャンネル（複素数）浮動小数点型配列を意味します．// 1+3 で埋め尽くされた 7x7 の複素行列を作成します。j.Mat M(7,7,CV_32FC2,Scalar(1,3));// そして今度は，M を 100x60 の 15 チャンネル 8 ビット行列に変えます。 // 古い内容は解放されます。M.create(100,60,CV_8UC(15)); 本章のイントロダクションで述べたように， create() は，現在の配列の形状や型が指定されたものと異なる場合にのみ，新しい配列を確保します．

多次元の配列を作成します。// 100x100x100 の 8 ビット配列を作成しますint sz[] = {100, 100, 100};Mat bigCube(3, sz, CV_8U, Scalar::all(0)); Mat のコンストラクタに次元数 =1 を渡していますが，作成される配列は列数が 1 の 2 次元になります．

右辺に配列や式が存在する可能性がある場合は，コピーコンストラクタや代入演算子を利用します（後述）．導入部で述べたように，配列の代入は，ヘッダのコピーと参照カウンタの増加だけなので，O(1) の処理です．Mat::clone() メソッドを利用すれば，必要な時に配列の完全な（深い）コピーを得ることができます．

別の配列の一部に対するヘッダを作成します．それは，1 つの行，1 つの列，複数の行，複数の列，配列中の矩形領域（代数学ではマイナーと呼ばれます），または対角線のいずれかです．このような操作も，新しいヘッダが同じデータを参照するため，O(1)となります．この機能を使って，実際に配列の一部を変更することができます．例えば// 5 番目の行に 3 を掛けたものを 3 番目の行に追加するM.row(3) = M.row(3) + M.row(5)*3;// 7 番目の列を 1 番目の列にコピーする// M.col(1) = M.col(7); // これは動作しませんMat M1 = M.col(1);M.col(7).copyTo(M1);// 320x240 の新しい imageMat img(Size(320,240),CV_8UC3);// ROIMat roi(img, Rect(10,10,100,100));// ROI を (0,255,0) (RGB 空間では緑) で埋める．// オリジナルの 320x240 の画像が変更されます． roi = Scalar(0,255,0); 追加の datastart および dataend メンバにより， locateROI() を用いて，メインコンテナ配列内の相対的なサブアレイの位置を計算することができます．Mat A = Mat::eye(10, 10, CV_32S);// A の列，1 (including) から 3 (exclusive) を抽出します．Mat B = A(Range::all(), Range(1, 3));// B の行，5 (including) から 9 (exclusive) を抽出します．locateROI(size, ofs);// size は (width=10,height=10) となり，ofs は (x=1, y=5) 行列全体の場合と同様に，深いコピーが必要な場合は，抽出された部分行列の clone() メソッドを利用します．

ユーザが割り当てたデータのヘッダを作成します。以下のようにすると便利です．

OpenCV を用いて，「外部」のデータを処理します（例えば，DirectShow* のフィルタや，gstreamer の処理モジュールを実装する場合など）．例えば，以下のようになります．Mat process_video_frame(const unsigned char* pixels, int width, int height, int step){ // 入力バッファをラップします． Mat img(height, width, CV_8UC3, (unsigned char*)pixels, step); Mat result; GaussianBlur(img, result, Size(7, 7), 1.5, 1.5); return result;}．

double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};Mat M = Mat(3, 3, CV_64F, m).inv();





MATLAB スタイルの配列初期化子，zeros(), ones(), eye() などを利用します．// 倍精度の単位行列を作成し，それを M.M += Mat::eye(M.rows, M.cols, CV_64F) に追加します．

コンマで区切られたイニシャライザを利用します．// 3x3 の倍精度単位行列を作成します。Mat M = (Mat_<double>(3,3) << 1, 0, 0, 1, 0, 0, 1); この方法では，まず適切なパラメータを指定して Mat クラスのコンストラクタを呼び出し，次に << 演算子の後に定数，変数，式などのコンマで区切られた値を置くだけです．また，コンパイルエラーを避けるために，余分な括弧が必要であることにも注意してください．



配列が作成されると、参照カウントの仕組みによって自動的に管理されます。配列のヘッダがユーザが割り当てたデータの上に構築されている場合は，そのデータを自分で処理する必要があります．配列データは、誰からも指されなくなると解放されます。配列デストラクタが呼ばれる前に，配列ヘッダが指し示すデータを解放したい場合は， Mat::release() を利用してください．

配列クラスについて次に学ぶべき重要なことは，要素へのアクセスです．このマニュアルでは，各配列要素のアドレスを計算する方法を既に説明しました．通常は，コード内で直接その式を使う必要はありません．配列要素の型（メソッド Mat::type() を用いて取得できます）を知っていれば，2 次元配列の要素 \(M_{ij}\) に，次のようにアクセスできます．M.at<double>(i,j) += 1.f; M は倍精度浮動小数点型配列であると仮定します．M.at<double>(i,j) += 1.f; Mは倍精度の浮動小数点配列であると仮定しています。

2 次元配列の行全体を処理する必要がある場合，最も効率的な方法は，最初に行へのポインタを取得し，次に C の単純な演算子 [] を使用することです： // 正の行列要素の総和を求めます // （M が倍精度の行列であると仮定して）double sum=0;for(int i = 0; i < M. .rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < M.cols; j++) sum += std::max(Mi[j], 0.);}．上の例のように，実際には配列の形状に依存しない演算もあります．このような演算は，配列の要素を1つずつ処理するだけです（あるいは，配列の加算など，同じ座標を持つ複数の配列の要素を処理することもあります）．このような操作を「要素ワイズ」と呼びます。すべての入出力配列が連続しているかどうか，つまり，各行の終わりに隙間がないかどうかをチェックすることは意味があります．もしそうであれば，それらを長い1つの行として処理します．// 最適化された正の行列要素の和を求めるtdouble sum=0;int cols = M.cols, rows = M.rows;if(M.isContinuous()){ cols *= rows; rows = 1;}for(int i = 0; i < rows; i++){ const double* Mi = M.ptr<double>(i); for(int j = 0; j < cols; j++) sum += std::max(Mi[j], 0.);}．連続した行列の場合，外側のループ本体は1回しか実行されません．そのため，オーバーヘッドが小さくなり，特に小さな行列の場合には顕著です．

最後に，連続した行の間のギャップをスキップすることができる STL スタイルのイテレータを紹介します．// 正の行列要素の総和を計算する，イテレータベースのバリアントdouble sum=0;MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();for(; it != it_end; ++it) sum += std::max(*it, 0.); 行列イテレータは，ランダムアクセスイテレータなので，std::sort() を含む，あらゆる STL アルゴリズムに渡すことができます．

注釈matrix Expressions and arithmetic see MatExpr

例： fld_lines.cpp，modules/shape/samples/shape_example.cpp，samples/cpp/camshiftdemo.cpp，samples/cpp/connected_components.cpp，samples/cpp/contours2.cpp，samples/cpp/convexhull.cpp，samples/cpp/cout_mat.cpp，samples/cpp/create_mask.cpp，samples/cpp/demhist.cpp，samples/cpp/distrans.cpp, samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/filestorage.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/intersectExample.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp，samples/cpp/laplace.cpp，samples/cpp/lkdemo.cpp，samples/cpp/minarea.cpp，samples/cpp/pca.cpp，samples/cpp/peopledetect.cpp，samples/cpp/polar_transforms.cpp，samples/cpp/segment_objects.cpp，samples/cpp/squares.cpp，samples/cpp/stitching.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp, samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp, samples/cpp/tutorial_code/videoio/video-write/video-write.cpp, samples/cpp/videowriter_basic.cpp, samples/cpp/warpPerspective_demo.cpp, samples/cpp/watershed.cpp, samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, samples/dnn/openpose.cpp, samples/dnn/segmentation.cpp, samples/dnn/text_detection.cpp, and samples/tapi/squares.cpp.


元関数名(C#): core_Mat_delete
元DLLエクスポート名: core_Mat_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_delete(cv::Mat *self)
{
    BEGIN_WRAP
    delete self;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_getUMat
[32/64bit] Mat から UMat を取得します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = int : int accessFlag
p3 = int : int usageFlags
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_getUMat
元DLLエクスポート名: core_Mat_getUMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_getUMat(cv::Mat* self, cv::AccessFlag accessFlags, cv::UMatUsageFlags usageFlags, cv::UMat** returnValue)
{
    BEGIN_WRAP
        * returnValue = new cv::UMat(self-&amp;gt;getUMat(accessFlags, usageFlags));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_row
[32/64bit] 指定された行列行に対する行列ヘッダを作成します．
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int y
p3 = var : out IntPtr returnValue
%inst
このメソッドは，指定された行列の行に対する新しいヘッダを作成し，それを返します．これは，行列のサイズに関わらず，O(1) の処理です．新しい行列の基礎データは，元の行列と共有されます．以下は，LU やその他多くのアルゴリズムで利用される，古典的な基本行列処理の 1 つである axpy の例です：inline void matrix_axpy(Mat& A, int i, int j, double alpha){ A.row(i) += A.row(j)*alpha;}fragmentNote現在の実装では，以下のコードは期待通りに動作しません．Mat A;...A.row(i) = A.row(j); // うまくいきません． これは，A.row(i) が一時的なヘッダを形成し，さらに別のヘッダに割り当てられるために起こります．これらの操作はそれぞれO(1)、つまりデータはコピーされないことを覚えておいてください。したがって，j番目の行がi番目の行にコピーされることを期待していたかもしれない場合には，上記の割り当ては真ではありません．これを実現するには，この単純な代入を式に変えるか， Mat::copyTo メソッドを利用する必要があります．A.row(j) = A.row(j) + 0;// これは少し長いですが，推奨される方法です．A.row(j).copyTo(A.row(i));例： samples/cpp/pca.cpp，samples/cpp/train_HOG.cpp．

元関数名(C#): core_Mat_row
元DLLエクスポート名: core_Mat_row
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_row(cv::Mat *self, int y, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(self-&amp;gt;row(y));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_col
[32/64bit] 指定された行列列の行列ヘッダを作成します。
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int x
p3 = var : out IntPtr returnValue
%inst
このメソッドは，指定された行列列に対する新しいヘッダを作成し，それを返します．これは，行列のサイズに関わらず，O(1)の処理です．この新しい行列の基礎データは，元の行列と共有されます．Mat::row の説明も参照してください．例： samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp.

元関数名(C#): core_Mat_col
元DLLエクスポート名: core_Mat_col
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_col(cv::Mat *self, int x, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(self-&amp;gt;col(x));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_rowRange
[32/64bit] 指定された行範囲に対する行列ヘッダを作成します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = int : int startRow
p3 = int : int endRow
p4 = var : out IntPtr returnValue
%inst
このメソッドは，行列の指定された行範囲に対して新しいヘッダを作成します．Mat::row や Mat::col と同様に，これは O(1) の処理です．例： samples/cpp/kmeans.cpp，samples/dnn/segmentation.cpp．

元関数名(C#): core_Mat_rowRange
元DLLエクスポート名: core_Mat_rowRange
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_rowRange(cv::Mat *self, int startRow, int endRow, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(self-&amp;gt;rowRange(startRow, endRow));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_colRange
[32/64bit] 指定された列数に対する行列ヘッダを作成します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = int : int startCol
p3 = int : int endCol
p4 = var : out IntPtr returnValue
%inst
このメソッドは，行列の指定された列スパンに対して新しいヘッダを作成します．Mat::row や Mat::col と同様に，これは O(1) の処理です．

元関数名(C#): core_Mat_colRange
元DLLエクスポート名: core_Mat_colRange
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_colRange(cv::Mat *self, int startCol, int endCol, cv::Mat **returnValue)
{ 
    BEGIN_WRAP
    *returnValue = new cv::Mat(self-&amp;gt;colRange(startCol, endCol));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_diag
[32/64bit] 行列から対角線を抽出します．
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int d
p3 = var : out IntPtr returnValue
%inst
このメソッドは，指定された行列の対角線上に新しいヘッダを作成します．この新しい行列は，1 列の行列として表現されます．Mat::row や Mat::col と同様に，これは O(1) の処理です．

元関数名(C#): core_Mat_diag
元DLLエクスポート名: core_Mat_diag
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_diag(cv::Mat *self, int d, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;diag(d);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_diag_static
[32/64bit] 行列から対角線を抽出します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst
このメソッドは，指定された行列の対角線上に新しいヘッダを作成します．この新しい行列は，1 列の行列として表現されます．Mat::row や Mat::col と同様に，これは O(1) の処理です．

元関数名(C#): core_Mat_diag_static
元DLLエクスポート名: core_Mat_diag_static
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_diag_static(cv::Mat *self, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::Mat::diag(*self);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_clone
[32/64bit] 配列とその基礎となるデータの完全なコピーを作成します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst
このメソッドは，配列の完全なコピーを作成します．元の step[] は考慮されません．したがって，配列のコピーは，total()*elemSize() バイトを占める連続した配列となります．例： samples/cpp/create_mask.cpp，samples/cpp/facedetect.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/train_HOG.cpp，samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, and samples/cpp/warpPerspective_demo.cpp.

元関数名(C#): core_Mat_clone
元DLLエクスポート名: core_Mat_clone
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_clone(cv::Mat *self, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;clone();
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_copyTo1
[32/64bit] 行列を別の行列にコピーします。
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
%inst
このメソッドは，行列のデータを別の行列にコピーします．データをコピーする前に，このメソッドは :m.create(this->size(), this->type()) を呼び出し，必要に応じてコピー先の行列が再割り当てされるようにします．操作マスクが指定されている場合，上述の Mat::create 呼び出しで行列が再割り当てされると，データをコピーする前に，新しく割り当てられた行列がすべて 0 で初期化されます．例： samples/cpp/camshiftdemo.cpp，samples/cpp/edge.cpp，samples/cpp/grabcut.cpp，samples/cpp/image_alignment.cpp，samples/cpp/lkdemo.cpp，samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp，samples/cpp/watershed.cpp，samples/tapi/hog.cpp，samples/tapi/squares.cpp．

元関数名(C#): core_Mat_copyTo1
元DLLエクスポート名: core_Mat_copyTo1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_copyTo1(cv::Mat *self, cv::_OutputArray *m)
{
    BEGIN_WRAP
    self-&amp;gt;copyTo(*m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_copyTo2
[32/64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
p3 = sptr : IntPtr mask
%inst
元関数名(C#): core_Mat_copyTo2
元DLLエクスポート名: core_Mat_copyTo2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_copyTo2(cv::Mat *self, cv::_OutputArray *m, cv::_InputArray *mask)
{
    BEGIN_WRAP
    self-&amp;gt;copyTo(*m, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_copyTo_toMat1
[32/64bit] 行列を別の行列にコピーします。
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
%inst
このメソッドは，行列のデータを別の行列にコピーします．データをコピーする前に，このメソッドは :m.create(this->size(), this->type()) を呼び出し，必要に応じてコピー先の行列が再割り当てされるようにします．操作マスクが指定されている場合，上述の Mat::create 呼び出しで行列が再割り当てされると，データをコピーする前に，新しく割り当てられた行列がすべて 0 で初期化されます．例： samples/cpp/camshiftdemo.cpp，samples/cpp/edge.cpp，samples/cpp/grabcut.cpp，samples/cpp/image_alignment.cpp，samples/cpp/lkdemo.cpp，samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp，samples/cpp/watershed.cpp，samples/tapi/hog.cpp，samples/tapi/squares.cpp．

元関数名(C#): core_Mat_copyTo_toMat1
元DLLエクスポート名: core_Mat_copyTo_toMat1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_copyTo_toMat1(cv::Mat *self, cv::Mat *m)
{
    BEGIN_WRAP
    self-&amp;gt;copyTo(*m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_copyTo_toMat2
[32/64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
p3 = sptr : IntPtr mask
%inst
元関数名(C#): core_Mat_copyTo_toMat2
元DLLエクスポート名: core_Mat_copyTo_toMat2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_copyTo_toMat2(cv::Mat *self, cv::Mat *m, cv::_InputArray *mask)
{
    BEGIN_WRAP
    self-&amp;gt;copyTo(*m, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_convertTo
[32/64bit] 配列を別のデータ型に変換し，オプションでスケーリングを行います．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
p3 = int : int rtype
p4 = double : double alpha
p5 = double : double beta
%inst
このメソッドは，ソースピクセルの値をターゲットデータ型に変換します．オーバーフローの可能性を回避するために，最後に saturate_cast<> が適用されます：[m(x,y) = saturate ″cast<rType>( ″alpha (*this)(x,y) + ″beta″ )]例： samples/cpp/demhist.cpp、samples/cpp/distrans.cpp、samples/cpp/fitellipse.cpp、samples/cpp/pca.cpp、samples/cpp/stitching_detailed.cpp、samples/dnn/colorization.cppです。

元関数名(C#): core_Mat_convertTo
元DLLエクスポート名: core_Mat_convertTo
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_convertTo(cv::Mat *self, cv::_OutputArray *m, int rtype, double alpha, double beta)
{
    BEGIN_WRAP
    self-&amp;gt;convertTo(*m, rtype, alpha, beta);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_assignTo
[32/64bit] convertTo の関数形式を提供します。
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
p3 = int : int type
%inst
これは，MatrixExpressions エンジンによって呼び出される，内部的に使用されるメソッドです．

元関数名(C#): core_Mat_assignTo
元DLLエクスポート名: core_Mat_assignTo
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_assignTo(cv::Mat *self, cv::Mat *m, int type)
{
    BEGIN_WRAP
    self-&amp;gt;assignTo(*m, type);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_setTo_Scalar
[32bit] 配列の全てまたは一部の要素を指定された値に設定します。
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = ARGS_SCALAR : Scalar value
p3 = sptr : IntPtr mask
%inst
これは， Mat::operator=(const Scalar& s) 演算子の発展型です．例： samples/cpp/stitching_detailed.cpp ，samples/dnn/segmentation.cpp など．

元関数名(C#): core_Mat_setTo_Scalar
元DLLエクスポート名: core_Mat_setTo_Scalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_setTo_Scalar(cv::Mat *self, MyCvScalar value, cv::Mat *mask)
{
    BEGIN_WRAP
    if (mask == nullptr)
        self-&amp;gt;setTo(cpp(value));
    else 
        self-&amp;gt;setTo(cpp(value), entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_setTo_Scalar
[64bit] 配列の全てまたは一部の要素を指定された値に設定します。
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = var : Scalar value
p3 = sptr : IntPtr mask
%inst
これは， Mat::operator=(const Scalar& s) 演算子の発展型です．例： samples/cpp/stitching_detailed.cpp ，samples/dnn/segmentation.cpp など．

元関数名(C#): core_Mat_setTo_Scalar
元DLLエクスポート名: core_Mat_setTo_Scalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_setTo_Scalar(cv::Mat *self, MyCvScalar value, cv::Mat *mask)
{
    BEGIN_WRAP
    if (mask == nullptr)
        self-&amp;gt;setTo(cpp(value));
    else 
        self-&amp;gt;setTo(cpp(value), entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_setTo_InputArray
[32/64bit] 配列の全てまたは一部の要素を指定された値に設定します。
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = sptr : IntPtr value
p3 = sptr : IntPtr mask
%inst
これは， Mat::operator=(const Scalar& s) 演算子の発展型です．例： samples/cpp/stitching_detailed.cpp ，samples/dnn/segmentation.cpp など．

元関数名(C#): core_Mat_setTo_InputArray
元DLLエクスポート名: core_Mat_setTo_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_setTo_InputArray(cv::Mat *self, cv::_InputArray *value, cv::Mat *mask)
{
    BEGIN_WRAP
    self-&amp;gt;setTo(*value, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_reshape1
[32/64bit] データをコピーすることなく，2 次元行列の形状やチャンネル数を変更します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = int : int cn
p3 = int : int rows
p4 = var : out IntPtr returnValue
%inst
このメソッドは，*this の要素に対する新しい行列のヘッダを作成します．この新しい行列は，サイズやチャンネル数が異なっていても構いません．以下の条件であれば，どのような組み合わせも可能です：新しい行列に余分な要素が含まれておらず，また要素が除外されていない場合．したがって，行*列*チャネル() の積は，変換後も同じでなければいけません．

データはコピーされません。つまり，これは O(1) の演算です．したがって，行数を変更したり，その他の方法で行の要素のインデックスを変更したりした場合，その行列は連続したものでなければいけません．Mat::isContinuous を参照してください．例えば，STL のベクトルとして格納された 3D ポイントの集合があり，そのポイントを 3xN の行列として表現したい場合，次のようにします： std::vector<Point3f> vec;...Mat pointMat = Mat(vec)．// ベクトルを Mat に変換，O(1) の演算 reshape(1)．// Nx1 の 3 チャンネル行列から，Nx3 の 1 チャンネル行列を作成します．                              // これも O(1) の処理です． t(); // 最後に，Nx3 の行列を転置します．                          これは， // すべての要素をコピーすることになりますfragmentExamples: samples/cpp/pca.cpp, samples/dnn/classification.cpp.

元関数名(C#): core_Mat_reshape1
元DLLエクスポート名: core_Mat_reshape1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_reshape1(cv::Mat *self, int cn, int rows, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;reshape(cn, rows);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_reshape2
[32/64bit] データをコピーすることなく，2 次元行列の形状やチャンネル数を変更します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr self
p2 = int : int cn
p3 = int : int newndims
p4 = var : [MarshalAs(UnmanagedType.LPArray), In] int[] newsz
p5 = var : out IntPtr returnValue
%inst
このメソッドは，*this の要素に対する新しい行列のヘッダを作成します．この新しい行列は，サイズやチャンネル数が異なっていても構いません．以下の条件であれば，どのような組み合わせも可能です：新しい行列に余分な要素が含まれておらず，また要素が除外されていない場合．したがって，行*列*チャネル() の積は，変換後も同じでなければいけません．

データはコピーされません。つまり，これは O(1) の演算です．したがって，行数を変更したり，その他の方法で行の要素のインデックスを変更したりした場合，その行列は連続したものでなければいけません．Mat::isContinuous を参照してください．例えば，STL のベクトルとして格納された 3D ポイントの集合があり，そのポイントを 3xN の行列として表現したい場合，次のようにします： std::vector<Point3f> vec;...Mat pointMat = Mat(vec)．// ベクトルを Mat に変換，O(1) の演算 reshape(1)．// Nx1 の 3 チャンネル行列から，Nx3 の 1 チャンネル行列を作成します．                              // これも O(1) の処理です． t(); // 最後に，Nx3 の行列を転置します．                          これは， // すべての要素をコピーすることになりますfragmentExamples: samples/cpp/pca.cpp, samples/dnn/classification.cpp.

元関数名(C#): core_Mat_reshape2
元DLLエクスポート名: core_Mat_reshape2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_reshape2(cv::Mat *self, int cn, int newndims, const int* newsz, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;reshape(cn, newndims, newsz);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_t
[32/64bit] 行列を転置します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst
このメソッドは，行列式を用いて行列の転置を行います．このオブジェクトは，より複雑な行列式の一部として利用したり，行列に割り当てたりすることができます： Mat A1 = A + Mat::eye(A.size(), A.type())*lambda;Mat C = A1.t()*A1; // (A + lambda*I)^t * (A + lambda*I)fragmentExamples: samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, and samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp.

元関数名(C#): core_Mat_t
元DLLエクスポート名: core_Mat_t
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_t(cv::Mat *self, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = self-&amp;gt;t();
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_inv
[32/64bit] 行列の逆行列を作成します。
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int method
p3 = var : out IntPtr returnValue
%inst
このメソッドは，行列式を用いて行列の反転を行います．つまり，一時的な行列反転オブジェクトが返され，より複雑な行列式の一部として利用したり，行列に代入したりすることができます．例： samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp.

元関数名(C#): core_Mat_inv
元DLLエクスポート名: core_Mat_inv
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_inv(cv::Mat *self, int method, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;inv(method);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_mul
[32/64bit] 2つの行列の要素ごとの乗算・除算を行います．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
p3 = double : double scale
p4 = var : out IntPtr returnValue
%inst
このメソッドは，要素毎の配列の乗算を，オプションの scale を用いてエンコードした一時的なオブジェクトを返します．例： Mat C = A.mul(5/B); // divide(A, B, C, 5)と等価なフラグメンテーション．

元関数名(C#): core_Mat_mul
元DLLエクスポート名: core_Mat_mul
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_mul(cv::Mat *self, cv::_InputArray *m, double scale, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;mul(*m, scale);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_cross
[32/64bit] 2 つの 3 要素のベクトルの外積を計算します．
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
p3 = var : out IntPtr returnValue
%inst
このメソッドは，2 つの 3 要素のベクトルの外積を計算します。ベクトルは，同じ形とサイズの 3 要素浮動小数点ベクトルでなければなりません。例： samples/cpp/tutorial_code/features2D/Homography/pose_from_homography.cpp.

元関数名(C#): core_Mat_cross
元DLLエクスポート名: core_Mat_cross
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_cross(cv::Mat *self, cv::_InputArray *m, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;cross(*m);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_dot
[32/64bit] 2つのベクトルのドット積を計算します。
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
p3 = var : out double returnValue
%inst
このメソッドは，2つの行列のドット積を計算します．行列が1列または1行のベクトルではない場合，上から下，左から右への走査順序が用いられ，1次元ベクトルとして扱われます。ベクトルのサイズとタイプは同じでなければなりません。例: samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp, and samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp.

元関数名(C#): core_Mat_dot
元DLLエクスポート名: core_Mat_dot
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_dot(cv::Mat *self, cv::_InputArray *m, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;dot(*m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_zeros1
[32/64bit] 指定されたサイズとタイプの0個の配列を返します。
%prm
p1,p2,p3,p4
p1 = int : int rows
p2 = int : int cols
p3 = int : int type
p4 = var : out IntPtr returnValue
%inst
このメソッドは，Matlab 形式のゼロ配列イニシャライザを返します．これは，関数のパラメータ，行列式の一部，あるいは行列のイニシャライザとして，定数配列を高速に形成するために利用できます： Mat A;A = Mat::zeros(3, 3, CV_32F);fragment上記の例では，A が 3x3 の浮動小数点型行列ではない場合にのみ，新しい行列が確保されます．例： samples/cpp/camshiftdemo.cpp, samples/cpp/contours2.cpp, samples/cpp/falecolor.cpp, samples/cpp/fitellipse.cpp, samples/cpp/kalman.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, and samples/dnn/segmentation.cpp.

元関数名(C#): core_Mat_zeros1
元DLLエクスポート名: core_Mat_zeros1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_zeros1(int rows, int cols, int type, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = cv::Mat::zeros(rows, cols, type);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_zeros2
[32/64bit] 指定されたサイズとタイプの0個の配列を返します。
%prm
p1,p2,p3,p4
p1 = int : int ndims
p2 = var : [MarshalAs(UnmanagedType.LPArray), In] int[] sz
p3 = int : int type
p4 = var : out IntPtr returnValue
%inst
このメソッドは，Matlab 形式のゼロ配列イニシャライザを返します．これは，関数のパラメータ，行列式の一部，あるいは行列のイニシャライザとして，定数配列を高速に形成するために利用できます： Mat A;A = Mat::zeros(3, 3, CV_32F);fragment上記の例では，A が 3x3 の浮動小数点型行列ではない場合にのみ，新しい行列が確保されます．例： samples/cpp/camshiftdemo.cpp, samples/cpp/contours2.cpp, samples/cpp/falecolor.cpp, samples/cpp/fitellipse.cpp, samples/cpp/kalman.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, and samples/dnn/segmentation.cpp.

元関数名(C#): core_Mat_zeros2
元DLLエクスポート名: core_Mat_zeros2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_zeros2(int ndims, const int *sz, int type, cv::MatExpr **returnValue) 
{
    BEGIN_WRAP
    const auto expr = cv::Mat::zeros(ndims, sz, type);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_ones1
[32/64bit] 指定されたサイズと型のすべての 1 の配列を返します。
%prm
p1,p2,p3,p4
p1 = int : int rows
p2 = int : int cols
p3 = int : int type
p4 = var : out IntPtr returnValue
%inst
このメソッドは， Mat::zeros と同様に，Matlab 形式の 1 の配列イニシャライザを返します．このメソッドを利用すると，次のような Matlab イディオムを用いて，任意の値で配列を初期化できることに注意してください： Mat A = Mat::ones(100, 100, CV_8U)*3; // 3.fragment で埋め尽くされた 100x100 の行列を作成します．上記の処理では，1 の 100x100 の行列を作成し，それに 3 を掛けることはありません．注意マルチチャンネルの場合，最初のチャンネルだけが 1 で初期化され，他のチャンネルは 0 になります．例： samples/cpp/demhist.cpp.

元関数名(C#): core_Mat_ones1
元DLLエクスポート名: core_Mat_ones1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_ones1(int rows, int cols, int type, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::Mat::ones(rows, cols, type);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_ones2
[32/64bit] 指定されたサイズと型のすべての 1 の配列を返します。
%prm
p1,p2,p3,p4
p1 = int : int ndims
p2 = var : [MarshalAs(UnmanagedType.LPArray), In] int[] sz
p3 = int : int type
p4 = var : out IntPtr returnValue
%inst
このメソッドは， Mat::zeros と同様に，Matlab 形式の 1 の配列イニシャライザを返します．このメソッドを利用すると，次のような Matlab イディオムを用いて，任意の値で配列を初期化できることに注意してください： Mat A = Mat::ones(100, 100, CV_8U)*3; // 3.fragment で埋め尽くされた 100x100 の行列を作成します．上記の処理では，1 の 100x100 の行列を作成し，それに 3 を掛けることはありません．注意マルチチャンネルの場合，最初のチャンネルだけが 1 で初期化され，他のチャンネルは 0 になります．例： samples/cpp/demhist.cpp.

元関数名(C#): core_Mat_ones2
元DLLエクスポート名: core_Mat_ones2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_ones2(int ndims, const int *sz, int type, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    auto ret = cv::Mat::ones(ndims, sz, type);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_eye
[32/64bit] 指定されたサイズと型の単位行列を返します．
%prm
p1,p2,p3,p4
p1 = int : int rows
p2 = int : int cols
p3 = int : int type
p4 = var : out IntPtr returnValue
%inst
このメソッドは，Mat::zeros と同様に，Matlab 形式の単位行列イニシャライザを返します．Mat::ones と同様に，スケール操作を利用して，スケーリングされた単位行列を効率的に作成することができます： // 対角線上に 0.1 を配置した 4x4 の対角行列を作成します．Mat A = Mat::eye(4, 4, CV_32F)*0.1;fragmentNoteマルチチャンネルタイプの場合，単位行列は最初のチャンネルに対してのみ初期化され，その他のチャンネルは 0's にセットされます．

元関数名(C#): core_Mat_eye
元DLLエクスポート名: core_Mat_eye
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_eye(int rows, int cols, int type, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto eye = cv::Mat::eye(rows, cols, type);
    *returnValue = new cv::MatExpr(eye);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_create1
[32/64bit] 必要に応じて，新しい配列データを確保します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = int : int rows
p3 = int : int cols
p4 = int : int type
%inst
これは，Mat の重要なメソッドの 1 つです．配列を生成する新スタイルの OpenCV 関数やメソッドのほとんどは，各出力配列に対してこのメソッドを呼び出します．このメソッドは，次のようなアルゴリズムを用います：現在の配列の形状と型が新しいものと一致する場合は，直ちに戻ります．そうでない場合は， Mat::release を呼び出して以前のデータの参照を解除します．

新しいヘッダを初期化します．

total()*elemSize() バイトの新しいデータを確保します．

データに関連付けられた新しい参照カウンタを確保し，それを 1 にセットします．このような方式は，メモリ管理を頑健かつ効率的にすると同時に，余計なタイプミスを防ぐのに役立ちます．つまり，通常，出力配列を明示的に確保する必要はありません。つまり，次のように書く代わりに，:Mat color;...Mat gray(color.rows, color.cols, color.depth());cvtColor(color, gray, COLOR_BGR2GRAY);fragmentty 単に次のように書くことができます：Mat color;...Mat gray;cvtColor(color, gray, COLOR_BGR2GRAY);fragmentなぜならば，cvtColor は，OpenCV のほとんどの関数と同様に，出力配列に対して Mat::create() を内部的に呼び出しているからです．例： samples/cpp/camshiftdemo.cpp，samples/cpp/edge.cpp，samples/cpp/ffilldemo.cpp，samples/cpp/grabcut.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp，samples/dnn/segmentation.cpp．

元関数名(C#): core_Mat_create1
元DLLエクスポート名: core_Mat_create1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_create1(cv::Mat *self, int rows, int cols, int type)
{
    BEGIN_WRAP
    self-&amp;gt;create(rows, cols, type);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_create2
[32/64bit] 必要に応じて，新しい配列データを確保します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = int : int ndims
p3 = var : [MarshalAs(UnmanagedType.LPArray)] int[] sizes
p4 = int : int type
%inst
これは，Mat の重要なメソッドの 1 つです．配列を生成する新スタイルの OpenCV 関数やメソッドのほとんどは，各出力配列に対してこのメソッドを呼び出します．このメソッドは，次のようなアルゴリズムを用います：現在の配列の形状と型が新しいものと一致する場合は，直ちに戻ります．そうでない場合は， Mat::release を呼び出して以前のデータの参照を解除します．

新しいヘッダを初期化します．

total()*elemSize() バイトの新しいデータを確保します．

データに関連付けられた新しい参照カウンタを確保し，それを 1 にセットします．このような方式は，メモリ管理を頑健かつ効率的にすると同時に，余計なタイプミスを防ぐのに役立ちます．つまり，通常，出力配列を明示的に確保する必要はありません。つまり，次のように書く代わりに，:Mat color;...Mat gray(color.rows, color.cols, color.depth());cvtColor(color, gray, COLOR_BGR2GRAY);fragmentty 単に次のように書くことができます：Mat color;...Mat gray;cvtColor(color, gray, COLOR_BGR2GRAY);fragmentなぜならば，cvtColor は，OpenCV のほとんどの関数と同様に，出力配列に対して Mat::create() を内部的に呼び出しているからです．例： samples/cpp/camshiftdemo.cpp，samples/cpp/edge.cpp，samples/cpp/ffilldemo.cpp，samples/cpp/grabcut.cpp，samples/cpp/stitching_detailed.cpp，samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp，samples/dnn/segmentation.cpp．

元関数名(C#): core_Mat_create2
元DLLエクスポート名: core_Mat_create2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_create2(cv::Mat *self, int ndims, const int *sizes, int type)
{
    BEGIN_WRAP
    self-&amp;gt;create(ndims, sizes, type);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_reserve
[32/64bit] 指定した行数分のスペースを確保します。
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = sptr : IntPtr sz
%inst
このメソッドは sz 行分のスペースを確保します。行列が既に sz 行分のスペースを持っている場合は何も起こりません。行列が再割り当てされた場合は，最初の Mat::rows 行が保存されます．このメソッドは，STL vector クラスの対応するメソッドをエミュレートします．

元関数名(C#): core_Mat_reserve
元DLLエクスポート名: core_Mat_reserve
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_reserve(cv::Mat *self, size_t sz)
{
    BEGIN_WRAP
    self-&amp;gt;reserve(sz);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_reserveBuffer
[32/64bit] 指定されたバイト数分の領域を確保します。
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = sptr : IntPtr sz
%inst
このメソッドは，sz バイト分の領域を確保します。行列が既に sz バイト分のスペースを持っている場合は何も起こりません。行列を再配置する必要がある場合、以前の内容が失われる可能性があります。

元関数名(C#): core_Mat_reserveBuffer
元DLLエクスポート名: core_Mat_reserveBuffer
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_reserveBuffer(cv::Mat *self, size_t sz)
{
    BEGIN_WRAP
    self-&amp;gt;reserveBuffer(sz);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_resize1
[32/64bit] 行列の行数を変更します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr sz
%inst
これらのメソッドは、行列の行数を変更します。行列が再割り当てされた場合，最初の min(Mat::rows, sz) 行が保存されます。これらのメソッドは，STL vector クラスの対応するメソッドを模したものです．

元関数名(C#): core_Mat_resize1
元DLLエクスポート名: core_Mat_resize1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_resize1(cv::Mat *obj, size_t sz)
{
    BEGIN_WRAP
    obj-&amp;gt;resize(sz);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_resize2
[32bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr sz
p3 = ARGS_SCALAR : Scalar s
%inst
元関数名(C#): core_Mat_resize2
元DLLエクスポート名: core_Mat_resize2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_resize2(cv::Mat *obj, size_t sz, MyCvScalar s)
{
    BEGIN_WRAP
    obj-&amp;gt;resize(sz, cpp(s));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_resize2
[64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr sz
p3 = var : Scalar s
%inst
元関数名(C#): core_Mat_resize2
元DLLエクスポート名: core_Mat_resize2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_resize2(cv::Mat *obj, size_t sz, MyCvScalar s)
{
    BEGIN_WRAP
    obj-&amp;gt;resize(sz, cpp(s));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_pop_back
[32/64bit] nelems ：削除される行数．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr nelems
%inst
このメソッドは，行列の最下部から 1 つ以上の行を削除します．

元関数名(C#): core_Mat_pop_back
元DLLエクスポート名: core_Mat_pop_back
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_pop_back(cv::Mat *obj, size_t nelems)
{
    BEGIN_WRAP
    obj-&amp;gt;pop_back(nelems);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_locateROI
[32/64bit] 行列のヘッダを親行列内に配置します。
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = var : out Size wholeSize
p3 = var : out Point ofs
%inst
Mat::row, Mat::col, Mat::rowRange, Mat::colRange などを用いて，行列から部分行列を抽出した後，結果として得られる部分行列は，元の大きな行列の一部を指し示します．しかし，各部分行列には，元の行列のサイズや，元の行列内での抽出された部分行列の位置を再構成するのに役立つ情報（ datastart と dataend フィールドによって表現されます）が含まれています．メソッド locateROI は，まさにそれを行います．

元関数名(C#): core_Mat_locateROI
元DLLエクスポート名: core_Mat_locateROI
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_locateROI(cv::Mat *self, MyCvSize *wholeSize, MyCvPoint *ofs)
{
    BEGIN_WRAP
    cv::Size wholeSize2;
    cv::Point ofs2;
    self-&amp;gt;locateROI(wholeSize2, ofs2);
    *wholeSize = c(cv::Size(wholeSize2.width, wholeSize2.height));
    *ofs = c(cv::Point(ofs2.x, ofs2.y));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_adjustROI
[32/64bit] 親行列内の部分行列のサイズと位置を調整します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr nativeObj
p2 = int : int dtop
p3 = int : int dbottom
p4 = int : int dleft
p5 = int : int dright
p6 = var : out IntPtr returnValue
%inst
このメソッドは， Mat::locateROI を補完するものです．これらの関数の典型的な利用方法は，親行列内の部分行列の位置を決定し，その位置を何らかの方法でシフトすることです．典型的には，ROI の外側にあるピクセルを考慮に入れるべきフィルタリング処理に必要になることがあります．A.adjustROI(2, 2, 2, 2);fragmentこの例では，行列のサイズが各方向に 4 要素ずつ増加しています．adjustROI は，調整後の ROI が親行列の内部に入るようにします．つまり，調整後の ROI の境界は，親行列の境界によって制約されます．例えば，部分行列 A が親行列の最初の行に位置していて，A.adjustROI(2, 2, 2, 2) と呼ばれた場合，A は上方向には増加しません．この関数は，OpenCV のフィルタリング関数（ filter2D や形態素解析など）によって内部的に利用されます．

元関数名(C#): core_Mat_adjustROI
元DLLエクスポート名: core_Mat_adjustROI
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_adjustROI(cv::Mat *self, int dtop, int dbottom, int dleft, int dright, cv::Mat** returnValue)
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;adjustROI(dtop, dbottom, dleft, dright);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_subMat1
[32/64bit] core_Mat_subMat1
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr self
p2 = int : int rowStart
p3 = int : int rowEnd
p4 = int : int colStart
p5 = int : int colEnd
p6 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_subMat1
元DLLエクスポート名: core_Mat_subMat1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_subMat1(cv::Mat *self, int rowStart, int rowEnd, int colStart, int colEnd, cv::Mat** returnValue)
{
    BEGIN_WRAP
    const cv::Range rowRange(rowStart, rowEnd);
    const cv::Range colRange(colStart, colEnd);
    const auto ret = (*self)(rowRange, colRange);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_subMat2
[32/64bit] core_Mat_subMat2
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = int : int nRanges
p3 = var : Range[] ranges
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_subMat2
元DLLエクスポート名: core_Mat_subMat2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_subMat2(cv::Mat *self, int nRanges, MyCvSlice *ranges, cv::Mat** returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Range&amp;gt; rangesVec(nRanges);
    for (auto i = 0; i &amp;lt; nRanges; i++)
    {
        rangesVec[i] = (cpp(ranges[i]));
    }
    const auto ret = (*self)(&amp;rangesVec[0]);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_isContinuous
[32/64bit] 行列が連続しているかどうかを報告します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
このメソッドは，行列の要素が各行の終わりに隙間なく連続して格納されている場合は true を返します．そうでない場合は，false を返します。明らかに，1x1 や 1xN の行列は常に連続しています．Mat::create で作成された行列は，常に連続しています．しかし， Mat::col や Mat::diag などを用いて行列の一部を抽出したり，外部から割り当てられたデータのために行列ヘッダを作成したりすると，そのような行列はもはやこの特性を持たないかもしれません．連続性フラグは Mat::flags フィールドのビットとして保存され，行列ヘッダを作成する際に自動的に計算されます．連続性フラグは Mat::flags フィールドのビットとして保存され，行列のヘッダを作成する際に自動的に計算されます．したがって，連続性チェックは非常に高速な処理ですが，理論的には以下のように行うこともできます： // Mat::isContinuous()の代替実装 bool myCheckMatContinuity(const Mat& m){ //return (m.flags & Mat::CONTINUOUS_FLAG) != 0; return m.rows == 1 || m.step == m.cols*m.elemSize();}fragmentこのメソッドは，OpenCV のかなり多くの関数で利用されています．ポイントは，要素単位の演算（算術演算や論理演算，数学関数，アルファブレンディング，色空間変換など）は，画像の形状に依存しないということです．したがって，入出力配列がすべて連続している場合，関数はそれらを非常に長い1列のベクトルとして処理することができます．以下の例は，アルファブレンディング関数がどのように実装されるかを示しています： template<typename T>void alphaBlendRGBA(const Mat& src1, const Mat& src2, Mat& dst){ const float alpha_scale = (float)std::numeric_limits<T>::max(), inv_scale = 1.f/alpha_scale; CV_Assert( src1.type() == src2.type() && src1.type() == CV_MAKETYPE(traits::Depth<T>::value, 4) && src1.size() == src2.size()); Size size = src1.size(); dst.create(size, src1.type()); // ここでイディオムですが，配列が連続しているかどうかをチェックし， // 連続している場合は， // 配列を 1 次元のベクトルとして扱う if( src1.isContinuous() && src2.isContinuous() && dst.isContinuous() )    { size.width *= size.height; size.height = 1; } size.width *= 4; for( int i = 0; i < size.height; i++ ) { // 配列が連続している場合， // 外側のループは一度だけ実行されます const T* ptr1 = src1.ptr<T>(i); const T* ptr2 = src2.ptr<T>(i); T* dptr = dst.ptr<T>(i); for( int j = 0; j < size.width; j += 4 ) { float alpha = ptr1[j+3]*inv_scale, beta = ptr2[j+3]*inv_scale; dptr[j] = saturate_cast<T>(ptr1[j]*alpha + ptr2[j]*beta);            dptr[j+1] = saturate_cast<T>(ptr1[j+1]*alpha + ptr2[j+1]*beta); dptr[j+2] = saturate_cast<T>(ptr1[j+2]*alpha + ptr2[j+2]*beta); dptr[j+3] = saturate_cast<T>((1 - (1-alpha)*(1-beta))*alpha_scale); }。    この関数に含まれるもう1つの OpenCV のイディオムである，出力配列に対する Mat::create の呼び出しは，出力配列が既に適切なサイズと型を持っている場合を除いて，その出力配列を確保します．また，新たに確保された配列は常に連続していますが， Mat::create が常に新しい行列を確保するとは限らないので，出力配列をチェックする必要があります．

元関数名(C#): core_Mat_isContinuous
元DLLエクスポート名: core_Mat_isContinuous
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_isContinuous(cv::Mat *self, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;isContinuous() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_isSubmatrix
[32/64bit] 行列が別の行列の部分行列である場合は真を返します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
元関数名(C#): core_Mat_isSubmatrix
元DLLエクスポート名: core_Mat_isSubmatrix
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_isSubmatrix(cv::Mat *self, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;isSubmatrix() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_elemSize
[32/64bit] 行列の要素サイズをバイト単位で返します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst
このメソッドは，行列の要素サイズをバイト単位で返します．例えば，行列の種類が CV_16SC3 の場合，このメソッドは 3*sizeof(short) または 6 を返します．

元関数名(C#): core_Mat_elemSize
元DLLエクスポート名: core_Mat_elemSize
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_elemSize(cv::Mat *self, size_t *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;elemSize();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_elemSize1
[32/64bit] 各行列要素のチャンネルのサイズをバイト単位で返します。
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst
このメソッドは，行列要素のチャンネルのサイズをバイト単位で返します（つまり，チャンネル数は無視します）．例えば，行列の種類が CV_16SC3 の場合，このメソッドは sizeof(short) または 2 を返します．

元関数名(C#): core_Mat_elemSize1
元DLLエクスポート名: core_Mat_elemSize1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_elemSize1(cv::Mat *self, size_t *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;elemSize1();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_type
[32/64bit] 行列の要素の型を返します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
このメソッドは，行列の要素の型を返します．これは， CV_16SC3 や 16 ビット符号付き 3 チャンネル配列などのように，CvMat の型システムと互換性のある識別子です．例： samples/cpp/grabcut.cpp， samples/cpp/image_alignment.cpp， samples/cpp/train_HOG.cpp， samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp．

元関数名(C#): core_Mat_type
元DLLエクスポート名: core_Mat_type
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_type(cv::Mat *self, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;type();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_depth
[32/64bit] 行列の要素の深さを返します。
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
このメソッドは，行列要素の深度（個々のチャンネルの型）の識別子を返します．例えば，16 ビット符号付き要素の配列の場合，このメソッドは CV_16S を返します．行列の型の完全なリストには，以下の値が含まれます： CV_8U - 8 ビット符号なし整数（0 〜 255 ）．

CV_8S - 8 ビットの符号付き整数 ( -128..127 )

CV_16U - 16 ビット符号なし整数 ( 0 〜 65535 )

CV_16S - 16 ビット符号付き整数 ( -32768 ...32767 )

CV_32S - 32ビット符号付き整数 ( -2147483648 〜.2147483647 )

CV_32F - 32ビット浮動小数点数 ( -FLT_MAX..FLT_MAX, INF, NAN )

CV_64F - 64 ビット浮動小数点数 ( -DBL_MAX..DBL_MAX, INF, NAN )例： samples/cpp/camshiftdemo.cpp.

元関数名(C#): core_Mat_depth
元DLLエクスポート名: core_Mat_depth
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_depth(cv::Mat *self, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;depth();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_channels
[32/64bit] マトリックスのチャンネル数を返します。
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
このメソッドは、行列のチャネル数を返します。例：samples/cpp/pca.cpp.

元関数名(C#): core_Mat_channels
元DLLエクスポート名: core_Mat_channels
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_channels(cv::Mat *self, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;channels();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_empty
[32/64bit] 配列に要素がない場合に真を返します。
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
このメソッドは， Mat::total() が 0 であるか， Mat::data が NULL である場合に真を返します．pop_back() や resize() メソッドがあるので， M.total() == 0 は M.data == NULL を意味しません． 例： fld_lines.cpp, samples/cpp/facedetect.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/lkdemo.cpp, samples/cpp/squares.cpp, samples/cpp/stitching.cpp, samples/cpp/stitching_detailed.cpp, samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp、samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp、samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp、samples/cpp/watershed.cpp、samples/dnn/colorization.cpp、samples/dnn/object_detection.cpp、samples/dnn/openpose.cpp、samples/dnn/segmentation.cppです。

元関数名(C#): core_Mat_empty
元DLLエクスポート名: core_Mat_empty
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_empty(cv::Mat *self, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;empty() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_total1
[32/64bit] 配列の総要素数を返します。
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst
サンプル/cpp/train_HOG.cpp. サンプル/cpp/train_HOG.cpp.

元関数名(C#): core_Mat_total1
元DLLエクスポート名: core_Mat_total1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_total1(cv::Mat *self, size_t *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;total();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_total2
[32/64bit] 配列の総要素数を返します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = int : int startDim
p3 = int : int endDim
p4 = var : out IntPtr returnValue
%inst
サンプル/cpp/train_HOG.cpp. サンプル/cpp/train_HOG.cpp.

元関数名(C#): core_Mat_total2
元DLLエクスポート名: core_Mat_total2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_total2(cv::Mat *self, int startDim, int endDim, size_t *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;total(startDim, endDim);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_checkVector
[32/64bit] 以下のコードは，2 次元の行列に対する使用例です．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr self
p2 = int : int elemChannels
p3 = int : int depth
p4 = int : int requireContinuous
p5 = var : out int returnValue
%inst
cv::Mat mat(20, 1, CV_32FC2); int n = mat.checkVector(2); CV_Assert(n == 20); // mat は 20 個の要素を持ちます mat.create(20, 2, CV_32FC1); n = mat.checkVector(1); CV_Assert(n == -1); // mat は，列ベクトルでも行ベクトルでもありません n = mat.checkVector(2); CV_Assert(n == 20); // 2 列を 1 つの要素と見なすfragment次のコードは，3 次元の行列に対する使い方を示しています： int dims[] = {1, 3, 5}; // 1 つの平面，すべての平面は 3 行 5 列である mat.create(3, dims, CV_32FC1); // 3-d の行列では，1つのチャンネルのみを持たなければいけません n = mat.checkVector(5); // 5つの列は1つの要素とみなされます CV_Assert(n == 3); int dims2[] = {3, 1, 5}; // 3つの平面，各平面は1つの行と5つの列を持ちます mat.create(3, dims2, CV_32FC1); n = mat.checkVector(5); // 5 つの列を 1 つの要素と見なす CV_Assert(n == 3);fragment

元関数名(C#): core_Mat_checkVector
元DLLエクスポート名: core_Mat_checkVector
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_checkVector(cv::Mat *self, int elemChannels, int depth, int requireContinuous, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;checkVector(elemChannels, depth, requireContinuous != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_ptr1d
[32/64bit] 行列の指定された行へのポインタを返します．
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int i0
p3 = var : out IntPtr returnValue
%inst
これらのメソッドは，指定された行列の行に対する uchar* または型付きポインタを返します．これらのメソッドの使い方については， Mat::isContinuous のサンプルを参照してください．例： samples/cpp/image_alignment.cpp, samples/cpp/train_HOG.cpp, samples/dnn/colorization.cpp, samples/dnn/openpose.cpp, and samples/dnn/segmentation.cpp.

元関数名(C#): core_Mat_ptr1d
元DLLエクスポート名: core_Mat_ptr1d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_ptr1d(cv::Mat *self, int i0, uchar **returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;ptr(i0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_ptr2d
[32/64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = int : int i0
p3 = int : int i1
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_ptr2d
元DLLエクスポート名: core_Mat_ptr2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_ptr2d(cv::Mat *self, int i0, int i1, uchar **returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;ptr(i0, i1);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_ptr3d
[32/64bit] 行列の指定された行へのポインタを返します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr self
p2 = int : int i0
p3 = int : int i1
p4 = int : int i2
p5 = var : out IntPtr returnValue
%inst
これらのメソッドは，指定された行列の行に対する uchar* または型付きポインタを返します．これらのメソッドの使い方については， Mat::isContinuous のサンプルを参照してください．例： samples/cpp/image_alignment.cpp, samples/cpp/train_HOG.cpp, samples/dnn/colorization.cpp, samples/dnn/openpose.cpp, and samples/dnn/segmentation.cpp.

元関数名(C#): core_Mat_ptr3d
元DLLエクスポート名: core_Mat_ptr3d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_ptr3d(cv::Mat *self, int i0, int i1, int i2, uchar **returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;ptr(i0, i1, i2);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_ptrnd
[32/64bit] 行列の指定された行へのポインタを返します．
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = var : [MarshalAs(UnmanagedType.LPArray), In] int[] idx
p3 = var : out IntPtr returnValue
%inst
これらのメソッドは，指定された行列の行に対する uchar* または型付きポインタを返します．これらのメソッドの使い方については， Mat::isContinuous のサンプルを参照してください．例： samples/cpp/image_alignment.cpp, samples/cpp/train_HOG.cpp, samples/dnn/colorization.cpp, samples/dnn/openpose.cpp, and samples/dnn/segmentation.cpp.

元関数名(C#): core_Mat_ptrnd
元DLLエクスポート名: core_Mat_ptrnd
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_ptrnd(cv::Mat *self, int *idx, uchar **returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;ptr(idx);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_flags
[32/64bit] cv::Mat::flags 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
には，いくつかのビットフィールドが含まれています．
マジックサイン

連続性フラグ

深さ

チャンネルの数

元関数名(C#): core_Mat_flags
元DLLエクスポート名: core_Mat_flags
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_flags(cv::Mat *self, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;flags;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_dims
[32/64bit] cv::Mat::dims 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
行列の次元，≧2


元関数名(C#): core_Mat_dims
元DLLエクスポート名: core_Mat_dims
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_dims(cv::Mat *self, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;dims;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_rows
[32/64bit] cv::Mat::rows 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
行列の行数と列数，または行列が2次元以上の場合は (-1, -1) を指定します．
例： samples/cpp/camshiftdemo.cpp, samples/cpp/convexhull.cpp, samples/cpp/demhist.cpp, samples/cpp/falecolor.cpp, samples/cpp/fitellipse.cpp, samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp, samples/cpp/minarea.cpp, samples/cpp/squares.cpp, samples/cpp/stitching.cpp, samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp、samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp、samples/cpp/warpPerspective_demo.cpp、samples/cpp/watershed.cpp、samples/dnn/object_detection.cpp、samples/dnn/openpose.cppがあります。

元関数名(C#): core_Mat_rows
元DLLエクスポート名: core_Mat_rows
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_rows(cv::Mat *self, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;rows;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_cols
[32/64bit] cv::Mat::cols 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
例： samples/cpp/camshiftdemo.cpp、samples/cpp/convexhull.cpp、samples/cpp/demhist.cpp、samples/cpp/facedetect.cpp、samples/cpp/falecolor.cpp、samples/cpp/fitellipse.cpp、samples/cpp/grabcut.cpp, samples/cpp/image_alignment.cpp, samples/cpp/kalman.cpp, samples/cpp/kmeans.cpp, samples/cpp/minarea.cpp, samples/cpp/squares.cpp, samples/cpp/stitching.cpp, samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp.cpp、samples/cpp/tutorial_code/ImgTrans/copyMakeBorder_demo.cpp、samples/cpp/warpPerspective_demo.cpp、samples/cpp/watershed.cpp、samples/dn/object_detection.cpp、samples/dn/openpose.cpp。


元関数名(C#): core_Mat_cols
元DLLエクスポート名: core_Mat_cols
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_cols(cv::Mat *self, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;cols;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_data
[32/64bit] cv::Mat::data 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out byte* returnValue
%inst
データへのポインタ
例：samples/dnn/segmentation.cpp.

元関数名(C#): core_Mat_data
元DLLエクスポート名: core_Mat_data
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_data(cv::Mat *self, uchar **returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;data;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_datastart
[32/64bit] cv::Mat::datastart 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst
locateROI および adjustROI で使用するヘルパー・フィールド


元関数名(C#): core_Mat_datastart
元DLLエクスポート名: core_Mat_datastart
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_datastart(cv::Mat *self, const uchar **returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;datastart;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_dataend
[32/64bit] cv::Mat::dataend 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): core_Mat_dataend
元DLLエクスポート名: core_Mat_dataend
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_dataend(cv::Mat *self, const uchar **returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;dataend;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_datalimit
[32/64bit] cv::Mat::datalimit 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): core_Mat_datalimit
元DLLエクスポート名: core_Mat_datalimit
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_datalimit(cv::Mat *self, const uchar **returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;datalimit;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_size
[32/64bit] core_Mat_size
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out Size returnValue
%inst
元関数名(C#): core_Mat_size
元DLLエクスポート名: core_Mat_size
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(uint64) core_Mat_sizeof()
{
    return sizeof(cv::Mat);
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_sizeAt
[32/64bit] cv::Mat::size 変数を取得します
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int i
p3 = var : out int returnValue
%inst
例：fld_lines.cpp、samples/cpp/camshiftdemo.cpp、samples/cpp/connected_components.cpp、samples/cpp/create_mask.cpp、samples/cpp/grabcut.cpp、samples/cpp/image_alignment.cpp、samples/cpp/polar_transforms.cpp、samples/cpp/segment_objects.cpp、samples/cpp/squares.cpp、samples/cpp/stitching_detailed.cpp。cpp, samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp、samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp、samples/cpp/watershed.cpp、samples/dnn/colorization.cpp、samples/dnn/openpose.cpp、samples/dnn/segmentation.cppです。


元関数名(C#): core_Mat_sizeAt
元DLLエクスポート名: core_Mat_sizeAt
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_sizeAt(cv::Mat *self, int i, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;size[i];
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_step1
[32/64bit] 正規化されたステップを返します。
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int i
p3 = var : out IntPtr returnValue
%inst
このメソッドは，行列のステップを Mat::elemSize1() で割った値を返します．これは，任意の行列要素に素早くアクセスするのに役立ちます．

元関数名(C#): core_Mat_step1
元DLLエクスポート名: core_Mat_step1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_step1(cv::Mat *self, int i, size_t *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;step1(i);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_step
[32/64bit] 正規化されたステップを返します。
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst
このメソッドは，行列のステップを Mat::elemSize1() で割った値を返します．これは，任意の行列要素に素早くアクセスするのに役立ちます．

元関数名(C#): core_Mat_step
元DLLエクスポート名: core_Mat_step
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_step1(cv::Mat *self, int i, size_t *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;step1(i);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_stepAt
[32/64bit] cv::Mat::step 変数を取得します
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int i
p3 = var : out IntPtr returnValue
%inst



元関数名(C#): core_Mat_stepAt
元DLLエクスポート名: core_Mat_stepAt
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_stepAt(cv::Mat *self, int i, size_t *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;step[i];
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_abs_Mat
[32/64bit] core_abs_Mat
%prm
p1,p2
p1 = sptr : IntPtr e
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_abs_Mat
元DLLエクスポート名: core_abs_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_abs_Mat(cv::Mat *m, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::abs(*m);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_setMatData
[32/64bit] core_Mat_setMatData
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = var : byte* vals
p3 = var : out int returnValue
%inst
元関数名(C#): core_Mat_setMatData
元DLLエクスポート名: core_Mat_setMatData
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_setMatData(cv::Mat *obj, uchar *vals, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = internal_Mat_set(obj, vals) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_getMatData
[32/64bit] core_Mat_getMatData
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = var : byte* vals
p3 = var : out int returnValue
%inst
元関数名(C#): core_Mat_getMatData
元DLLエクスポート名: core_Mat_getMatData
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_getMatData(cv::Mat *obj, uchar *vals, int *returnValue)
{    
    BEGIN_WRAP
    *returnValue = internal_Mat_get(obj, vals) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Mat
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Mat
元DLLエクスポート名: core_Mat_push_back_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Mat(cv::Mat *self, cv::Mat *m)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(*m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_char
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = int : sbyte v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_char
元DLLエクスポート名: core_Mat_push_back_char
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_char(cv::Mat *self, char v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(v);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_uchar
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = int : byte v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_uchar
元DLLエクスポート名: core_Mat_push_back_uchar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_uchar(cv::Mat *self, uchar v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(v);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_short
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = int : short v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_short
元DLLエクスポート名: core_Mat_push_back_short
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_short(cv::Mat *self, short v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(v);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_ushort
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = int : ushort v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_ushort
元DLLエクスポート名: core_Mat_push_back_ushort
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_ushort(cv::Mat *self, ushort v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(v);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_int
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = int : int v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_int
元DLLエクスポート名: core_Mat_push_back_int
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_int(cv::Mat *self, int v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(v);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_float
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = float : float v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_float
元DLLエクスポート名: core_Mat_push_back_float
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_float(cv::Mat *self, float v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(v);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_double
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = double : double v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_double
元DLLエクスポート名: core_Mat_push_back_double
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_double(cv::Mat *self, double v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(v);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec2b
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC2B : Vec2b v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec2b
元DLLエクスポート名: core_Mat_push_back_Vec2b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec2b(cv::Mat *self, CvVec2b v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec2b(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec2b
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = int : Vec2b v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec2b
元DLLエクスポート名: core_Mat_push_back_Vec2b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec2b(cv::Mat *self, CvVec2b v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec2b(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec3b
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC3B : Vec3b v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec3b
元DLLエクスポート名: core_Mat_push_back_Vec3b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec3b(cv::Mat *self, CvVec3b v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec3b(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec3b
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = int : Vec3b v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec3b
元DLLエクスポート名: core_Mat_push_back_Vec3b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec3b(cv::Mat *self, CvVec3b v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec3b(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec4b
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC4B : Vec4b v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec4b
元DLLエクスポート名: core_Mat_push_back_Vec4b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec4b(cv::Mat *self, CvVec4b v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec4b(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec4b
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = int : Vec4b v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec4b
元DLLエクスポート名: core_Mat_push_back_Vec4b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec4b(cv::Mat *self, CvVec4b v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec4b(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec6b
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC6B : Vec6b v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec6b
元DLLエクスポート名: core_Mat_push_back_Vec6b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec6b(cv::Mat *self, CvVec6b v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec6b(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec2s
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC2S : Vec2s v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec2s
元DLLエクスポート名: core_Mat_push_back_Vec2s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec2s(cv::Mat *self, CvVec2s v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec2s(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec2s
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = int : Vec2s v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec2s
元DLLエクスポート名: core_Mat_push_back_Vec2s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec2s(cv::Mat *self, CvVec2s v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec2s(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec3s
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC3S : Vec3s v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec3s
元DLLエクスポート名: core_Mat_push_back_Vec3s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec3s(cv::Mat *self, CvVec3s v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec3s(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec4s
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC4S : Vec4s v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec4s
元DLLエクスポート名: core_Mat_push_back_Vec4s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec4s(cv::Mat *self, CvVec4s v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec4s(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec6s
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC6S : Vec6s v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec6s
元DLLエクスポート名: core_Mat_push_back_Vec6s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec6s(cv::Mat *self, CvVec6s v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec6s(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec6s
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Vec6s v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec6s
元DLLエクスポート名: core_Mat_push_back_Vec6s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec6s(cv::Mat *self, CvVec6s v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec6s(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec2w
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC2W : Vec2w v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec2w
元DLLエクスポート名: core_Mat_push_back_Vec2w
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec2w(cv::Mat *self, CvVec2w v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec2w(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec2w
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = int : Vec2w v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec2w
元DLLエクスポート名: core_Mat_push_back_Vec2w
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec2w(cv::Mat *self, CvVec2w v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec2w(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec3w
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC3W : Vec3w v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec3w
元DLLエクスポート名: core_Mat_push_back_Vec3w
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec3w(cv::Mat *self, CvVec3w v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec3w(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec4w
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC4W : Vec4w v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec4w
元DLLエクスポート名: core_Mat_push_back_Vec4w
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec4w(cv::Mat *self, CvVec4w v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec4w(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec6w
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC6W : Vec6w v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec6w
元DLLエクスポート名: core_Mat_push_back_Vec6w
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec6w(cv::Mat *self, CvVec6w v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec6w(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec6w
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Vec6w v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec6w
元DLLエクスポート名: core_Mat_push_back_Vec6w
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec6w(cv::Mat *self, CvVec6w v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec6w(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec2i
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC2I : Vec2i v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec2i
元DLLエクスポート名: core_Mat_push_back_Vec2i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec2i(cv::Mat *self, CvVec2i v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec2i(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec3i
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC3I : Vec3i v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec3i
元DLLエクスポート名: core_Mat_push_back_Vec3i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec3i(cv::Mat *self, CvVec3i v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec3i(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec3i
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Vec3i v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec3i
元DLLエクスポート名: core_Mat_push_back_Vec3i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec3i(cv::Mat *self, CvVec3i v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec3i(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec4i
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC4I : Vec4i v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec4i
元DLLエクスポート名: core_Mat_push_back_Vec4i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec4i(cv::Mat *self, CvVec4i v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec4i(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec4i
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Vec4i v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec4i
元DLLエクスポート名: core_Mat_push_back_Vec4i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec4i(cv::Mat *self, CvVec4i v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec4i(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec6i
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC6I : Vec6i v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec6i
元DLLエクスポート名: core_Mat_push_back_Vec6i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec6i(cv::Mat *self, CvVec6i v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec6i(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec6i
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Vec6i v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec6i
元DLLエクスポート名: core_Mat_push_back_Vec6i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec6i(cv::Mat *self, CvVec6i v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec6i(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec2f
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC2F : Vec2f v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec2f
元DLLエクスポート名: core_Mat_push_back_Vec2f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec2f(cv::Mat *self, CvVec2f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec2f(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec3f
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC3F : Vec3f v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec3f
元DLLエクスポート名: core_Mat_push_back_Vec3f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec3f(cv::Mat *self, CvVec3f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec3f(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec3f
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Vec3f v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec3f
元DLLエクスポート名: core_Mat_push_back_Vec3f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec3f(cv::Mat *self, CvVec3f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec3f(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec4f
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC4F : Vec4f v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec4f
元DLLエクスポート名: core_Mat_push_back_Vec4f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec4f(cv::Mat *self, CvVec4f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec4f(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec4f
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Vec4f v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec4f
元DLLエクスポート名: core_Mat_push_back_Vec4f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec4f(cv::Mat *self, CvVec4f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec4f(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec6f
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC6F : Vec6f v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec6f
元DLLエクスポート名: core_Mat_push_back_Vec6f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec6f(cv::Mat *self, CvVec6f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec6f(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec6f
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Vec6f v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec6f
元DLLエクスポート名: core_Mat_push_back_Vec6f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec6f(cv::Mat *self, CvVec6f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec6f(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec2d
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC2D : Vec2d v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec2d
元DLLエクスポート名: core_Mat_push_back_Vec2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec2d(cv::Mat *self, CvVec2d v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec2d(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec2d
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Vec2d v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec2d
元DLLエクスポート名: core_Mat_push_back_Vec2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec2d(cv::Mat *self, CvVec2d v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec2d(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec3d
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC3D : Vec3d v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec3d
元DLLエクスポート名: core_Mat_push_back_Vec3d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec3d(cv::Mat *self, CvVec3d v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec3d(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec3d
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Vec3d v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec3d
元DLLエクスポート名: core_Mat_push_back_Vec3d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec3d(cv::Mat *self, CvVec3d v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec3d(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec4d
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC4D : Vec4d v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec4d
元DLLエクスポート名: core_Mat_push_back_Vec4d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec4d(cv::Mat *self, CvVec4d v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec4d(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec4d
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Vec4d v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec4d
元DLLエクスポート名: core_Mat_push_back_Vec4d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec4d(cv::Mat *self, CvVec4d v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec4d(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec6d
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_VEC6D : Vec6d v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec6d
元DLLエクスポート名: core_Mat_push_back_Vec6d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec6d(cv::Mat *self, CvVec6d v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec6d(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Vec6d
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Vec6d v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Vec6d
元DLLエクスポート名: core_Mat_push_back_Vec6d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Vec6d(cv::Mat *self, CvVec6d v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Vec6d(v.val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Point
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_POINT : Point v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Point
元DLLエクスポート名: core_Mat_push_back_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Point(cv::Mat *self, MyCvPoint v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Point(v.x, v.y));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Point2f
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_POINT2F : Point2f v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Point2f
元DLLエクスポート名: core_Mat_push_back_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Point2f(cv::Mat *self, MyCvPoint2D32f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Point2f(v.x, v.y));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Point2d
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_POINT2D : Point2d v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Point2d
元DLLエクスポート名: core_Mat_push_back_Point2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Point2d(cv::Mat *self, MyCvPoint2D64f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Point2d(v.x, v.y));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Point2d
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Point2d v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Point2d
元DLLエクスポート名: core_Mat_push_back_Point2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Point2d(cv::Mat *self, MyCvPoint2D64f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Point2d(v.x, v.y));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Point3i
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_POINT3I : Point3i v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Point3i
元DLLエクスポート名: core_Mat_push_back_Point3i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Point3i(cv::Mat *self, MyCvPoint3D32i v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Point3i(v.x, v.y, v.z));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Point3i
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Point3i v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Point3i
元DLLエクスポート名: core_Mat_push_back_Point3i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Point3i(cv::Mat *self, MyCvPoint3D32i v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Point3i(v.x, v.y, v.z));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Point3f
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_POINT3F : Point3f v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Point3f
元DLLエクスポート名: core_Mat_push_back_Point3f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Point3f(cv::Mat *self, MyCvPoint3D32f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Point3f(v.x, v.y, v.z));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Point3f
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Point3f v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Point3f
元DLLエクスポート名: core_Mat_push_back_Point3f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Point3f(cv::Mat *self, MyCvPoint3D32f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Point3f(v.x, v.y, v.z));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Point3d
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_POINT3D : Point3d v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Point3d
元DLLエクスポート名: core_Mat_push_back_Point3d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Point3d(cv::Mat *self, MyCvPoint3D64f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Point3d(v.x, v.y, v.z));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Point3d
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Point3d v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Point3d
元DLLエクスポート名: core_Mat_push_back_Point3d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Point3d(cv::Mat *self, MyCvPoint3D64f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Point3d(v.x, v.y, v.z));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Size
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_SIZE : Size v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Size
元DLLエクスポート名: core_Mat_push_back_Size
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Size(cv::Mat *self, MyCvSize v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Size(v.width, v.height));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Size2f
[32/64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_SIZE2F : Size2f v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Size2f
元DLLエクスポート名: core_Mat_push_back_Size2f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Size2f(cv::Mat *self, MyCvSize2D32f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Size2f(v.width, v.height));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Size2d
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_SIZE2D : Size2d v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Size2d
元DLLエクスポート名: core_Mat_push_back_Size2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Size2d(cv::Mat *self, MyCvSize2D64f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Size2d(v.width, v.height));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Size2d
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Size2d v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Size2d
元DLLエクスポート名: core_Mat_push_back_Size2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Size2d(cv::Mat *self, MyCvSize2D64f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Size2d(v.width, v.height));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Rect
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_RECT : Rect v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Rect
元DLLエクスポート名: core_Mat_push_back_Rect
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Rect(cv::Mat *self, MyCvRect v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Rect(v.x, v.y, v.width, v.height));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Rect
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Rect v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Rect
元DLLエクスポート名: core_Mat_push_back_Rect
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Rect(cv::Mat *self, MyCvRect v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Rect(v.x, v.y, v.width, v.height));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Rect2f
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_RECT2F : Rect2f v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Rect2f
元DLLエクスポート名: core_Mat_push_back_Rect2f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Rect2f(cv::Mat *self, MyCvRect2D32f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Rect2f(v.x, v.y, v.width, v.height));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Rect2f
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Rect2f v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Rect2f
元DLLエクスポート名: core_Mat_push_back_Rect2f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Rect2f(cv::Mat *self, MyCvRect2D32f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Rect2f(v.x, v.y, v.width, v.height));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Rect2d
[32bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_RECT2D : Rect2d v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Rect2d
元DLLエクスポート名: core_Mat_push_back_Rect2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Rect2d(cv::Mat *self, MyCvRect2D64f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Rect2d(v.x, v.y, v.width, v.height));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_push_back_Rect2d
[64bit] 行列の底に要素を追加します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : Rect2d v
%inst
これらのメソッドは，1 つ以上の要素を行列の底に追加します．これらのメソッドは，STL vector クラスの対応するメソッドをエミュレートしています．elem が Mat の場合，その型と列数は，コンテナ行列と同じでなければいけません．

元関数名(C#): core_Mat_push_back_Rect2d
元DLLエクスポート名: core_Mat_push_back_Rect2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_push_back_Rect2d(cv::Mat *self, MyCvRect2D64f v)
{
    BEGIN_WRAP
    self-&amp;gt;push_back(cv::Rect2d(v.x, v.y, v.width, v.height));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_uchar
[32/64bit] core_Mat_forEach_uchar
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionByte proc
%inst
元関数名(C#): core_Mat_forEach_uchar
元DLLエクスポート名: core_Mat_forEach_uchar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_uchar(cv::Mat *m, Mat_foreach_uchar proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_uchar, uchar&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;uchar&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec2b
[32/64bit] core_Mat_forEach_Vec2b
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec2b proc
%inst
元関数名(C#): core_Mat_forEach_Vec2b
元DLLエクスポート名: core_Mat_forEach_Vec2b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec2b(cv::Mat *m, Mat_foreach_Vec2b proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec2b, cv::Vec2b&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec2b&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec3b
[32/64bit] core_Mat_forEach_Vec3b
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec3b proc
%inst
元関数名(C#): core_Mat_forEach_Vec3b
元DLLエクスポート名: core_Mat_forEach_Vec3b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec3b(cv::Mat *m, Mat_foreach_Vec3b proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec3b, cv::Vec3b&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec3b&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec4b
[32/64bit] core_Mat_forEach_Vec4b
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec4b proc
%inst
元関数名(C#): core_Mat_forEach_Vec4b
元DLLエクスポート名: core_Mat_forEach_Vec4b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec4b(cv::Mat *m, Mat_foreach_Vec4b proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec4b, cv::Vec4b&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec4b&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec6b
[32/64bit] core_Mat_forEach_Vec6b
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec6b proc
%inst
元関数名(C#): core_Mat_forEach_Vec6b
元DLLエクスポート名: core_Mat_forEach_Vec6b
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec6b(cv::Mat *m, Mat_foreach_Vec6b proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec6b, cv::Vec6b&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec6b&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_short
[32/64bit] core_Mat_forEach_short
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionInt16 proc
%inst
元関数名(C#): core_Mat_forEach_short
元DLLエクスポート名: core_Mat_forEach_short
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_short(cv::Mat *m, Mat_foreach_short proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_short, short&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;short&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec2s
[32/64bit] core_Mat_forEach_Vec2s
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec2s proc
%inst
元関数名(C#): core_Mat_forEach_Vec2s
元DLLエクスポート名: core_Mat_forEach_Vec2s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec2s(cv::Mat *m, Mat_foreach_Vec2s proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec2s, cv::Vec2s&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec2s&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec3s
[32/64bit] core_Mat_forEach_Vec3s
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec3s proc
%inst
元関数名(C#): core_Mat_forEach_Vec3s
元DLLエクスポート名: core_Mat_forEach_Vec3s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec3s(cv::Mat *m, Mat_foreach_Vec3s proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec3s, cv::Vec3s&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec3s&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec4s
[32/64bit] core_Mat_forEach_Vec4s
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec4s proc
%inst
元関数名(C#): core_Mat_forEach_Vec4s
元DLLエクスポート名: core_Mat_forEach_Vec4s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec4s(cv::Mat *m, Mat_foreach_Vec4s proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec4s, cv::Vec4s&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec4s&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec6s
[32/64bit] core_Mat_forEach_Vec6s
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec6s proc
%inst
元関数名(C#): core_Mat_forEach_Vec6s
元DLLエクスポート名: core_Mat_forEach_Vec6s
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec6s(cv::Mat *m, Mat_foreach_Vec6s proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec6s, cv::Vec6s&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec6s&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_int
[32/64bit] core_Mat_forEach_int
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionInt32 proc
%inst
元関数名(C#): core_Mat_forEach_int
元DLLエクスポート名: core_Mat_forEach_int
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_int(cv::Mat *m, Mat_foreach_int proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_int, int&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;int&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec2i
[32/64bit] core_Mat_forEach_Vec2i
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec2i proc
%inst
元関数名(C#): core_Mat_forEach_Vec2i
元DLLエクスポート名: core_Mat_forEach_Vec2i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec2i(cv::Mat *m, Mat_foreach_Vec2i proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec2i, cv::Vec2i&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec2i&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec3i
[32/64bit] core_Mat_forEach_Vec3i
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec3i proc
%inst
元関数名(C#): core_Mat_forEach_Vec3i
元DLLエクスポート名: core_Mat_forEach_Vec3i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec3i(cv::Mat *m, Mat_foreach_Vec3i proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec3i, cv::Vec3i&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec3i&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec4i
[32/64bit] core_Mat_forEach_Vec4i
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec4i proc
%inst
元関数名(C#): core_Mat_forEach_Vec4i
元DLLエクスポート名: core_Mat_forEach_Vec4i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec4i(cv::Mat *m, Mat_foreach_Vec4i proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec4i, cv::Vec4i&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec4i&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec6i
[32/64bit] core_Mat_forEach_Vec6i
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec6i proc
%inst
元関数名(C#): core_Mat_forEach_Vec6i
元DLLエクスポート名: core_Mat_forEach_Vec6i
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec6i(cv::Mat *m, Mat_foreach_Vec6i proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec6i, cv::Vec6i&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec6i&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_float
[32/64bit] core_Mat_forEach_float
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionFloat proc
%inst
元関数名(C#): core_Mat_forEach_float
元DLLエクスポート名: core_Mat_forEach_float
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_float(cv::Mat *m, Mat_foreach_float proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_float, float&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;float&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec2f
[32/64bit] core_Mat_forEach_Vec2f
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec2f proc
%inst
元関数名(C#): core_Mat_forEach_Vec2f
元DLLエクスポート名: core_Mat_forEach_Vec2f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec2f(cv::Mat *m, Mat_foreach_Vec2f proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec2f, cv::Vec2f&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec2f&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec3f
[32/64bit] core_Mat_forEach_Vec3f
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec3f proc
%inst
元関数名(C#): core_Mat_forEach_Vec3f
元DLLエクスポート名: core_Mat_forEach_Vec3f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec3f(cv::Mat *m, Mat_foreach_Vec3f proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec3f, cv::Vec3f&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec3f&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec4f
[32/64bit] core_Mat_forEach_Vec4f
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec4f proc
%inst
元関数名(C#): core_Mat_forEach_Vec4f
元DLLエクスポート名: core_Mat_forEach_Vec4f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec4f(cv::Mat *m, Mat_foreach_Vec4f proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec4f, cv::Vec4f&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec4f&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec6f
[32/64bit] core_Mat_forEach_Vec6f
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec6f proc
%inst
元関数名(C#): core_Mat_forEach_Vec6f
元DLLエクスポート名: core_Mat_forEach_Vec6f
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec6f(cv::Mat *m, Mat_foreach_Vec6f proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec6f, cv::Vec6f&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec6f&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_double
[32/64bit] core_Mat_forEach_double
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionDouble proc
%inst
元関数名(C#): core_Mat_forEach_double
元DLLエクスポート名: core_Mat_forEach_double
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_double(cv::Mat *m, Mat_foreach_double proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_double, double&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;double&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec2d
[32/64bit] core_Mat_forEach_Vec2d
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec2d proc
%inst
元関数名(C#): core_Mat_forEach_Vec2d
元DLLエクスポート名: core_Mat_forEach_Vec2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec2d(cv::Mat *m, Mat_foreach_Vec2d proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec2d, cv::Vec2d&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec2d&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec3d
[32/64bit] core_Mat_forEach_Vec3d
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec3d proc
%inst
元関数名(C#): core_Mat_forEach_Vec3d
元DLLエクスポート名: core_Mat_forEach_Vec3d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec3d(cv::Mat *m, Mat_foreach_Vec3d proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec3d, cv::Vec3d&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec3d&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec4d
[32/64bit] core_Mat_forEach_Vec4d
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec4d proc
%inst
元関数名(C#): core_Mat_forEach_Vec4d
元DLLエクスポート名: core_Mat_forEach_Vec4d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec4d(cv::Mat *m, Mat_foreach_Vec4d proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec4d, cv::Vec4d&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec4d&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_forEach_Vec6d
[32/64bit] core_Mat_forEach_Vec6d
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : MatForeachFunctionVec6d proc
%inst
元関数名(C#): core_Mat_forEach_Vec6d
元DLLエクスポート名: core_Mat_forEach_Vec6d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_forEach_Vec6d(cv::Mat *m, Mat_foreach_Vec6d proc)
{
    BEGIN_WRAP
    const Functor&amp;lt;Mat_foreach_Vec6d, cv::Vec6d&amp;gt; functor(proc);
    m-&amp;gt;forEach&amp;lt;cv::Vec6d&amp;gt;(functor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorUnaryMinus
[32/64bit] core_Mat_operatorUnaryMinus
%prm
p1,p2
p1 = sptr : IntPtr mat
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorUnaryMinus
元DLLエクスポート名: core_Mat_operatorUnaryMinus
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorUnaryMinus(cv::Mat *mat, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = -(*mat);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorAdd_MatMat
[32/64bit] core_Mat_operatorAdd_MatMat
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorAdd_MatMat
元DLLエクスポート名: core_Mat_operatorAdd_MatMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorAdd_MatMat(cv::Mat *a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) + (*b);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorAdd_MatScalar
[32bit] core_Mat_operatorAdd_MatScalar
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = ARGS_SCALAR : Scalar s
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorAdd_MatScalar
元DLLエクスポート名: core_Mat_operatorAdd_MatScalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorAdd_MatScalar(cv::Mat *a, MyCvScalar s, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) + cpp(s);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorAdd_MatScalar
[64bit] core_Mat_operatorAdd_MatScalar
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = var : Scalar s
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorAdd_MatScalar
元DLLエクスポート名: core_Mat_operatorAdd_MatScalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorAdd_MatScalar(cv::Mat *a, MyCvScalar s, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) + cpp(s);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorAdd_ScalarMat
[32bit] core_Mat_operatorAdd_ScalarMat
%prm
p1,p2,p3
p1 = ARGS_SCALAR : Scalar s
p2 = sptr : IntPtr a
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorAdd_ScalarMat
元DLLエクスポート名: core_Mat_operatorAdd_ScalarMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorAdd_ScalarMat(MyCvScalar s, cv::Mat *a, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = cpp(s) + (*a); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorAdd_ScalarMat
[64bit] core_Mat_operatorAdd_ScalarMat
%prm
p1,p2,p3
p1 = var : Scalar s
p2 = sptr : IntPtr a
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorAdd_ScalarMat
元DLLエクスポート名: core_Mat_operatorAdd_ScalarMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorAdd_ScalarMat(MyCvScalar s, cv::Mat *a, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = cpp(s) + (*a); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorMinus_Mat
[32/64bit] core_Mat_operatorMinus_Mat
%prm
p1,p2
p1 = sptr : IntPtr a
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorMinus_Mat
元DLLエクスポート名: core_Mat_operatorMinus_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorMinus_Mat(cv::Mat *a, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = -(*a);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorSubtract_MatMat
[32/64bit] core_Mat_operatorSubtract_MatMat
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorSubtract_MatMat
元DLLエクスポート名: core_Mat_operatorSubtract_MatMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorSubtract_MatMat(cv::Mat *a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) - (*b);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorSubtract_MatScalar
[32bit] core_Mat_operatorSubtract_MatScalar
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = ARGS_SCALAR : Scalar s
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorSubtract_MatScalar
元DLLエクスポート名: core_Mat_operatorSubtract_MatScalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorSubtract_MatScalar(cv::Mat *a, MyCvScalar s, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) - cpp(s);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorSubtract_MatScalar
[64bit] core_Mat_operatorSubtract_MatScalar
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = var : Scalar s
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorSubtract_MatScalar
元DLLエクスポート名: core_Mat_operatorSubtract_MatScalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorSubtract_MatScalar(cv::Mat *a, MyCvScalar s, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) - cpp(s);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorSubtract_ScalarMat
[32bit] core_Mat_operatorSubtract_ScalarMat
%prm
p1,p2,p3
p1 = ARGS_SCALAR : Scalar s
p2 = sptr : IntPtr a
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorSubtract_ScalarMat
元DLLエクスポート名: core_Mat_operatorSubtract_ScalarMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorSubtract_ScalarMat(MyCvScalar s, cv::Mat *a, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = cpp(s) - (*a); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorSubtract_ScalarMat
[64bit] core_Mat_operatorSubtract_ScalarMat
%prm
p1,p2,p3
p1 = var : Scalar s
p2 = sptr : IntPtr a
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorSubtract_ScalarMat
元DLLエクスポート名: core_Mat_operatorSubtract_ScalarMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorSubtract_ScalarMat(MyCvScalar s, cv::Mat *a, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = cpp(s) - (*a); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorMultiply_MatMat
[32/64bit] core_Mat_operatorMultiply_MatMat
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorMultiply_MatMat
元DLLエクスポート名: core_Mat_operatorMultiply_MatMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorMultiply_MatMat(cv::Mat *a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) * (*b);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorMultiply_MatDouble
[32/64bit] core_Mat_operatorMultiply_MatDouble
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = double : double s
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorMultiply_MatDouble
元DLLエクスポート名: core_Mat_operatorMultiply_MatDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorMultiply_MatDouble(cv::Mat *a, double s, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) * s;
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorMultiply_DoubleMat
[32/64bit] core_Mat_operatorMultiply_DoubleMat
%prm
p1,p2,p3
p1 = double : double s
p2 = sptr : IntPtr a
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorMultiply_DoubleMat
元DLLエクスポート名: core_Mat_operatorMultiply_DoubleMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorMultiply_DoubleMat(double s, cv::Mat *a, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = s * (*a); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorDivide_MatMat
[32/64bit] core_Mat_operatorDivide_MatMat
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorDivide_MatMat
元DLLエクスポート名: core_Mat_operatorDivide_MatMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorDivide_MatMat(cv::Mat *a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) / (*b);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorDivide_MatDouble
[32/64bit] core_Mat_operatorDivide_MatDouble
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = double : double s
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorDivide_MatDouble
元DLLエクスポート名: core_Mat_operatorDivide_MatDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorDivide_MatDouble(cv::Mat *a, double s, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) / s;
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorDivide_DoubleMat
[32/64bit] core_Mat_operatorDivide_DoubleMat
%prm
p1,p2,p3
p1 = double : double s
p2 = sptr : IntPtr a
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorDivide_DoubleMat
元DLLエクスポート名: core_Mat_operatorDivide_DoubleMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorDivide_DoubleMat(double s, cv::Mat *a, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = s / (*a); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorAnd_MatMat
[32/64bit] core_Mat_operatorAnd_MatMat
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorAnd_MatMat
元DLLエクスポート名: core_Mat_operatorAnd_MatMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorAnd_MatMat(cv::Mat *a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) &amp; (*b);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorAnd_MatDouble
[32/64bit] core_Mat_operatorAnd_MatDouble
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = double : double s
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorAnd_MatDouble
元DLLエクスポート名: core_Mat_operatorAnd_MatDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorAnd_MatDouble(cv::Mat *a, double s, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) &amp; s;
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorAnd_DoubleMat
[32/64bit] core_Mat_operatorAnd_DoubleMat
%prm
p1,p2,p3
p1 = double : double s
p2 = sptr : IntPtr a
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorAnd_DoubleMat
元DLLエクスポート名: core_Mat_operatorAnd_DoubleMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorAnd_DoubleMat(double s, cv::Mat *a, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = s &amp; (*a); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorOr_MatMat
[32/64bit] core_Mat_operatorOr_MatMat
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorOr_MatMat
元DLLエクスポート名: core_Mat_operatorOr_MatMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorOr_MatMat(cv::Mat *a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) | (*b);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorOr_MatDouble
[32/64bit] core_Mat_operatorOr_MatDouble
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = double : double s
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorOr_MatDouble
元DLLエクスポート名: core_Mat_operatorOr_MatDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorOr_MatDouble(cv::Mat *a, double s, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) | s;
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorOr_DoubleMat
[32/64bit] core_Mat_operatorOr_DoubleMat
%prm
p1,p2,p3
p1 = double : double s
p2 = sptr : IntPtr a
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorOr_DoubleMat
元DLLエクスポート名: core_Mat_operatorOr_DoubleMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorOr_DoubleMat(double s, cv::Mat *a, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = s | (*a); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorXor_MatMat
[32/64bit] core_Mat_operatorXor_MatMat
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorXor_MatMat
元DLLエクスポート名: core_Mat_operatorXor_MatMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorXor_MatMat(cv::Mat *a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) ^ (*b);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorXor_MatDouble
[32/64bit] core_Mat_operatorXor_MatDouble
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = double : double s
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorXor_MatDouble
元DLLエクスポート名: core_Mat_operatorXor_MatDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorXor_MatDouble(cv::Mat *a, double s, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) ^ s;
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorXor_DoubleMat
[32/64bit] core_Mat_operatorXor_DoubleMat
%prm
p1,p2,p3
p1 = double : double s
p2 = sptr : IntPtr a
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorXor_DoubleMat
元DLLエクスポート名: core_Mat_operatorXor_DoubleMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorXor_DoubleMat(double s, cv::Mat *a, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = s ^ (*a); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorNot
[32/64bit] core_Mat_operatorNot
%prm
p1,p2
p1 = sptr : IntPtr a
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorNot
元DLLエクスポート名: core_Mat_operatorNot
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorNot(cv::Mat *a, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = ~(*a);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorLT_MatMat
[32/64bit] core_Mat_operatorLT_MatMat
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorLT_MatMat
元DLLエクスポート名: core_Mat_operatorLT_MatMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorLT_MatMat(cv::Mat *a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) &amp;lt; (*b); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorLT_DoubleMat
[32/64bit] core_Mat_operatorLT_DoubleMat
%prm
p1,p2,p3
p1 = double : double a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorLT_DoubleMat
元DLLエクスポート名: core_Mat_operatorLT_DoubleMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorLT_DoubleMat(double a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = a &amp;lt; (*b); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorLT_MatDouble
[32/64bit] core_Mat_operatorLT_MatDouble
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = double : double b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorLT_MatDouble
元DLLエクスポート名: core_Mat_operatorLT_MatDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorLT_MatDouble(cv::Mat *a, double b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) &amp;lt; b; 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorLE_MatMat
[32/64bit] core_Mat_operatorLE_MatMat
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorLE_MatMat
元DLLエクスポート名: core_Mat_operatorLE_MatMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorLE_MatMat(cv::Mat *a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) &amp;lt;= (*b); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorLE_DoubleMat
[32/64bit] core_Mat_operatorLE_DoubleMat
%prm
p1,p2,p3
p1 = double : double a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorLE_DoubleMat
元DLLエクスポート名: core_Mat_operatorLE_DoubleMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorLE_DoubleMat(double a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = a &amp;lt;= (*b); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorLE_MatDouble
[32/64bit] core_Mat_operatorLE_MatDouble
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = double : double b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorLE_MatDouble
元DLLエクスポート名: core_Mat_operatorLE_MatDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorLE_MatDouble(cv::Mat *a, double b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) &amp;lt;= b; 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorGT_MatMat
[32/64bit] core_Mat_operatorGT_MatMat
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorGT_MatMat
元DLLエクスポート名: core_Mat_operatorGT_MatMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorGT_MatMat(cv::Mat *a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) &amp;gt; (*b); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorGT_DoubleMat
[32/64bit] core_Mat_operatorGT_DoubleMat
%prm
p1,p2,p3
p1 = double : double a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorGT_DoubleMat
元DLLエクスポート名: core_Mat_operatorGT_DoubleMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorGT_DoubleMat(double a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = a &amp;gt; (*b); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorGT_MatDouble
[32/64bit] core_Mat_operatorGT_MatDouble
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = double : double b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorGT_MatDouble
元DLLエクスポート名: core_Mat_operatorGT_MatDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorGT_MatDouble(cv::Mat *a, double b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) &amp;gt; b; 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorGE_MatMat
[32/64bit] core_Mat_operatorGE_MatMat
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorGE_MatMat
元DLLエクスポート名: core_Mat_operatorGE_MatMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorGE_MatMat(cv::Mat *a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) &amp;gt;= (*b); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorGE_DoubleMat
[32/64bit] core_Mat_operatorGE_DoubleMat
%prm
p1,p2,p3
p1 = double : double a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorGE_DoubleMat
元DLLエクスポート名: core_Mat_operatorGE_DoubleMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorGE_DoubleMat(double a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = a &amp;gt;= (*b); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorGE_MatDouble
[32/64bit] core_Mat_operatorGE_MatDouble
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = double : double b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorGE_MatDouble
元DLLエクスポート名: core_Mat_operatorGE_MatDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorGE_MatDouble(cv::Mat *a, double b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) &amp;gt;= b; 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorEQ_MatMat
[32/64bit] core_Mat_operatorEQ_MatMat
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorEQ_MatMat
元DLLエクスポート名: core_Mat_operatorEQ_MatMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorEQ_MatMat(cv::Mat *a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) == (*b); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorEQ_DoubleMat
[32/64bit] core_Mat_operatorEQ_DoubleMat
%prm
p1,p2,p3
p1 = double : double a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorEQ_DoubleMat
元DLLエクスポート名: core_Mat_operatorEQ_DoubleMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorEQ_DoubleMat(double a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = a == (*b); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorEQ_MatDouble
[32/64bit] core_Mat_operatorEQ_MatDouble
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = double : double b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorEQ_MatDouble
元DLLエクスポート名: core_Mat_operatorEQ_MatDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorEQ_MatDouble(cv::Mat *a, double b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) == b; 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorNE_MatMat
[32/64bit] core_Mat_operatorNE_MatMat
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorNE_MatMat
元DLLエクスポート名: core_Mat_operatorNE_MatMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorNE_MatMat(cv::Mat *a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) != (*b); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorNE_DoubleMat
[32/64bit] core_Mat_operatorNE_DoubleMat
%prm
p1,p2,p3
p1 = double : double a
p2 = sptr : IntPtr b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorNE_DoubleMat
元DLLエクスポート名: core_Mat_operatorNE_DoubleMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorNE_DoubleMat(double a, cv::Mat *b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = a != (*b); 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_Mat_operatorNE_MatDouble
[32/64bit] core_Mat_operatorNE_MatDouble
%prm
p1,p2,p3
p1 = sptr : IntPtr a
p2 = double : double b
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_Mat_operatorNE_MatDouble
元DLLエクスポート名: core_Mat_operatorNE_MatDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_Mat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_Mat_operatorNE_MatDouble(cv::Mat *a, double b, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*a) != b; 
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_Mat

%index
core_MatExpr_new1
[32/64bit] cv::MatExpr のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst
行列式の表現．

これは，実装されている行列演算のリストで，任意の複素数表現に組み合わせることができます（ここで A, B は行列（Mat ）を，s はスカラ（Scalar ）を，alpha は実数値のスカラ（double ）を表します）．

加算，減算，否定．A+B, A-B, A+s, A-s, s+A, s-A, -A

スケーリングA*α

要素ごとの乗算と除算。A.mul(B)、A/B、α/A

マトリックスの乗算。A*B

転置。A.t() (ATの意)

行列の逆変換や擬似逆変換、連立方程式や最小二乗問題の解法。A.inv([方法])（〜A<sup>-1</sup>）、A.inv([方法])*B（〜X: AX=B)

比較する。A cmpop B, A cmpop alpha, alpha cmpop A, ここで cmpop は >, >=, ==, !=, <=, < のいずれかです。比較の結果は、要素が 255 (特定の要素または要素のペアが条件を満たす場合) または 0 に設定される 8 ビットのシングルチャネルマスクです。

ビット単位の論理演算。A logicop B, A logicop s, s logicop A, ~A（logicop は &, |, ^ のいずれか）。

要素単位の最小値と最大値：min(A, B), min(A, alpha), max(A, B), max(A, alpha)

要素ごとの絶対値：abs(A)

クロスプロダクト、ドットプロダクトA.cross(B), A.dot(B)

norm, mean, sum, countNonZero, trace, determinant, repeat など，行列や行列とスカラを返すあらゆる関数．

行列の初期化子（ Mat::eye(), Mat::zeros(), Mat::ones() ），カンマで区切られた行列の初期化子，行列のコンストラクタ，サブ行列を抽出する演算子（ Mat の説明を参照してください）．

結果を適切な型にキャストする Mat_<destination_type>() コンストラクタ．注意カンマで区切られた初期化子や，おそらくその他のいくつかの演算子は，起こりうる曖昧さを解決するために，明示的な Mat() または Mat_<T>() コンストラクタの呼び出しを必要とします．

以下は，行列式の例です．A.inv(DECOMP_SVD)SVD svd(A);Mat pinvA = svd.vt.t()*Mat::diag(1./svd.w)*svd.u. t()； // A の擬似逆行列を計算する（A.inv(DECOMP_SVD)SVD svd(A) と同等）。t();// Levenberg-Marquardt アルゴリズムのパラメータの新しいベクトルを計算するx -= (A.t()*A + lambda*Mat::eye(A.cols,A.cols,A.type()).inv(DECOMP_CHOLESKY)*(A.t()*err);// 「アンシャープマスク」アルゴリズムを用いて画像をシャープにするMat blurred; double sigma = 1, threshold = 5, amount = 1;GaussianBlur(img, blurred, Size(), sigma, sigma);Mat lowContrastMask = abs(img - blurred) < threshold;Mat sharpened = img*(1+amount) + blurred*(-amount);img.copyTo(sharpened, lowContrastMask)．


元関数名(C#): core_MatExpr_new1
元DLLエクスポート名: core_MatExpr_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_MatExpr_new1(cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::MatExpr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_MatExpr_new2
[32/64bit] cv::MatExpr のインスタンスを生成します
%prm
p1,p2
p1 = sptr : IntPtr mat
p2 = var : out IntPtr returnValue
%inst
行列式の表現．

これは，実装されている行列演算のリストで，任意の複素数表現に組み合わせることができます（ここで A, B は行列（Mat ）を，s はスカラ（Scalar ）を，alpha は実数値のスカラ（double ）を表します）．

加算，減算，否定．A+B, A-B, A+s, A-s, s+A, s-A, -A

スケーリングA*α

要素ごとの乗算と除算。A.mul(B)、A/B、α/A

マトリックスの乗算。A*B

転置。A.t() (ATの意)

行列の逆変換や擬似逆変換、連立方程式や最小二乗問題の解法。A.inv([方法])（〜A<sup>-1</sup>）、A.inv([方法])*B（〜X: AX=B)

比較する。A cmpop B, A cmpop alpha, alpha cmpop A, ここで cmpop は >, >=, ==, !=, <=, < のいずれかです。比較の結果は、要素が 255 (特定の要素または要素のペアが条件を満たす場合) または 0 に設定される 8 ビットのシングルチャネルマスクです。

ビット単位の論理演算。A logicop B, A logicop s, s logicop A, ~A（logicop は &, |, ^ のいずれか）。

要素単位の最小値と最大値：min(A, B), min(A, alpha), max(A, B), max(A, alpha)

要素ごとの絶対値：abs(A)

クロスプロダクト、ドットプロダクトA.cross(B), A.dot(B)

norm, mean, sum, countNonZero, trace, determinant, repeat など，行列や行列とスカラを返すあらゆる関数．

行列の初期化子（ Mat::eye(), Mat::zeros(), Mat::ones() ），カンマで区切られた行列の初期化子，行列のコンストラクタ，サブ行列を抽出する演算子（ Mat の説明を参照してください）．

結果を適切な型にキャストする Mat_<destination_type>() コンストラクタ．注意カンマで区切られた初期化子や，おそらくその他のいくつかの演算子は，起こりうる曖昧さを解決するために，明示的な Mat() または Mat_<T>() コンストラクタの呼び出しを必要とします．

以下は，行列式の例です．A.inv(DECOMP_SVD)SVD svd(A);Mat pinvA = svd.vt.t()*Mat::diag(1./svd.w)*svd.u. t()； // A の擬似逆行列を計算する（A.inv(DECOMP_SVD)SVD svd(A) と同等）。t();// Levenberg-Marquardt アルゴリズムのパラメータの新しいベクトルを計算するx -= (A.t()*A + lambda*Mat::eye(A.cols,A.cols,A.type()).inv(DECOMP_CHOLESKY)*(A.t()*err);// 「アンシャープマスク」アルゴリズムを用いて画像をシャープにするMat blurred; double sigma = 1, threshold = 5, amount = 1;GaussianBlur(img, blurred, Size(), sigma, sigma);Mat lowContrastMask = abs(img - blurred) < threshold;Mat sharpened = img*(1+amount) + blurred*(-amount);img.copyTo(sharpened, lowContrastMask)．


元関数名(C#): core_MatExpr_new2
元DLLエクスポート名: core_MatExpr_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_MatExpr_new2(cv::Mat *mat, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::MatExpr(*mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_MatExpr_delete
[32/64bit] cv::MatExpr のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr expr
%inst
行列式の表現．

これは，実装されている行列演算のリストで，任意の複素数表現に組み合わせることができます（ここで A, B は行列（Mat ）を，s はスカラ（Scalar ）を，alpha は実数値のスカラ（double ）を表します）．

加算，減算，否定．A+B, A-B, A+s, A-s, s+A, s-A, -A

スケーリングA*α

要素ごとの乗算と除算。A.mul(B)、A/B、α/A

マトリックスの乗算。A*B

転置。A.t() (ATの意)

行列の逆変換や擬似逆変換、連立方程式や最小二乗問題の解法。A.inv([方法])（〜A<sup>-1</sup>）、A.inv([方法])*B（〜X: AX=B)

比較する。A cmpop B, A cmpop alpha, alpha cmpop A, ここで cmpop は >, >=, ==, !=, <=, < のいずれかです。比較の結果は、要素が 255 (特定の要素または要素のペアが条件を満たす場合) または 0 に設定される 8 ビットのシングルチャネルマスクです。

ビット単位の論理演算。A logicop B, A logicop s, s logicop A, ~A（logicop は &, |, ^ のいずれか）。

要素単位の最小値と最大値：min(A, B), min(A, alpha), max(A, B), max(A, alpha)

要素ごとの絶対値：abs(A)

クロスプロダクト、ドットプロダクトA.cross(B), A.dot(B)

norm, mean, sum, countNonZero, trace, determinant, repeat など，行列や行列とスカラを返すあらゆる関数．

行列の初期化子（ Mat::eye(), Mat::zeros(), Mat::ones() ），カンマで区切られた行列の初期化子，行列のコンストラクタ，サブ行列を抽出する演算子（ Mat の説明を参照してください）．

結果を適切な型にキャストする Mat_<destination_type>() コンストラクタ．注意カンマで区切られた初期化子や，おそらくその他のいくつかの演算子は，起こりうる曖昧さを解決するために，明示的な Mat() または Mat_<T>() コンストラクタの呼び出しを必要とします．

以下は，行列式の例です．A.inv(DECOMP_SVD)SVD svd(A);Mat pinvA = svd.vt.t()*Mat::diag(1./svd.w)*svd.u. t()； // A の擬似逆行列を計算する（A.inv(DECOMP_SVD)SVD svd(A) と同等）。t();// Levenberg-Marquardt アルゴリズムのパラメータの新しいベクトルを計算するx -= (A.t()*A + lambda*Mat::eye(A.cols,A.cols,A.type()).inv(DECOMP_CHOLESKY)*(A.t()*err);// 「アンシャープマスク」アルゴリズムを用いて画像をシャープにするMat blurred; double sigma = 1, threshold = 5, amount = 1;GaussianBlur(img, blurred, Size(), sigma, sigma);Mat lowContrastMask = abs(img - blurred) < threshold;Mat sharpened = img*(1+amount) + blurred*(-amount);img.copyTo(sharpened, lowContrastMask)．


元関数名(C#): core_MatExpr_delete
元DLLエクスポート名: core_MatExpr_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_MatExpr_delete(cv::MatExpr *self)
{
    BEGIN_WRAP
    delete self;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_MatExpr_toMat
[32/64bit] core_MatExpr_toMat
%prm
p1,p2
p1 = sptr : IntPtr expr
p2 = sptr : IntPtr returnValue
%inst
元関数名(C#): core_MatExpr_toMat
元DLLエクスポート名: core_MatExpr_toMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_MatExpr_toMat(cv::MatExpr *self, cv::Mat *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*self);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_MatExpr_row
[32/64bit] core_MatExpr_row
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int y
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_MatExpr_row
元DLLエクスポート名: core_MatExpr_row
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_MatExpr_row(cv::MatExpr *self, int y, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;row(y);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_MatExpr_col
[32/64bit] core_MatExpr_col
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int x
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_MatExpr_col
元DLLエクスポート名: core_MatExpr_col
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_MatExpr_col(cv::MatExpr *self, int x, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;col(x);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_MatExpr_diag
[32/64bit] core_MatExpr_diag
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int d
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_MatExpr_diag
元DLLエクスポート名: core_MatExpr_diag
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_MatExpr_diag(cv::MatExpr *self, int d, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;diag(d);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_MatExpr_submat
[32/64bit] core_MatExpr_submat
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr self
p2 = int : int rowStart
p3 = int : int rowEnd
p4 = int : int colStart
p5 = int : int colEnd
p6 = var : out IntPtr returnValue
%inst
元関数名(C#): core_MatExpr_submat
元DLLエクスポート名: core_MatExpr_submat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_MatExpr_submat(cv::MatExpr *self, int rowStart, int rowEnd, int colStart, int colEnd, cv::MatExpr **returnValue) 
{
    BEGIN_WRAP
    const cv::Range rowRange(rowStart, rowEnd);
    const cv::Range colRange(colStart, colEnd);
    const auto ret = (*self)(rowRange, colRange);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_MatExpr_t
[32/64bit] core_MatExpr_t
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_MatExpr_t
元DLLエクスポート名: core_MatExpr_t
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_MatExpr_toMat(cv::MatExpr *self, cv::Mat *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*self);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_MatExpr_inv
[32/64bit] core_MatExpr_inv
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int method
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_MatExpr_inv
元DLLエクスポート名: core_MatExpr_inv
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_MatExpr_inv(cv::MatExpr *self, int method, cv::MatExpr **returnValue) 
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;inv(method);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_MatExpr_mul_toMatExpr
[32/64bit] core_MatExpr_mul_toMatExpr
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = sptr : IntPtr e
p3 = double : double scale
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_MatExpr_mul_toMatExpr
元DLLエクスポート名: core_MatExpr_mul_toMatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_MatExpr_mul_toMatExpr(cv::MatExpr *self, cv::MatExpr *e, double scale, cv::MatExpr **returnValue) 
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;mul(*e, scale);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_MatExpr_mul_toMat
[32/64bit] core_MatExpr_mul_toMat
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
p3 = double : double scale
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_MatExpr_mul_toMat
元DLLエクスポート名: core_MatExpr_mul_toMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_MatExpr_mul_toMatExpr(cv::MatExpr *self, cv::MatExpr *e, double scale, cv::MatExpr **returnValue) 
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;mul(*e, scale);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_MatExpr_cross
[32/64bit] core_MatExpr_cross
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_MatExpr_cross
元DLLエクスポート名: core_MatExpr_cross
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_MatExpr_cross(cv::MatExpr *self, cv::Mat *m, cv::Mat **returnValue) 
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;cross(*m);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_MatExpr_dot
[32/64bit] core_MatExpr_dot
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
p3 = var : out double returnValue
%inst
元関数名(C#): core_MatExpr_dot
元DLLエクスポート名: core_MatExpr_dot
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_MatExpr_dot(cv::MatExpr *self, cv::Mat *m, double *returnValue) 
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;dot(*m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_MatExpr_size
[32/64bit] core_MatExpr_size
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out Size returnValue
%inst
元関数名(C#): core_MatExpr_size
元DLLエクスポート名: core_MatExpr_size
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_MatExpr_size(cv::MatExpr *self, MyCvSize *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(self-&amp;gt;size());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_MatExpr_type
[32/64bit] core_MatExpr_type
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
元関数名(C#): core_MatExpr_type
元DLLエクスポート名: core_MatExpr_type
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_MatExpr_type(cv::MatExpr *self, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;type();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorUnaryMinus_MatExpr
[32/64bit] core_operatorUnaryMinus_MatExpr
%prm
p1,p2
p1 = sptr : IntPtr e
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorUnaryMinus_MatExpr
元DLLエクスポート名: core_operatorUnaryMinus_MatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorUnaryMinus_MatExpr(cv::MatExpr *e, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = -(*e);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorUnaryNot_MatExpr
[32/64bit] core_operatorUnaryNot_MatExpr
%prm
p1,p2
p1 = sptr : IntPtr e
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorUnaryNot_MatExpr
元DLLエクスポート名: core_operatorUnaryNot_MatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorUnaryNot_MatExpr(cv::MatExpr *e, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = ~(*e);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorAdd_MatExprMat
[32/64bit] core_operatorAdd_MatExprMat
%prm
p1,p2,p3
p1 = sptr : IntPtr e
p2 = sptr : IntPtr m
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorAdd_MatExprMat
元DLLエクスポート名: core_operatorAdd_MatExprMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorAdd_MatExprMat(cv::MatExpr *e, cv:: Mat *m, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*e) + (*m);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorAdd_MatMatExpr
[32/64bit] core_operatorAdd_MatMatExpr
%prm
p1,p2,p3
p1 = sptr : IntPtr m
p2 = sptr : IntPtr e
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorAdd_MatMatExpr
元DLLエクスポート名: core_operatorAdd_MatMatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorAdd_MatMatExpr(cv::Mat *m, cv::MatExpr *e, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*m) + (*e);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorAdd_MatExprScalar
[32bit] core_operatorAdd_MatExprScalar
%prm
p1,p2,p3
p1 = sptr : IntPtr e
p2 = ARGS_SCALAR : Scalar s
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorAdd_MatExprScalar
元DLLエクスポート名: core_operatorAdd_MatExprScalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorAdd_MatExprScalar(cv::MatExpr *e, MyCvScalar s, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*e) + cpp(s);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorAdd_MatExprScalar
[64bit] core_operatorAdd_MatExprScalar
%prm
p1,p2,p3
p1 = sptr : IntPtr e
p2 = var : Scalar s
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorAdd_MatExprScalar
元DLLエクスポート名: core_operatorAdd_MatExprScalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorAdd_MatExprScalar(cv::MatExpr *e, MyCvScalar s, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*e) + cpp(s);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorAdd_ScalarMatExpr
[32bit] core_operatorAdd_ScalarMatExpr
%prm
p1,p2,p3
p1 = ARGS_SCALAR : Scalar s
p2 = sptr : IntPtr e
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorAdd_ScalarMatExpr
元DLLエクスポート名: core_operatorAdd_ScalarMatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorAdd_ScalarMatExpr(MyCvScalar s, cv::MatExpr *e, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = cpp(s) + (*e);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorAdd_ScalarMatExpr
[64bit] core_operatorAdd_ScalarMatExpr
%prm
p1,p2,p3
p1 = var : Scalar s
p2 = sptr : IntPtr e
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorAdd_ScalarMatExpr
元DLLエクスポート名: core_operatorAdd_ScalarMatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorAdd_ScalarMatExpr(MyCvScalar s, cv::MatExpr *e, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = cpp(s) + (*e);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorAdd_MatExprMatExpr
[32/64bit] core_operatorAdd_MatExprMatExpr
%prm
p1,p2,p3
p1 = sptr : IntPtr e1
p2 = sptr : IntPtr e2
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorAdd_MatExprMatExpr
元DLLエクスポート名: core_operatorAdd_MatExprMatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorAdd_MatExprMatExpr(cv::MatExpr *e1, cv::MatExpr *e2, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*e1) + (*e2);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorSubtract_MatExprMat
[32/64bit] core_operatorSubtract_MatExprMat
%prm
p1,p2,p3
p1 = sptr : IntPtr e
p2 = sptr : IntPtr m
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorSubtract_MatExprMat
元DLLエクスポート名: core_operatorSubtract_MatExprMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorSubtract_MatExprMat(cv::MatExpr *e, cv::Mat *m, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*e) - (*m);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorSubtract_MatMatExpr
[32/64bit] core_operatorSubtract_MatMatExpr
%prm
p1,p2,p3
p1 = sptr : IntPtr m
p2 = sptr : IntPtr e
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorSubtract_MatMatExpr
元DLLエクスポート名: core_operatorSubtract_MatMatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorSubtract_MatMatExpr(cv::Mat *m, cv::MatExpr *e, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*m) - (*e);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorSubtract_MatExprScalar
[32bit] core_operatorSubtract_MatExprScalar
%prm
p1,p2,p3
p1 = sptr : IntPtr e
p2 = ARGS_SCALAR : Scalar s
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorSubtract_MatExprScalar
元DLLエクスポート名: core_operatorSubtract_MatExprScalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorSubtract_MatExprScalar(cv::MatExpr *e, MyCvScalar s, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*e) - cpp(s);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorSubtract_MatExprScalar
[64bit] core_operatorSubtract_MatExprScalar
%prm
p1,p2,p3
p1 = sptr : IntPtr e
p2 = var : Scalar s
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorSubtract_MatExprScalar
元DLLエクスポート名: core_operatorSubtract_MatExprScalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorSubtract_MatExprScalar(cv::MatExpr *e, MyCvScalar s, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*e) - cpp(s);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorSubtract_ScalarMatExpr
[32bit] core_operatorSubtract_ScalarMatExpr
%prm
p1,p2,p3
p1 = ARGS_SCALAR : Scalar s
p2 = sptr : IntPtr e
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorSubtract_ScalarMatExpr
元DLLエクスポート名: core_operatorSubtract_ScalarMatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorSubtract_ScalarMatExpr(MyCvScalar s, cv::MatExpr *e, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = cpp(s) - (*e);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorSubtract_ScalarMatExpr
[64bit] core_operatorSubtract_ScalarMatExpr
%prm
p1,p2,p3
p1 = var : Scalar s
p2 = sptr : IntPtr e
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorSubtract_ScalarMatExpr
元DLLエクスポート名: core_operatorSubtract_ScalarMatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorSubtract_ScalarMatExpr(MyCvScalar s, cv::MatExpr *e, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = cpp(s) - (*e);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorSubtract_MatExprMatExpr
[32/64bit] core_operatorSubtract_MatExprMatExpr
%prm
p1,p2,p3
p1 = sptr : IntPtr e1
p2 = sptr : IntPtr e2
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorSubtract_MatExprMatExpr
元DLLエクスポート名: core_operatorSubtract_MatExprMatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorSubtract_MatExprMatExpr(cv::MatExpr *e1, cv::MatExpr *e2, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto expr = (*e1) - (*e2);
    *returnValue = new cv::MatExpr(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorMultiply_MatExprMat
[32/64bit] core_operatorMultiply_MatExprMat
%prm
p1,p2,p3
p1 = sptr : IntPtr e
p2 = sptr : IntPtr m
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorMultiply_MatExprMat
元DLLエクスポート名: core_operatorMultiply_MatExprMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorMultiply_MatExprMat(cv::MatExpr *e, cv::Mat *m, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto ret = (*e) * (*m);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorMultiply_MatMatExpr
[32/64bit] core_operatorMultiply_MatMatExpr
%prm
p1,p2,p3
p1 = sptr : IntPtr m
p2 = sptr : IntPtr e
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorMultiply_MatMatExpr
元DLLエクスポート名: core_operatorMultiply_MatMatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorMultiply_MatMatExpr(cv::Mat *m, cv::MatExpr *e, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto ret = (*m) * (*e);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorMultiply_MatExprDouble
[32/64bit] core_operatorMultiply_MatExprDouble
%prm
p1,p2,p3
p1 = sptr : IntPtr e
p2 = double : double s
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorMultiply_MatExprDouble
元DLLエクスポート名: core_operatorMultiply_MatExprDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorMultiply_MatExprDouble(cv::MatExpr *e, double s, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto ret = (*e) * s;
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorMultiply_DoubleMatExpr
[32/64bit] core_operatorMultiply_DoubleMatExpr
%prm
p1,p2,p3
p1 = double : double s
p2 = sptr : IntPtr e
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorMultiply_DoubleMatExpr
元DLLエクスポート名: core_operatorMultiply_DoubleMatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorMultiply_DoubleMatExpr(double s, cv::MatExpr *e, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto ret = s * (*e);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorMultiply_MatExprMatExpr
[32/64bit] core_operatorMultiply_MatExprMatExpr
%prm
p1,p2,p3
p1 = sptr : IntPtr e1
p2 = sptr : IntPtr e2
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorMultiply_MatExprMatExpr
元DLLエクスポート名: core_operatorMultiply_MatExprMatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorMultiply_MatExprMatExpr(cv::MatExpr *e1, cv::MatExpr *e2, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto ret = (*e1) * (*e2);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorDivide_MatExprMat
[32/64bit] core_operatorDivide_MatExprMat
%prm
p1,p2,p3
p1 = sptr : IntPtr e
p2 = sptr : IntPtr m
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorDivide_MatExprMat
元DLLエクスポート名: core_operatorDivide_MatExprMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorDivide_MatExprMat(cv::MatExpr *e, cv::Mat *m, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto ret = (*e) / (*m);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorDivide_MatMatExpr
[32/64bit] core_operatorDivide_MatMatExpr
%prm
p1,p2,p3
p1 = sptr : IntPtr m
p2 = sptr : IntPtr e
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorDivide_MatMatExpr
元DLLエクスポート名: core_operatorDivide_MatMatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorDivide_MatMatExpr(cv::Mat *m, cv::MatExpr *e, cv::MatExpr **returnValue) 
{
    BEGIN_WRAP
    const auto ret = (*m) / (*e);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorDivide_MatExprDouble
[32/64bit] core_operatorDivide_MatExprDouble
%prm
p1,p2,p3
p1 = sptr : IntPtr e
p2 = double : double s
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorDivide_MatExprDouble
元DLLエクスポート名: core_operatorDivide_MatExprDouble
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorDivide_MatExprDouble(cv::MatExpr *e, double s, cv::MatExpr **returnValue) 
{
    BEGIN_WRAP
    const auto ret = (*e) / s;
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorDivide_DoubleMatExpr
[32/64bit] core_operatorDivide_DoubleMatExpr
%prm
p1,p2,p3
p1 = double : double s
p2 = sptr : IntPtr e
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorDivide_DoubleMatExpr
元DLLエクスポート名: core_operatorDivide_DoubleMatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorDivide_DoubleMatExpr(double s, cv::MatExpr *e, cv::MatExpr **returnValue) 
{
    BEGIN_WRAP
    const auto ret = s / (*e);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_operatorDivide_MatExprMatExpr
[32/64bit] core_operatorDivide_MatExprMatExpr
%prm
p1,p2,p3
p1 = sptr : IntPtr e1
p2 = sptr : IntPtr e2
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_operatorDivide_MatExprMatExpr
元DLLエクスポート名: core_operatorDivide_MatExprMatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_operatorDivide_MatExprMatExpr(cv::MatExpr *e1, cv::MatExpr *e2, cv::MatExpr **returnValue) 
{
    BEGIN_WRAP
    const auto ret = (*e1) / (*e2);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_abs_MatExpr
[32/64bit] core_abs_MatExpr
%prm
p1,p2
p1 = sptr : IntPtr e
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_abs_MatExpr
元DLLエクスポート名: core_abs_MatExpr
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_MatExpr.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_abs_MatExpr(cv::MatExpr *e, cv::MatExpr **returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::abs(*e);
    *returnValue = new cv::MatExpr(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_MatExpr

%index
core_OutputArray_new_byMat
[32/64bit] cv::_OutputArray のインスタンスを生成します
%prm
p1,p2
p1 = sptr : IntPtr mat
p2 = var : out IntPtr returnValue
%inst
この型は，入出力や出力関数のパラメータに使われることを除けば，InputArray と非常によく似ています．

InputArray の場合と同様に，OpenCV ユーザは OutputArray を気にする必要はなく， Mat や vector<T> などを関数に渡すだけです．InputArray と同様の制限があります．OutputArray のインスタンスを明示的に作成してはいけません。

関数を多相型にしたい（つまり，出力パラメータとして異なる配列を受け付ける）場合も，それほど難しいことではありません．上のサンプルを参考にしてください。_OutputArray::create() は， _OutputArray::getMat() の前に呼ばれる必要があることに注意してください．こうすることで，出力配列が適切に確保されていることが保証されます．

オプションの出力パラメータ．特定の出力配列を計算して返す必要がない場合は，入力配列がオプションの場合と同様に， cv::noArray() を渡します．実装レベルでは， _OutputArray::needed() を用いて，ある出力配列を計算する必要があるかどうかをチェックします．

OutputArray には，Python/Java/... ラッパーの自動生成を補助するために利用される，いくつかの同義語があります： typedef OutputArray OutputArrayOfArrays;typedef OutputArray InputOutputArray;typedef OutputArray InputOutputArrayOfArrays;


元関数名(C#): core_OutputArray_new_byMat
元DLLエクスポート名: core_OutputArray_new_byMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_OutputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_OutputArray_new_byMat(cv::Mat *mat, cv::_OutputArray **returnValue)
{
    BEGIN_WRAP
    const cv::_OutputArray ia(*mat);
    *returnValue = new cv::_OutputArray(ia);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_OutputArray

%index
core_OutputArray_new_byUMat
[32/64bit] cv::_OutputArray のインスタンスを生成します
%prm
p1,p2
p1 = sptr : IntPtr mat
p2 = var : out IntPtr returnValue
%inst
この型は，入出力や出力関数のパラメータに使われることを除けば，InputArray と非常によく似ています．

InputArray の場合と同様に，OpenCV ユーザは OutputArray を気にする必要はなく， Mat や vector<T> などを関数に渡すだけです．InputArray と同様の制限があります．OutputArray のインスタンスを明示的に作成してはいけません。

関数を多相型にしたい（つまり，出力パラメータとして異なる配列を受け付ける）場合も，それほど難しいことではありません．上のサンプルを参考にしてください。_OutputArray::create() は， _OutputArray::getMat() の前に呼ばれる必要があることに注意してください．こうすることで，出力配列が適切に確保されていることが保証されます．

オプションの出力パラメータ．特定の出力配列を計算して返す必要がない場合は，入力配列がオプションの場合と同様に， cv::noArray() を渡します．実装レベルでは， _OutputArray::needed() を用いて，ある出力配列を計算する必要があるかどうかをチェックします．

OutputArray には，Python/Java/... ラッパーの自動生成を補助するために利用される，いくつかの同義語があります： typedef OutputArray OutputArrayOfArrays;typedef OutputArray InputOutputArray;typedef OutputArray InputOutputArrayOfArrays;


元関数名(C#): core_OutputArray_new_byUMat
元DLLエクスポート名: core_OutputArray_new_byUMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_OutputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_OutputArray_new_byUMat(cv::UMat* mat, cv::_OutputArray** returnValue)
{
    BEGIN_WRAP
        const cv::_OutputArray ia(*mat);
    *returnValue = new cv::_OutputArray(ia);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_OutputArray

%index
core_OutputArray_new_byScalar
[32bit] cv::_OutputArray のインスタンスを生成します
%prm
p1,p2
p1 = ARGS_SCALAR : Scalar val
p2 = var : out IntPtr returnValue
%inst
この型は，入出力や出力関数のパラメータに使われることを除けば，InputArray と非常によく似ています．

InputArray の場合と同様に，OpenCV ユーザは OutputArray を気にする必要はなく， Mat や vector<T> などを関数に渡すだけです．InputArray と同様の制限があります．OutputArray のインスタンスを明示的に作成してはいけません。

関数を多相型にしたい（つまり，出力パラメータとして異なる配列を受け付ける）場合も，それほど難しいことではありません．上のサンプルを参考にしてください。_OutputArray::create() は， _OutputArray::getMat() の前に呼ばれる必要があることに注意してください．こうすることで，出力配列が適切に確保されていることが保証されます．

オプションの出力パラメータ．特定の出力配列を計算して返す必要がない場合は，入力配列がオプションの場合と同様に， cv::noArray() を渡します．実装レベルでは， _OutputArray::needed() を用いて，ある出力配列を計算する必要があるかどうかをチェックします．

OutputArray には，Python/Java/... ラッパーの自動生成を補助するために利用される，いくつかの同義語があります： typedef OutputArray OutputArrayOfArrays;typedef OutputArray InputOutputArray;typedef OutputArray InputOutputArrayOfArrays;


元関数名(C#): core_OutputArray_new_byScalar
元DLLエクスポート名: core_OutputArray_new_byScalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_OutputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_OutputArray_new_byScalar(MyCvScalar scalar, cv::_OutputArray **returnValue)
{
    BEGIN_WRAP
    cv::Scalar scalarVal(cpp(scalar));
    const cv::_OutputArray ia(scalarVal);
    *returnValue = new cv::_OutputArray(ia);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_OutputArray

%index
core_OutputArray_new_byScalar
[64bit] cv::_OutputArray のインスタンスを生成します
%prm
p1,p2
p1 = var : Scalar val
p2 = var : out IntPtr returnValue
%inst
この型は，入出力や出力関数のパラメータに使われることを除けば，InputArray と非常によく似ています．

InputArray の場合と同様に，OpenCV ユーザは OutputArray を気にする必要はなく， Mat や vector<T> などを関数に渡すだけです．InputArray と同様の制限があります．OutputArray のインスタンスを明示的に作成してはいけません。

関数を多相型にしたい（つまり，出力パラメータとして異なる配列を受け付ける）場合も，それほど難しいことではありません．上のサンプルを参考にしてください。_OutputArray::create() は， _OutputArray::getMat() の前に呼ばれる必要があることに注意してください．こうすることで，出力配列が適切に確保されていることが保証されます．

オプションの出力パラメータ．特定の出力配列を計算して返す必要がない場合は，入力配列がオプションの場合と同様に， cv::noArray() を渡します．実装レベルでは， _OutputArray::needed() を用いて，ある出力配列を計算する必要があるかどうかをチェックします．

OutputArray には，Python/Java/... ラッパーの自動生成を補助するために利用される，いくつかの同義語があります： typedef OutputArray OutputArrayOfArrays;typedef OutputArray InputOutputArray;typedef OutputArray InputOutputArrayOfArrays;


元関数名(C#): core_OutputArray_new_byScalar
元DLLエクスポート名: core_OutputArray_new_byScalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_OutputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_OutputArray_new_byScalar(MyCvScalar scalar, cv::_OutputArray **returnValue)
{
    BEGIN_WRAP
    cv::Scalar scalarVal(cpp(scalar));
    const cv::_OutputArray ia(scalarVal);
    *returnValue = new cv::_OutputArray(ia);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_OutputArray

%index
core_OutputArray_new_byVectorOfMat
[32/64bit] cv::_OutputArray のインスタンスを生成します
%prm
p1,p2
p1 = sptr : IntPtr vector
p2 = var : out IntPtr returnValue
%inst
この型は，入出力や出力関数のパラメータに使われることを除けば，InputArray と非常によく似ています．

InputArray の場合と同様に，OpenCV ユーザは OutputArray を気にする必要はなく， Mat や vector<T> などを関数に渡すだけです．InputArray と同様の制限があります．OutputArray のインスタンスを明示的に作成してはいけません。

関数を多相型にしたい（つまり，出力パラメータとして異なる配列を受け付ける）場合も，それほど難しいことではありません．上のサンプルを参考にしてください。_OutputArray::create() は， _OutputArray::getMat() の前に呼ばれる必要があることに注意してください．こうすることで，出力配列が適切に確保されていることが保証されます．

オプションの出力パラメータ．特定の出力配列を計算して返す必要がない場合は，入力配列がオプションの場合と同様に， cv::noArray() を渡します．実装レベルでは， _OutputArray::needed() を用いて，ある出力配列を計算する必要があるかどうかをチェックします．

OutputArray には，Python/Java/... ラッパーの自動生成を補助するために利用される，いくつかの同義語があります： typedef OutputArray OutputArrayOfArrays;typedef OutputArray InputOutputArray;typedef OutputArray InputOutputArrayOfArrays;


元関数名(C#): core_OutputArray_new_byVectorOfMat
元DLLエクスポート名: core_OutputArray_new_byVectorOfMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_OutputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_OutputArray_new_byVectorOfMat(std::vector&amp;lt;cv::Mat&amp;gt; *vector, cv::_OutputArray **returnValue)
{
    BEGIN_WRAP
    const cv::_OutputArray ia(*vector);
    *returnValue = new cv::_OutputArray(ia);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_OutputArray

%index
core_OutputArray_delete
[32/64bit] cv::_OutputArray のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr oa
%inst
この型は，入出力や出力関数のパラメータに使われることを除けば，InputArray と非常によく似ています．

InputArray の場合と同様に，OpenCV ユーザは OutputArray を気にする必要はなく， Mat や vector<T> などを関数に渡すだけです．InputArray と同様の制限があります．OutputArray のインスタンスを明示的に作成してはいけません。

関数を多相型にしたい（つまり，出力パラメータとして異なる配列を受け付ける）場合も，それほど難しいことではありません．上のサンプルを参考にしてください。_OutputArray::create() は， _OutputArray::getMat() の前に呼ばれる必要があることに注意してください．こうすることで，出力配列が適切に確保されていることが保証されます．

オプションの出力パラメータ．特定の出力配列を計算して返す必要がない場合は，入力配列がオプションの場合と同様に， cv::noArray() を渡します．実装レベルでは， _OutputArray::needed() を用いて，ある出力配列を計算する必要があるかどうかをチェックします．

OutputArray には，Python/Java/... ラッパーの自動生成を補助するために利用される，いくつかの同義語があります： typedef OutputArray OutputArrayOfArrays;typedef OutputArray InputOutputArray;typedef OutputArray InputOutputArrayOfArrays;


元関数名(C#): core_OutputArray_delete
元DLLエクスポート名: core_OutputArray_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_OutputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_OutputArray_delete(cv::_OutputArray *oa)
{
    BEGIN_WRAP
    delete oa;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_OutputArray

%index
core_OutputArray_getMat
[32/64bit] core_OutputArray_getMat
%prm
p1,p2
p1 = sptr : IntPtr oa
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_OutputArray_getMat
元DLLエクスポート名: core_OutputArray_getMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_OutputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_OutputArray_getMat(cv::_OutputArray *oa, cv::Mat **returnValue)
{
    BEGIN_WRAP
    auto&amp; mat = oa-&amp;gt;getMatRef();
    *returnValue = new cv::Mat(mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_OutputArray

%index
core_OutputArray_getScalar
[32/64bit] core_OutputArray_getScalar
%prm
p1,p2
p1 = sptr : IntPtr oa
p2 = var : out Scalar returnValue
%inst
元関数名(C#): core_OutputArray_getScalar
元DLLエクスポート名: core_OutputArray_getScalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_OutputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_OutputArray_getScalar(cv::_OutputArray *oa, MyCvScalar *returnValue)
{
    BEGIN_WRAP
    cv::Mat &amp;mat = oa-&amp;gt;getMatRef();
    const auto scalar = mat.at&amp;lt;cv::Scalar&amp;gt;(0);
    *returnValue = c(scalar);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_OutputArray

%index
core_OutputArray_getVectorOfMat
[32/64bit] core_OutputArray_getVectorOfMat
%prm
p1,p2
p1 = sptr : IntPtr oa
p2 = sptr : IntPtr vector
%inst
元関数名(C#): core_OutputArray_getVectorOfMat
元DLLエクスポート名: core_OutputArray_getVectorOfMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_OutputArray.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_OutputArray_getVectorOfMat(cv::_OutputArray *oa, std::vector&amp;lt;cv::Mat*&amp;gt; *vector)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; temp;
    oa-&amp;gt;getMatVector(temp);

    vector-&amp;gt;resize(temp.size());
    for (size_t i = 0; i &amp;lt; temp.size(); i++)
    {
        (*vector)[i] = new cv::Mat(temp[i]);
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_OutputArray

%index
core_SparseMat_new1
[32/64bit] cv::SparseMat のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst
SparseMat クラスは，多次元の疎な数値配列を表します．

このような疎な配列は， Mat が格納できるあらゆる型の要素を格納できます．疎な配列とは，0 ではない要素のみが格納されていることを意味します（ただし，疎な行列に対する演算の結果，格納されている要素のいくつかは実際に 0 になる可能性があります．）0 ではない要素は，ハッシュテーブルに保存されます．このハッシュテーブルは，（要素が存在するかどうかに関わらず）平均して検索時間が O(1) になるように，埋められるたびに大きくなります．要素へのアクセスには，以下の方法があります．

例えば，クエリ操作（SparseMat::ptr や，上位の SparseMat::ref，SparseMat::value，SparseMat::find）．const int dims = 5;int size[5] = {10, 10, 10, 10, 10};SparseMat sparse_mat(dims, size, CV_32F);for(int i = 0; i < 1000; i++){ int idx[dims]; for(int k = 0; k < dims; k++) idx[k] = rand() % size[k]; sparse_mat.ref<float>(idx) += 1.f;}cout << "nnz = " << sparse_mat.nzcount() << endl;

疎行列のイテレータ．これらは MatIterator と似ていますが，NAryMatIterator とは異なります．つまり，STL ユーザーにはおなじみの反復ループです．// 疎な浮動小数点型行列の要素//と要素の合計を表示します．SparseMatConstIterator_<float> it = sparse_mat.begin<float>(), it_end = sparse_mat.end<float>();double s = 0;int dims = sparse_mat.dims();for(; it != it_end; ++it){ // 要素のインデックスと要素の値を表示 const SparseMat::Node* n = it.node(); printf("("); for(int i = 0; i < dims; i++) printf("%d%s", n->idx[i], i < dims-1 ? ", " : ")"); printf(":%g\n", it.value<float>()); s += *it;}printf("Element sum is %g\n", s); このループを実行すると、要素が論理的な順序（辞書的な順序など）で列挙されていないことに気がつきます。ハッシュテーブルに格納されているのと同じ順序（半ランダム）で並んでいます。ノードへのポインタを集めてソートすれば、適切な順序になります。ただし，行列に要素を追加すると，ノードへのポインタが無効になることがあるので注意が必要です．これは，バッファが再割り当てされる可能性があるために起こります．

2つ以上の疎な行列を同時に処理する必要がある場合は，上記2つの方法を組み合わせます．double cross_corr(const SparseMat& a, const SparseMat& b){ const SparseMat *_a = &a, *_b = &b; // b の要素数が a よりも少ない場合は， // b を繰り返し処理した方が高速です if(_a->nzcount() > _b->nzcount()) std::swap(_a, _b); SparseMatConstIterator_<float> it = _a->begin<float>(), it_end = _a->end<float>(); double ccorr = 0; for(; it != it_end; ++it) { // 1 番目の行列から次の要素を取り出します float avalue = *it; const Node* anode = it.node(); // そして，2 番目の行列から同じインデックスを持つ要素を見つけようとします．        // ハッシュ値は要素のインデックスにのみ依存するので， // ノードに格納されているハッシュ値を再利用します float bvalue = _b->value<float>(anode->idx,&anode->hashval); ccorr += avalue*bvalue; } return ccorr;}.


元関数名(C#): core_SparseMat_new1
元DLLエクスポート名: core_SparseMat_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_new1(cv::SparseMat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::SparseMat;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_new2
[32/64bit] cv::SparseMat のインスタンスを生成します
%prm
p1,p2,p3,p4
p1 = int : int dims
p2 = var : int[] sizes
p3 = int : int type
p4 = var : out IntPtr returnValue
%inst
SparseMat クラスは，多次元の疎な数値配列を表します．

このような疎な配列は， Mat が格納できるあらゆる型の要素を格納できます．疎な配列とは，0 ではない要素のみが格納されていることを意味します（ただし，疎な行列に対する演算の結果，格納されている要素のいくつかは実際に 0 になる可能性があります．）0 ではない要素は，ハッシュテーブルに保存されます．このハッシュテーブルは，（要素が存在するかどうかに関わらず）平均して検索時間が O(1) になるように，埋められるたびに大きくなります．要素へのアクセスには，以下の方法があります．

例えば，クエリ操作（SparseMat::ptr や，上位の SparseMat::ref，SparseMat::value，SparseMat::find）．const int dims = 5;int size[5] = {10, 10, 10, 10, 10};SparseMat sparse_mat(dims, size, CV_32F);for(int i = 0; i < 1000; i++){ int idx[dims]; for(int k = 0; k < dims; k++) idx[k] = rand() % size[k]; sparse_mat.ref<float>(idx) += 1.f;}cout << "nnz = " << sparse_mat.nzcount() << endl;

疎行列のイテレータ．これらは MatIterator と似ていますが，NAryMatIterator とは異なります．つまり，STL ユーザーにはおなじみの反復ループです．// 疎な浮動小数点型行列の要素//と要素の合計を表示します．SparseMatConstIterator_<float> it = sparse_mat.begin<float>(), it_end = sparse_mat.end<float>();double s = 0;int dims = sparse_mat.dims();for(; it != it_end; ++it){ // 要素のインデックスと要素の値を表示 const SparseMat::Node* n = it.node(); printf("("); for(int i = 0; i < dims; i++) printf("%d%s", n->idx[i], i < dims-1 ? ", " : ")"); printf(":%g\n", it.value<float>()); s += *it;}printf("Element sum is %g\n", s); このループを実行すると、要素が論理的な順序（辞書的な順序など）で列挙されていないことに気がつきます。ハッシュテーブルに格納されているのと同じ順序（半ランダム）で並んでいます。ノードへのポインタを集めてソートすれば、適切な順序になります。ただし，行列に要素を追加すると，ノードへのポインタが無効になることがあるので注意が必要です．これは，バッファが再割り当てされる可能性があるために起こります．

2つ以上の疎な行列を同時に処理する必要がある場合は，上記2つの方法を組み合わせます．double cross_corr(const SparseMat& a, const SparseMat& b){ const SparseMat *_a = &a, *_b = &b; // b の要素数が a よりも少ない場合は， // b を繰り返し処理した方が高速です if(_a->nzcount() > _b->nzcount()) std::swap(_a, _b); SparseMatConstIterator_<float> it = _a->begin<float>(), it_end = _a->end<float>(); double ccorr = 0; for(; it != it_end; ++it) { // 1 番目の行列から次の要素を取り出します float avalue = *it; const Node* anode = it.node(); // そして，2 番目の行列から同じインデックスを持つ要素を見つけようとします．        // ハッシュ値は要素のインデックスにのみ依存するので， // ノードに格納されているハッシュ値を再利用します float bvalue = _b->value<float>(anode->idx,&anode->hashval); ccorr += avalue*bvalue; } return ccorr;}.


元関数名(C#): core_SparseMat_new2
元DLLエクスポート名: core_SparseMat_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_new2(int dims, const int *sizes, int type, cv::SparseMat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::SparseMat(dims, sizes, type);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_new3
[32/64bit] cv::SparseMat のインスタンスを生成します
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = var : out IntPtr returnValue
%inst
SparseMat クラスは，多次元の疎な数値配列を表します．

このような疎な配列は， Mat が格納できるあらゆる型の要素を格納できます．疎な配列とは，0 ではない要素のみが格納されていることを意味します（ただし，疎な行列に対する演算の結果，格納されている要素のいくつかは実際に 0 になる可能性があります．）0 ではない要素は，ハッシュテーブルに保存されます．このハッシュテーブルは，（要素が存在するかどうかに関わらず）平均して検索時間が O(1) になるように，埋められるたびに大きくなります．要素へのアクセスには，以下の方法があります．

例えば，クエリ操作（SparseMat::ptr や，上位の SparseMat::ref，SparseMat::value，SparseMat::find）．const int dims = 5;int size[5] = {10, 10, 10, 10, 10};SparseMat sparse_mat(dims, size, CV_32F);for(int i = 0; i < 1000; i++){ int idx[dims]; for(int k = 0; k < dims; k++) idx[k] = rand() % size[k]; sparse_mat.ref<float>(idx) += 1.f;}cout << "nnz = " << sparse_mat.nzcount() << endl;

疎行列のイテレータ．これらは MatIterator と似ていますが，NAryMatIterator とは異なります．つまり，STL ユーザーにはおなじみの反復ループです．// 疎な浮動小数点型行列の要素//と要素の合計を表示します．SparseMatConstIterator_<float> it = sparse_mat.begin<float>(), it_end = sparse_mat.end<float>();double s = 0;int dims = sparse_mat.dims();for(; it != it_end; ++it){ // 要素のインデックスと要素の値を表示 const SparseMat::Node* n = it.node(); printf("("); for(int i = 0; i < dims; i++) printf("%d%s", n->idx[i], i < dims-1 ? ", " : ")"); printf(":%g\n", it.value<float>()); s += *it;}printf("Element sum is %g\n", s); このループを実行すると、要素が論理的な順序（辞書的な順序など）で列挙されていないことに気がつきます。ハッシュテーブルに格納されているのと同じ順序（半ランダム）で並んでいます。ノードへのポインタを集めてソートすれば、適切な順序になります。ただし，行列に要素を追加すると，ノードへのポインタが無効になることがあるので注意が必要です．これは，バッファが再割り当てされる可能性があるために起こります．

2つ以上の疎な行列を同時に処理する必要がある場合は，上記2つの方法を組み合わせます．double cross_corr(const SparseMat& a, const SparseMat& b){ const SparseMat *_a = &a, *_b = &b; // b の要素数が a よりも少ない場合は， // b を繰り返し処理した方が高速です if(_a->nzcount() > _b->nzcount()) std::swap(_a, _b); SparseMatConstIterator_<float> it = _a->begin<float>(), it_end = _a->end<float>(); double ccorr = 0; for(; it != it_end; ++it) { // 1 番目の行列から次の要素を取り出します float avalue = *it; const Node* anode = it.node(); // そして，2 番目の行列から同じインデックスを持つ要素を見つけようとします．        // ハッシュ値は要素のインデックスにのみ依存するので， // ノードに格納されているハッシュ値を再利用します float bvalue = _b->value<float>(anode->idx,&anode->hashval); ccorr += avalue*bvalue; } return ccorr;}.


元関数名(C#): core_SparseMat_new3
元DLLエクスポート名: core_SparseMat_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_new3(cv::Mat *m, cv::SparseMat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::SparseMat(*m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_delete
[32/64bit] cv::SparseMat のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
SparseMat クラスは，多次元の疎な数値配列を表します．

このような疎な配列は， Mat が格納できるあらゆる型の要素を格納できます．疎な配列とは，0 ではない要素のみが格納されていることを意味します（ただし，疎な行列に対する演算の結果，格納されている要素のいくつかは実際に 0 になる可能性があります．）0 ではない要素は，ハッシュテーブルに保存されます．このハッシュテーブルは，（要素が存在するかどうかに関わらず）平均して検索時間が O(1) になるように，埋められるたびに大きくなります．要素へのアクセスには，以下の方法があります．

例えば，クエリ操作（SparseMat::ptr や，上位の SparseMat::ref，SparseMat::value，SparseMat::find）．const int dims = 5;int size[5] = {10, 10, 10, 10, 10};SparseMat sparse_mat(dims, size, CV_32F);for(int i = 0; i < 1000; i++){ int idx[dims]; for(int k = 0; k < dims; k++) idx[k] = rand() % size[k]; sparse_mat.ref<float>(idx) += 1.f;}cout << "nnz = " << sparse_mat.nzcount() << endl;

疎行列のイテレータ．これらは MatIterator と似ていますが，NAryMatIterator とは異なります．つまり，STL ユーザーにはおなじみの反復ループです．// 疎な浮動小数点型行列の要素//と要素の合計を表示します．SparseMatConstIterator_<float> it = sparse_mat.begin<float>(), it_end = sparse_mat.end<float>();double s = 0;int dims = sparse_mat.dims();for(; it != it_end; ++it){ // 要素のインデックスと要素の値を表示 const SparseMat::Node* n = it.node(); printf("("); for(int i = 0; i < dims; i++) printf("%d%s", n->idx[i], i < dims-1 ? ", " : ")"); printf(":%g\n", it.value<float>()); s += *it;}printf("Element sum is %g\n", s); このループを実行すると、要素が論理的な順序（辞書的な順序など）で列挙されていないことに気がつきます。ハッシュテーブルに格納されているのと同じ順序（半ランダム）で並んでいます。ノードへのポインタを集めてソートすれば、適切な順序になります。ただし，行列に要素を追加すると，ノードへのポインタが無効になることがあるので注意が必要です．これは，バッファが再割り当てされる可能性があるために起こります．

2つ以上の疎な行列を同時に処理する必要がある場合は，上記2つの方法を組み合わせます．double cross_corr(const SparseMat& a, const SparseMat& b){ const SparseMat *_a = &a, *_b = &b; // b の要素数が a よりも少ない場合は， // b を繰り返し処理した方が高速です if(_a->nzcount() > _b->nzcount()) std::swap(_a, _b); SparseMatConstIterator_<float> it = _a->begin<float>(), it_end = _a->end<float>(); double ccorr = 0; for(; it != it_end; ++it) { // 1 番目の行列から次の要素を取り出します float avalue = *it; const Node* anode = it.node(); // そして，2 番目の行列から同じインデックスを持つ要素を見つけようとします．        // ハッシュ値は要素のインデックスにのみ依存するので， // ノードに格納されているハッシュ値を再利用します float bvalue = _b->value<float>(anode->idx,&anode->hashval); ccorr += avalue*bvalue; } return ccorr;}.


元関数名(C#): core_SparseMat_delete
元DLLエクスポート名: core_SparseMat_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_delete(cv::SparseMat *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_operatorAssign_SparseMat
[32/64bit] core_SparseMat_operatorAssign_SparseMat
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr m
%inst
元関数名(C#): core_SparseMat_operatorAssign_SparseMat
元DLLエクスポート名: core_SparseMat_operatorAssign_SparseMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_operatorAssign_SparseMat(cv::SparseMat *obj, cv::SparseMat *m)
{
    BEGIN_WRAP
    *obj = *m;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_operatorAssign_Mat
[32/64bit] core_SparseMat_operatorAssign_Mat
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr m
%inst
元関数名(C#): core_SparseMat_operatorAssign_Mat
元DLLエクスポート名: core_SparseMat_operatorAssign_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_operatorAssign_Mat(cv::SparseMat *obj, cv::Mat *m)
{
    BEGIN_WRAP
    *obj = *m;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_clone
[32/64bit] 行列の完全なコピーを作成
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_SparseMat_clone
元DLLエクスポート名: core_SparseMat_clone
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_clone(cv::SparseMat *obj, cv::SparseMat **returnValue)
{
    BEGIN_WRAP
    const auto sm = obj-&amp;gt;clone();
    *returnValue = new cv::SparseMat(sm);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_copyTo_SparseMat
[32/64bit] は，すべてのデータをコピー先の行列にコピーします．m の以前の内容はすべて消去されます。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr m
%inst
元関数名(C#): core_SparseMat_copyTo_SparseMat
元DLLエクスポート名: core_SparseMat_copyTo_SparseMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_copyTo_SparseMat(cv::SparseMat *obj, cv::SparseMat *m)
{
    BEGIN_WRAP
    obj-&amp;gt;copyTo(*m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_copyTo_Mat
[32/64bit] は，すべてのデータをコピー先の行列にコピーします．m の以前の内容はすべて消去されます。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr m
%inst
元関数名(C#): core_SparseMat_copyTo_Mat
元DLLエクスポート名: core_SparseMat_copyTo_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_copyTo_Mat(cv::SparseMat *obj, cv::Mat *m)
{
    BEGIN_WRAP
    obj-&amp;gt;copyTo(*m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_convertTo_SparseMat
[32/64bit] 疎な行列を，オプションの型変換とスケーリングを用いて，密な n-dim 行列に変換します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr m
p3 = int : int rtype
p4 = double : double alpha
%inst
元関数名(C#): core_SparseMat_convertTo_SparseMat
元DLLエクスポート名: core_SparseMat_convertTo_SparseMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_convertTo_SparseMat(cv::SparseMat *obj, cv::SparseMat *m, int rtype, double alpha)
{
    BEGIN_WRAP
    obj-&amp;gt;convertTo(*m, rtype, alpha);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_convertTo_Mat
[32/64bit] 疎な行列を，オプションの型変換とスケーリングを用いて，密な n-dim 行列に変換します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr m
p3 = int : int rtype
p4 = double : double alpha
p5 = double : double beta
%inst
元関数名(C#): core_SparseMat_convertTo_Mat
元DLLエクスポート名: core_SparseMat_convertTo_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_convertTo_Mat(cv::SparseMat *obj, cv::Mat *m, int rtype, double alpha = 1, double beta = 0)
{
    BEGIN_WRAP
    obj-&amp;gt;convertTo(*m, rtype, alpha, beta);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_assignTo
[32/64bit] core_SparseMat_assignTo
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr m
p3 = int : int type
%inst
元関数名(C#): core_SparseMat_assignTo
元DLLエクスポート名: core_SparseMat_assignTo
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_assignTo(cv::SparseMat *obj, cv::SparseMat *m, int type = -1)
{
    BEGIN_WRAP
    obj-&amp;gt;assignTo(*m, type);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_create
[32/64bit] 疎な行列を再割り当てします．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = int : int dims
p3 = var : int[] sizes
p4 = int : int type
%inst
行列が既に適切なサイズと型を持っている場合は，単に clear() でクリアされます．そうでない場合は，（release() を用いて）古い行列が解放され，新しい行列が割り当てられます．

元関数名(C#): core_SparseMat_create
元DLLエクスポート名: core_SparseMat_create
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_create(cv::SparseMat *obj, int dims, const int* sizes, int type)
{
    BEGIN_WRAP
    obj-&amp;gt;create(dims, sizes, type);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_clear
[32/64bit] 疎な行列の要素をすべて 0 にし，ハッシュテーブルをクリアします．
%prm
p1
p1 = sptr : IntPtr obj
%inst
元関数名(C#): core_SparseMat_clear
元DLLエクスポート名: core_SparseMat_clear
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_clear(cv::SparseMat *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;clear();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_addref
[32/64bit] ヘッダへの参照カウンタを手動でインクリメントします．
%prm
p1
p1 = sptr : IntPtr obj
%inst
元関数名(C#): core_SparseMat_addref
元DLLエクスポート名: core_SparseMat_addref
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_addref(cv::SparseMat *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;addref();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_release
[32/64bit] core_SparseMat_release
%prm
p1
p1 = sptr : IntPtr obj
%inst
元関数名(C#): core_SparseMat_release
元DLLエクスポート名: core_SparseMat_release
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_release(cv::SparseMat *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;release();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_elemSize
[32/64bit] 疎行列を古い形式の表現に変換し，すべての要素がコピーされます．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
各要素のサイズをバイト単位で返します（オーバーヘッド，つまり SparseMat::Node 要素によって占有される領域は含まれません）．

元関数名(C#): core_SparseMat_elemSize
元DLLエクスポート名: core_SparseMat_elemSize
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_elemSize(cv::SparseMat *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;elemSize());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_elemSize1
[32/64bit] elemSize()/channels() を返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): core_SparseMat_elemSize1
元DLLエクスポート名: core_SparseMat_elemSize1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_elemSize1(cv::SparseMat *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;elemSize1());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_type
[32/64bit] 疎な行列要素の型を返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): core_SparseMat_type
元DLLエクスポート名: core_SparseMat_type
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_type(cv::SparseMat *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;type();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_depth
[32/64bit] 疎な行列の要素の深さを返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): core_SparseMat_depth
元DLLエクスポート名: core_SparseMat_depth
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_depth(cv::SparseMat *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;depth();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_channels
[32/64bit] チャンネルの数を返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): core_SparseMat_channels
元DLLエクスポート名: core_SparseMat_channels
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_channels(cv::SparseMat *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;channels();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_size1
[32/64bit] サイズの配列を返します．また，行列が割り当てられていない場合は NULL を返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_SparseMat_size1
元DLLエクスポート名: core_SparseMat_size1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_size1(cv::SparseMat *obj, const int **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;size();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_size2
[32/64bit] サイズの配列を返します．また，行列が割り当てられていない場合は NULL を返します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = int : int i
p3 = var : out int returnValue
%inst
元関数名(C#): core_SparseMat_size2
元DLLエクスポート名: core_SparseMat_size2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_size2(cv::SparseMat *obj, int i, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;size(i);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_dims
[32/64bit] 行列の次元を返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): core_SparseMat_dims
元DLLエクスポート名: core_SparseMat_dims
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_dims(cv::SparseMat *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;dims();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_nzcount
[32/64bit] 0 ではない要素の数（＝ハッシュテーブルのノード数）を返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_SparseMat_nzcount
元DLLエクスポート名: core_SparseMat_nzcount
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_nzcount(cv::SparseMat *obj, size_t *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;nzcount();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_hash_1d
[32/64bit] 要素のハッシュ値を計算します（1次元の場合）．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = int : int i0
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_SparseMat_hash_1d
元DLLエクスポート名: core_SparseMat_hash_1d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_hash_1d(cv::SparseMat *obj, int i0, size_t *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;hash(i0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_hash_2d
[32/64bit] 要素のハッシュ値を計算します（1次元の場合）．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = int : int i0
p3 = int : int i1
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_SparseMat_hash_2d
元DLLエクスポート名: core_SparseMat_hash_2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_hash_2d(cv::SparseMat *obj, int i0, int i1, size_t *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;hash(i0, i1);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_hash_3d
[32/64bit] 要素のハッシュ値を計算します（1次元の場合）．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = int : int i0
p3 = int : int i1
p4 = int : int i2
p5 = var : out IntPtr returnValue
%inst
元関数名(C#): core_SparseMat_hash_3d
元DLLエクスポート名: core_SparseMat_hash_3d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_hash_3d(cv::SparseMat *obj, int i0, int i1, int i2, size_t *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;hash(i0, i1, i2);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_hash_nd
[32/64bit] 要素のハッシュ値を計算します（1次元の場合）．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = var : int[] idx
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_SparseMat_hash_nd
元DLLエクスポート名: core_SparseMat_hash_nd
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_hash_nd(cv::SparseMat *obj, const int* idx, size_t *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;hash(idx);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_ptr_1d
[32/64bit] 指定された要素へのポインタを返します（1次元の場合）．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = int : int i0
p3 = int : int createMissing
p4 = var : ulong* hashVal
p5 = var : out IntPtr returnValue
%inst
1D, 2D, 3D に特化したバージョンと，n-D に特化した generic_type があります． 行列の要素へのポインタを返します．要素が存在する（0 ではない）場合は，そのポインタが返されます．

要素が存在せず，かつ createMissing=false の場合は，NULLポインタが返されます．

要素が存在せず createMissing=true であれば，新しい要素が作成され，0 で初期化されます．そのポインタが返されます．

オプションの hashval ポインタが NULL でない場合，要素のハッシュ値は計算されず，代わりに *hashval が取得されます．

元関数名(C#): core_SparseMat_ptr_1d
元DLLエクスポート名: core_SparseMat_ptr_1d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_ptr_1d(cv::SparseMat *obj, int i0, int createMissing, uint64* hashVal, uchar **returnValue)
{
    BEGIN_WRAP
    if (hashVal == nullptr)
    {
        *returnValue = obj-&amp;gt;ptr(i0, createMissing != 0);
    }else
    {
        auto hashVal0 = static_cast&amp;lt;size_t&amp;gt;(*hashVal);
        *returnValue = obj-&amp;gt;ptr(i0, createMissing != 0, &amp;hashVal0);
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_ptr_2d
[32/64bit] 指定された要素へのポインタを返します（1次元の場合）．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr obj
p2 = int : int i0
p3 = int : int i1
p4 = int : int createMissing
p5 = var : ulong* hashVal
p6 = var : out IntPtr returnValue
%inst
1D, 2D, 3D に特化したバージョンと，n-D に特化した generic_type があります． 行列の要素へのポインタを返します．要素が存在する（0 ではない）場合は，そのポインタが返されます．

要素が存在せず，かつ createMissing=false の場合は，NULLポインタが返されます．

要素が存在せず createMissing=true であれば，新しい要素が作成され，0 で初期化されます．そのポインタが返されます．

オプションの hashval ポインタが NULL でない場合，要素のハッシュ値は計算されず，代わりに *hashval が取得されます．

元関数名(C#): core_SparseMat_ptr_2d
元DLLエクスポート名: core_SparseMat_ptr_2d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_ptr_2d(cv::SparseMat *obj, int i0, int i1, int createMissing, uint64* hashVal, uchar **returnValue)
{
    BEGIN_WRAP
    if (hashVal == nullptr)
    {
        *returnValue = obj-&amp;gt;ptr(i0, i1, createMissing != 0);
    }
    else
    {
        auto hashVal0 = static_cast&amp;lt;size_t&amp;gt;(*hashVal);
        *returnValue = obj-&amp;gt;ptr(i0, i1, createMissing != 0, &amp;hashVal0);
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_ptr_3d
[32/64bit] 指定された要素へのポインタを返します（1次元の場合）．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr obj
p2 = int : int i0
p3 = int : int i1
p4 = int : int i2
p5 = int : int createMissing
p6 = var : ulong* hashVal
p7 = var : out IntPtr returnValue
%inst
1D, 2D, 3D に特化したバージョンと，n-D に特化した generic_type があります． 行列の要素へのポインタを返します．要素が存在する（0 ではない）場合は，そのポインタが返されます．

要素が存在せず，かつ createMissing=false の場合は，NULLポインタが返されます．

要素が存在せず createMissing=true であれば，新しい要素が作成され，0 で初期化されます．そのポインタが返されます．

オプションの hashval ポインタが NULL でない場合，要素のハッシュ値は計算されず，代わりに *hashval が取得されます．

元関数名(C#): core_SparseMat_ptr_3d
元DLLエクスポート名: core_SparseMat_ptr_3d
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_ptr_3d(cv::SparseMat *obj, int i0, int i1, int i2, int createMissing, uint64* hashVal, uchar **returnValue)
{
    BEGIN_WRAP
    if (hashVal == nullptr)
    {
        *returnValue = obj-&amp;gt;ptr(i0, i1, i2, createMissing != 0);
    }
    else
    {
        auto hashVal0 = static_cast&amp;lt;size_t&amp;gt;(*hashVal);
        *returnValue = obj-&amp;gt;ptr(i0, i1, i2, createMissing != 0, &amp;hashVal0);
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_SparseMat_ptr_nd
[32/64bit] 指定された要素へのポインタを返します（1次元の場合）．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = var : int[] idx
p3 = int : int createMissing
p4 = var : ulong* hashVal
p5 = var : out IntPtr returnValue
%inst
1D, 2D, 3D に特化したバージョンと，n-D に特化した generic_type があります． 行列の要素へのポインタを返します．要素が存在する（0 ではない）場合は，そのポインタが返されます．

要素が存在せず，かつ createMissing=false の場合は，NULLポインタが返されます．

要素が存在せず createMissing=true であれば，新しい要素が作成され，0 で初期化されます．そのポインタが返されます．

オプションの hashval ポインタが NULL でない場合，要素のハッシュ値は計算されず，代わりに *hashval が取得されます．

元関数名(C#): core_SparseMat_ptr_nd
元DLLエクスポート名: core_SparseMat_ptr_nd
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_SparseMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_SparseMat_ptr_nd(cv::SparseMat *obj, const int* idx, int createMissing, uint64* hashVal, uchar **returnValue)
{
    BEGIN_WRAP
    if (hashVal == nullptr)
    {
        *returnValue = obj-&amp;gt;ptr(idx, createMissing != 0);
    }
    else
    {
        auto hashVal0 = static_cast&amp;lt;size_t&amp;gt;(*hashVal);
        *returnValue = obj-&amp;gt;ptr(idx, createMissing != 0, &amp;hashVal0);
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_SparseMat

%index
core_UMat_new1
[32/64bit] cv::Umat のインスタンスを生成します
%prm
p1,p2
p1 = int : int usageFlags
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): core_UMat_new1
元DLLエクスポート名: core_UMat_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_new1(const cv::UMatUsageFlags usageFlags, cv::UMat** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::UMat(usageFlags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_new2
[32/64bit] cv::Umat のインスタンスを生成します
%prm
p1,p2,p3,p4,p5
p1 = int : int rows
p2 = int : int cols
p3 = int : int type
p4 = int : int usageFlags
p5 = var : out IntPtr returnValue
%inst



元関数名(C#): core_UMat_new2
元DLLエクスポート名: core_UMat_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_new2(const int rows, const int cols, const int type, const cv::UMatUsageFlags usageFlags, cv::UMat** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::UMat(rows, cols, type, usageFlags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_new3
[32bit] cv::Umat のインスタンスを生成します
%prm
p1,p2,p3,p4,p5,p6
p1 = int : int rows
p2 = int : int cols
p3 = int : int type
p4 = ARGS_SCALAR : Scalar scalar
p5 = int : int usageFlags
p6 = var : out IntPtr returnValue
%inst



元関数名(C#): core_UMat_new3
元DLLエクスポート名: core_UMat_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_new3(cv::Size size, int type, cv::UMatUsageFlags usageFlags, cv::UMat** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::UMat(size, type, usageFlags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_new3
[64bit] cv::Umat のインスタンスを生成します
%prm
p1,p2,p3,p4,p5,p6
p1 = int : int rows
p2 = int : int cols
p3 = int : int type
p4 = var : Scalar scalar
p5 = int : int usageFlags
p6 = var : out IntPtr returnValue
%inst



元関数名(C#): core_UMat_new3
元DLLエクスポート名: core_UMat_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_new3(cv::Size size, int type, cv::UMatUsageFlags usageFlags, cv::UMat** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::UMat(size, type, usageFlags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_new4
[32/64bit] cv::Umat のインスタンスを生成します
%prm
p1,p2,p3,p4
p1 = int : int ndims
p2 = var : [MarshalAs(UnmanagedType.LPArray)] int[] sizes
p3 = int : int type
p4 = var : out IntPtr returnValue
%inst



元関数名(C#): core_UMat_new4
元DLLエクスポート名: core_UMat_new4
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_new4(
    const int ndims, const int* sizes, const int type, const cv::UMatUsageFlags usageFlags, cv::UMat** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::UMat(ndims, sizes, type, usageFlags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_new5
[32bit] cv::Umat のインスタンスを生成します
%prm
p1,p2,p3,p4,p5
p1 = int : int ndims
p2 = var : [MarshalAs(UnmanagedType.LPArray)] int[] sizes
p3 = int : int type
p4 = ARGS_SCALAR : Scalar s
p5 = var : out IntPtr returnValue
%inst



元関数名(C#): core_UMat_new5
元DLLエクスポート名: core_UMat_new5
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_new5(cv::Size size, int type, MyCvScalar s, cv::UMatUsageFlags usageFlags, cv::UMat** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::UMat(size, type, cpp(s), usageFlags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_new5
[64bit] cv::Umat のインスタンスを生成します
%prm
p1,p2,p3,p4,p5
p1 = int : int ndims
p2 = var : [MarshalAs(UnmanagedType.LPArray)] int[] sizes
p3 = int : int type
p4 = var : Scalar s
p5 = var : out IntPtr returnValue
%inst



元関数名(C#): core_UMat_new5
元DLLエクスポート名: core_UMat_new5
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_new5(cv::Size size, int type, MyCvScalar s, cv::UMatUsageFlags usageFlags, cv::UMat** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::UMat(size, type, cpp(s), usageFlags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_new6
[32/64bit] cv::Umat のインスタンスを生成します
%prm
p1,p2
p1 = sptr : IntPtr umat
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): core_UMat_new6
元DLLエクスポート名: core_UMat_new6
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_new6(cv::UMat* umat, cv::UMat** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::UMat(*umat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_new7
[32/64bit] cv::Umat のインスタンスを生成します
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr umat
p2 = ARGS_RANGE : Range rowRange
p3 = ARGS_RANGE : Range colRange
p4 = int : int usageFlags
p5 = var : out IntPtr returnValue
%inst



元関数名(C#): core_UMat_new7
元DLLエクスポート名: core_UMat_new7
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_new7(cv::UMat* umat, const MyCvSlice rowRange, const MyCvSlice colRange, cv::UMat** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::UMat(*umat, cpp(rowRange), cpp(colRange));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_new8
[32bit] cv::Umat のインスタンスを生成します
%prm
p1,p2,p3
p1 = sptr : IntPtr umat
p2 = ARGS_RECT : Rect roi
p3 = var : out IntPtr returnValue
%inst



元関数名(C#): core_UMat_new8
元DLLエクスポート名: core_UMat_new8
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_new8(cv::UMat* umat, const MyCvRect roi, cv::UMat** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::UMat(*umat, cpp(roi));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_new8
[64bit] cv::Umat のインスタンスを生成します
%prm
p1,p2,p3
p1 = sptr : IntPtr umat
p2 = var : Rect roi
p3 = var : out IntPtr returnValue
%inst



元関数名(C#): core_UMat_new8
元DLLエクスポート名: core_UMat_new8
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_new8(cv::UMat* umat, const MyCvRect roi, cv::UMat** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::UMat(*umat, cpp(roi));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_new9
[32/64bit] cv::Umat のインスタンスを生成します
%prm
p1,p2,p3
p1 = sptr : IntPtr umat
p2 = var : Range[] ranges
p3 = var : out IntPtr returnValue
%inst



元関数名(C#): core_UMat_new9
元DLLエクスポート名: core_UMat_new9
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_new9(cv::UMat* umat, cv::Range* ranges, cv::UMat** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::UMat(*umat, ranges);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_delete
[32/64bit] cv::Umat のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr umat
%inst



元関数名(C#): core_UMat_delete
元DLLエクスポート名: core_UMat_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_delete(cv::UMat* self)
{
    BEGIN_WRAP
        delete self;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_getMat
[32/64bit] core_UMat_getMat
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int accessFlag
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_getMat
元DLLエクスポート名: core_UMat_getMat
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_getMat(cv::UMat* self, cv::AccessFlag accessFlag, cv::Mat** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(self-&amp;gt;getMat(accessFlag));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_row
[32/64bit] core_UMat_row
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int y
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_row
元DLLエクスポート名: core_UMat_row
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_row(cv::UMat* self, int y, cv::UMat** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::UMat(self-&amp;gt;row(y));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_col
[32/64bit] core_UMat_col
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int x
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_col
元DLLエクスポート名: core_UMat_col
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_col(cv::UMat* self, int x, cv::UMat** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::UMat(self-&amp;gt;col(x));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_rowRange
[32/64bit] core_UMat_rowRange
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = int : int startRow
p3 = int : int endRow
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_rowRange
元DLLエクスポート名: core_UMat_rowRange
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_rowRange(cv::UMat* self, int startRow, int endRow, cv::UMat** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::UMat(self-&amp;gt;rowRange(startRow, endRow));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_colRange
[32/64bit] core_UMat_colRange
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = int : int startCol
p3 = int : int endCol
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_colRange
元DLLエクスポート名: core_UMat_colRange
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_colRange(cv::UMat* self, int startCol, int endCol, cv::UMat** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::UMat(self-&amp;gt;colRange(startCol, endCol));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_diag
[32/64bit] core_UMat_diag
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int d
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_diag
元DLLエクスポート名: core_UMat_diag
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_diag(cv::UMat* self, int d, cv::UMat** returnValue)
{
    BEGIN_WRAP
        const auto ret = self-&amp;gt;diag(d);
    *returnValue = new cv::UMat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_diag_static
[32/64bit] core_UMat_diag_static
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_diag_static
元DLLエクスポート名: core_UMat_diag_static
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_diag_static(cv::UMat* self, cv::UMat** returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::UMat::diag(*self);
    *returnValue = new cv::UMat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_clone
[32/64bit] core_UMat_clone
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_clone
元DLLエクスポート名: core_UMat_clone
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_clone(cv::UMat* self, cv::UMat** returnValue)
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;clone();
    *returnValue = new cv::UMat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_copyTo1
[32/64bit] core_UMat_copyTo1
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
%inst
元関数名(C#): core_UMat_copyTo1
元DLLエクスポート名: core_UMat_copyTo1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_copyTo1(cv::UMat* self, cv::_OutputArray* m)
{
    BEGIN_WRAP
    self-&amp;gt;copyTo(*m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_copyTo2
[32/64bit] core_UMat_copyTo2
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
p3 = sptr : IntPtr mask
%inst
元関数名(C#): core_UMat_copyTo2
元DLLエクスポート名: core_UMat_copyTo2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_copyTo2(cv::UMat* self, cv::_OutputArray* m, cv::_InputArray* mask)
{
    BEGIN_WRAP
    self-&amp;gt;copyTo(*m, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_copyTo_toUMat1
[32/64bit] core_UMat_copyTo_toUMat1
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
%inst
元関数名(C#): core_UMat_copyTo_toUMat1
元DLLエクスポート名: core_UMat_copyTo_toUMat1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_copyTo_toUMat1(cv::UMat* self, cv::UMat* m)
{
    BEGIN_WRAP
    self-&amp;gt;copyTo(*m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_copyTo_toUMat2
[32/64bit] core_UMat_copyTo_toUMat2
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
p3 = sptr : IntPtr mask
%inst
元関数名(C#): core_UMat_copyTo_toUMat2
元DLLエクスポート名: core_UMat_copyTo_toUMat2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_copyTo_toUMat2(cv::UMat* self, cv::UMat* m, cv::_InputArray* mask)
{
    BEGIN_WRAP
    self-&amp;gt;copyTo(*m, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_convertTo
[32/64bit] core_UMat_convertTo
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
p3 = int : int rtype
p4 = double : double alpha
p5 = double : double beta
%inst
元関数名(C#): core_UMat_convertTo
元DLLエクスポート名: core_UMat_convertTo
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_convertTo(cv::UMat* self, cv::_OutputArray* m, int rtype, double alpha, double beta)
{
    BEGIN_WRAP
    self-&amp;gt;convertTo(*m, rtype, alpha, beta);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_assignTo
[32/64bit] core_UMat_assignTo
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
p3 = int : int type
%inst
元関数名(C#): core_UMat_assignTo
元DLLエクスポート名: core_UMat_assignTo
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_assignTo(cv::UMat* self, cv::UMat* m, int type)
{
    BEGIN_WRAP
    self-&amp;gt;assignTo(*m, type);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_setTo_Scalar
[32bit] core_UMat_setTo_Scalar
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = ARGS_SCALAR : Scalar value
p3 = sptr : IntPtr mask
%inst
元関数名(C#): core_UMat_setTo_Scalar
元DLLエクスポート名: core_UMat_setTo_Scalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_setTo_Scalar(cv::UMat* self, MyCvScalar value, cv::UMat* mask)
{
    BEGIN_WRAP
    if (mask == nullptr)
        self-&amp;gt;setTo(cpp(value));
    else
        self-&amp;gt;setTo(cpp(value), entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_setTo_Scalar
[64bit] core_UMat_setTo_Scalar
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = var : Scalar value
p3 = sptr : IntPtr mask
%inst
元関数名(C#): core_UMat_setTo_Scalar
元DLLエクスポート名: core_UMat_setTo_Scalar
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_setTo_Scalar(cv::UMat* self, MyCvScalar value, cv::UMat* mask)
{
    BEGIN_WRAP
    if (mask == nullptr)
        self-&amp;gt;setTo(cpp(value));
    else
        self-&amp;gt;setTo(cpp(value), entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_setTo_InputArray
[32/64bit] core_UMat_setTo_InputArray
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = sptr : IntPtr value
p3 = sptr : IntPtr mask
%inst
元関数名(C#): core_UMat_setTo_InputArray
元DLLエクスポート名: core_UMat_setTo_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_setTo_InputArray(cv::UMat* self, cv::_InputArray* value, cv::UMat* mask)
{
    BEGIN_WRAP
    self-&amp;gt;setTo(*value, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_reshape1
[32/64bit] core_UMat_reshape1
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = int : int cn
p3 = int : int rows
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_reshape1
元DLLエクスポート名: core_UMat_reshape1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_reshape1(cv::UMat* self, int cn, int rows, cv::UMat** returnValue)
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;reshape(cn, rows);
    *returnValue = new cv::UMat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_reshape2
[32/64bit] core_UMat_reshape2
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr self
p2 = int : int cn
p3 = int : int newndims
p4 = var : [MarshalAs(UnmanagedType.LPArray), In] int[] newsz
p5 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_reshape2
元DLLエクスポート名: core_UMat_reshape2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_reshape2(cv::UMat* self, int cn, int newndims, const int* newsz, cv::UMat** returnValue)
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;reshape(cn, newndims, newsz);
    *returnValue = new cv::UMat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_t
[32/64bit] core_UMat_t
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_t
元DLLエクスポート名: core_UMat_t
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_t(cv::UMat* self, cv::UMat** returnValue)
{
    BEGIN_WRAP
    const auto expr = self-&amp;gt;t();
    *returnValue = new cv::UMat(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_inv
[32/64bit] core_UMat_inv
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int method
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_inv
元DLLエクスポート名: core_UMat_inv
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_inv(cv::UMat* self, int method, cv::UMat** returnValue)
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;inv(method);
    *returnValue = new cv::UMat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_mul
[32/64bit] core_UMat_mul
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
p3 = double : double scale
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_mul
元DLLエクスポート名: core_UMat_mul
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_mul(cv::UMat* self, cv::_InputArray* m, double scale, cv::UMat** returnValue)
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;mul(*m, scale);
    *returnValue = new cv::UMat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_dot
[32/64bit] core_UMat_dot
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = sptr : IntPtr m
p3 = var : out double returnValue
%inst
元関数名(C#): core_UMat_dot
元DLLエクスポート名: core_UMat_dot
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_dot(cv::UMat* self, cv::_InputArray* m, double* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;dot(*m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_zeros1
[32/64bit] core_UMat_zeros1
%prm
p1,p2,p3,p4
p1 = int : int rows
p2 = int : int cols
p3 = int : int type
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_zeros1
元DLLエクスポート名: core_UMat_zeros1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_zeros1(int rows, int cols, int type, cv::UMat** returnValue)
{
    BEGIN_WRAP
    const auto expr = cv::UMat::zeros(rows, cols, type);
    *returnValue = new cv::UMat(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_zeros2
[32/64bit] core_UMat_zeros2
%prm
p1,p2,p3,p4
p1 = int : int ndims
p2 = var : [MarshalAs(UnmanagedType.LPArray), In] int[] sz
p3 = int : int type
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_zeros2
元DLLエクスポート名: core_UMat_zeros2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_zeros2(int ndims, const int* sz, int type, cv::UMat** returnValue)
{
    BEGIN_WRAP
    const auto expr = cv::UMat::zeros(ndims, sz, type);
    *returnValue = new cv::UMat(expr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_ones1
[32/64bit] core_UMat_ones1
%prm
p1,p2,p3,p4
p1 = int : int rows
p2 = int : int cols
p3 = int : int type
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_ones1
元DLLエクスポート名: core_UMat_ones1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_ones1(int rows, int cols, int type, cv::UMat** returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::UMat::ones(rows, cols, type);
    *returnValue = new cv::UMat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_ones2
[32/64bit] core_UMat_ones2
%prm
p1,p2,p3,p4
p1 = int : int ndims
p2 = var : [MarshalAs(UnmanagedType.LPArray), In] int[] sz
p3 = int : int type
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_ones2
元DLLエクスポート名: core_UMat_ones2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_ones2(int ndims, const int* sz, int type, cv::UMat** returnValue)
{
    BEGIN_WRAP
    cv::UMat ret = cv::UMat::ones(ndims, sz, type);
    *returnValue = new cv::UMat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_eye
[32/64bit] core_UMat_eye
%prm
p1,p2,p3,p4
p1 = int : int rows
p2 = int : int cols
p3 = int : int type
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_eye
元DLLエクスポート名: core_UMat_eye
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_eye(int rows, int cols, int type, cv::UMat** returnValue)
{
    BEGIN_WRAP
    const auto eye = cv::UMat::eye(rows, cols, type);
    *returnValue = new cv::UMat(eye);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_create1
[32/64bit] core_UMat_create1
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = int : int rows
p3 = int : int cols
p4 = int : int type
%inst
元関数名(C#): core_UMat_create1
元DLLエクスポート名: core_UMat_create1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_create1(cv::UMat* self, int rows, int cols, int type, cv::UMatUsageFlags usageFlags)
{
    BEGIN_WRAP
    self-&amp;gt;create(rows, cols, type, usageFlags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_create2
[32/64bit] core_UMat_create2
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = int : int ndims
p3 = var : [MarshalAs(UnmanagedType.LPArray)] int[] sizes
p4 = int : int type
%inst
元関数名(C#): core_UMat_create2
元DLLエクスポート名: core_UMat_create2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_create2(cv::UMat* self, int ndims, const int* sizes, int type, cv::UMatUsageFlags usageFlags)
{
    BEGIN_WRAP
    self-&amp;gt;create(ndims, sizes, type, usageFlags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_locateROI
[32/64bit] core_UMat_locateROI
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = var : out Size wholeSize
p3 = var : out Point ofs
%inst
元関数名(C#): core_UMat_locateROI
元DLLエクスポート名: core_UMat_locateROI
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_locateROI(cv::UMat* self, MyCvSize* wholeSize, MyCvPoint* ofs)
{
    BEGIN_WRAP
    cv::Size wholeSize2;
    cv::Point ofs2;
    self-&amp;gt;locateROI(wholeSize2, ofs2);
    *wholeSize = c(cv::Size(wholeSize2.width, wholeSize2.height));
    *ofs = c(cv::Point(ofs2.x, ofs2.y));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_adjustROI
[32/64bit] core_UMat_adjustROI
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr nativeObj
p2 = int : int dtop
p3 = int : int dbottom
p4 = int : int dleft
p5 = int : int dright
p6 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_adjustROI
元DLLエクスポート名: core_UMat_adjustROI
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_adjustROI(cv::UMat* self, int dtop, int dbottom, int dleft, int dright, cv::UMat** returnValue)
{
    BEGIN_WRAP
    const auto ret = self-&amp;gt;adjustROI(dtop, dbottom, dleft, dright);
    *returnValue = new cv::UMat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_subMat1
[32/64bit] core_UMat_subMat1
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr self
p2 = int : int rowStart
p3 = int : int rowEnd
p4 = int : int colStart
p5 = int : int colEnd
p6 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_subMat1
元DLLエクスポート名: core_UMat_subMat1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_subMat1(cv::UMat* self, int rowStart, int rowEnd, int colStart, int colEnd, cv::UMat** returnValue)
{
    BEGIN_WRAP
    const cv::Range rowRange(rowStart, rowEnd);
    const cv::Range colRange(colStart, colEnd);
    const auto ret = (*self)(rowRange, colRange);
    *returnValue = new cv::UMat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_subMat2
[32/64bit] core_UMat_subMat2
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = int : int nRanges
p3 = var : Range[] ranges
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_subMat2
元DLLエクスポート名: core_UMat_subMat2
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_subMat2(cv::UMat* self, int nRanges, MyCvSlice* ranges, cv::UMat** returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Range&amp;gt; rangesVec(nRanges);
    for (auto i = 0; i &amp;lt; nRanges; i++)
    {
        rangesVec[i] = (cpp(ranges[i]));
    }
    const auto ret = (*self)(&amp;rangesVec[0]);
    *returnValue = new cv::UMat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_isContinuous
[32/64bit] core_UMat_isContinuous
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
元関数名(C#): core_UMat_isContinuous
元DLLエクスポート名: core_UMat_isContinuous
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_isContinuous(cv::UMat* self, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;isContinuous() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_isSubmatrix
[32/64bit] core_UMat_isSubmatrix
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
元関数名(C#): core_UMat_isSubmatrix
元DLLエクスポート名: core_UMat_isSubmatrix
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_isSubmatrix(cv::UMat* self, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;isSubmatrix() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_elemSize
[32/64bit] core_UMat_elemSize
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_elemSize
元DLLエクスポート名: core_UMat_elemSize
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_elemSize(cv::UMat* self, size_t* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;elemSize();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_elemSize1
[32/64bit] core_UMat_elemSize1
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_elemSize1
元DLLエクスポート名: core_UMat_elemSize1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_elemSize1(cv::UMat* self, size_t* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;elemSize1();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_type
[32/64bit] core_UMat_type
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
元関数名(C#): core_UMat_type
元DLLエクスポート名: core_UMat_type
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_type(cv::UMat* self, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;type();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_depth
[32/64bit] core_UMat_depth
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
元関数名(C#): core_UMat_depth
元DLLエクスポート名: core_UMat_depth
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_depth(cv::UMat* self, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;depth();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_channels
[32/64bit] core_UMat_channels
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
元関数名(C#): core_UMat_channels
元DLLエクスポート名: core_UMat_channels
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_channels(cv::UMat* self, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;channels();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_step1
[32/64bit] core_UMat_step1
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int i
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_step1
元DLLエクスポート名: core_UMat_step1
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_step1(cv::UMat* self, int i, size_t* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;step1(i);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_empty
[32/64bit] core_UMat_empty
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
元関数名(C#): core_UMat_empty
元DLLエクスポート名: core_UMat_empty
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_empty(cv::UMat* self, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;empty() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_total
[32/64bit] core_UMat_total
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_total
元DLLエクスポート名: core_UMat_total
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_total(cv::UMat* self, size_t* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;total();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_checkVector
[32/64bit] core_UMat_checkVector
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr self
p2 = int : int elemChannels
p3 = int : int depth
p4 = int : int requireContinuous
p5 = var : out int returnValue
%inst
元関数名(C#): core_UMat_checkVector
元DLLエクスポート名: core_UMat_checkVector
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_checkVector(cv::UMat* self, int elemChannels, int depth, int requireContinuous, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;checkVector(elemChannels, depth, requireContinuous != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_flags
[32/64bit] cv::Umat::flags 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst



元関数名(C#): core_UMat_flags
元DLLエクスポート名: core_UMat_flags
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_flags(cv::UMat* self, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;flags;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_dims
[32/64bit] cv::Umat::dims 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst



元関数名(C#): core_UMat_dims
元DLLエクスポート名: core_UMat_dims
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_dims(cv::UMat* self, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;dims;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_rows
[32/64bit] cv::Umat::rows 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst



元関数名(C#): core_UMat_rows
元DLLエクスポート名: core_UMat_rows
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_rows(cv::UMat* self, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;rows;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_cols
[32/64bit] cv::Umat::cols 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst



元関数名(C#): core_UMat_cols
元DLLエクスポート名: core_UMat_cols
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_cols(cv::UMat* self, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;cols;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_size
[32/64bit] core_UMat_size
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out Size returnValue
%inst
元関数名(C#): core_UMat_size
元DLLエクスポート名: core_UMat_size
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_size(cv::UMat* self, MyCvSize* returnValue)
{
    BEGIN_WRAP
    *returnValue = c(self-&amp;gt;size());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_sizeAt
[32/64bit] cv::Umat::size 変数を取得します
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int i
p3 = var : out int returnValue
%inst



元関数名(C#): core_UMat_sizeAt
元DLLエクスポート名: core_UMat_sizeAt
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_sizeAt(cv::UMat* self, int i, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;size[i];
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_step
[32/64bit] core_UMat_step
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): core_UMat_step
元DLLエクスポート名: core_UMat_step
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_step1(cv::UMat* self, int i, size_t* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;step1(i);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
core_UMat_stepAt
[32/64bit] cv::Umat::step 変数を取得します
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = int : int i
p3 = var : out IntPtr returnValue
%inst



元関数名(C#): core_UMat_stepAt
元DLLエクスポート名: core_UMat_stepAt
参照元CSファイル: Internal\PInvoke\NativeMethods\core\NativeMethods_core_UMat.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) core_UMat_stepAt(cv::UMat* self, int i, size_t* returnValue)
{
    BEGIN_WRAP
    *returnValue = self-&amp;gt;step[i];
    END_WRAP
}

</pre>
}html
%group
NativeMethods_core_UMat

%index
dnn_readNetFromDarknet_NotWindows
[32/64bit] Darknetモデルファイルに格納されているネットワークモデルを読み込みます。
%prm
p1,p2,p3
p1 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string cfgFile
p2 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string? darknetModel
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): dnn_readNetFromDarknet_NotWindows
元DLLエクスポート名: dnn_readNetFromDarknet
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readNetFromDarknet(const char *cfgFile, const char *darknetModel, cv::dnn::Net **returnValue)
{
    BEGIN_WRAP
    const auto darknetModelStr = (darknetModel == nullptr) ? cv::String() : cv::String(darknetModel);
    const auto net = cv::dnn::readNetFromDarknet(cfgFile, darknetModelStr);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readNetFromDarknet_Windows
[32/64bit] Darknetモデルファイルに格納されているネットワークモデルを読み込みます。
%prm
p1,p2,p3
p1 = str : [MarshalAs(StringUnmanagedTypeWindows)] string cfgFile
p2 = str : [MarshalAs(StringUnmanagedTypeWindows)] string? darknetModel
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): dnn_readNetFromDarknet_Windows
元DLLエクスポート名: dnn_readNetFromDarknet
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readNetFromDarknet(const char *cfgFile, const char *darknetModel, cv::dnn::Net **returnValue)
{
    BEGIN_WRAP
    const auto darknetModelStr = (darknetModel == nullptr) ? cv::String() : cv::String(darknetModel);
    const auto net = cv::dnn::readNetFromDarknet(cfgFile, darknetModelStr);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readNetFromDarknet
[32/64bit] Darknetモデルファイルに格納されているネットワークモデルを読み込みます。
%prm
p1,p2,p3,p4,p5
p1 = var : byte* bufferCfg
p2 = sptr : IntPtr lenCfg
p3 = var : byte* bufferModel
p4 = sptr : IntPtr lenModel
p5 = var : out IntPtr returnValue
%inst
元関数名(C#): dnn_readNetFromDarknet
元DLLエクスポート名: dnn_readNetFromDarknet_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readNetFromDarknet_InputArray(const char* bufferCfg, size_t lenCfg, const char* bufferModel, size_t lenModel, cv::dnn::Net** returnValue)
{
    BEGIN_WRAP
    const auto net = cv::dnn::readNetFromDarknet(bufferCfg, lenCfg, bufferModel, lenModel);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readNetFromCaffe_NotWindows
[32/64bit] Caffe フレームワークのフォーマットで保存されたネットワークモデルを読み込みます。
%prm
p1,p2,p3
p1 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string prototxt
p2 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string? caffeModel
p3 = var : out IntPtr returnValue
%inst
例：samples/dnn/colorization.cpp.

元関数名(C#): dnn_readNetFromCaffe_NotWindows
元DLLエクスポート名: dnn_readNetFromCaffe
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readNetFromCaffe(const char *prototxt, const char *caffeModel, cv::dnn::Net **returnValue)
{
    BEGIN_WRAP
    const auto caffeModelStr = (caffeModel == nullptr) ? cv::String() : cv::String(caffeModel);
    const auto net = cv::dnn::readNetFromCaffe(prototxt, caffeModelStr);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readNetFromCaffe_Windows
[32/64bit] Caffe フレームワークのフォーマットで保存されたネットワークモデルを読み込みます。
%prm
p1,p2,p3
p1 = str : [MarshalAs(StringUnmanagedTypeWindows)] string prototxt
p2 = str : [MarshalAs(StringUnmanagedTypeWindows)] string? caffeModel
p3 = var : out IntPtr returnValue
%inst
例：samples/dnn/colorization.cpp.

元関数名(C#): dnn_readNetFromCaffe_Windows
元DLLエクスポート名: dnn_readNetFromCaffe
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readNetFromCaffe(const char *prototxt, const char *caffeModel, cv::dnn::Net **returnValue)
{
    BEGIN_WRAP
    const auto caffeModelStr = (caffeModel == nullptr) ? cv::String() : cv::String(caffeModel);
    const auto net = cv::dnn::readNetFromCaffe(prototxt, caffeModelStr);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readNetFromCaffe
[32/64bit] Caffeモデルに格納されたネットワークモデルをメモリ上に読み込みます。
%prm
p1,p2,p3,p4,p5
p1 = var : byte* bufferProto
p2 = sptr : IntPtr lenProto
p3 = var : byte* bufferModel
p4 = sptr : IntPtr lenModel
p5 = var : out IntPtr returnValue
%inst
この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．

元関数名(C#): dnn_readNetFromCaffe
元DLLエクスポート名: dnn_readNetFromCaffe_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readNetFromCaffe_InputArray(
    const char* bufferProto, size_t lenProto, const char* bufferModel, size_t lenModel, cv::dnn::Net** returnValue)
{
    BEGIN_WRAP
    const auto net = cv::dnn::readNetFromCaffe(
        bufferProto, lenProto,
        bufferModel, lenModel);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readNetFromTensorflow_NotWindows
[32/64bit] TensorFlow フレームワークのフォーマットで保存されたネットワークモデルを読み込みます。
%prm
p1,p2,p3
p1 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string model
p2 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string? config
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): dnn_readNetFromTensorflow_NotWindows
元DLLエクスポート名: dnn_readNetFromTensorflow
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readNetFromTensorflow(const char *model, const char *config, cv::dnn::Net **returnValue)
{
    BEGIN_WRAP
    const auto configStr = (config == nullptr) ? cv::String() : cv::String(config);
    const auto net = cv::dnn::readNetFromTensorflow(model, configStr);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readNetFromTensorflow_Windows
[32/64bit] TensorFlow フレームワークのフォーマットで保存されたネットワークモデルを読み込みます。
%prm
p1,p2,p3
p1 = str : [MarshalAs(StringUnmanagedTypeWindows)] string model
p2 = str : [MarshalAs(StringUnmanagedTypeWindows)] string? config
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): dnn_readNetFromTensorflow_Windows
元DLLエクスポート名: dnn_readNetFromTensorflow
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readNetFromTensorflow(const char *model, const char *config, cv::dnn::Net **returnValue)
{
    BEGIN_WRAP
    const auto configStr = (config == nullptr) ? cv::String() : cv::String(config);
    const auto net = cv::dnn::readNetFromTensorflow(model, configStr);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readNetFromTensorflow
[32/64bit] TensorFlow フレームワークのフォーマットで保存されたネットワークモデルを読み込みます。
%prm
p1,p2,p3,p4,p5
p1 = var : byte* bufferModel
p2 = sptr : IntPtr modelDataLength
p3 = var : byte* bufferConfig
p4 = sptr : IntPtr configDataLength
p5 = var : out IntPtr returnValue
%inst
この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．

元関数名(C#): dnn_readNetFromTensorflow
元DLLエクスポート名: dnn_readNetFromTensorflow_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readNetFromTensorflow_InputArray(const char *model,size_t lenModel, const char *config, size_t lenConfig, cv::dnn::Net **returnValue)
{
    BEGIN_WRAP
    const auto net = cv::dnn::readNetFromTensorflow(model, lenModel, config, lenConfig);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readNetFromTorch_NotWindows
[32/64bit] Torch7フレームワークのフォーマットで保存されたネットワークモデルを読み込みます。
%prm
p1,p2,p3
p1 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string model
p2 = int : int isBinary
p3 = var : out IntPtr returnValue
%inst
注）バイナリモードでは、C言語のロングタイプが多用され、システムによってビット長が異なるため、Torchシリアライザのアスキーモードの方が好ましいです。ローディングファイルには、ネットワークをインポートしたnn.Moduleオブジェクトをシリアライズしたものが含まれていなければなりません。サポートされているレイヤ(Torch nn.Moduleクラスから派生したオブジェクトインスタンス)のリスト:nn.Sequential

nn.パラレル

nn.コンカト

nn.リニア

nn.SpatialConvolution（空間コンボリューション

nn.SpatialMaxPooling, nn.SpatialAveragePooling

nn.ReLU, nn.TanH, nn.Sigmoid

nn.リシェープ

nn.SoftMax, nn.LogSoftMaxまた、cunn、cudnn、fbcunnのこれらのクラスの同等のものが正常にインポートされる場合もあります。

元関数名(C#): dnn_readNetFromTorch_NotWindows
元DLLエクスポート名: dnn_readNetFromTorch
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readNetFromTorch(const char *model, const int isBinary, cv::dnn::Net **returnValue)
{
    BEGIN_WRAP
    const auto net = cv::dnn::readNetFromTorch(model, isBinary != 0);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readNetFromTorch_Windows
[32/64bit] Torch7フレームワークのフォーマットで保存されたネットワークモデルを読み込みます。
%prm
p1,p2,p3
p1 = str : [MarshalAs(StringUnmanagedTypeWindows)] string model
p2 = int : int isBinary
p3 = var : out IntPtr returnValue
%inst
注）バイナリモードでは、C言語のロングタイプが多用され、システムによってビット長が異なるため、Torchシリアライザのアスキーモードの方が好ましいです。ローディングファイルには、ネットワークをインポートしたnn.Moduleオブジェクトをシリアライズしたものが含まれていなければなりません。サポートされているレイヤ(Torch nn.Moduleクラスから派生したオブジェクトインスタンス)のリスト:nn.Sequential

nn.パラレル

nn.コンカト

nn.リニア

nn.SpatialConvolution（空間コンボリューション

nn.SpatialMaxPooling, nn.SpatialAveragePooling

nn.ReLU, nn.TanH, nn.Sigmoid

nn.リシェープ

nn.SoftMax, nn.LogSoftMaxまた、cunn、cudnn、fbcunnのこれらのクラスの同等のものが正常にインポートされる場合もあります。

元関数名(C#): dnn_readNetFromTorch_Windows
元DLLエクスポート名: dnn_readNetFromTorch
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readNetFromTorch(const char *model, const int isBinary, cv::dnn::Net **returnValue)
{
    BEGIN_WRAP
    const auto net = cv::dnn::readNetFromTorch(model, isBinary != 0);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readNet_NotWindows
[32/64bit] Darknetモデルファイルに格納されているネットワークモデルを読み込みます。
%prm
p1,p2,p3,p4
p1 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string model
p2 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string config
p3 = str : [MarshalAs(UnmanagedType.LPStr)] string framework
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): dnn_readNet_NotWindows
元DLLエクスポート名: dnn_readNet
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readNetFromDarknet(const char *cfgFile, const char *darknetModel, cv::dnn::Net **returnValue)
{
    BEGIN_WRAP
    const auto darknetModelStr = (darknetModel == nullptr) ? cv::String() : cv::String(darknetModel);
    const auto net = cv::dnn::readNetFromDarknet(cfgFile, darknetModelStr);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readNet_Windows
[32/64bit] Darknetモデルファイルに格納されているネットワークモデルを読み込みます。
%prm
p1,p2,p3,p4
p1 = str : [MarshalAs(StringUnmanagedTypeWindows)] string model
p2 = str : [MarshalAs(StringUnmanagedTypeWindows)] string config
p3 = str : [MarshalAs(UnmanagedType.LPStr)] string framework
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): dnn_readNet_Windows
元DLLエクスポート名: dnn_readNet
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readNetFromDarknet(const char *cfgFile, const char *darknetModel, cv::dnn::Net **returnValue)
{
    BEGIN_WRAP
    const auto darknetModelStr = (darknetModel == nullptr) ? cv::String() : cv::String(darknetModel);
    const auto net = cv::dnn::readNetFromDarknet(cfgFile, darknetModelStr);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readTorchBlob_NotWindows
[32/64bit] Torch7 フレームワークの torch.Tensor オブジェクトとしてシリアル化された blob を読み込みます。
%prm
p1,p2,p3
p1 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string fileName
p2 = int : int isBinary
p3 = var : out IntPtr returnValue
%inst
警告この関数には readNetFromTorch() と同じ制限があります。

元関数名(C#): dnn_readTorchBlob_NotWindows
元DLLエクスポート名: dnn_readTorchBlob
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readTorchBlob(const char *filename, const int isBinary, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto blob = cv::dnn::readTorchBlob(filename, isBinary != 0);
    *returnValue = new cv::Mat(blob);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readTorchBlob_Windows
[32/64bit] Torch7 フレームワークの torch.Tensor オブジェクトとしてシリアル化された blob を読み込みます。
%prm
p1,p2,p3
p1 = str : [MarshalAs(StringUnmanagedTypeWindows)] string fileName
p2 = int : int isBinary
p3 = var : out IntPtr returnValue
%inst
警告この関数には readNetFromTorch() と同じ制限があります。

元関数名(C#): dnn_readTorchBlob_Windows
元DLLエクスポート名: dnn_readTorchBlob
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readTorchBlob(const char *filename, const int isBinary, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto blob = cv::dnn::readTorchBlob(filename, isBinary != 0);
    *returnValue = new cv::Mat(blob);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readNetFromModelOptimizer_NotWindows
[32/64bit] インテルの Model Optimizer の中間表現からネットワークを読み込みます。
%prm
p1,p2,p3
p1 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string xml
p2 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string bin
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): dnn_readNetFromModelOptimizer_NotWindows
元DLLエクスポート名: dnn_readNetFromModelOptimizer
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readNetFromModelOptimizer(const char *xml, const char *bin, cv::dnn::Net **returnValue)
{
    BEGIN_WRAP
    const auto net = cv::dnn::readNetFromModelOptimizer(xml, bin);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readNetFromModelOptimizer_Windows
[32/64bit] インテルの Model Optimizer の中間表現からネットワークを読み込みます。
%prm
p1,p2,p3
p1 = str : [MarshalAs(StringUnmanagedTypeWindows)] string xml
p2 = str : [MarshalAs(StringUnmanagedTypeWindows)] string bin
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): dnn_readNetFromModelOptimizer_Windows
元DLLエクスポート名: dnn_readNetFromModelOptimizer
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readNetFromModelOptimizer(const char *xml, const char *bin, cv::dnn::Net **returnValue)
{
    BEGIN_WRAP
    const auto net = cv::dnn::readNetFromModelOptimizer(xml, bin);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readNetFromONNX_NotWindows
[32/64bit] ネットワークモデルONNXを読み込みます。
%prm
p1,p2
p1 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string onnxFile
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): dnn_readNetFromONNX_NotWindows
元DLLエクスポート名: dnn_readNetFromONNX
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readNetFromONNX(const char *onnxFile, cv::dnn::Net **returnValue)
{
    BEGIN_WRAP
    const auto net = cv::dnn::readNetFromONNX(onnxFile);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readNetFromONNX_Windows
[32/64bit] ネットワークモデルONNXを読み込みます。
%prm
p1,p2
p1 = str : [MarshalAs(StringUnmanagedTypeWindows)] string onnxFile
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): dnn_readNetFromONNX_Windows
元DLLエクスポート名: dnn_readNetFromONNX
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readNetFromONNX(const char *onnxFile, cv::dnn::Net **returnValue)
{
    BEGIN_WRAP
    const auto net = cv::dnn::readNetFromONNX(onnxFile);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readNetFromONNX
[32/64bit] ONNXのインメモリバッファからネットワークモデルを読み込みます。
%prm
p1,p2,p3
p1 = var : byte* buffer
p2 = sptr : IntPtr sizeBuffer
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): dnn_readNetFromONNX
元DLLエクスポート名: dnn_readNetFromONNX_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readNetFromONNX_InputArray(const char* buffer, size_t sizeBuffer, cv::dnn::Net** returnValue)
{
    BEGIN_WRAP
    const auto net = cv::dnn::readNetFromONNX(buffer, sizeBuffer);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readTensorFromONNX_NotWindows
[32/64bit] .pbファイルからblobを作成します。
%prm
p1,p2
p1 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string path
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): dnn_readTensorFromONNX_NotWindows
元DLLエクスポート名: dnn_readTensorFromONNX
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readTensorFromONNX(const char *path, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto mat = cv::dnn::readTensorFromONNX(path);
    *returnValue = new cv::Mat(mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_readTensorFromONNX_Windows
[32/64bit] .pbファイルからblobを作成します。
%prm
p1,p2
p1 = str : [MarshalAs(StringUnmanagedTypeWindows)] string path
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): dnn_readTensorFromONNX_Windows
元DLLエクスポート名: dnn_readTensorFromONNX
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_readTensorFromONNX(const char *path, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto mat = cv::dnn::readTensorFromONNX(path);
    *returnValue = new cv::Mat(mat);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_blobFromImage
[32bit] 画像から4次元のblobを作成します。オプションとして，画像のリサイズと中央からの切り取り，平均値の差し引き，scalefactorによる値のスケーリング，青と赤のチャンネルの入れ替えを行います．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr image
p2 = double : double scaleFactor
p3 = ARGS_SIZE : Size size
p4 = ARGS_SCALAR : Scalar mean
p5 = int : int swapRB
p6 = int : int crop
p7 = var : out IntPtr returnValue
%inst
crop が真の場合，入力画像はリサイズされ，リサイズ後の片側が対応する次元のサイズと等しくなり，もう片側が同等以上のサイズになります．そして，中央からのクロップが行われます．例： samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, samples/dnn/openpose.cpp, samples/dnn/segmentation.cpp.

元関数名(C#): dnn_blobFromImage
元DLLエクスポート名: dnn_blobFromImage
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_blobFromImage(
    cv::Mat *image, const double scalefactor, const MyCvSize size, const MyCvScalar mean, const int swapRB, const int crop, 
    cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto blob = cv::dnn::blobFromImage(*image, scalefactor, cpp(size), cpp(mean), swapRB != 0, crop != 0);
    *returnValue = new cv::Mat(blob);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_blobFromImage
[64bit] 画像から4次元のblobを作成します。オプションとして，画像のリサイズと中央からの切り取り，平均値の差し引き，scalefactorによる値のスケーリング，青と赤のチャンネルの入れ替えを行います．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr image
p2 = double : double scaleFactor
p3 = ARGS_SIZE : Size size
p4 = var : Scalar mean
p5 = int : int swapRB
p6 = int : int crop
p7 = var : out IntPtr returnValue
%inst
crop が真の場合，入力画像はリサイズされ，リサイズ後の片側が対応する次元のサイズと等しくなり，もう片側が同等以上のサイズになります．そして，中央からのクロップが行われます．例： samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, samples/dnn/openpose.cpp, samples/dnn/segmentation.cpp.

元関数名(C#): dnn_blobFromImage
元DLLエクスポート名: dnn_blobFromImage
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_blobFromImage(
    cv::Mat *image, const double scalefactor, const MyCvSize size, const MyCvScalar mean, const int swapRB, const int crop, 
    cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto blob = cv::dnn::blobFromImage(*image, scalefactor, cpp(size), cpp(mean), swapRB != 0, crop != 0);
    *returnValue = new cv::Mat(blob);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_blobFromImages
[32bit] 一連の画像から 4 次元の blob を作成します。オプションで，画像のリサイズや中央からの切り出し，平均値の減算，scalefactor による値のスケーリング，青と赤のチャンネルの入れ替えなどを行います．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr[] images
p2 = int : int imagesLength
p3 = double : double scaleFactor
p4 = ARGS_SIZE : Size size
p5 = ARGS_SCALAR : Scalar mean
p6 = int : int swapRB
p7 = int : int crop
p8 = var : out IntPtr returnValue
%inst
crop が true の場合，入力画像はリサイズされ，リサイズ後の片側は対応する次元のサイズと等しくなり，もう片側は同等かそれ以上になります．そして，中央からのクロップを行います．crop が false の場合、アスペクト比を維持したままトリミングを行わない直接のリサイズが行われます。

元関数名(C#): dnn_blobFromImages
元DLLエクスポート名: dnn_blobFromImages
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_blobFromImages(
    const cv::Mat **images, const int imagesLength, const double scalefactor, const MyCvSize size, const MyCvScalar mean, const int swapRB, const int crop, 
    cv::Mat **returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; imagesVec;
    toVec(images, imagesLength, imagesVec);

    const auto blob = cv::dnn::blobFromImages(imagesVec, scalefactor, cpp(size), cpp(mean), swapRB != 0, crop != 0);
    *returnValue = new cv::Mat(blob);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_blobFromImages
[64bit] 一連の画像から 4 次元の blob を作成します。オプションで，画像のリサイズや中央からの切り出し，平均値の減算，scalefactor による値のスケーリング，青と赤のチャンネルの入れ替えなどを行います．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr[] images
p2 = int : int imagesLength
p3 = double : double scaleFactor
p4 = ARGS_SIZE : Size size
p5 = var : Scalar mean
p6 = int : int swapRB
p7 = int : int crop
p8 = var : out IntPtr returnValue
%inst
crop が true の場合，入力画像はリサイズされ，リサイズ後の片側は対応する次元のサイズと等しくなり，もう片側は同等かそれ以上になります．そして，中央からのクロップを行います．crop が false の場合、アスペクト比を維持したままトリミングを行わない直接のリサイズが行われます。

元関数名(C#): dnn_blobFromImages
元DLLエクスポート名: dnn_blobFromImages
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_blobFromImages(
    const cv::Mat **images, const int imagesLength, const double scalefactor, const MyCvSize size, const MyCvScalar mean, const int swapRB, const int crop, 
    cv::Mat **returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; imagesVec;
    toVec(images, imagesLength, imagesVec);

    const auto blob = cv::dnn::blobFromImages(imagesVec, scalefactor, cpp(size), cpp(mean), swapRB != 0, crop != 0);
    *returnValue = new cv::Mat(blob);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_shrinkCaffeModel_NotWindows
[32/64bit] Caffe ネットワークのすべての重みを半精度浮動小数点に変換します。
%prm
p1,p2,p3,p4
p1 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string src
p2 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string dst
p3 = var : string[] layersTypes
p4 = int : int layersTypesSize
%inst
NoteShrinked モデルにはオリジンの float32 重みがないため、オリジンの Caffe フレームワークでは使用できません。しかし、データの構造はNVidiaのCaffeフォーク（https://github.com/NVIDIA/caffe）から取られています。そのため、結果のモデルはそこで使用することができます。

元関数名(C#): dnn_shrinkCaffeModel_NotWindows
元DLLエクスポート名: dnn_shrinkCaffeModel
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_shrinkCaffeModel(
    const char *src, const char *dst,
    const char **layersTypes, int layersTypesSize)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::String&amp;gt; layersTypesVec(layersTypesSize);
    for (int i = 0; i &amp;lt; layersTypesSize; i++) {
        layersTypesVec[i].assign(layersTypes[i]);
    }
    cv::dnn::shrinkCaffeModel(src, dst, layersTypesVec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_shrinkCaffeModel_Windows
[32/64bit] Caffe ネットワークのすべての重みを半精度浮動小数点に変換します。
%prm
p1,p2,p3,p4
p1 = str : [MarshalAs(StringUnmanagedTypeWindows)] string src
p2 = str : [MarshalAs(StringUnmanagedTypeWindows)] string dst
p3 = var : string[] layersTypes
p4 = int : int layersTypesSize
%inst
NoteShrinked モデルにはオリジンの float32 重みがないため、オリジンの Caffe フレームワークでは使用できません。しかし、データの構造はNVidiaのCaffeフォーク（https://github.com/NVIDIA/caffe）から取られています。そのため、結果のモデルはそこで使用することができます。

元関数名(C#): dnn_shrinkCaffeModel_Windows
元DLLエクスポート名: dnn_shrinkCaffeModel
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_shrinkCaffeModel(
    const char *src, const char *dst,
    const char **layersTypes, int layersTypesSize)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::String&amp;gt; layersTypesVec(layersTypesSize);
    for (int i = 0; i &amp;lt; layersTypesSize; i++) {
        layersTypesVec[i].assign(layersTypes[i]);
    }
    cv::dnn::shrinkCaffeModel(src, dst, layersTypesVec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_writeTextGraph_NotWindows
[32/64bit] プロトコルバッファ形式で保存されたバイナリネットワークのテキスト表現を作成します。
%prm
p1,p2
p1 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string model
p2 = str : [MarshalAs(StringUnmanagedTypeNotWindows)] string output
%inst
注意 出力ファイルのサイズを小さくするため、学習済みの重みは含まれません。

元関数名(C#): dnn_writeTextGraph_NotWindows
元DLLエクスポート名: dnn_writeTextGraph
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_writeTextGraph(const char *model, const char *output)
{
    BEGIN_WRAP
    cv::dnn::writeTextGraph(model, output);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_writeTextGraph_Windows
[32/64bit] プロトコルバッファ形式で保存されたバイナリネットワークのテキスト表現を作成します。
%prm
p1,p2
p1 = str : [MarshalAs(StringUnmanagedTypeWindows)] string model
p2 = str : [MarshalAs(StringUnmanagedTypeWindows)] string output
%inst
注意 出力ファイルのサイズを小さくするため、学習済みの重みは含まれません。

元関数名(C#): dnn_writeTextGraph_Windows
元DLLエクスポート名: dnn_writeTextGraph
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_writeTextGraph(const char *model, const char *output)
{
    BEGIN_WRAP
    cv::dnn::writeTextGraph(model, output);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_NMSBoxes_Rect
[32/64bit] ボックスとそれに対応するスコアが与えられると、非最大級の抑制を行います。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr bboxes
p2 = sptr : IntPtr scores
p3 = float : float score_threshold
p4 = float : float nms_threshold
p5 = sptr : IntPtr indices
p6 = float : float eta
p7 = int : int top_k
%inst
例：samples/dnn/object_detection.cpp.

元関数名(C#): dnn_NMSBoxes_Rect
元DLLエクスポート名: dnn_NMSBoxes_Rect
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_NMSBoxes_Rect(std::vector&amp;lt;cv::Rect&amp;gt; *bboxes, std::vector&amp;lt;float&amp;gt; *scores,
    const float score_threshold, const float nms_threshold,
    std::vector&amp;lt;int&amp;gt; *indices, const float eta, const int top_k)
{
    BEGIN_WRAP
    cv::dnn::NMSBoxes(*bboxes, *scores, score_threshold, nms_threshold, *indices, eta, top_k);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_NMSBoxes_Rect2d
[32/64bit] ボックスとそれに対応するスコアが与えられると、非最大級の抑制を行います。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr bboxes
p2 = sptr : IntPtr scores
p3 = float : float score_threshold
p4 = float : float nms_threshold
p5 = sptr : IntPtr indices
p6 = float : float eta
p7 = int : int top_k
%inst
例：samples/dnn/object_detection.cpp.

元関数名(C#): dnn_NMSBoxes_Rect2d
元DLLエクスポート名: dnn_NMSBoxes_Rect2d
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_NMSBoxes_Rect2d(std::vector&amp;lt;cv::Rect2d&amp;gt; *bboxes, std::vector&amp;lt;float&amp;gt; *scores,
    const float score_threshold, const float nms_threshold,
    std::vector&amp;lt;int&amp;gt; *indices, const float eta, const int top_k)
{
    BEGIN_WRAP
    cv::dnn::NMSBoxes(*bboxes, *scores, score_threshold, nms_threshold, *indices, eta, top_k);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_NMSBoxes_RotatedRect
[32/64bit] ボックスとそれに対応するスコアが与えられると、非最大級の抑制を行います。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr bboxes
p2 = sptr : IntPtr scores
p3 = float : float score_threshold
p4 = float : float nms_threshold
p5 = sptr : IntPtr indices
p6 = float : float eta
p7 = int : int top_k
%inst
例：samples/dnn/object_detection.cpp.

元関数名(C#): dnn_NMSBoxes_RotatedRect
元DLLエクスポート名: dnn_NMSBoxes_RotatedRect
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_NMSBoxes_RotatedRect(std::vector&amp;lt;cv::RotatedRect&amp;gt; *bboxes, std::vector&amp;lt;float&amp;gt; *scores,
    const float score_threshold, const float nms_threshold,
    std::vector&amp;lt;int&amp;gt; *indices, const float eta, const int top_k)
{
    BEGIN_WRAP
    cv::dnn::NMSBoxes(*bboxes, *scores, score_threshold, nms_threshold, *indices, eta, top_k);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_resetMyriadDevice
[32/64bit] Myriadデバイス（OpenCVにバインドされている）を解放する．
%prm

%inst
1つのMyriadデバイスを，推論エンジンのMyriadプラグインを利用する複数のプロセスで共有することはできません．

元関数名(C#): dnn_resetMyriadDevice
元DLLエクスポート名: dnn_resetMyriadDevice
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_resetMyriadDevice()
{
    BEGIN_WRAP
    cv::dnn::resetMyriadDevice();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn

%index
dnn_Net_new
[32/64bit] cv::dnn::Net のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst
このクラスは，包括的な人工ニューラルネットワークの作成と操作を可能にします．

ニューラルネットワークは，有向非循環グラフ（DAG）として表現され，頂点はレイヤのインスタンスであり，辺はレイヤの入力と出力の間の関係を指定する．

各ネットワーク層は、そのネットワーク内で一意の整数IDと一意の文字列名を持っています。LayerIdには、レイヤ名とレイヤIDのいずれかが格納されます。

このクラスは、そのインスタンスの参照カウントをサポートしています。

例：samples/dnn/colorization.cpp、samples/dnn/openpose.cpp。


元関数名(C#): dnn_Net_new
元DLLエクスポート名: dnn_Net_new
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_new(cv::dnn::Net **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::dnn::Net;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_delete
[32/64bit] cv::dnn::Net のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr net
%inst
このクラスは，包括的な人工ニューラルネットワークの作成と操作を可能にします．

ニューラルネットワークは，有向非循環グラフ（DAG）として表現され，頂点はレイヤのインスタンスであり，辺はレイヤの入力と出力の間の関係を指定する．

各ネットワーク層は、そのネットワーク内で一意の整数IDと一意の文字列名を持っています。LayerIdには、レイヤ名とレイヤIDのいずれかが格納されます。

このクラスは、そのインスタンスの参照カウントをサポートしています。

例：samples/dnn/colorization.cpp、samples/dnn/openpose.cpp。


元関数名(C#): dnn_Net_delete
元DLLエクスポート名: dnn_Net_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_delete(cv::dnn::Net* net)
{
    BEGIN_WRAP
    delete net;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_readFromModelOptimizer
[32/64bit] インテルのモデル・オプティマイザーの中間表現 (IR) からネットワークを作成します。
%prm
p1,p2,p3
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string xml
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string bin
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): dnn_Net_readFromModelOptimizer
元DLLエクスポート名: dnn_Net_readFromModelOptimizer
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_readFromModelOptimizer(const char *xml, const char *bin, cv::dnn::Net **returnValue)
{
    BEGIN_WRAP
    const auto net = cv::dnn::Net::readFromModelOptimizer(xml, bin);
    *returnValue = new cv::dnn::Net(net);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_empty
[32/64bit] ネットワークにレイヤーが存在しない場合は true を返します。
%prm
p1,p2
p1 = sptr : IntPtr net
p2 = var : out int returnValue
%inst
元関数名(C#): dnn_Net_empty
元DLLエクスポート名: dnn_Net_empty
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_empty(cv::dnn::Net* net, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = net-&amp;gt;empty() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_dump
[32/64bit] ネットを文字列にダンプします。
%prm
p1,p2
p1 = sptr : IntPtr net
p2 = sptr : IntPtr outString
%inst
元関数名(C#): dnn_Net_dump
元DLLエクスポート名: dnn_Net_dump
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_dump(cv::dnn::Net* net, std::string *outString)
{
    BEGIN_WRAP
    outString-&amp;gt;assign(net-&amp;gt;dump());
    END_WRAP    
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_dumpToFile
[32/64bit] netの構造、ハイパーパラメータ、backend、target、fusionをdotファイルにダンプします。
%prm
p1,p2
p1 = sptr : IntPtr net
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string path
%inst
alsodump()参照

元関数名(C#): dnn_Net_dumpToFile
元DLLエクスポート名: dnn_Net_dumpToFile
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_dumpToFile(cv::dnn::Net* net, const char *path)
{
    BEGIN_WRAP
    net-&amp;gt;dumpToFile(path);
    END_WRAP    
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_getLayerId
[32/64bit] レイヤーの文字列名を整数の識別子に変換します。
%prm
p1,p2,p3
p1 = sptr : IntPtr net
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string layer
p3 = var : out int returnValue
%inst
元関数名(C#): dnn_Net_getLayerId
元DLLエクスポート名: dnn_Net_getLayerId
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_getLayerId(cv::dnn::Net* net, const char *layer, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = net-&amp;gt;getLayerId(layer);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_getLayerNames
[32/64bit] dnn_Net_getLayerNames
%prm
p1,p2
p1 = sptr : IntPtr net
p2 = sptr : IntPtr outVec
%inst
元関数名(C#): dnn_Net_getLayerNames
元DLLエクスポート名: dnn_Net_getLayerNames
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_getLayerNames(cv::dnn::Net* net, std::vector&amp;lt;cv::String&amp;gt; *outVec)
{
    BEGIN_WRAP
    const auto result = net-&amp;gt;getLayerNames();
    outVec-&amp;gt;assign(result.begin(), result.end());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_connect1
[32/64bit] 第1層の出力を第2層の入力に接続します。
%prm
p1,p2,p3
p1 = sptr : IntPtr net
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string outPin
p3 = str : [MarshalAs(UnmanagedType.LPStr)] string inpPin
%inst
記述子は，次のようなテンプレートを持っています。 <layer_name>[.input_number]:テンプレートの最初の部分 layer_name は，追加される層の文字列名です。この部分が空の場合は、ネットワーク入力の疑似レイヤーが使用されます。

テンプレートの2番目のオプション部分 input_number は，入力されたレイヤの番号で，ラベル1の場合もあります。この部分が省略された場合は，最初の層の入力が使用されます。

See alsetNetInputs(), Layer::inputNameToIndex(), Layer::outputNameToIndex()

元関数名(C#): dnn_Net_connect1
元DLLエクスポート名: dnn_Net_connect1
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_connect1(cv::dnn::Net* net, const char *outPin, const char *inpPin)
{
    BEGIN_WRAP
    net-&amp;gt;connect(outPin, inpPin);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_connect2
[32/64bit] 第1層の#outNum出力と第2層の#inNum入力を接続する。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr net
p2 = int : int outLayerId
p3 = int : int outNum
p4 = int : int inpLayerId
p5 = int : int inpNum
%inst
元関数名(C#): dnn_Net_connect2
元DLLエクスポート名: dnn_Net_connect2
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_connect2(cv::dnn::Net* net, int outLayerId, int outNum, int inpLayerId, int inpNum)
{
    BEGIN_WRAP
    net-&amp;gt;connect(outLayerId, outNum, inpLayerId, inpNum);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_setInputsNames
[32/64bit] ネットワーク入力疑似層の出力名を設定する。
%prm
p1,p2,p3
p1 = sptr : IntPtr net
p2 = var : string[] inputBlobNames
p3 = int : int inputBlobNamesLength
%inst
各ネットは、id=0の特別なネットワーク入力疑似層を常に持っています。この層は、ユーザーblobを保存するだけで、いかなる計算も行いません。実際、この層は、ユーザーデータをネットワークに渡す唯一の方法を提供します。他の層と同様に、この層はその出力にラベルを付けることができ、この関数はこれを簡単に行う方法を提供します。

元関数名(C#): dnn_Net_setInputsNames
元DLLエクスポート名: dnn_Net_setInputsNames
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_setInputsNames(cv::dnn::Net* net, const char **inputBlobNames, int inputBlobNamesLength)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::String&amp;gt; inputBlobNamesVec(inputBlobNamesLength);
    for (auto i = 0; i &amp;lt; inputBlobNamesLength; i++)
    {
        inputBlobNamesVec[i] = inputBlobNames[i];
    }
    net-&amp;gt;setInputsNames(inputBlobNamesVec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_forward1
[32/64bit] outputName という名前のレイヤーの出力を計算するためにフォワードパスを実行します。
%prm
p1,p2,p3
p1 = sptr : IntPtr net
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string? outputName
p3 = var : out IntPtr returnValue
%inst
sample/dn/colorization.cppやsamples/dn/openpose.cppのように、デフォルトではネットワーク全体のフォワードパスを実行します。

元関数名(C#): dnn_Net_forward1
元DLLエクスポート名: dnn_Net_forward1
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_forward1(cv::dnn::Net* net, const char *outputName, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto outputNameStr = (outputName == nullptr) ? cv::String() : cv::String(outputName);
    const auto ret = net-&amp;gt;forward(outputNameStr);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_forward2
[32/64bit] outputName という名前のレイヤーの出力を計算するためにフォワードパスを実行します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr net
p2 = sptr : IntPtr[] outputBlobs
p3 = int : int outputBlobsLength
p4 = str : [MarshalAs(UnmanagedType.LPStr)] string? outputName
%inst
outputNameが空の場合は、ネットワーク全体のフォワードパスを実行します。

元関数名(C#): dnn_Net_forward2
元DLLエクスポート名: dnn_Net_forward2
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_forward2(
    cv::dnn::Net* net, cv::Mat **outputBlobs, int outputBlobsLength, const char *outputName)
{
    BEGIN_WRAP
    const auto outputNameStr = (outputName == nullptr) ? cv::String() : cv::String(outputName);
    std::vector&amp;lt;cv::Mat&amp;gt; outputBlobsVec;
    toVec(outputBlobs, outputBlobsLength, outputBlobsVec);

    net-&amp;gt;forward(outputBlobsVec, outputNameStr);

    for (auto i = 0; i &amp;lt; outputBlobsLength; i++)
    {
        *outputBlobs[i] = outputBlobsVec[i];
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_forward3
[32/64bit] outputName という名前のレイヤーの出力を計算するためにフォワードパスを実行します。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr net
p2 = sptr : IntPtr[] outputBlobs
p3 = int : int outputBlobsLength
p4 = var : string[] outBlobNames
p5 = int : int outBlobNamesLength
%inst
outputNameが空の場合は、ネットワーク全体のフォワードパスを実行します。

元関数名(C#): dnn_Net_forward3
元DLLエクスポート名: dnn_Net_forward3
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_forward3(
    cv::dnn::Net* net, cv::Mat **outputBlobs, int outputBlobsLength, const char **outBlobNames, int outBlobNamesLength)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; outputBlobsVec;
    toVec(outputBlobs, outputBlobsLength, outputBlobsVec);

    std::vector&amp;lt;cv::String&amp;gt; outBlobNamesVec(outBlobNamesLength);
    for (auto i = 0; i &amp;lt; outBlobNamesLength; i++)
    {
        outBlobNamesVec[i] = outBlobNames[i];
    }

    net-&amp;gt;forward(outputBlobsVec, outBlobNamesVec);

    for (auto i = 0; i &amp;lt; outputBlobsLength; i++)
    {
        *outputBlobs[i] = outputBlobsVec[i];
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_setHalideScheduler
[32/64bit] Halideレイヤーをコンパイルします。
%prm
p1,p2
p1 = sptr : IntPtr net
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string scheduler
%inst
alsosetPreferableBackendScheduleを参照して、Halideバックエンドをサポートするレイヤーを設定します。その後、特定のターゲットのためにコンパイルします。スケジューリングファイルに記述されていないレイヤーや、手動でのスケジューリングが全く行われていない場合は、自動スケジューリングが適用されます。

元関数名(C#): dnn_Net_setHalideScheduler
元DLLエクスポート名: dnn_Net_setHalideScheduler
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_setHalideScheduler(cv::dnn::Net* net, const char *scheduler)
{
    BEGIN_WRAP
    net-&amp;gt;setHalideScheduler(scheduler);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_setPreferableBackend
[32/64bit] ネットワークに、サポートされている特定の計算バックエンドを使用するように依頼します。
%prm
p1,p2
p1 = sptr : IntPtr net
p2 = int : int backendId
%inst
Backend も参照してください。OpenCV が Intel の Inference Engine ライブラリと一緒にコンパイルされている場合，DNN_BACKEND_DEFAULT は DNN_BACKEND_INFERENCE_ENGINE を意味します．それ以外の場合は，DNN_BACKEND_OPENCVになります．

元関数名(C#): dnn_Net_setPreferableBackend
元DLLエクスポート名: dnn_Net_setPreferableBackend
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_setPreferableBackend(cv::dnn::Net* net, int backendId)
{
    BEGIN_WRAP
    net-&amp;gt;setPreferableBackend(backendId);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_setPreferableTarget
[32/64bit] ネットワークに特定のターゲットデバイスでの計算を依頼する。
%prm
p1,p2
p1 = sptr : IntPtr net
p2 = int : int targetId
%inst
参照：サポートされる組み合わせのTargetList backend / target:DNN_BACKEND_OPENCV DNN_BACKEND_INFERENCE_ENGINE DNN_BACKEND_HALIDE DNN_BACKEND_CUDA



DNN_ターゲット_CPU + + +



DNN_Target_opencl + +



Dnn_Target_opencl_fp16 + + Dnn_Target_opencl_fp16 + +



Dnn_Target_Myriad + +



DNN_Target_FPGA + +



Dnn_Target_cuda +



Dnn_Target_Cuda_fp16 + + Dnn_Target_Cuda_fp16 +



DNN_TARGET_HDDL +例：samples/dnn/colorization.cpp.

元関数名(C#): dnn_Net_setPreferableTarget
元DLLエクスポート名: dnn_Net_setPreferableTarget
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_setPreferableTarget(cv::dnn::Net* net, int targetId)
{
    BEGIN_WRAP
    net-&amp;gt;setPreferableTarget(targetId);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_setInput
[32/64bit] ネットワークの新しい入力値を設定します。
%prm
p1,p2,p3
p1 = sptr : IntPtr net
p2 = sptr : IntPtr blob
p3 = str : [MarshalAs(UnmanagedType.LPStr)] string name
%inst
scale や mean が指定された場合，最終的な入力 blob は次のように計算されます：?[input(n,c,h,w) = scalefactor ?[times (blob(n,c,h,w) - mean_c) ?]例：samples/dn/colorization.cpp, samples/dn/openpose.cpp.

元関数名(C#): dnn_Net_setInput
元DLLエクスポート名: dnn_Net_setInput
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_setInputsNames(cv::dnn::Net* net, const char **inputBlobNames, int inputBlobNamesLength)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::String&amp;gt; inputBlobNamesVec(inputBlobNamesLength);
    for (auto i = 0; i &amp;lt; inputBlobNamesLength; i++)
    {
        inputBlobNamesVec[i] = inputBlobNames[i];
    }
    net-&amp;gt;setInputsNames(inputBlobNamesVec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_getUnconnectedOutLayers
[32/64bit] 出力がつながっていないレイヤーのインデックスを返します。
%prm
p1,p2
p1 = sptr : IntPtr net
p2 = sptr : IntPtr result
%inst
元関数名(C#): dnn_Net_getUnconnectedOutLayers
元DLLエクスポート名: dnn_Net_getUnconnectedOutLayers
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_getUnconnectedOutLayers(cv::dnn::Net* net, std::vector&amp;lt;int&amp;gt; *result)
{
    BEGIN_WRAP
    const auto v = net-&amp;gt;getUnconnectedOutLayers();
    result-&amp;gt;clear();
    result-&amp;gt;resize(v.size());
    for (size_t i = 0; i &amp;lt; v.size(); i++)
    {
        result-&amp;gt;at(i) = v[i];
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_getUnconnectedOutLayersNames
[32/64bit] 出力がつながっていないレイヤーの名前を返します。
%prm
p1,p2
p1 = sptr : IntPtr net
p2 = sptr : IntPtr result
%inst
元関数名(C#): dnn_Net_getUnconnectedOutLayersNames
元DLLエクスポート名: dnn_Net_getUnconnectedOutLayersNames
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_getUnconnectedOutLayersNames(cv::dnn::Net* net, std::vector&amp;lt;std::string&amp;gt; *result)
{
    BEGIN_WRAP
    const auto v = net-&amp;gt;getUnconnectedOutLayersNames();
    result-&amp;gt;clear();
    result-&amp;gt;resize(v.size());
    for (size_t i = 0; i &amp;lt; v.size(); i++)
    {
        result-&amp;gt;at(i) = v[i];
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_enableFusion
[32/64bit] ネットワークのレイヤーフュージョンを有効または無効にします。
%prm
p1,p2
p1 = sptr : IntPtr net
p2 = int : int fusion
%inst
元関数名(C#): dnn_Net_enableFusion
元DLLエクスポート名: dnn_Net_enableFusion
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_enableFusion(cv::dnn::Net* net, int fusion)
{
    BEGIN_WRAP
    net-&amp;gt;enableFusion(fusion != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
dnn_Net_getPerfProfile
[32/64bit] 推論にかかる全体の時間と、レイヤーのタイミング（ティック単位）を返します。
%prm
p1,p2,p3
p1 = sptr : IntPtr net
p2 = sptr : IntPtr timings
p3 = var : out long returnValue
%inst
返されたベクトルのインデックスは，レイヤーのIDに対応する。いくつかのレイヤーは他のレイヤーと融合することができ、その場合、スキップされたレイヤーについては0ティックカウントが返されます。DNN_TARGET_CPU上のDNN_BACKEND_OPENCVでのみサポートされます。

元関数名(C#): dnn_Net_getPerfProfile
元DLLエクスポート名: dnn_Net_getPerfProfile
参照元CSファイル: Internal\PInvoke\NativeMethods\dnn\NativeMethods_dnn_Net.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) dnn_Net_getPerfProfile(cv::dnn::Net* net, std::vector&amp;lt;double&amp;gt; *timings, int64 *returnValue)
{
    BEGIN_WRAP
    *returnValue = net-&amp;gt;getPerfProfile(*timings);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_dnn_Net

%index
face_Facemark_loadModel
[32/64bit] フィット処理の前に，学習済みモデルをロードする関数です．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string model
%inst
使用例efacemark->loadModel("../data/lbf.model");fragment

元関数名(C#): face_Facemark_loadModel
元DLLエクスポート名: face_Facemark_loadModel
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_Facemark_loadModel(cv::face::Facemark *obj, const char *model)
{
    BEGIN_WRAP
    obj-&amp;gt;loadModel(model);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_Facemark_fit
[32/64bit] 画像から顔のランドマークを検出します。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = sptr : IntPtr faces
p4 = sptr : IntPtr landmarks
p5 = var : out int returnValue
%inst
使用例Mat image = imread("image.jpg");std::vector<Rect> faces;std::vector<std::vector<Point2f> > landmarks;facemark->fit(image, faces, landmarks);fragment

元関数名(C#): face_Facemark_fit
元DLLエクスポート名: face_Facemark_fit
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_create
[32/64bit] face_FacemarkLBF_create
%prm
p1,p2
p1 = sptr : IntPtr @params
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): face_FacemarkLBF_create
元DLLエクスポート名: face_FacemarkLBF_create
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_create(cv::face::FacemarkLBF::Params *params, cv::Ptr&amp;lt;cv::face::FacemarkLBF&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto obj = (params == nullptr) ? 
        cv::face::FacemarkLBF::create() :
        cv::face::FacemarkLBF::create(*params);
    *returnValue = clone(obj);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_Ptr_FacemarkLBF_get
[32/64bit] cv::face::FacemarkLBF のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): face_Ptr_FacemarkLBF_get
元DLLエクスポート名: face_Ptr_FacemarkLBF_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_Ptr_FacemarkLBF_get(cv::Ptr&amp;lt;cv::face::FacemarkLBF&amp;gt; *obj, cv::face::FacemarkLBF **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_Ptr_FacemarkLBF_delete
[32/64bit] cv::face::FacemarkLBF のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): face_Ptr_FacemarkLBF_delete
元DLLエクスポート名: face_Ptr_FacemarkLBF_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_Ptr_FacemarkLBF_delete(cv::Ptr&amp;lt;cv::face::FacemarkLBF&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_new
[32/64bit] cv::face::FacemarkLBF::Params のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst



元関数名(C#): face_FacemarkLBF_Params_new
元DLLエクスポート名: face_FacemarkLBF_Params_new
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_new(cv::face::FacemarkLBF::Params **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::face::FacemarkLBF::Params;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_delete
[32/64bit] cv::face::FacemarkLBF::Params のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): face_FacemarkLBF_Params_delete
元DLLエクスポート名: face_FacemarkLBF_Params_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_delete(cv::face::FacemarkLBF::Params *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_shape_offset_get
[32/64bit] cv::face::FacemarkLBF::Params::shape_offset 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
読み込まれた顔のランドマークポイントのオフセット


元関数名(C#): face_FacemarkLBF_Params_shape_offset_get
元DLLエクスポート名: face_FacemarkLBF_Params_shape_offset_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_shape_offset_get(cv::face::FacemarkLBF::Params *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;shape_offset;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_shape_offset_set
[32/64bit] cv::face::FacemarkLBF::Params::shape_offset 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
読み込まれた顔のランドマークポイントのオフセット


元関数名(C#): face_FacemarkLBF_Params_shape_offset_set
元DLLエクスポート名: face_FacemarkLBF_Params_shape_offset_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_shape_offset_set(cv::face::FacemarkLBF::Params *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;shape_offset = val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_cascade_face_get
[32/64bit] cv::face::FacemarkLBF::Params::cascade_face 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr s
%inst
顔検出モデルのファイル名


元関数名(C#): face_FacemarkLBF_Params_cascade_face_get
元DLLエクスポート名: face_FacemarkLBF_Params_cascade_face_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_cascade_face_get(cv::face::FacemarkLBF::Params *obj, std::string *s)
{
    BEGIN_WRAP
    s-&amp;gt;assign(obj-&amp;gt;cascade_face);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_cascade_face_set
[32/64bit] cv::face::FacemarkLBF::Params::cascade_face 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string s
%inst
顔検出モデルのファイル名


元関数名(C#): face_FacemarkLBF_Params_cascade_face_set
元DLLエクスポート名: face_FacemarkLBF_Params_cascade_face_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_cascade_face_set(cv::face::FacemarkLBF::Params *obj, const char *s)
{
    BEGIN_WRAP
     obj-&amp;gt;cascade_face = s;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_verbose_get
[32/64bit] cv::face::FacemarkLBF::Params::verbose 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
学習用プリントアウトの表示


元関数名(C#): face_FacemarkLBF_Params_verbose_get
元DLLエクスポート名: face_FacemarkLBF_Params_verbose_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_verbose_get(cv::face::FacemarkLBF::Params *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;verbose ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_verbose_set
[32/64bit] cv::face::FacemarkLBF::Params::verbose 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
学習用プリントアウトの表示


元関数名(C#): face_FacemarkLBF_Params_verbose_set
元DLLエクスポート名: face_FacemarkLBF_Params_verbose_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_verbose_set(cv::face::FacemarkLBF::Params *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;verbose = (val != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_n_landmarks_get
[32/64bit] cv::face::FacemarkLBF::Params::n_landmarks 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
ランドマークポイントの数


元関数名(C#): face_FacemarkLBF_Params_n_landmarks_get
元DLLエクスポート名: face_FacemarkLBF_Params_n_landmarks_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_n_landmarks_get(cv::face::FacemarkLBF::Params *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;n_landmarks;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_n_landmarks_set
[32/64bit] cv::face::FacemarkLBF::Params::n_landmarks 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
ランドマークポイントの数


元関数名(C#): face_FacemarkLBF_Params_n_landmarks_set
元DLLエクスポート名: face_FacemarkLBF_Params_n_landmarks_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_n_landmarks_set(cv::face::FacemarkLBF::Params *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;n_landmarks = val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_initShape_n_get
[32/64bit] cv::face::FacemarkLBF::Params::initShape_n 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
学習データを補強するための乗数


元関数名(C#): face_FacemarkLBF_Params_initShape_n_get
元DLLエクスポート名: face_FacemarkLBF_Params_initShape_n_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_initShape_n_get(cv::face::FacemarkLBF::Params *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;initShape_n;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_initShape_n_set
[32/64bit] cv::face::FacemarkLBF::Params::initShape_n 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
学習データを補強するための乗数


元関数名(C#): face_FacemarkLBF_Params_initShape_n_set
元DLLエクスポート名: face_FacemarkLBF_Params_initShape_n_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_initShape_n_set(cv::face::FacemarkLBF::Params *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;initShape_n = val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_stages_n_get
[32/64bit] cv::face::FacemarkLBF::Params::stages_n 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
リファインメントのステージ数


元関数名(C#): face_FacemarkLBF_Params_stages_n_get
元DLLエクスポート名: face_FacemarkLBF_Params_stages_n_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_stages_n_get(cv::face::FacemarkLBF::Params *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;stages_n;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_stages_n_set
[32/64bit] cv::face::FacemarkLBF::Params::stages_n 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
リファインメントのステージ数


元関数名(C#): face_FacemarkLBF_Params_stages_n_set
元DLLエクスポート名: face_FacemarkLBF_Params_stages_n_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_stages_n_set(cv::face::FacemarkLBF::Params *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;stages_n = val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_tree_n_get
[32/64bit] cv::face::FacemarkLBF::Params::tree_n 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
各ランドマークポイントの絞り込みのためのモデル内の木の数


元関数名(C#): face_FacemarkLBF_Params_tree_n_get
元DLLエクスポート名: face_FacemarkLBF_Params_tree_n_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_tree_n_get(cv::face::FacemarkLBF::Params *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;tree_n;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_tree_n_set
[32/64bit] cv::face::FacemarkLBF::Params::tree_n 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
各ランドマークポイントの絞り込みのためのモデル内の木の数


元関数名(C#): face_FacemarkLBF_Params_tree_n_set
元DLLエクスポート名: face_FacemarkLBF_Params_tree_n_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_tree_n_set(cv::face::FacemarkLBF::Params *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;tree_n = val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_tree_depth_get
[32/64bit] cv::face::FacemarkLBF::Params::tree_depth 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
決定木の深さで、特徴量の大きさを決める


元関数名(C#): face_FacemarkLBF_Params_tree_depth_get
元DLLエクスポート名: face_FacemarkLBF_Params_tree_depth_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_tree_depth_get(cv::face::FacemarkLBF::Params *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;tree_depth;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_tree_depth_set
[32/64bit] cv::face::FacemarkLBF::Params::tree_depth 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
決定木の深さで、特徴量の大きさを決める


元関数名(C#): face_FacemarkLBF_Params_tree_depth_set
元DLLエクスポート名: face_FacemarkLBF_Params_tree_depth_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_tree_depth_set(cv::face::FacemarkLBF::Params *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;tree_depth = val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_bagging_overlap_get
[32/64bit] cv::face::FacemarkLBF::Params::bagging_overlap 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
LBF特徴を学習する際のオーバーラップ率


元関数名(C#): face_FacemarkLBF_Params_bagging_overlap_get
元DLLエクスポート名: face_FacemarkLBF_Params_bagging_overlap_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_bagging_overlap_get(cv::face::FacemarkLBF::Params *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;bagging_overlap;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_bagging_overlap_set
[32/64bit] cv::face::FacemarkLBF::Params::bagging_overlap 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
LBF特徴を学習する際のオーバーラップ率


元関数名(C#): face_FacemarkLBF_Params_bagging_overlap_set
元DLLエクスポート名: face_FacemarkLBF_Params_bagging_overlap_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_bagging_overlap_set(cv::face::FacemarkLBF::Params *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;bagging_overlap = val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_model_filename_get
[32/64bit] cv::face::FacemarkLBF::Params::model_filename 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr s
%inst
学習されたモデルが保存されるファイル名


元関数名(C#): face_FacemarkLBF_Params_model_filename_get
元DLLエクスポート名: face_FacemarkLBF_Params_model_filename_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_model_filename_get(cv::face::FacemarkLBF::Params *obj, std::string *s)
{
    BEGIN_WRAP
    s-&amp;gt;assign(obj-&amp;gt;model_filename);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_model_filename_set
[32/64bit] cv::face::FacemarkLBF::Params::model_filename 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string s
%inst
学習されたモデルが保存されるファイル名


元関数名(C#): face_FacemarkLBF_Params_model_filename_set
元DLLエクスポート名: face_FacemarkLBF_Params_model_filename_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_model_filename_set(cv::face::FacemarkLBF::Params *obj, const char *s)
{
    BEGIN_WRAP
    obj-&amp;gt;model_filename = s;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_save_model_get
[32/64bit] cv::face::FacemarkLBF::Params::save_model 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
学習したモデルを保存するかどうかのフラグ


元関数名(C#): face_FacemarkLBF_Params_save_model_get
元DLLエクスポート名: face_FacemarkLBF_Params_save_model_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_save_model_get(cv::face::FacemarkLBF::Params *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;save_model ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_save_model_set
[32/64bit] cv::face::FacemarkLBF::Params::save_model 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
学習したモデルを保存するかどうかのフラグ


元関数名(C#): face_FacemarkLBF_Params_save_model_set
元DLLエクスポート名: face_FacemarkLBF_Params_save_model_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_save_model_set(cv::face::FacemarkLBF::Params *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;save_model = (val != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_seed_get
[32/64bit] cv::face::FacemarkLBF::Params::seed 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out uint returnValue
%inst
学習データをシャッフルするためのシード


元関数名(C#): face_FacemarkLBF_Params_seed_get
元DLLエクスポート名: face_FacemarkLBF_Params_seed_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_seed_get(cv::face::FacemarkLBF::Params *obj, unsigned int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;seed;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_seed_set
[32/64bit] cv::face::FacemarkLBF::Params::seed 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : uint val
%inst
学習データをシャッフルするためのシード


元関数名(C#): face_FacemarkLBF_Params_seed_set
元DLLエクスポート名: face_FacemarkLBF_Params_seed_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_seed_set(cv::face::FacemarkLBF::Params *obj, unsigned int val)
{
    BEGIN_WRAP
    obj-&amp;gt;seed = val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_feats_m_get
[32/64bit] cv::face::FacemarkLBF::Params::feats_m 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr v
%inst



元関数名(C#): face_FacemarkLBF_Params_feats_m_get
元DLLエクスポート名: face_FacemarkLBF_Params_feats_m_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_feats_m_get(cv::face::FacemarkLBF::Params *obj, std::vector&amp;lt;int&amp;gt; *v)
{
    BEGIN_WRAP
    std::copy(obj-&amp;gt;feats_m.begin(), obj-&amp;gt;feats_m.end(), std::back_inserter(*v));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_feats_m_set
[32/64bit] cv::face::FacemarkLBF::Params::feats_m 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr v
%inst



元関数名(C#): face_FacemarkLBF_Params_feats_m_set
元DLLエクスポート名: face_FacemarkLBF_Params_feats_m_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_feats_m_set(cv::face::FacemarkLBF::Params *obj, std::vector&amp;lt;int&amp;gt; *v)
{
    BEGIN_WRAP
    obj-&amp;gt;feats_m.clear();
    std::copy(v-&amp;gt;begin(), v-&amp;gt;end(), std::back_inserter(obj-&amp;gt;feats_m));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_radius_m_get
[32/64bit] cv::face::FacemarkLBF::Params::radius_m 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr v
%inst



元関数名(C#): face_FacemarkLBF_Params_radius_m_get
元DLLエクスポート名: face_FacemarkLBF_Params_radius_m_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_radius_m_get(cv::face::FacemarkLBF::Params *obj, std::vector&amp;lt;double&amp;gt; *v)
{
    BEGIN_WRAP
    std::copy(obj-&amp;gt;radius_m.begin(), obj-&amp;gt;radius_m.end(), std::back_inserter(*v));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_radius_m_set
[32/64bit] cv::face::FacemarkLBF::Params::radius_m 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr v
%inst



元関数名(C#): face_FacemarkLBF_Params_radius_m_set
元DLLエクスポート名: face_FacemarkLBF_Params_radius_m_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_radius_m_set(cv::face::FacemarkLBF::Params *obj, std::vector&amp;lt;double&amp;gt; *v)
{
    BEGIN_WRAP
    obj-&amp;gt;radius_m.clear();
    std::copy(v-&amp;gt;begin(), v-&amp;gt;end(), std::back_inserter(obj-&amp;gt;radius_m));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_pupils0_get
[32/64bit] cv::face::FacemarkLBF::Params::pupils 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr v
%inst



元関数名(C#): face_FacemarkLBF_Params_pupils0_get
元DLLエクスポート名: face_FacemarkLBF_Params_pupils0_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_pupils0_get(cv::face::FacemarkLBF::Params *obj, std::vector&amp;lt;int&amp;gt; *v)
{
    BEGIN_WRAP
    std::copy(obj-&amp;gt;pupils[0].begin(), obj-&amp;gt;pupils[0].end(), std::back_inserter(*v));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_pupils0_set
[32/64bit] cv::face::FacemarkLBF::Params::pupils 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr v
%inst



元関数名(C#): face_FacemarkLBF_Params_pupils0_set
元DLLエクスポート名: face_FacemarkLBF_Params_pupils0_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_pupils0_set(cv::face::FacemarkLBF::Params *obj, std::vector&amp;lt;int&amp;gt; *v)
{
    BEGIN_WRAP
    obj-&amp;gt;pupils[0].clear();
    std::copy(v-&amp;gt;begin(), v-&amp;gt;end(), std::back_inserter(obj-&amp;gt;pupils[0]));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_pupils1_get
[32/64bit] cv::face::FacemarkLBF::Params::pupils 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr v
%inst



元関数名(C#): face_FacemarkLBF_Params_pupils1_get
元DLLエクスポート名: face_FacemarkLBF_Params_pupils1_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_pupils1_get(cv::face::FacemarkLBF::Params *obj, std::vector&amp;lt;int&amp;gt; *v)
{
    BEGIN_WRAP
    std::copy(obj-&amp;gt;pupils[1].begin(), obj-&amp;gt;pupils[1].end(), std::back_inserter(*v));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_pupils1_set
[32/64bit] cv::face::FacemarkLBF::Params::pupils 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr v
%inst



元関数名(C#): face_FacemarkLBF_Params_pupils1_set
元DLLエクスポート名: face_FacemarkLBF_Params_pupils1_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_pupils1_set(cv::face::FacemarkLBF::Params *obj, std::vector&amp;lt;int&amp;gt; *v)
{
    BEGIN_WRAP
    obj-&amp;gt;pupils[1].clear();
    std::copy(v-&amp;gt;begin(), v-&amp;gt;end(), std::back_inserter(obj-&amp;gt;pupils[1]));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_detectROI_get
[32/64bit] cv::face::FacemarkLBF::Params::detectROI 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out Rect returnValue
%inst



元関数名(C#): face_FacemarkLBF_Params_detectROI_get
元DLLエクスポート名: face_FacemarkLBF_Params_detectROI_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_detectROI_get(cv::face::FacemarkLBF::Params *obj, MyCvRect *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(obj-&amp;gt;detectROI);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_detectROI_set
[32bit] cv::face::FacemarkLBF::Params::detectROI 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = ARGS_RECT : Rect val
%inst



元関数名(C#): face_FacemarkLBF_Params_detectROI_set
元DLLエクスポート名: face_FacemarkLBF_Params_detectROI_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_detectROI_set(cv::face::FacemarkLBF::Params *obj, MyCvRect val)
{
    BEGIN_WRAP
    obj-&amp;gt;detectROI = cpp(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_detectROI_set
[64bit] cv::face::FacemarkLBF::Params::detectROI 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : Rect val
%inst



元関数名(C#): face_FacemarkLBF_Params_detectROI_set
元DLLエクスポート名: face_FacemarkLBF_Params_detectROI_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_detectROI_set(cv::face::FacemarkLBF::Params *obj, MyCvRect val)
{
    BEGIN_WRAP
    obj-&amp;gt;detectROI = cpp(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_read
[32/64bit] face_FacemarkLBF_Params_read
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr fn
%inst
元関数名(C#): face_FacemarkLBF_Params_read
元DLLエクスポート名: face_FacemarkLBF_Params_read
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_read(cv::face::FacemarkLBF::Params *obj, cv::FileNode *fn)
{
    BEGIN_WRAP
    obj-&amp;gt;read(*fn);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkLBF_Params_write
[32/64bit] face_FacemarkLBF_Params_write
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr fs
%inst
元関数名(C#): face_FacemarkLBF_Params_write
元DLLエクスポート名: face_FacemarkLBF_Params_write
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkLBF_Params_write(cv::face::FacemarkLBF::Params *obj, cv::FileStorage *fs)
{
    BEGIN_WRAP
    obj-&amp;gt;write(*fs);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_create
[32/64bit] イニシャライザ
%prm
p1,p2
p1 = sptr : IntPtr @params
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): face_FacemarkAAM_create
元DLLエクスポート名: face_FacemarkAAM_create
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_create(cv::face::FacemarkAAM::Params *params, cv::Ptr&amp;lt;cv::face::FacemarkAAM&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto obj = (params == nullptr) ?
        cv::face::FacemarkAAM::create() :
        cv::face::FacemarkAAM::create(*params);
    *returnValue = clone(obj);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_Ptr_FacemarkAAM_get
[32/64bit] cv::face::FacemarkAAM のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): face_Ptr_FacemarkAAM_get
元DLLエクスポート名: face_Ptr_FacemarkAAM_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_Ptr_FacemarkAAM_get(cv::Ptr&amp;lt;cv::face::FacemarkAAM&amp;gt; *obj, cv::face::FacemarkAAM **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_Ptr_FacemarkAAM_delete
[32/64bit] cv::face::FacemarkAAM のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): face_Ptr_FacemarkAAM_delete
元DLLエクスポート名: face_Ptr_FacemarkAAM_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_Ptr_FacemarkAAM_delete(cv::Ptr&amp;lt;cv::face::FacemarkAAM&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_new
[32/64bit] cv::face::FacemarkAAM::Params のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst



元関数名(C#): face_FacemarkAAM_Params_new
元DLLエクスポート名: face_FacemarkAAM_Params_new
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_new(cv::face::FacemarkAAM::Params **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::face::FacemarkAAM::Params;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_delete
[32/64bit] cv::face::FacemarkAAM::Params のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): face_FacemarkAAM_Params_delete
元DLLエクスポート名: face_FacemarkAAM_Params_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_delete(cv::face::FacemarkAAM::Params *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_model_filename_get
[32/64bit] cv::face::FacemarkAAM::Params::model_filename 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr s
%inst



元関数名(C#): face_FacemarkAAM_Params_model_filename_get
元DLLエクスポート名: face_FacemarkAAM_Params_model_filename_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_model_filename_get(cv::face::FacemarkAAM::Params *obj, std::string *s)
{
    BEGIN_WRAP
    s-&amp;gt;assign(obj-&amp;gt;model_filename);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_model_filename_set
[32/64bit] cv::face::FacemarkAAM::Params::model_filename 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string s
%inst



元関数名(C#): face_FacemarkAAM_Params_model_filename_set
元DLLエクスポート名: face_FacemarkAAM_Params_model_filename_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_model_filename_set(cv::face::FacemarkAAM::Params *obj, const char *s)
{
    BEGIN_WRAP
    obj-&amp;gt;model_filename = s;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_m_get
[32/64bit] cv::face::FacemarkAAM::Params::m 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): face_FacemarkAAM_Params_m_get
元DLLエクスポート名: face_FacemarkAAM_Params_m_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_m_get(cv::face::FacemarkAAM::Params *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;m;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_m_set
[32/64bit] cv::face::FacemarkAAM::Params::m 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst



元関数名(C#): face_FacemarkAAM_Params_m_set
元DLLエクスポート名: face_FacemarkAAM_Params_m_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_m_set(cv::face::FacemarkAAM::Params *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;m = val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_n_get
[32/64bit] cv::face::FacemarkAAM::Params::n 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): face_FacemarkAAM_Params_n_get
元DLLエクスポート名: face_FacemarkAAM_Params_n_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_n_get(cv::face::FacemarkAAM::Params *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;n;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_n_set
[32/64bit] cv::face::FacemarkAAM::Params::n 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst



元関数名(C#): face_FacemarkAAM_Params_n_set
元DLLエクスポート名: face_FacemarkAAM_Params_n_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_n_set(cv::face::FacemarkAAM::Params *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;n = val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_n_iter_get
[32/64bit] cv::face::FacemarkAAM::Params::n_iter 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): face_FacemarkAAM_Params_n_iter_get
元DLLエクスポート名: face_FacemarkAAM_Params_n_iter_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_n_iter_get(cv::face::FacemarkAAM::Params *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;n_iter;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_n_iter_set
[32/64bit] cv::face::FacemarkAAM::Params::n_iter 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst



元関数名(C#): face_FacemarkAAM_Params_n_iter_set
元DLLエクスポート名: face_FacemarkAAM_Params_n_iter_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_n_iter_set(cv::face::FacemarkAAM::Params *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;n_iter = val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_verbose_get
[32/64bit] cv::face::FacemarkAAM::Params::verbose 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): face_FacemarkAAM_Params_verbose_get
元DLLエクスポート名: face_FacemarkAAM_Params_verbose_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_verbose_get(cv::face::FacemarkAAM::Params *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;verbose ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_verbose_set
[32/64bit] cv::face::FacemarkAAM::Params::verbose 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst



元関数名(C#): face_FacemarkAAM_Params_verbose_set
元DLLエクスポート名: face_FacemarkAAM_Params_verbose_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_verbose_set(cv::face::FacemarkAAM::Params *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;verbose = (val != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_save_model_get
[32/64bit] cv::face::FacemarkAAM::Params::save_model 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): face_FacemarkAAM_Params_save_model_get
元DLLエクスポート名: face_FacemarkAAM_Params_save_model_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_save_model_get(cv::face::FacemarkAAM::Params *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;save_model ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_save_model_set
[32/64bit] cv::face::FacemarkAAM::Params::save_model 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst



元関数名(C#): face_FacemarkAAM_Params_save_model_set
元DLLエクスポート名: face_FacemarkAAM_Params_save_model_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_save_model_set(cv::face::FacemarkAAM::Params *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;save_model = (val != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_max_m_get
[32/64bit] cv::face::FacemarkAAM::Params::max_m 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): face_FacemarkAAM_Params_max_m_get
元DLLエクスポート名: face_FacemarkAAM_Params_max_m_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_max_m_get(cv::face::FacemarkAAM::Params *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;max_m;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_max_m_set
[32/64bit] cv::face::FacemarkAAM::Params::max_m 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst



元関数名(C#): face_FacemarkAAM_Params_max_m_set
元DLLエクスポート名: face_FacemarkAAM_Params_max_m_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_max_m_set(cv::face::FacemarkAAM::Params *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;max_m = val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_max_n_get
[32/64bit] cv::face::FacemarkAAM::Params::max_n 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): face_FacemarkAAM_Params_max_n_get
元DLLエクスポート名: face_FacemarkAAM_Params_max_n_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_max_n_get(cv::face::FacemarkAAM::Params *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;max_n;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_max_n_set
[32/64bit] cv::face::FacemarkAAM::Params::max_n 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst



元関数名(C#): face_FacemarkAAM_Params_max_n_set
元DLLエクスポート名: face_FacemarkAAM_Params_max_n_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_max_n_set(cv::face::FacemarkAAM::Params *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;max_n = val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_texture_max_m_get
[32/64bit] cv::face::FacemarkAAM::Params::texture_max_m 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): face_FacemarkAAM_Params_texture_max_m_get
元DLLエクスポート名: face_FacemarkAAM_Params_texture_max_m_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_texture_max_m_get(cv::face::FacemarkAAM::Params *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;texture_max_m;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_texture_max_m_set
[32/64bit] cv::face::FacemarkAAM::Params::texture_max_m 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst



元関数名(C#): face_FacemarkAAM_Params_texture_max_m_set
元DLLエクスポート名: face_FacemarkAAM_Params_texture_max_m_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_texture_max_m_set(cv::face::FacemarkAAM::Params *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;texture_max_m = val;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_scales_get
[32/64bit] cv::face::FacemarkAAM::Params::scales 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr v
%inst



元関数名(C#): face_FacemarkAAM_Params_scales_get
元DLLエクスポート名: face_FacemarkAAM_Params_scales_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_scales_get(cv::face::FacemarkAAM::Params *obj, std::vector&amp;lt;float&amp;gt; *v)
{
    BEGIN_WRAP
    std::copy(obj-&amp;gt;scales.begin(), obj-&amp;gt;scales.end(), std::back_inserter(*v));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_scales_set
[32/64bit] cv::face::FacemarkAAM::Params::scales 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr v
%inst



元関数名(C#): face_FacemarkAAM_Params_scales_set
元DLLエクスポート名: face_FacemarkAAM_Params_scales_set
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_scales_set(cv::face::FacemarkAAM::Params *obj, std::vector&amp;lt;float&amp;gt; *v)
{
    BEGIN_WRAP
    obj-&amp;gt;scales.clear();
    std::copy(v-&amp;gt;begin(), v-&amp;gt;end(), std::back_inserter(obj-&amp;gt;scales));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_read
[32/64bit] ファイルからパラメータを読み込みます、現在は使用されていません。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr fn
%inst
元関数名(C#): face_FacemarkAAM_Params_read
元DLLエクスポート名: face_FacemarkAAM_Params_read
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_read(cv::face::FacemarkAAM::Params *obj, cv::FileNode *fn)
{
    BEGIN_WRAP
    obj-&amp;gt;read(*fn);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FacemarkAAM_Params_write
[32/64bit] ファイルからパラメータを読み込みます、現在は使用されていません。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr fs
%inst
元関数名(C#): face_FacemarkAAM_Params_write
元DLLエクスポート名: face_FacemarkAAM_Params_write
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_Facemark.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FacemarkAAM_Params_write(cv::face::FacemarkAAM::Params *obj, cv::FileStorage *fs)
{
    BEGIN_WRAP
    obj-&amp;gt;write(*fs);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_Facemark

%index
face_FaceRecognizer_train
[32/64bit] 与えられたデータとラベルを使って、FaceRecognizerを学習します。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr[] src
p3 = int : int srcLength
p4 = var : int[] labels
p5 = int : int labelsLength
%inst
以下のソースコードは，与えられた画像群に対して，どのようにFisherfacesモデルを学習するかを示すものです．画像は imread によって読み込まれ，std::vector<Mat> に格納されます．各画像のラベルは，std::vector<int> に格納されます（CV_32SC1 型の Mat を利用することもできます）．ラベルとは，この画像が属する対象（人）のことであり，同じ対象（人）は同じラベルを持つべきです．利用可能な FaceRecognizer では，ラベルの順序を気にする必要はなく，同じ人物が同じラベルを持っていることを確認するだけです： // 画像とラベルを保持しますvector<Mat> images;vector<int> labels;// CV_32SC1 型の Mat を利用します// Mat labels(number_of_samples, 1, CV_32SC1);// 最初の人物に対する画像images.push_back(imread("person0/0.jpg", IMREAD_GRAYSCALE)); labels.push_back(0);images.push_back(imread("person0/1.jpg", IMREAD_GRAYSCALE)); labels.push_back(0);images.push_back(imread("person0/2.jpg", IMREAD_GRAYSCALE)); labels.push_back(0);// 2人目用の画像images.push_back(imread("person1/0.jpg", IMREAD_GRAYSCALE)); labels.push_back(1);images.push_back(imread("person1/1.jpg", IMREAD_GRAYSCALE)); labels.push_back(1);images.push_back(imread("person1/2.jpg", IMREAD_GRAYSCALE)); labels.push_back(1);fragmentさて、いくつかの画像を読み込んだところで、新しいFaceRecognizerを作成してみましょう。この例では、Fisherfaces モデルを作成し、可能なすべての Fisherfaces を保持することにします： // 新しい Fisherfaces モデルを作成し、利用可能なすべての Fisherfaces を保持します、 // これはこの特定の FaceRecognizer の最も一般的な使用法です。//Ptr<FaceRecognizer> model = FisherFaceRecognizer::create();fragmentそして最後に，与えられたデータセット（顔画像とラベル）に対してこれを学習させます： // これは，利用可能な cv::FaceRecognizer// のすべての実装を学習させるための，共通のインタフェースです： //model->train(images, labels);fragment

元関数名(C#): face_FaceRecognizer_train
元DLLエクスポート名: face_FaceRecognizer_train
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FaceRecognizer_train(
    cv::face::FaceRecognizer *obj, cv::Mat **src, int srcLength, int *labels, int labelsLength)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; srcVec(srcLength);
    for (auto i = 0; i &amp;lt; srcLength; i++)
        srcVec[i] = *src[i];
    const std::vector&amp;lt;int&amp;gt; labelsVec(labels, labels + labelsLength);
    obj-&amp;gt;train(srcVec, labelsVec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_FaceRecognizer_update
[32/64bit] 与えられたデータと関連付けられたラベルを用いて，FaceRecognizer を更新します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr[] src
p3 = int : int srcLength
p4 = var : int[] labels
p5 = int : int labelsLength
%inst
このメソッドは，（おそらく学習済みの）FaceRecognizer を更新しますが，アルゴリズムがそれをサポートしている場合に限ります．LBPH（Local Binary Patterns Histograms）認識器（createLBPHFaceRecognizerを参照）を更新することができます。EigenfacesとFisherfacesメソッドの場合、これはアルゴリズム的に可能ではなく、FaceRecognizer::trainでモデルを再推定する必要があります。いずれにしても、train の呼び出しは既存のモデルを空にして新しいモデルを学習しますが、update はモデルデータを削除しません。// 新しい LBPH モデルを作成し（更新可能）、デフォルトのパラメータを使用します // これは、この特定の FaceRecognizer の最も一般的な使い方です： //Ptr<FaceRecognizer> model = LBPHFaceRecognizer::create();// これは、利用可能なすべての cv を学習するための共通のインタフェースです。:FaceRecognizer// implementations://model->train(images, labels);// 新しい画像を格納するいくつかのコンテナ:vector<Mat> newImages;vector<int> newLabels;// コンテナに画像を追加する必要があります://// ...//// ここで，モデルを更新します．...//// モデルの更新は，呼び出すだけで簡単に行えます:model->update(newImages,newLabels);// これにより，古いモデルデータが保存され，既存のモデル//を newImages から抽出された新しい特徴で拡張します！fragment更新をサポートしない Eigenfaces モデル（EigenFaceRecognizer::create を参照）に対して update を呼び出すと，以下のようなエラーが発生します：OpenCV Error:The function/feature is not implemented (This FaceRecognizer (FaceRecognizer.Eigenfaces) does not support updating, you must have to use FaceRecognizer::train to update it.) in update, file /home/philipp/git/opencv/modules/contrib/src/facerec.cpp, line 305terminate called after throwing an instance of 'cv::Exception'fragmentNote FaceRecognizer は，あなたのトレーニング画像を保存しません．それは，非常にメモリを消費するからであり，また，そうすることは FaceRecognizer の責任ではないからです．呼び出し側は、作業したいデータセットを維持する責任があります。

元関数名(C#): face_FaceRecognizer_update
元DLLエクスポート名: face_FaceRecognizer_update
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FaceRecognizer_update(
    cv::face::FaceRecognizer *obj, cv::Mat **src, int srcLength, int *labels, int labelsLength)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; srcVec(srcLength);
    for (auto i = 0; i &amp;lt; srcLength; i++)
        srcVec[i] = *src[i];
    const std::vector&amp;lt;int&amp;gt; labelsVec(labels, labels + labelsLength);
    obj-&amp;gt;update(srcVec, labelsVec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_FaceRecognizer_predict1
[32/64bit] 与えられた入力画像に対して，ラベルとそれに伴う信頼度（距離など）を予測します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr src
p3 = var : out int returnValue
%inst
接尾辞 const は，予測値がモデルの内部状態に影響を与えないことを意味します．したがって，このメソッドは，異なるスレッドから安全に呼び出すことができます．次の例は，学習済みモデルから予測値を得る方法を示しています： using namespace cv;// ここで初期化を行います（cv::FaceRecognizer モデルを作成します）．...// ...// サンプル画像を読み込みます： Mat img = imread("person1/3.jpg", IMREAD_GRAYSCALE);// そして， cv::FaceRecognizer から予測値を取得します： int predicted = model->predict(img);fragmentあるいは，予測値とそれに関連する信頼度（例えば，距離）を取得します．例えば，距離）:using namespace cv;// ここで初期化を行います（cv::FaceRecognizer モデルを作成します） ...// ...Mat img = imread("person1/3.jpg", IMREAD_GRAYSCALE);// 予測されたラベルとそれに関連する信頼度（例えば，距離）のためのいくつかの変数．modelel->predict(img, predicted_label, predicted_confidence);fragment

元関数名(C#): face_FaceRecognizer_predict1
元DLLエクスポート名: face_FaceRecognizer_predict1
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FaceRecognizer_predict1(cv::face::FaceRecognizer *obj, cv::_InputArray *src, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;predict(*src);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_FaceRecognizer_predict2
[32/64bit] 与えられた入力画像に対して，ラベルとそれに伴う信頼度（距離など）を予測します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr src
p3 = var : out int label
p4 = var : out double confidence
%inst
接尾辞 const は，予測値がモデルの内部状態に影響を与えないことを意味します．したがって，このメソッドは，異なるスレッドから安全に呼び出すことができます．次の例は，学習済みモデルから予測値を得る方法を示しています： using namespace cv;// ここで初期化を行います（cv::FaceRecognizer モデルを作成します）．...// ...// サンプル画像を読み込みます： Mat img = imread("person1/3.jpg", IMREAD_GRAYSCALE);// そして， cv::FaceRecognizer から予測値を取得します： int predicted = model->predict(img);fragmentあるいは，予測値とそれに関連する信頼度（例えば，距離）を取得します．例えば，距離）:using namespace cv;// ここで初期化を行います（cv::FaceRecognizer モデルを作成します） ...// ...Mat img = imread("person1/3.jpg", IMREAD_GRAYSCALE);// 予測されたラベルとそれに関連する信頼度（例えば，距離）のためのいくつかの変数．modelel->predict(img, predicted_label, predicted_confidence);fragment

元関数名(C#): face_FaceRecognizer_predict2
元DLLエクスポート名: face_FaceRecognizer_predict2
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FaceRecognizer_predict2(
    cv::face::FaceRecognizer *obj, cv::_InputArray *src, int *label, double *confidence)
{
    BEGIN_WRAP
    obj-&amp;gt;predict(*src, *label, *confidence);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_FaceRecognizer_write1
[32/64bit] FaceRecognizerとそのモデルの状態を保存します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
%inst
すべての FaceRecognizer は、内部モデルの状態を保存するために FaceRecognizer::save(FileStorage& fs) を上書きします。FaceRecognizer::save(const String& filename) は、与えられたファイル名にモデルの状態を保存します。接尾辞 const は、予測が内部モデルの状態に影響しないことを意味し、このメソッドは異なるスレッド内から安全に呼び出すことができます。

元関数名(C#): face_FaceRecognizer_write1
元DLLエクスポート名: face_FaceRecognizer_write1
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FaceRecognizer_write1(cv::face::FaceRecognizer *obj, const char *filename)
{
    BEGIN_WRAP
    obj-&amp;gt;write(filename);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_FaceRecognizer_read1
[32/64bit] FaceRecognizerとそのモデルの状態を読み込みます。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
%inst
与えられたXMLまたはYAMLファイルから、永続化されたモデルと状態を読み込みます。すべての FaceRecognizer はモデル状態をロードするために FaceRecognizer::load(FileStorage& fs) を上書きしなければなりません。FaceRecognizer::load(FileStorage& fs) は、モデルの保存を容易にするために FaceRecognizer::load(const String& filename) によって呼び出されます。

元関数名(C#): face_FaceRecognizer_read1
元DLLエクスポート名: face_FaceRecognizer_read1
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FaceRecognizer_read1(cv::face::FaceRecognizer *obj, const char *filename)
{
    BEGIN_WRAP
    obj-&amp;gt;read(filename);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_FaceRecognizer_write2
[32/64bit] FaceRecognizerとそのモデルの状態を保存します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr fs
%inst
すべての FaceRecognizer は、内部モデルの状態を保存するために FaceRecognizer::save(FileStorage& fs) を上書きします。FaceRecognizer::save(const String& filename) は、与えられたファイル名にモデルの状態を保存します。接尾辞 const は、予測が内部モデルの状態に影響しないことを意味し、このメソッドは異なるスレッド内から安全に呼び出すことができます。

元関数名(C#): face_FaceRecognizer_write2
元DLLエクスポート名: face_FaceRecognizer_write2
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FaceRecognizer_write2(cv::face::FaceRecognizer *obj, cv::FileStorage *fs)
{
    BEGIN_WRAP
    obj-&amp;gt;write(*fs);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_FaceRecognizer_read2
[32/64bit] FaceRecognizerとそのモデルの状態を読み込みます。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr fs
%inst
与えられたXMLまたはYAMLファイルから、永続化されたモデルと状態を読み込みます。すべての FaceRecognizer はモデル状態をロードするために FaceRecognizer::load(FileStorage& fs) を上書きしなければなりません。FaceRecognizer::load(FileStorage& fs) は、モデルの保存を容易にするために FaceRecognizer::load(const String& filename) によって呼び出されます。

元関数名(C#): face_FaceRecognizer_read2
元DLLエクスポート名: face_FaceRecognizer_read2
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FaceRecognizer_read2(cv::face::FaceRecognizer *obj, cv::FileNode *fn)
{
    BEGIN_WRAP
    obj-&amp;gt;read(*fn);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_FaceRecognizer_setLabelInfo
[32/64bit] 指定されたモデルのラベルに文字列情報を設定します。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = int : int label
p3 = str : [MarshalAs(UnmanagedType.LPStr)] string strInfo
%inst
文字列情報は、指定されたラベルに以前に設定されていた場合は、指定された値で置き換えられます。

元関数名(C#): face_FaceRecognizer_setLabelInfo
元DLLエクスポート名: face_FaceRecognizer_setLabelInfo
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FaceRecognizer_setLabelInfo(cv::face::FaceRecognizer *obj, int label, const char *strInfo)
{
    BEGIN_WRAP
    obj-&amp;gt;setLabelInfo(label, strInfo);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_FaceRecognizer_getLabelInfo
[32/64bit] ラベルの文字列情報を取得します。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = int : int label
p3 = sptr : IntPtr dst
%inst
未知のラベルIDが指定された場合や、指定されたラベルIDに関連するラベル情報がない場合、このメソッドは空の文字列を返します。

元関数名(C#): face_FaceRecognizer_getLabelInfo
元DLLエクスポート名: face_FaceRecognizer_getLabelInfo
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FaceRecognizer_getLabelInfo(cv::face::FaceRecognizer *obj, int label, std::string *dst)
{
    BEGIN_WRAP
    const auto result = obj-&amp;gt;getLabelInfo(label);
    dst-&amp;gt;assign(result);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_FaceRecognizer_getLabelsByString
[32/64bit] 文字列によるラベルのベクトルを取得します。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string str
p3 = sptr : IntPtr dst
%inst
この関数は、関連付けられた文字列情報の中で、指定されたサブ文字列を含むラベルを検索します。

元関数名(C#): face_FaceRecognizer_getLabelsByString
元DLLエクスポート名: face_FaceRecognizer_getLabelsByString
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FaceRecognizer_getLabelsByString(cv::face::FaceRecognizer *obj, const char* str, std::vector&amp;lt;int&amp;gt; *dst)
{
    BEGIN_WRAP
    const auto result = obj-&amp;gt;getLabelsByString(str);
    std::copy(result.begin(), result.end(), std::back_inserter(*dst));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_FaceRecognizer_getThreshold
[32/64bit] threshold パラメータアクセッサ - デフォルトの BestMinDist コレクターに必要です．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
cv::face::LBPHFaceRecognizer, および cv::face::BasicFaceRecognizer で実装されています．

元関数名(C#): face_FaceRecognizer_getThreshold
元DLLエクスポート名: face_FaceRecognizer_getThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FaceRecognizer_getThreshold(cv::face::FaceRecognizer *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_FaceRecognizer_setThreshold
[32/64bit] モデルの閾値を設定します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
cv::face::LBPHFaceRecognizer, および cv::face::BasicFaceRecognizer で実装されています．

元関数名(C#): face_FaceRecognizer_setThreshold
元DLLエクスポート名: face_FaceRecognizer_setThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FaceRecognizer_setThreshold(cv::face::FaceRecognizer *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setThreshold(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_BasicFaceRecognizer_getNumComponents
[32/64bit] alsosetNumComponents を参照してください．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): face_BasicFaceRecognizer_getNumComponents
元DLLエクスポート名: face_BasicFaceRecognizer_getNumComponents
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_BasicFaceRecognizer_getNumComponents(cv::face::BasicFaceRecognizer *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getNumComponents();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_BasicFaceRecognizer_setNumComponents
[32/64bit] alsogetNumComponents を参照してください．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): face_BasicFaceRecognizer_setNumComponents
元DLLエクスポート名: face_BasicFaceRecognizer_setNumComponents
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_BasicFaceRecognizer_setNumComponents(cv::face::BasicFaceRecognizer *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setNumComponents(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_BasicFaceRecognizer_getThreshold
[32/64bit] alsosetThreshold を参照してください．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
cv::face::FaceRecognizer をインプリメントします．

元関数名(C#): face_BasicFaceRecognizer_getThreshold
元DLLエクスポート名: face_BasicFaceRecognizer_getThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_BasicFaceRecognizer_getThreshold(cv::face::BasicFaceRecognizer *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_BasicFaceRecognizer_setThreshold
[32/64bit] alsogetThreshold を参照してください．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
cv::face::FaceRecognizer をインプリメントします．

元関数名(C#): face_BasicFaceRecognizer_setThreshold
元DLLエクスポート名: face_BasicFaceRecognizer_setThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_BasicFaceRecognizer_setThreshold(cv::face::BasicFaceRecognizer *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setThreshold(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_BasicFaceRecognizer_getProjections
[32/64bit] face_BasicFaceRecognizer_getProjections
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr dst
%inst
元関数名(C#): face_BasicFaceRecognizer_getProjections
元DLLエクスポート名: face_BasicFaceRecognizer_getProjections
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_BasicFaceRecognizer_getProjections(cv::face::BasicFaceRecognizer *obj, std::vector&amp;lt;cv::Mat&amp;gt; *dst)
{
    BEGIN_WRAP
    auto result = obj-&amp;gt;getProjections();
    dst-&amp;gt;clear();
    dst-&amp;gt;reserve(result.size());
    for (size_t i = 0; i &amp;lt; result.size(); i++)
    {
        dst-&amp;gt;push_back(result[i]);
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_BasicFaceRecognizer_getLabels
[32/64bit] face_BasicFaceRecognizer_getLabels
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr dst
%inst
元関数名(C#): face_BasicFaceRecognizer_getLabels
元DLLエクスポート名: face_BasicFaceRecognizer_getLabels
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_BasicFaceRecognizer_getLabels(cv::face::BasicFaceRecognizer *obj, cv::Mat *dst)
{
    BEGIN_WRAP
    const auto result = obj-&amp;gt;getLabels();
    result.copyTo(*dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_BasicFaceRecognizer_getEigenValues
[32/64bit] face_BasicFaceRecognizer_getEigenValues
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr dst
%inst
元関数名(C#): face_BasicFaceRecognizer_getEigenValues
元DLLエクスポート名: face_BasicFaceRecognizer_getEigenValues
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_BasicFaceRecognizer_getEigenValues(cv::face::BasicFaceRecognizer *obj, cv::Mat *dst)
{
    BEGIN_WRAP
    const auto result = obj-&amp;gt;getEigenValues();
    result.copyTo(*dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_BasicFaceRecognizer_getEigenVectors
[32/64bit] face_BasicFaceRecognizer_getEigenVectors
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr dst
%inst
元関数名(C#): face_BasicFaceRecognizer_getEigenVectors
元DLLエクスポート名: face_BasicFaceRecognizer_getEigenVectors
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_BasicFaceRecognizer_getEigenVectors(cv::face::BasicFaceRecognizer *obj, cv::Mat *dst)
{
    BEGIN_WRAP
    const auto result = obj-&amp;gt;getEigenVectors();
    result.copyTo(*dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_BasicFaceRecognizer_getMean
[32/64bit] face_BasicFaceRecognizer_getMean
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr dst
%inst
元関数名(C#): face_BasicFaceRecognizer_getMean
元DLLエクスポート名: face_BasicFaceRecognizer_getMean
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_BasicFaceRecognizer_getMean(cv::face::BasicFaceRecognizer *obj, cv::Mat *dst)
{
    BEGIN_WRAP
    const auto result = obj-&amp;gt;getMean();
    result.copyTo(*dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_EigenFaceRecognizer_create
[32/64bit] 備考
%prm
p1,p2,p3
p1 = int : int numComponents
p2 = double : double threshold
p3 = var : out IntPtr returnValue
%inst
学習と予測は，グレースケール画像に対して行う必要があります．色空間間の変換には cvtColor を利用します．

eigenfacesメソッドは，学習画像とテスト画像が同じサイズであることを仮定しています．(caps-lock, なぜなら、多くのメールでこのことを尋ねられたからです)。入力データが正しい形であることを確認しなければなりません。さもなければ、意味のある例外が投げられます。画像のサイズを変更するには resize を使います。

Model internal data:num_components see EigenFaceRecognizer::create.

threshold EigenFaceRecognizer::createを参照。

eigenvalues この主成分分析の固有値（降順）。

固有ベクトル この主成分分析の固有ベクトル（固有値の順）。

mean 訓練データから計算された標本平均．

projections 学習データの投影結果です。

labels 予測に適用される閾値です。最近傍距離が閾値よりも大きい場合、このメソッドは-1を返します。

元関数名(C#): face_EigenFaceRecognizer_create
元DLLエクスポート名: face_EigenFaceRecognizer_create
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_EigenFaceRecognizer_create(
    const int numComponents, const double threshold, cv::Ptr&amp;lt;cv::face::EigenFaceRecognizer&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto r = cv::face::EigenFaceRecognizer::create(numComponents, threshold);
    *returnValue = clone(r);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_Ptr_EigenFaceRecognizer_get
[32/64bit] cv::face::EigenFaceRecognizer のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): face_Ptr_EigenFaceRecognizer_get
元DLLエクスポート名: face_Ptr_EigenFaceRecognizer_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_Ptr_EigenFaceRecognizer_get(cv::Ptr&amp;lt;cv::face::EigenFaceRecognizer&amp;gt; *obj, cv::face::EigenFaceRecognizer **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_Ptr_EigenFaceRecognizer_delete
[32/64bit] cv::face::EigenFaceRecognizer のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): face_Ptr_EigenFaceRecognizer_delete
元DLLエクスポート名: face_Ptr_EigenFaceRecognizer_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_Ptr_EigenFaceRecognizer_delete(cv::Ptr&amp;lt;cv::face::EigenFaceRecognizer&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_FisherFaceRecognizer_create
[32/64bit] 備考
%prm
p1,p2,p3
p1 = int : int numComponents
p2 = double : double threshold
p3 = var : out IntPtr returnValue
%inst
学習と予測は，グレースケール画像に対して行う必要があります．色空間間の変換には cvtColor を利用します．

fisherfacesメソッドは，トレーニング画像とテスト画像が同じサイズであることを仮定しています．(この方法は、訓練画像とテスト画像のサイズが等しいことを前提としています。）入力データが正しい形であることを確認しなければなりません。さもなければ、意味のある例外が投げられます。画像のサイズを変更するには resize を使います。

Model internal data:num_components see FisherFaceRecognizer::create.

threshold FisherFaceRecognizer::createを参照。

eigenvalues この線形判別分析の固有値（降順）。

eigenvectors この線形判別分析の固有ベクトル（固有値の順）。

mean 訓練データから計算された標本平均．

projections 学習データの投影結果です。

labels 射影に対応するラベルです。

元関数名(C#): face_FisherFaceRecognizer_create
元DLLエクスポート名: face_FisherFaceRecognizer_create
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_FisherFaceRecognizer_create(
    const int numComponents, const double threshold, cv::Ptr&amp;lt;cv::face::FisherFaceRecognizer&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto r = cv::face::FisherFaceRecognizer::create(numComponents, threshold);
    *returnValue = clone(r);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_Ptr_FisherFaceRecognizer_get
[32/64bit] cv::face::FisherFaceRecognizer のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): face_Ptr_FisherFaceRecognizer_get
元DLLエクスポート名: face_Ptr_FisherFaceRecognizer_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_Ptr_FisherFaceRecognizer_get(cv::Ptr&amp;lt;cv::face::FisherFaceRecognizer&amp;gt; *obj, cv::face::FisherFaceRecognizer **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_Ptr_FisherFaceRecognizer_delete
[32/64bit] cv::face::FisherFaceRecognizer のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): face_Ptr_FisherFaceRecognizer_delete
元DLLエクスポート名: face_Ptr_FisherFaceRecognizer_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_Ptr_FisherFaceRecognizer_delete(cv::Ptr&amp;lt;cv::face::FisherFaceRecognizer&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_LBPHFaceRecognizer_create
[32/64bit] 備考
%prm
p1,p2,p3,p4,p5,p6
p1 = int : int radius
p2 = int : int neighbors
p3 = int : int gridX
p4 = int : int gridY
p5 = double : double threshold
p6 = var : out IntPtr returnValue
%inst
Circular Local Binary Patterns（学習および予測に利用される）は，グレースケール画像として与えられたデータを想定しており，色空間間の変換には cvtColor を利用します．

このモデルは，更新をサポートします．モデル内部データ： radius は LBPHFaceRecognizer::create を参照してください．

neighbors は，LBPHFaceRecognizer::create を参照してください．

grid_xはLBPHFaceRecognizer::createを参照。

grid_yはLBPHFaceRecognizer::createを参照。

threshold LBPHFaceRecognizer::createをご参照ください。

histograms 与えられた学習データから算出されたローカルバイナリパターンのヒストグラム（何も与えられていない場合は空）。

Labels 計算されたローカルバイナリパターンヒストグラムに対応するラベル。

元関数名(C#): face_LBPHFaceRecognizer_create
元DLLエクスポート名: face_LBPHFaceRecognizer_create
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_LBPHFaceRecognizer_create(
    const int radius, const int neighbors, const int gridX, const int gridY, const double threshold,
    cv::Ptr&amp;lt;cv::face::LBPHFaceRecognizer&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto r = cv::face::LBPHFaceRecognizer::create(radius, neighbors, gridX, gridY, threshold);
    *returnValue = clone(r);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_LBPHFaceRecognizer_getGridX
[32/64bit] alsosetGridX を参照してください。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): face_LBPHFaceRecognizer_getGridX
元DLLエクスポート名: face_LBPHFaceRecognizer_getGridX
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_LBPHFaceRecognizer_getGridX(cv::face::LBPHFaceRecognizer *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getGridX();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_LBPHFaceRecognizer_setGridX
[32/64bit] alsogetGridXを参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): face_LBPHFaceRecognizer_setGridX
元DLLエクスポート名: face_LBPHFaceRecognizer_setGridX
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_LBPHFaceRecognizer_setGridX(cv::face::LBPHFaceRecognizer *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setGridX(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_LBPHFaceRecognizer_getGridY
[32/64bit] alsosetGridYを見る
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): face_LBPHFaceRecognizer_getGridY
元DLLエクスポート名: face_LBPHFaceRecognizer_getGridY
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_LBPHFaceRecognizer_getGridY(cv::face::LBPHFaceRecognizer *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getGridY();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_LBPHFaceRecognizer_setGridY
[32/64bit] alsogetGridYを参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): face_LBPHFaceRecognizer_setGridY
元DLLエクスポート名: face_LBPHFaceRecognizer_setGridY
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_LBPHFaceRecognizer_setGridY(cv::face::LBPHFaceRecognizer *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setGridY(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_LBPHFaceRecognizer_getRadius
[32/64bit] See alsosetRadius
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): face_LBPHFaceRecognizer_getRadius
元DLLエクスポート名: face_LBPHFaceRecognizer_getRadius
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_LBPHFaceRecognizer_getRadius(cv::face::LBPHFaceRecognizer *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getRadius();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_LBPHFaceRecognizer_setRadius
[32/64bit] alsogetRadiusを参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): face_LBPHFaceRecognizer_setRadius
元DLLエクスポート名: face_LBPHFaceRecognizer_setRadius
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_LBPHFaceRecognizer_setRadius(cv::face::LBPHFaceRecognizer *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setRadius(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_LBPHFaceRecognizer_getNeighbors
[32/64bit] See alsogetNeighbors
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): face_LBPHFaceRecognizer_getNeighbors
元DLLエクスポート名: face_LBPHFaceRecognizer_getNeighbors
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_LBPHFaceRecognizer_getNeighbors(cv::face::LBPHFaceRecognizer *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getNeighbors();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_LBPHFaceRecognizer_setNeighbors
[32/64bit] alsogetNeighbors参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): face_LBPHFaceRecognizer_setNeighbors
元DLLエクスポート名: face_LBPHFaceRecognizer_setNeighbors
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_LBPHFaceRecognizer_setNeighbors(cv::face::LBPHFaceRecognizer *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setNeighbors(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_LBPHFaceRecognizer_getThreshold
[32/64bit] alsosetThreshold を参照してください．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
cv::face::FaceRecognizer をインプリメントします．

元関数名(C#): face_LBPHFaceRecognizer_getThreshold
元DLLエクスポート名: face_LBPHFaceRecognizer_getThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_LBPHFaceRecognizer_getThreshold(cv::face::LBPHFaceRecognizer *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_LBPHFaceRecognizer_setThreshold
[32/64bit] alsogetThreshold を参照してください．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
cv::face::FaceRecognizer をインプリメントします．

元関数名(C#): face_LBPHFaceRecognizer_setThreshold
元DLLエクスポート名: face_LBPHFaceRecognizer_setThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_LBPHFaceRecognizer_setThreshold(cv::face::LBPHFaceRecognizer *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setThreshold(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_LBPHFaceRecognizer_getHistograms
[32/64bit] face_LBPHFaceRecognizer_getHistograms
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr dst
%inst
元関数名(C#): face_LBPHFaceRecognizer_getHistograms
元DLLエクスポート名: face_LBPHFaceRecognizer_getHistograms
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_LBPHFaceRecognizer_getHistograms(cv::face::LBPHFaceRecognizer *obj, std::vector&amp;lt;cv::Mat&amp;gt; *dst)
{
    BEGIN_WRAP
    auto result = obj-&amp;gt;getHistograms();
    dst-&amp;gt;clear();
    dst-&amp;gt;reserve(result.size());
    for (size_t i = 0; i &amp;lt; result.size(); i++)
    {
        dst-&amp;gt;at(i) = result[i];
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_LBPHFaceRecognizer_getLabels
[32/64bit] face_LBPHFaceRecognizer_getLabels
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr dst
%inst
元関数名(C#): face_LBPHFaceRecognizer_getLabels
元DLLエクスポート名: face_LBPHFaceRecognizer_getLabels
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_LBPHFaceRecognizer_getLabels(cv::face::LBPHFaceRecognizer *obj, cv::Mat *dst)
{
    BEGIN_WRAP
    const auto result = obj-&amp;gt;getLabels();
    result.copyTo(*dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_Ptr_LBPHFaceRecognizer_get
[32/64bit] cv::face::LBPHFaceRecognizer のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): face_Ptr_LBPHFaceRecognizer_get
元DLLエクスポート名: face_Ptr_LBPHFaceRecognizer_get
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_Ptr_LBPHFaceRecognizer_get(cv::Ptr&amp;lt;cv::face::LBPHFaceRecognizer&amp;gt; *obj, cv::face::LBPHFaceRecognizer **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
face_Ptr_LBPHFaceRecognizer_delete
[32/64bit] cv::face::LBPHFaceRecognizer のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): face_Ptr_LBPHFaceRecognizer_delete
元DLLエクスポート名: face_Ptr_LBPHFaceRecognizer_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\face\NativeMethods_face_FaceRecognizer.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) face_Ptr_LBPHFaceRecognizer_delete(cv::Ptr&amp;lt;cv::face::LBPHFaceRecognizer&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_face_FaceRecognizer

%index
features2d_drawKeypoints
[32bit] キーポイントを描画します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr image
p2 = var : KeyPoint[] keypoints
p3 = int : int keypointsLength
p4 = sptr : IntPtr outImage
p5 = ARGS_SCALAR : Scalar color
p6 = int : int flags
%inst
注意 Python API の場合， flags は cv.DRAW_MATCHES_FLAGS_DEFAULT, cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS, cv.DRAW_MATCHES_FLAGS_DRAW_OVER_OUTIMG, cv.DRAW_MATCHES_FLAGS_NOT_DRAW_SINGLE_POINTS のように変更されます．

元関数名(C#): features2d_drawKeypoints
元DLLエクスポート名: features2d_drawKeypoints
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_drawKeypoints(cv::_InputArray *image, cv::KeyPoint *keypoints, int keypointsLength,
    cv::_InputOutputArray *outImage, MyCvScalar color, int flags)
{
    BEGIN_WRAP
    const std::vector&amp;lt;cv::KeyPoint&amp;gt; keypointsVec(keypoints, keypoints + keypointsLength);
    cv::drawKeypoints(*image, keypointsVec, *outImage, cpp(color), static_cast&amp;lt;cv::DrawMatchesFlags&amp;gt;(flags));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d

%index
features2d_drawKeypoints
[64bit] キーポイントを描画します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr image
p2 = var : KeyPoint[] keypoints
p3 = int : int keypointsLength
p4 = sptr : IntPtr outImage
p5 = var : Scalar color
p6 = int : int flags
%inst
注意 Python API の場合， flags は cv.DRAW_MATCHES_FLAGS_DEFAULT, cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS, cv.DRAW_MATCHES_FLAGS_DRAW_OVER_OUTIMG, cv.DRAW_MATCHES_FLAGS_NOT_DRAW_SINGLE_POINTS のように変更されます．

元関数名(C#): features2d_drawKeypoints
元DLLエクスポート名: features2d_drawKeypoints
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_drawKeypoints(cv::_InputArray *image, cv::KeyPoint *keypoints, int keypointsLength,
    cv::_InputOutputArray *outImage, MyCvScalar color, int flags)
{
    BEGIN_WRAP
    const std::vector&amp;lt;cv::KeyPoint&amp;gt; keypointsVec(keypoints, keypoints + keypointsLength);
    cv::drawKeypoints(*image, keypointsVec, *outImage, cpp(color), static_cast&amp;lt;cv::DrawMatchesFlags&amp;gt;(flags));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d

%index
features2d_drawMatches
[32bit] 2つの画像からキーポイントの一致を見つけて，それを描画します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14
p1 = sptr : IntPtr img1
p2 = var : KeyPoint[] keypoints1
p3 = int : int keypoints1Length
p4 = sptr : IntPtr img2
p5 = var : KeyPoint[] keypoints2
p6 = int : int keypoints2Length
p7 = var : DMatch[] matches1to2
p8 = int : int matches1to2Length
p9 = sptr : IntPtr outImg
p10 = ARGS_SCALAR : Scalar matchColor
p11 = ARGS_SCALAR : Scalar singlePointColor
p12 = var : byte[]? matchesMask
p13 = int : int matchesMaskLength
p14 = int : int flags
%inst
この関数は，2つの画像のキーポイント同士のマッチを，出力画像に描画します．マッチとは，2つのキーポイント（円）を結ぶ線のことです．cv::DrawMatchesFlags を参照してください．

元関数名(C#): features2d_drawMatches
元DLLエクスポート名: features2d_drawMatches
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_drawMatches(cv::Mat *img1, cv::KeyPoint *keypoints1, int keypoints1Length,
    cv::Mat *img2, cv::KeyPoint *keypoints2, int keypoints2Length,
    cv::DMatch *matches1to2, int matches1to2Length, cv::Mat *outImg,
    MyCvScalar matchColor, MyCvScalar singlePointColor,
    char *matchesMask, int matchesMaskLength, int flags)
{
    BEGIN_WRAP
    const std::vector&amp;lt;cv::KeyPoint&amp;gt; keypoints1Vec(keypoints1, keypoints1 + keypoints1Length);
    const std::vector&amp;lt;cv::KeyPoint&amp;gt; keypoints2Vec(keypoints2, keypoints2 + keypoints2Length);
    const std::vector&amp;lt;cv::DMatch&amp;gt; matches1to2Vec(matches1to2, matches1to2 + matches1to2Length);
    std::vector&amp;lt;char&amp;gt; matchesMaskVec;
    if (matchesMask != nullptr)
        matchesMaskVec = std::vector&amp;lt;char&amp;gt;(matchesMask, matchesMask + matchesMaskLength);
    cv::drawMatches(*img1, keypoints1Vec, *img2, keypoints2Vec, matches1to2Vec, *outImg,
        cpp(matchColor), cpp(singlePointColor), matchesMaskVec, static_cast&amp;lt;cv::DrawMatchesFlags&amp;gt;(flags));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d

%index
features2d_drawMatches
[64bit] 2つの画像からキーポイントの一致を見つけて，それを描画します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14
p1 = sptr : IntPtr img1
p2 = var : KeyPoint[] keypoints1
p3 = int : int keypoints1Length
p4 = sptr : IntPtr img2
p5 = var : KeyPoint[] keypoints2
p6 = int : int keypoints2Length
p7 = var : DMatch[] matches1to2
p8 = int : int matches1to2Length
p9 = sptr : IntPtr outImg
p10 = var : Scalar matchColor
p11 = var : Scalar singlePointColor
p12 = var : byte[]? matchesMask
p13 = int : int matchesMaskLength
p14 = int : int flags
%inst
この関数は，2つの画像のキーポイント同士のマッチを，出力画像に描画します．マッチとは，2つのキーポイント（円）を結ぶ線のことです．cv::DrawMatchesFlags を参照してください．

元関数名(C#): features2d_drawMatches
元DLLエクスポート名: features2d_drawMatches
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_drawMatches(cv::Mat *img1, cv::KeyPoint *keypoints1, int keypoints1Length,
    cv::Mat *img2, cv::KeyPoint *keypoints2, int keypoints2Length,
    cv::DMatch *matches1to2, int matches1to2Length, cv::Mat *outImg,
    MyCvScalar matchColor, MyCvScalar singlePointColor,
    char *matchesMask, int matchesMaskLength, int flags)
{
    BEGIN_WRAP
    const std::vector&amp;lt;cv::KeyPoint&amp;gt; keypoints1Vec(keypoints1, keypoints1 + keypoints1Length);
    const std::vector&amp;lt;cv::KeyPoint&amp;gt; keypoints2Vec(keypoints2, keypoints2 + keypoints2Length);
    const std::vector&amp;lt;cv::DMatch&amp;gt; matches1to2Vec(matches1to2, matches1to2 + matches1to2Length);
    std::vector&amp;lt;char&amp;gt; matchesMaskVec;
    if (matchesMask != nullptr)
        matchesMaskVec = std::vector&amp;lt;char&amp;gt;(matchesMask, matchesMask + matchesMaskLength);
    cv::drawMatches(*img1, keypoints1Vec, *img2, keypoints2Vec, matches1to2Vec, *outImg,
        cpp(matchColor), cpp(singlePointColor), matchesMaskVec, static_cast&amp;lt;cv::DrawMatchesFlags&amp;gt;(flags));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d

%index
features2d_drawMatchesKnn
[32bit] 2つの画像からキーポイントの一致を見つけて，それを描画します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16
p1 = sptr : IntPtr img1
p2 = var : KeyPoint[] keypoints1
p3 = int : int keypoints1Length
p4 = sptr : IntPtr img2
p5 = var : KeyPoint[] keypoints2
p6 = int : int keypoints2Length
p7 = sptr : IntPtr[] matches1to2
p8 = int : int matches1to2Size1
p9 = var : int[] matches1to2Size2
p10 = sptr : IntPtr outImg
p11 = ARGS_SCALAR : Scalar matchColor
p12 = ARGS_SCALAR : Scalar singlePointColor
p13 = var : IntPtr[]? matchesMask
p14 = int : int matchesMaskSize1
p15 = var : int[]? matchesMaskSize2
p16 = int : int flags
%inst
この関数は，2つの画像のキーポイント同士のマッチを，出力画像に描画します．マッチとは，2つのキーポイント（円）を結ぶ線のことです．cv::DrawMatchesFlags を参照してください．

元関数名(C#): features2d_drawMatchesKnn
元DLLエクスポート名: features2d_drawMatchesKnn
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_drawMatchesKnn(cv::Mat *img1, cv::KeyPoint *keypoints1, int keypoints1Length,
    cv::Mat *img2, cv::KeyPoint *keypoints2, int keypoints2Length,
    cv::DMatch **matches1to2, int matches1to2Size1, int *matches1to2Size2,
    cv::Mat *outImg, MyCvScalar matchColor, MyCvScalar singlePointColor,
    char **matchesMask, int matchesMaskSize1, int *matchesMaskSize2, int flags)
{
    BEGIN_WRAP
    const std::vector&amp;lt;cv::KeyPoint&amp;gt; keypoints1Vec(keypoints1, keypoints1 + keypoints1Length);
    const std::vector&amp;lt;cv::KeyPoint&amp;gt; keypoints2Vec(keypoints2, keypoints2 + keypoints2Length);
    std::vector&amp;lt;std::vector&amp;lt;cv::DMatch&amp;gt; &amp;gt; matches1to2Vec(matches1to2Size1);
    for (int i = 0; i &amp;lt; matches1to2Size1; i++)
    {
        cv::DMatch *p = matches1to2[i];
        matches1to2Vec[i] = std::vector&amp;lt;cv::DMatch&amp;gt;(p, p + matches1to2Size2[i]);
    }

    std::vector&amp;lt;std::vector&amp;lt;char&amp;gt; &amp;gt; matchesMaskVec;
    if (matchesMask != nullptr)
    {
        matchesMaskVec = std::vector&amp;lt;std::vector&amp;lt;char&amp;gt; &amp;gt;(matchesMaskSize1);
        for (int i = 0; i &amp;lt; matchesMaskSize1; i++)
        {
            char *p = matchesMask[i];
            matchesMaskVec[i] = std::vector&amp;lt;char&amp;gt;(p, p + matchesMaskSize2[i]);
        }
    }

    cv::drawMatches(*img1, keypoints1Vec, *img2, keypoints2Vec, matches1to2Vec,
        *outImg, cpp(matchColor), cpp(singlePointColor), matchesMaskVec, static_cast&amp;lt;cv::DrawMatchesFlags&amp;gt;(flags));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d

%index
features2d_drawMatchesKnn
[64bit] 2つの画像からキーポイントの一致を見つけて，それを描画します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16
p1 = sptr : IntPtr img1
p2 = var : KeyPoint[] keypoints1
p3 = int : int keypoints1Length
p4 = sptr : IntPtr img2
p5 = var : KeyPoint[] keypoints2
p6 = int : int keypoints2Length
p7 = sptr : IntPtr[] matches1to2
p8 = int : int matches1to2Size1
p9 = var : int[] matches1to2Size2
p10 = sptr : IntPtr outImg
p11 = var : Scalar matchColor
p12 = var : Scalar singlePointColor
p13 = var : IntPtr[]? matchesMask
p14 = int : int matchesMaskSize1
p15 = var : int[]? matchesMaskSize2
p16 = int : int flags
%inst
この関数は，2つの画像のキーポイント同士のマッチを，出力画像に描画します．マッチとは，2つのキーポイント（円）を結ぶ線のことです．cv::DrawMatchesFlags を参照してください．

元関数名(C#): features2d_drawMatchesKnn
元DLLエクスポート名: features2d_drawMatchesKnn
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_drawMatchesKnn(cv::Mat *img1, cv::KeyPoint *keypoints1, int keypoints1Length,
    cv::Mat *img2, cv::KeyPoint *keypoints2, int keypoints2Length,
    cv::DMatch **matches1to2, int matches1to2Size1, int *matches1to2Size2,
    cv::Mat *outImg, MyCvScalar matchColor, MyCvScalar singlePointColor,
    char **matchesMask, int matchesMaskSize1, int *matchesMaskSize2, int flags)
{
    BEGIN_WRAP
    const std::vector&amp;lt;cv::KeyPoint&amp;gt; keypoints1Vec(keypoints1, keypoints1 + keypoints1Length);
    const std::vector&amp;lt;cv::KeyPoint&amp;gt; keypoints2Vec(keypoints2, keypoints2 + keypoints2Length);
    std::vector&amp;lt;std::vector&amp;lt;cv::DMatch&amp;gt; &amp;gt; matches1to2Vec(matches1to2Size1);
    for (int i = 0; i &amp;lt; matches1to2Size1; i++)
    {
        cv::DMatch *p = matches1to2[i];
        matches1to2Vec[i] = std::vector&amp;lt;cv::DMatch&amp;gt;(p, p + matches1to2Size2[i]);
    }

    std::vector&amp;lt;std::vector&amp;lt;char&amp;gt; &amp;gt; matchesMaskVec;
    if (matchesMask != nullptr)
    {
        matchesMaskVec = std::vector&amp;lt;std::vector&amp;lt;char&amp;gt; &amp;gt;(matchesMaskSize1);
        for (int i = 0; i &amp;lt; matchesMaskSize1; i++)
        {
            char *p = matchesMask[i];
            matchesMaskVec[i] = std::vector&amp;lt;char&amp;gt;(p, p + matchesMaskSize2[i]);
        }
    }

    cv::drawMatches(*img1, keypoints1Vec, *img2, keypoints2Vec, matches1to2Vec,
        *outImg, cpp(matchColor), cpp(singlePointColor), matchesMaskVec, static_cast&amp;lt;cv::DrawMatchesFlags&amp;gt;(flags));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d

%index
features2d_evaluateFeatureDetector
[32/64bit] features2d_evaluateFeatureDetector
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr img1
p2 = sptr : IntPtr img2
p3 = sptr : IntPtr H1to2
p4 = sptr : IntPtr keypoints1
p5 = sptr : IntPtr keypoints2
p6 = var : out float repeatability
p7 = var : out int correspCount
%inst
元関数名(C#): features2d_evaluateFeatureDetector
元DLLエクスポート名: features2d_evaluateFeatureDetector
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_evaluateFeatureDetector(
    cv::Mat *img1, cv::Mat *img2, cv::Mat *H1to2,
    std::vector&amp;lt;cv::KeyPoint&amp;gt; *keypoints1, std::vector&amp;lt;cv::KeyPoint&amp;gt; *keypoints2,
    float *repeatability, int *correspCount/*,
    const Ptr&amp;lt;FeatureDetector&amp;gt;&amp; fdetector = Ptr&amp;lt;FeatureDetector&amp;gt;()*/)
{
    BEGIN_WRAP
    cv::evaluateFeatureDetector(
        *img1, *img2, *H1to2, keypoints1, keypoints2,
        *repeatability, *correspCount);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d

%index
features2d_computeRecallPrecisionCurve
[32/64bit] features2d_computeRecallPrecisionCurve
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr[] matches1to2
p2 = int : int matches1to2Size1
p3 = var : int[] matches1to2Size2
p4 = sptr : IntPtr[] correctMatches1to2Mask
p5 = int : int correctMatches1to2MaskSize1
p6 = var : int[] correctMatches1to2MaskSize2
p7 = sptr : IntPtr recallPrecisionCurve
%inst
元関数名(C#): features2d_computeRecallPrecisionCurve
元DLLエクスポート名: features2d_computeRecallPrecisionCurve
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_computeRecallPrecisionCurve(
    cv::DMatch **matches1to2, int matches1to2Size1, int *matches1to2Size2,
    uchar **correctMatches1to2Mask, int correctMatches1to2MaskSize1, int *correctMatches1to2MaskSize2,
    std::vector&amp;lt;cv::Point2f&amp;gt; *recallPrecisionCurve)
{
    BEGIN_WRAP
    std::vector&amp;lt;std::vector&amp;lt;cv::DMatch&amp;gt; &amp;gt; matches1to2Vec;
    std::vector&amp;lt;std::vector&amp;lt;uchar&amp;gt; &amp;gt; correctMatches1to2MaskVec;
    matches1to2Vec.reserve(matches1to2Size1);
    for (int i = 0; i &amp;lt; matches1to2Size1; i++)
    {
        matches1to2Vec.emplace_back(matches1to2[i], matches1to2[i] + matches1to2Size2[i]);
    }
    correctMatches1to2MaskVec.reserve(correctMatches1to2MaskSize1);
    for (int i = 0; i &amp;lt; correctMatches1to2MaskSize1; i++)
    {
        correctMatches1to2MaskVec.emplace_back(correctMatches1to2Mask[i], correctMatches1to2Mask[i] + correctMatches1to2MaskSize2[i]);
    }
    cv::computeRecallPrecisionCurve(
        matches1to2Vec, correctMatches1to2MaskVec, *recallPrecisionCurve);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d

%index
features2d_getRecall
[32/64bit] features2d_getRecall
%prm
p1,p2,p3,p4
p1 = var : Point2f[] recallPrecisionCurve
p2 = int : int recallPrecisionCurveSize
p3 = float : float l_precision
p4 = var : out float returnValue
%inst
元関数名(C#): features2d_getRecall
元DLLエクスポート名: features2d_getRecall
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_getRecall(
    cv::Point2f *recallPrecisionCurve, int recallPrecisionCurveSize, float l_precision, float *returnValue)
{
    BEGIN_WRAP
    const std::vector&amp;lt;cv::Point2f&amp;gt; recallPrecisionCurveVec(
        recallPrecisionCurve, recallPrecisionCurve + recallPrecisionCurveSize);
    *returnValue = cv::getRecall(recallPrecisionCurveVec, l_precision);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d

%index
features2d_getNearestPoint
[32/64bit] features2d_getNearestPoint
%prm
p1,p2,p3,p4
p1 = var : Point2f[] recallPrecisionCurve
p2 = int : int recallPrecisionCurveSize
p3 = float : float l_precision
p4 = var : out int returnValue
%inst
元関数名(C#): features2d_getNearestPoint
元DLLエクスポート名: features2d_getNearestPoint
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_getNearestPoint(
    cv::Point2f *recallPrecisionCurve, int recallPrecisionCurveSize, float l_precision, int *returnValue)
{
    BEGIN_WRAP
    const std::vector&amp;lt;cv::Point2f&amp;gt; recallPrecisionCurveVec(
        recallPrecisionCurve, recallPrecisionCurve + recallPrecisionCurveSize);
    *returnValue = cv::getNearestPoint(recallPrecisionCurveVec, l_precision);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d

%index
features2d_KeyPointsFilter_runByImageBorder
[32/64bit] features2d_KeyPointsFilter_runByImageBorder
%prm
p1,p2,p3
p1 = sptr : IntPtr keypoints
p2 = ARGS_SIZE : Size imageSize
p3 = int : int borderSize
%inst
元関数名(C#): features2d_KeyPointsFilter_runByImageBorder
元DLLエクスポート名: features2d_KeyPointsFilter_runByImageBorder
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KeyPointsFilter_runByImageBorder(
    std::vector&amp;lt;cv::KeyPoint&amp;gt; *keypoints, MyCvSize imageSize, int borderSize)
{
    BEGIN_WRAP
    cv::KeyPointsFilter::runByImageBorder(*keypoints, cpp(imageSize), borderSize);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d

%index
features2d_KeyPointsFilter_runByKeypointSize
[32/64bit] features2d_KeyPointsFilter_runByKeypointSize
%prm
p1,p2,p3
p1 = sptr : IntPtr keypoints
p2 = float : float minSize
p3 = float : float maxSize
%inst
元関数名(C#): features2d_KeyPointsFilter_runByKeypointSize
元DLLエクスポート名: features2d_KeyPointsFilter_runByKeypointSize
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KeyPointsFilter_runByKeypointSize(
    std::vector&amp;lt;cv::KeyPoint&amp;gt; *keypoints, float minSize, float maxSize)
{
    BEGIN_WRAP
    cv::KeyPointsFilter::runByKeypointSize(*keypoints, minSize, maxSize);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d

%index
features2d_KeyPointsFilter_runByPixelsMask
[32/64bit] features2d_KeyPointsFilter_runByPixelsMask
%prm
p1,p2
p1 = sptr : IntPtr keypoints
p2 = sptr : IntPtr mask
%inst
元関数名(C#): features2d_KeyPointsFilter_runByPixelsMask
元DLLエクスポート名: features2d_KeyPointsFilter_runByPixelsMask
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KeyPointsFilter_runByPixelsMask(
    std::vector&amp;lt;cv::KeyPoint&amp;gt; *keypoints, cv::Mat *mask)
{
    BEGIN_WRAP
    cv::KeyPointsFilter::runByPixelsMask(*keypoints, *mask);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d

%index
features2d_KeyPointsFilter_removeDuplicated
[32/64bit] features2d_KeyPointsFilter_removeDuplicated
%prm
p1
p1 = sptr : IntPtr keypoints
%inst
元関数名(C#): features2d_KeyPointsFilter_removeDuplicated
元DLLエクスポート名: features2d_KeyPointsFilter_removeDuplicated
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KeyPointsFilter_removeDuplicated(
    std::vector&amp;lt;cv::KeyPoint&amp;gt; *keypoints)
{
    BEGIN_WRAP
    cv::KeyPointsFilter::removeDuplicated(*keypoints);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d

%index
features2d_KeyPointsFilter_removeDuplicatedSorted
[32/64bit] features2d_KeyPointsFilter_removeDuplicatedSorted
%prm
p1
p1 = sptr : IntPtr keypoints
%inst
元関数名(C#): features2d_KeyPointsFilter_removeDuplicatedSorted
元DLLエクスポート名: features2d_KeyPointsFilter_removeDuplicatedSorted
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KeyPointsFilter_removeDuplicatedSorted(
    std::vector&amp;lt;cv::KeyPoint&amp;gt; *keypoints)
{
    BEGIN_WRAP
    cv::KeyPointsFilter::removeDuplicatedSorted(*keypoints);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d

%index
features2d_KeyPointsFilter_retainBest
[32/64bit] features2d_KeyPointsFilter_retainBest
%prm
p1,p2
p1 = sptr : IntPtr keypoints
p2 = int : int nPoints
%inst
元関数名(C#): features2d_KeyPointsFilter_retainBest
元DLLエクスポート名: features2d_KeyPointsFilter_retainBest
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KeyPointsFilter_retainBest(
    std::vector&amp;lt;cv::KeyPoint&amp;gt; *keypoints, int nPoints)
{
    BEGIN_WRAP
    cv::KeyPointsFilter::retainBest(*keypoints, nPoints);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d

%index
features2d_BOWTrainer_add
[32/64bit] トレーニングセットにディスクリプタを追加します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr descriptors
%inst
学習セットは，clustermethod を用いてクラスタリングされ，語彙が構築されます．

元関数名(C#): features2d_BOWTrainer_add
元DLLエクスポート名: features2d_BOWTrainer_add
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWTrainer_add(cv::BOWTrainer *obj, cv::Mat *descriptors)
{
    BEGIN_WRAP
    obj-&amp;gt;add(*descriptors);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWTrainer_getDescriptors
[32/64bit] ディスクリプタのトレーニングセットを返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr descriptors
%inst
元関数名(C#): features2d_BOWTrainer_getDescriptors
元DLLエクスポート名: features2d_BOWTrainer_getDescriptors
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWTrainer_getDescriptors(cv::BOWTrainer *obj, std::vector&amp;lt;cv::Mat&amp;gt; *descriptors)
{
    BEGIN_WRAP
    const std::vector&amp;lt;cv::Mat&amp;gt; d = obj-&amp;gt;getDescriptors();
    std::copy(d.begin(), d.end(), std::back_inserter(*descriptors));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWTrainer_descriptorsCount
[32/64bit] 学習セットに格納されている，すべての記述子の数を返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_BOWTrainer_descriptorsCount
元DLLエクスポート名: features2d_BOWTrainer_descriptorsCount
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWTrainer_descriptorsCount(cv::BOWTrainer *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;descriptorsCount();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWTrainer_clear
[32/64bit] features2d_BOWTrainer_clear
%prm
p1
p1 = sptr : IntPtr obj
%inst
元関数名(C#): features2d_BOWTrainer_clear
元DLLエクスポート名: features2d_BOWTrainer_clear
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWTrainer_clear(cv::BOWTrainer *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;clear();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWKMeansTrainer_new
[32bit] cv::BOWKMeansTrainer のインスタンスを生成します
%prm
p1,p2,p3,p4,p5
p1 = int : int clusterCount
p2 = ARGS_TERMCRITERIA : TermCriteria termcrit
p3 = int : int attempts
p4 = int : int flags
p5 = var : out IntPtr returnValue
%inst
kmeans - based class を用いて，視覚的単語の袋（bag of visual words）アプローチで視覚的語彙を学習します．


元関数名(C#): features2d_BOWKMeansTrainer_new
元DLLエクスポート名: features2d_BOWKMeansTrainer_new
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWKMeansTrainer_new(
    int clusterCount, MyCvTermCriteria termcrit, int attempts, int flags, cv::BOWKMeansTrainer **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::BOWKMeansTrainer(clusterCount, cpp(termcrit), attempts, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWKMeansTrainer_new
[64bit] cv::BOWKMeansTrainer のインスタンスを生成します
%prm
p1,p2,p3,p4,p5
p1 = int : int clusterCount
p2 = var : TermCriteria termcrit
p3 = int : int attempts
p4 = int : int flags
p5 = var : out IntPtr returnValue
%inst
kmeans - based class を用いて，視覚的単語の袋（bag of visual words）アプローチで視覚的語彙を学習します．


元関数名(C#): features2d_BOWKMeansTrainer_new
元DLLエクスポート名: features2d_BOWKMeansTrainer_new
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWKMeansTrainer_new(
    int clusterCount, MyCvTermCriteria termcrit, int attempts, int flags, cv::BOWKMeansTrainer **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::BOWKMeansTrainer(clusterCount, cpp(termcrit), attempts, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWKMeansTrainer_delete
[32/64bit] kmeans - based class を用いて，視覚的単語の袋（bag of visual words）アプローチで視覚的語彙を学習します．
%prm
p1
p1 = sptr : IntPtr obj
%inst
元関数名(C#): features2d_BOWKMeansTrainer_delete
元DLLエクスポート名: features2d_BOWKMeansTrainer_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWKMeansTrainer_delete(cv::BOWKMeansTrainer *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWKMeansTrainer_cluster1
[32/64bit] クラスタは，ディスクリプタを学習します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
語彙は，クラスタセンターから構成されます．そのため，このメソッドは，語彙を返します．このメソッドの第1のバージョンでは，オブジェクトに格納された訓練ディスクリプタがクラスタリングされます．第2のバージョンでは，入力ディスクリプタがクラスタリングされます． Implements cv::BOWTrainer.

元関数名(C#): features2d_BOWKMeansTrainer_cluster1
元DLLエクスポート名: features2d_BOWKMeansTrainer_cluster1
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWKMeansTrainer_cluster1(cv::BOWKMeansTrainer *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const cv::Mat m = obj-&amp;gt;cluster();
    *returnValue = new cv::Mat(m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWKMeansTrainer_cluster2
[32/64bit] クラスタは，ディスクリプタを学習します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr descriptors
p3 = var : out IntPtr returnValue
%inst
語彙は，クラスタセンターから構成されます．そのため，このメソッドは，語彙を返します．このメソッドの第1のバージョンでは，オブジェクトに格納された訓練ディスクリプタがクラスタリングされます．第2のバージョンでは，入力ディスクリプタがクラスタリングされます． Implements cv::BOWTrainer.

元関数名(C#): features2d_BOWKMeansTrainer_cluster2
元DLLエクスポート名: features2d_BOWKMeansTrainer_cluster2
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWKMeansTrainer_cluster2(cv::BOWKMeansTrainer *obj, cv::Mat *descriptors, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const cv::Mat m = obj-&amp;gt;cluster(*descriptors);
    *returnValue = new cv::Mat(m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWImgDescriptorExtractor_new1_Ptr
[32/64bit] cv::BOWImgDescriptorExtractor のインスタンスを生成します
%prm
p1,p2,p3
p1 = sptr : IntPtr dextractor
p2 = sptr : IntPtr dmatcher
p3 = var : out IntPtr returnValue
%inst
視覚的単語の袋を用いて画像ディスクリプタを計算するために， cv::BOWTrainer.Class を実装します．

この計算は，以下のステップで構成されます．



与えられた画像とそのキーポイントセットに対するディスクリプタを計算します．

各キーポイントディスクリプタに対して，語彙から最も近い視覚的な単語を見つけます．

画像中に現れる語彙の正規化されたヒストグラムである，bag-of-words画像記述子を計算します．ヒストグラムのi番目のビンは，与えられた画像における語彙のi番目の単語の頻度を表します．


元関数名(C#): features2d_BOWImgDescriptorExtractor_new1_Ptr
元DLLエクスポート名: features2d_BOWImgDescriptorExtractor_new1_Ptr
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWImgDescriptorExtractor_new1_Ptr(
    cv::Ptr&amp;lt;cv::DescriptorExtractor&amp;gt; *dextractor, cv::Ptr&amp;lt;cv::DescriptorMatcher&amp;gt; *dmatcher, cv::BOWImgDescriptorExtractor **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::BOWImgDescriptorExtractor(*dextractor, *dmatcher);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWImgDescriptorExtractor_new2_Ptr
[32/64bit] cv::BOWImgDescriptorExtractor のインスタンスを生成します
%prm
p1,p2
p1 = sptr : IntPtr dmatcher
p2 = var : out IntPtr returnValue
%inst
視覚的単語の袋を用いて画像ディスクリプタを計算するために， cv::BOWTrainer.Class を実装します．

この計算は，以下のステップで構成されます．



与えられた画像とそのキーポイントセットに対するディスクリプタを計算します．

各キーポイントディスクリプタに対して，語彙から最も近い視覚的な単語を見つけます．

画像中に現れる語彙の正規化されたヒストグラムである，bag-of-words画像記述子を計算します．ヒストグラムのi番目のビンは，与えられた画像における語彙のi番目の単語の頻度を表します．


元関数名(C#): features2d_BOWImgDescriptorExtractor_new2_Ptr
元DLLエクスポート名: features2d_BOWImgDescriptorExtractor_new2_Ptr
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWImgDescriptorExtractor_new2_Ptr(
    cv::Ptr&amp;lt;cv::DescriptorMatcher&amp;gt; *dmatcher, cv::BOWImgDescriptorExtractor **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::BOWImgDescriptorExtractor(*dmatcher);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWImgDescriptorExtractor_new1_RawPtr
[32/64bit] cv::BOWImgDescriptorExtractor のインスタンスを生成します
%prm
p1,p2,p3
p1 = sptr : IntPtr dextractor
p2 = sptr : IntPtr dmatcher
p3 = var : out IntPtr returnValue
%inst
視覚的単語の袋を用いて画像ディスクリプタを計算するために， cv::BOWTrainer.Class を実装します．

この計算は，以下のステップで構成されます．



与えられた画像とそのキーポイントセットに対するディスクリプタを計算します．

各キーポイントディスクリプタに対して，語彙から最も近い視覚的な単語を見つけます．

画像中に現れる語彙の正規化されたヒストグラムである，bag-of-words画像記述子を計算します．ヒストグラムのi番目のビンは，与えられた画像における語彙のi番目の単語の頻度を表します．


元関数名(C#): features2d_BOWImgDescriptorExtractor_new1_RawPtr
元DLLエクスポート名: features2d_BOWImgDescriptorExtractor_new1_RawPtr
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWImgDescriptorExtractor_new1_RawPtr(
    cv::DescriptorExtractor *dextractor, cv::DescriptorMatcher *dmatcher, cv::BOWImgDescriptorExtractor **returnValue)
{
    BEGIN_WRAP
    // do not delete dextractor and dmatcher
    const cv::Ptr&amp;lt;cv::DescriptorExtractor&amp;gt; dextractorPtr(dextractor, DescriptorExtractorDeleter);
    const cv::Ptr&amp;lt;cv::DescriptorMatcher&amp;gt; dmatcherPtr(dmatcher, DescriptorMatcherDeleter);
    *returnValue = new cv::BOWImgDescriptorExtractor(dextractorPtr, dmatcherPtr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWImgDescriptorExtractor_new2_RawPtr
[32/64bit] cv::BOWImgDescriptorExtractor のインスタンスを生成します
%prm
p1,p2
p1 = sptr : IntPtr dmatcher
p2 = var : out IntPtr returnValue
%inst
視覚的単語の袋を用いて画像ディスクリプタを計算するために， cv::BOWTrainer.Class を実装します．

この計算は，以下のステップで構成されます．



与えられた画像とそのキーポイントセットに対するディスクリプタを計算します．

各キーポイントディスクリプタに対して，語彙から最も近い視覚的な単語を見つけます．

画像中に現れる語彙の正規化されたヒストグラムである，bag-of-words画像記述子を計算します．ヒストグラムのi番目のビンは，与えられた画像における語彙のi番目の単語の頻度を表します．


元関数名(C#): features2d_BOWImgDescriptorExtractor_new2_RawPtr
元DLLエクスポート名: features2d_BOWImgDescriptorExtractor_new2_RawPtr
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWImgDescriptorExtractor_new2_RawPtr(
    cv::DescriptorMatcher *dmatcher, cv::BOWImgDescriptorExtractor **returnValue)
{
    BEGIN_WRAP
    // do not delete dmatcher
    const cv::Ptr&amp;lt;cv::DescriptorMatcher&amp;gt; dmatcherPtr(dmatcher, DescriptorMatcherDeleter);
    *returnValue = new cv::BOWImgDescriptorExtractor(dmatcherPtr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWImgDescriptorExtractor_delete
[32/64bit] cv::BOWImgDescriptorExtractor のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
視覚的単語の袋を用いて画像ディスクリプタを計算するために， cv::BOWTrainer.Class を実装します．

この計算は，以下のステップで構成されます．



与えられた画像とそのキーポイントセットに対するディスクリプタを計算します．

各キーポイントディスクリプタに対して，語彙から最も近い視覚的な単語を見つけます．

画像中に現れる語彙の正規化されたヒストグラムである，bag-of-words画像記述子を計算します．ヒストグラムのi番目のビンは，与えられた画像における語彙のi番目の単語の頻度を表します．


元関数名(C#): features2d_BOWImgDescriptorExtractor_delete
元DLLエクスポート名: features2d_BOWImgDescriptorExtractor_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWImgDescriptorExtractor_delete(cv::BOWImgDescriptorExtractor *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWImgDescriptorExtractor_setVocabulary
[32/64bit] 視覚的な語彙を設定します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr vocabulary
%inst
元関数名(C#): features2d_BOWImgDescriptorExtractor_setVocabulary
元DLLエクスポート名: features2d_BOWImgDescriptorExtractor_setVocabulary
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWImgDescriptorExtractor_setVocabulary(cv::BOWImgDescriptorExtractor *obj, cv::Mat *vocabulary)
{
    BEGIN_WRAP
    obj-&amp;gt;setVocabulary(*vocabulary);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWImgDescriptorExtractor_getVocabulary
[32/64bit] 設定された語彙を返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): features2d_BOWImgDescriptorExtractor_getVocabulary
元DLLエクスポート名: features2d_BOWImgDescriptorExtractor_getVocabulary
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWImgDescriptorExtractor_getVocabulary(cv::BOWImgDescriptorExtractor *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    cv::Mat m = obj-&amp;gt;getVocabulary();
    *returnValue = new cv::Mat(m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWImgDescriptorExtractor_compute11
[32/64bit] set visual vocabulary を用いて，画像ディスクリプタを計算します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = sptr : IntPtr keypoints
p4 = sptr : IntPtr imgDescriptor
p5 = sptr : IntPtr pointIdxsOfClusters
p6 = sptr : IntPtr descriptors
%inst
元関数名(C#): features2d_BOWImgDescriptorExtractor_compute11
元DLLエクスポート名: features2d_BOWImgDescriptorExtractor_compute11
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWImgDescriptorExtractor_compute11(
    cv::BOWImgDescriptorExtractor *obj, cv::_InputArray *image, std::vector&amp;lt;cv::KeyPoint&amp;gt; *keypoints, cv::_OutputArray *imgDescriptor, 
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt;* pointIdxsOfClusters, cv::Mat* descriptors)
{
    BEGIN_WRAP
    obj-&amp;gt;compute(*image, *keypoints, *imgDescriptor, pointIdxsOfClusters, descriptors);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWImgDescriptorExtractor_compute12
[32/64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr keypointDescriptors
p3 = sptr : IntPtr imgDescriptor
p4 = sptr : IntPtr pointIdxsOfClusters
%inst
元関数名(C#): features2d_BOWImgDescriptorExtractor_compute12
元DLLエクスポート名: features2d_BOWImgDescriptorExtractor_compute12
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWImgDescriptorExtractor_compute12(
    cv::BOWImgDescriptorExtractor *obj, cv::_InputArray *keypointDescriptors, 
    cv::_OutputArray *imgDescriptor,     std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt;* pointIdxsOfClusters)
{
    BEGIN_WRAP
    obj-&amp;gt;compute(*keypointDescriptors, *imgDescriptor, pointIdxsOfClusters);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWImgDescriptorExtractor_compute2
[32/64bit] features2d_BOWImgDescriptorExtractor_compute2
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = sptr : IntPtr keypoints
p4 = sptr : IntPtr imgDescriptor
%inst
元関数名(C#): features2d_BOWImgDescriptorExtractor_compute2
元DLLエクスポート名: features2d_BOWImgDescriptorExtractor_compute2
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWImgDescriptorExtractor_compute2(
    cv::BOWImgDescriptorExtractor *obj, cv::Mat *image, std::vector&amp;lt;cv::KeyPoint&amp;gt; *keypoints, cv::Mat *imgDescriptor)
{
    BEGIN_WRAP
    obj-&amp;gt;compute2(*image, *keypoints, *imgDescriptor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWImgDescriptorExtractor_descriptorSize
[32/64bit] vocabularyが設定されている場合は，画像ディスクリプタのサイズを返します．そうでない場合は，0を返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_BOWImgDescriptorExtractor_descriptorSize
元DLLエクスポート名: features2d_BOWImgDescriptorExtractor_descriptorSize
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWImgDescriptorExtractor_descriptorSize(cv::BOWImgDescriptorExtractor *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;descriptorSize();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_BOWImgDescriptorExtractor_descriptorType
[32/64bit] 画像ディスクリプタのタイプを返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_BOWImgDescriptorExtractor_descriptorType
元DLLエクスポート名: features2d_BOWImgDescriptorExtractor_descriptorType
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_BOW.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BOWImgDescriptorExtractor_descriptorType(cv::BOWImgDescriptorExtractor *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;descriptorType();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_BOW

%index
features2d_DescriptorMatcher_add
[32/64bit] CPU(trainDescCollectionis) または GPU(utrainDescCollectionis) のディスクリプタコレクションを学習するために，ディスクリプタを追加します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr[] descriptors
p3 = int : int descriptorLength
%inst
コレクションが空ではない場合，新しいディスクリプタは，既存の訓練ディスクリプタに追加されます．cv::FlannBasedMatcherで再実装されました．

元関数名(C#): features2d_DescriptorMatcher_add
元DLLエクスポート名: features2d_DescriptorMatcher_add
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_DescriptorMatcher_add(cv::DescriptorMatcher *obj, cv::Mat **descriptors, int descriptorLength)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; descriptorsVec(descriptorLength);
    for (int i = 0; i &amp;lt; descriptorLength; i++)    
        descriptorsVec[i] = *descriptors[i];
    obj-&amp;gt;add(descriptorsVec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_DescriptorMatcher_getTrainDescriptors
[32/64bit] 列車ディスクリプタコレクション trainDescCollection への定数リンクを返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr dst
%inst
元関数名(C#): features2d_DescriptorMatcher_getTrainDescriptors
元DLLエクスポート名: features2d_DescriptorMatcher_getTrainDescriptors
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_DescriptorMatcher_getTrainDescriptors(cv::DescriptorMatcher *obj, std::vector&amp;lt;cv::Mat&amp;gt; *dst)
{
    BEGIN_WRAP
    *dst = obj-&amp;gt;getTrainDescriptors();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_DescriptorMatcher_clear
[32/64bit] 列車ディスクリプタコレクションをクリアします．
%prm
p1
p1 = sptr : IntPtr obj
%inst
cv::Algorithm.Reimplemented in cv::FlannBasedMatcher.Reimplemented from cv::Algorithm.Reimplemented in cv::FlannBasedMatcher.

元関数名(C#): features2d_DescriptorMatcher_clear
元DLLエクスポート名: features2d_DescriptorMatcher_clear
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_DescriptorMatcher_clear(cv::DescriptorMatcher *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;clear();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_DescriptorMatcher_empty
[32/64bit] 両方のコレクションに列車ディスクリプタが存在しない場合は，真を返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
cv::Algorithm を再実装したものです．

元関数名(C#): features2d_DescriptorMatcher_empty
元DLLエクスポート名: features2d_DescriptorMatcher_empty
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_DescriptorMatcher_empty(cv::DescriptorMatcher *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;empty() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_DescriptorMatcher_isMaskSupported
[32/64bit] ディスクリプタ Matcher が，許可されたマッチのマスキングをサポートする場合に true を返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
cv::FlannBasedMatcher, および cv::BFMatcher で実装されています．

元関数名(C#): features2d_DescriptorMatcher_isMaskSupported
元DLLエクスポート名: features2d_DescriptorMatcher_isMaskSupported
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_DescriptorMatcher_isMaskSupported(cv::DescriptorMatcher *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;isMaskSupported() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_DescriptorMatcher_train
[32/64bit] ディスクリプタ Matcherを学習します．
%prm
p1
p1 = sptr : IntPtr obj
%inst
ディスクリプタ Matcherを学習します（例えば，flannインデックス）．マッチングを行うすべてのメソッドにおいて，マッチングの前に毎回 train() が実行されます．一部のディスクリプタ Matcher（例えば，BruteForceMatcher）は，このメソッドの実装が空です．その他の Matcher は，実際に内部構造を学習します（例えば， FlannBasedMatcher は flann::Index を学習します）．

元関数名(C#): features2d_DescriptorMatcher_train
元DLLエクスポート名: features2d_DescriptorMatcher_train
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_DescriptorMatcher_train(cv::DescriptorMatcher *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;train();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_DescriptorMatcher_match1
[32/64bit] クエリセットから，各ディスクリプタに最もマッチするものを見つけます．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr queryDescriptors
p3 = sptr : IntPtr trainDescriptors
p4 = sptr : IntPtr matches
p5 = sptr : IntPtr mask
%inst
このメソッドの第1のバージョンでは，訓練ディスクリプタが入力引数として渡されます．このメソッドの第2のバージョンでは， DescriptorMatcher::add によってセットされた訓練ディスクリプタコレクションが利用されます．オプションの mask （複数可）を渡すことで，どのクエリと訓練ディスクリプタをマッチングさせるかを指定できます．つまり， mask.at<uchar>(i,j) が0ではない場合にのみ， queryDescriptors[i] と trainDescriptors[j] がマッチングされます．

元関数名(C#): features2d_DescriptorMatcher_match1
元DLLエクスポート名: features2d_DescriptorMatcher_match1
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_DescriptorMatcher_match1(
    cv::DescriptorMatcher *obj, cv::Mat *queryDescriptors, 
    cv::Mat *trainDescriptors, std::vector&amp;lt;cv::DMatch&amp;gt; *matches, cv::Mat *mask)
{
    BEGIN_WRAP
    obj-&amp;gt;match(*queryDescriptors, *trainDescriptors, *matches, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_DescriptorMatcher_knnMatch1
[32/64bit] クエリセットから各ディスクリプタに対して，k個のベストマッチを見つけます．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr queryDescriptors
p3 = sptr : IntPtr trainDescriptors
p4 = sptr : IntPtr matches
p5 = int : int k
p6 = sptr : IntPtr mask
p7 = int : int compactResult
%inst
これらの DescriptorMatcher::match メソッドの拡張版は，各クエリディスクリプタに対して，複数のベストマッチを見つけます．これらのマッチは，距離の昇順で返されます．クエリディスクリプタと訓練ディスクリプタの詳細については， DescriptorMatcher::match を参照してください．

元関数名(C#): features2d_DescriptorMatcher_knnMatch1
元DLLエクスポート名: features2d_DescriptorMatcher_knnMatch1
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_DescriptorMatcher_knnMatch1(
    cv::DescriptorMatcher *obj, cv::Mat *queryDescriptors,
    cv::Mat *trainDescriptors, std::vector&amp;lt;std::vector&amp;lt;cv::DMatch&amp;gt; &amp;gt; *matches, int k,
    cv::Mat *mask, int compactResult)
{
    BEGIN_WRAP
    obj-&amp;gt;knnMatch(*queryDescriptors, *trainDescriptors, *matches, k, entity(mask), compactResult != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_DescriptorMatcher_radiusMatch1
[32/64bit] 各クエリディスクリプタに対して，指定された距離よりも遠くないトレーニングディスクリプタを見つけます．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr queryDescriptors
p3 = sptr : IntPtr trainDescriptors
p4 = sptr : IntPtr matches
p5 = float : float maxDistance
p6 = sptr : IntPtr mask
p7 = int : int compactResult
%inst
各クエリディスクリプタに対して，メソッドは，クエリディスクリプタとトレーニングディスクリプタの間の距離が maxDistance と同等かそれよりも小さくなるようなトレーニングディスクリプタを見つけます．検索されたマッチは，距離が大きい順に返されます．

元関数名(C#): features2d_DescriptorMatcher_radiusMatch1
元DLLエクスポート名: features2d_DescriptorMatcher_radiusMatch1
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_DescriptorMatcher_radiusMatch1(
    cv::DescriptorMatcher *obj, cv::Mat *queryDescriptors, 
    cv::Mat *trainDescriptors, std::vector&amp;lt;std::vector&amp;lt;cv::DMatch&amp;gt; &amp;gt; *matches, float maxDistance,
    cv::Mat *mask, int compactResult)
{
    BEGIN_WRAP
    obj-&amp;gt;radiusMatch(*queryDescriptors, *trainDescriptors, *matches, maxDistance, entity(mask), compactResult != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_DescriptorMatcher_match2
[32/64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr queryDescriptors
p3 = sptr : IntPtr matches
p4 = sptr : IntPtr[] masks
p5 = int : int masksSize
%inst
元関数名(C#): features2d_DescriptorMatcher_match2
元DLLエクスポート名: features2d_DescriptorMatcher_match2
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_DescriptorMatcher_match2(
    cv::DescriptorMatcher *obj, cv::Mat *queryDescriptors, std::vector&amp;lt;cv::DMatch&amp;gt; *matches,
    cv::Mat **masks, int masksSize)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; masksVal;
    if (masksSize != 0)
    {
        masksVal = std::vector&amp;lt;cv::Mat&amp;gt;(masksSize);
        for (int i = 0; i &amp;lt; masksSize; i++)
        {
            masksVal[i] = *(masks[i]);
        }
    }
    obj-&amp;gt;match(*queryDescriptors, *matches, masksVal);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_DescriptorMatcher_knnMatch2
[32/64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr queryDescriptors
p3 = sptr : IntPtr matches
p4 = int : int k
p5 = sptr : IntPtr[] masks
p6 = int : int masksSize
p7 = int : int compactResult
%inst
元関数名(C#): features2d_DescriptorMatcher_knnMatch2
元DLLエクスポート名: features2d_DescriptorMatcher_knnMatch2
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_DescriptorMatcher_knnMatch2(
    cv::DescriptorMatcher *obj, cv::Mat *queryDescriptors, std::vector&amp;lt;std::vector&amp;lt;cv::DMatch&amp;gt; &amp;gt; *matches, 
    int k, cv::Mat **masks, int masksSize, int compactResult)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; masksVal;
    if (masksSize != 0)
    {
        masksVal = std::vector&amp;lt;cv::Mat&amp;gt;(masksSize);
        for (int i = 0; i &amp;lt; masksSize; i++)
        {
            masksVal[i] = *(masks[i]);
        }
    }
    obj-&amp;gt;knnMatch(*queryDescriptors, *matches, k, masksVal, compactResult != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_DescriptorMatcher_radiusMatch2
[32/64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr queryDescriptors
p3 = sptr : IntPtr matches
p4 = float : float maxDistance
p5 = sptr : IntPtr[] masks
p6 = int : int masksSize
p7 = int : int compactResult
%inst
元関数名(C#): features2d_DescriptorMatcher_radiusMatch2
元DLLエクスポート名: features2d_DescriptorMatcher_radiusMatch2
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_DescriptorMatcher_radiusMatch2(
    cv::DescriptorMatcher *obj, cv::Mat *queryDescriptors, std::vector&amp;lt;std::vector&amp;lt;cv::DMatch&amp;gt; &amp;gt; *matches, 
    float maxDistance, cv::Mat **masks, int masksSize, int compactResult)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; masksVal;
    if (masksSize != 0)
    {
        masksVal = std::vector&amp;lt;cv::Mat&amp;gt;(masksSize);
        for (int i = 0; i &amp;lt; masksSize; i++)
        {
            masksVal[i] = *(masks[i]);
        }
    }
    obj-&amp;gt;radiusMatch(*queryDescriptors, *matches, maxDistance, masksVal, compactResult != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_DescriptorMatcher_create
[32/64bit] 与えられたタイプのディスクリプタ Matcher を，デフォルトのパラメータ（デフォルトコンストラクタを利用）で作成します．
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string descriptorMatcherType
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): features2d_DescriptorMatcher_create
元DLLエクスポート名: features2d_DescriptorMatcher_create
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_DescriptorMatcher_create(
    const char *descriptorMatcherType, cv::Ptr&amp;lt;cv::DescriptorMatcher&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const cv::Ptr&amp;lt;cv::DescriptorMatcher&amp;gt; ret = cv::DescriptorMatcher::create(descriptorMatcherType);
    *returnValue = new cv::Ptr&amp;lt;cv::DescriptorMatcher&amp;gt;(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_Ptr_DescriptorMatcher_get
[32/64bit] cv::DescriptorMatcher のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
キーポイントのディスクリプタをマッチングするための抽象的な基底クラス．

これには2つのマッチングメソッドがあり，画像のディスクリプタを別の画像や画像セットとマッチングさせることができます．


元関数名(C#): features2d_Ptr_DescriptorMatcher_get
元DLLエクスポート名: features2d_Ptr_DescriptorMatcher_get
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_DescriptorMatcher_get(
    cv::Ptr&amp;lt;cv::DescriptorMatcher&amp;gt; *ptr, cv::DescriptorMatcher **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_Ptr_DescriptorMatcher_delete
[32/64bit] cv::DescriptorMatcher のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
キーポイントのディスクリプタをマッチングするための抽象的な基底クラス．

これには2つのマッチングメソッドがあり，画像のディスクリプタを別の画像や画像セットとマッチングさせることができます．


元関数名(C#): features2d_Ptr_DescriptorMatcher_delete
元DLLエクスポート名: features2d_Ptr_DescriptorMatcher_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_DescriptorMatcher_delete(cv::Ptr&amp;lt;cv::DescriptorMatcher&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_BFMatcher_new
[32/64bit] cv::BFMatcher のインスタンスを生成します
%prm
p1,p2,p3
p1 = int : int normType
p2 = int : int crossCheck
p3 = var : out IntPtr returnValue
%inst
ブルートフォースディスクリプタ Matcher．

この Matcherは，第1の集合の各ディスクリプタに対して，第2の集合の中で最も近いディスクリプタを，それぞれ試しながら見つけます．このディスクリプタ Matcherは，ディスクリプタ集合の許容されるマッチングのマスクをサポートします．


元関数名(C#): features2d_BFMatcher_new
元DLLエクスポート名: features2d_BFMatcher_new
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BFMatcher_new(int normType, int crossCheck, cv::BFMatcher **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::BFMatcher(normType, crossCheck != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_BFMatcher_delete
[32/64bit] cv::BFMatcher のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
ブルートフォースディスクリプタ Matcher．

この Matcherは，第1の集合の各ディスクリプタに対して，第2の集合の中で最も近いディスクリプタを，それぞれ試しながら見つけます．このディスクリプタ Matcherは，ディスクリプタ集合の許容されるマッチングのマスクをサポートします．


元関数名(C#): features2d_BFMatcher_delete
元DLLエクスポート名: features2d_BFMatcher_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BFMatcher_delete(cv::BFMatcher *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_BFMatcher_isMaskSupported
[32/64bit] ディスクリプタ Matcher が，許可されたマッチのマスキングをサポートする場合に true を返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
cv::DescriptorMatcher を実装しています．

元関数名(C#): features2d_BFMatcher_isMaskSupported
元DLLエクスポート名: features2d_BFMatcher_isMaskSupported
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BFMatcher_isMaskSupported(cv::BFMatcher *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;isMaskSupported() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_Ptr_BFMatcher_get
[32/64bit] cv::BFMatcher のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
ブルートフォースディスクリプタ Matcher．

この Matcherは，第1の集合の各ディスクリプタに対して，第2の集合の中で最も近いディスクリプタを，それぞれ試しながら見つけます．このディスクリプタ Matcherは，ディスクリプタ集合の許容されるマッチングのマスクをサポートします．


元関数名(C#): features2d_Ptr_BFMatcher_get
元DLLエクスポート名: features2d_Ptr_BFMatcher_get
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_BFMatcher_get(cv::Ptr&amp;lt;cv::BFMatcher&amp;gt; *ptr, cv::BFMatcher **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_Ptr_BFMatcher_delete
[32/64bit] cv::BFMatcher のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
ブルートフォースディスクリプタ Matcher．

この Matcherは，第1の集合の各ディスクリプタに対して，第2の集合の中で最も近いディスクリプタを，それぞれ試しながら見つけます．このディスクリプタ Matcherは，ディスクリプタ集合の許容されるマッチングのマスクをサポートします．


元関数名(C#): features2d_Ptr_BFMatcher_delete
元DLLエクスポート名: features2d_Ptr_BFMatcher_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_BFMatcher_delete(cv::Ptr&amp;lt;cv::BFMatcher&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_FlannBasedMatcher_new
[32/64bit] cv::FlannBasedMatcher のインスタンスを生成します
%prm
p1,p2,p3
p1 = sptr : IntPtr indexParams
p2 = sptr : IntPtr searchParams
p3 = var : out IntPtr returnValue
%inst
Flann ベースのディスクリプタ Matcher．

この Matcherは，訓練ディスクリプタ集合に対して cv::flann::Index を学習させ，最適なマッチを見つけるためにその最近接探索メソッドを呼び出します．そのため，大規模な訓練コレクションをマッチングする場合，このマッチャは，ブルートフォース・マッチャよりも高速になる可能性があります．flann::Index がサポートしていないので，FlannBasedMatcher は，ディスクリプタ集合の許容されるマッチをマスクすることをサポートしません．


元関数名(C#): features2d_FlannBasedMatcher_new
元DLLエクスポート名: features2d_FlannBasedMatcher_new
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_FlannBasedMatcher_new(
    cv::Ptr&amp;lt;cv::flann::IndexParams&amp;gt; *indexParams, cv::Ptr&amp;lt;cv::flann::SearchParams&amp;gt; *searchParams, cv::FlannBasedMatcher **returnValue)
{
    BEGIN_WRAP
    cv::Ptr&amp;lt;cv::flann::IndexParams&amp;gt; indexParamsPtr;
    cv::Ptr&amp;lt;cv::flann::SearchParams&amp;gt; searchParamsPtr;
    if (indexParams == nullptr)
        indexParamsPtr = cv::makePtr&amp;lt;cv::flann::KDTreeIndexParams&amp;gt;();
    else
        indexParamsPtr = *indexParams;
    
    if (searchParams == nullptr)
        searchParamsPtr = cv::makePtr&amp;lt;cv::flann::SearchParams&amp;gt;();
    else    
        searchParamsPtr = *searchParams;
    
    *returnValue = new cv::FlannBasedMatcher(indexParamsPtr, searchParamsPtr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_FlannBasedMatcher_delete
[32/64bit] cv::FlannBasedMatcher のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
Flann ベースのディスクリプタ Matcher．

この Matcherは，訓練ディスクリプタ集合に対して cv::flann::Index を学習させ，最適なマッチを見つけるためにその最近接探索メソッドを呼び出します．そのため，大規模な訓練コレクションをマッチングする場合，このマッチャは，ブルートフォース・マッチャよりも高速になる可能性があります．flann::Index がサポートしていないので，FlannBasedMatcher は，ディスクリプタ集合の許容されるマッチをマスクすることをサポートしません．


元関数名(C#): features2d_FlannBasedMatcher_delete
元DLLエクスポート名: features2d_FlannBasedMatcher_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_FlannBasedMatcher_delete(cv::FlannBasedMatcher *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_FlannBasedMatcher_add
[32/64bit] CPU(trainDescCollectionis) または GPU(utrainDescCollectionis) のディスクリプタコレクションを学習するために，ディスクリプタを追加します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr[] descriptors
p3 = int : int descriptorsSize
%inst
コレクションが空ではない場合，新しいディスクリプタは，既存の訓練ディスクリプタに追加されます．

元関数名(C#): features2d_FlannBasedMatcher_add
元DLLエクスポート名: features2d_FlannBasedMatcher_add
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_FlannBasedMatcher_add(
    cv::FlannBasedMatcher *obj, cv::Mat **descriptors, int descriptorsSize)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; descriptorsVal(descriptorsSize);
    for (int i = 0; i &amp;lt; descriptorsSize; i++)
    {
        descriptorsVal[i] = *(descriptors[i]);
    }
    obj-&amp;gt;add(descriptorsVal);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_FlannBasedMatcher_clear
[32/64bit] 列車ディスクリプタコレクションをクリアします．
%prm
p1
p1 = sptr : IntPtr obj
%inst
cv::DescriptorMatcher を再実装したものです．

元関数名(C#): features2d_FlannBasedMatcher_clear
元DLLエクスポート名: features2d_FlannBasedMatcher_clear
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_FlannBasedMatcher_clear(cv::FlannBasedMatcher *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;clear();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_FlannBasedMatcher_train
[32/64bit] ディスクリプタ Matcherを学習します．
%prm
p1
p1 = sptr : IntPtr obj
%inst
ディスクリプタ Matcherを学習します（例えば，flannインデックス）．マッチングを行うすべてのメソッドにおいて，マッチングの前に毎回 train() が実行されます．一部のディスクリプタ Matcher（例えば，BruteForceMatcher）は，このメソッドの実装が空です．その他の Matcher は，実際に内部構造を学習します（例えば， FlannBasedMatcher は flann::Index を学習します）． cv::DescriptorMatcher からの再実装．

元関数名(C#): features2d_FlannBasedMatcher_train
元DLLエクスポート名: features2d_FlannBasedMatcher_train
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_FlannBasedMatcher_train(cv::FlannBasedMatcher *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;train();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_FlannBasedMatcher_isMaskSupported
[32/64bit] ディスクリプタ Matcher が，許可されたマッチのマスキングをサポートする場合に true を返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
cv::DescriptorMatcher を実装しています．

元関数名(C#): features2d_FlannBasedMatcher_isMaskSupported
元DLLエクスポート名: features2d_FlannBasedMatcher_isMaskSupported
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_FlannBasedMatcher_isMaskSupported(cv::FlannBasedMatcher *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;isMaskSupported() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_Ptr_FlannBasedMatcher_get
[32/64bit] cv::FlannBasedMatcher のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
Flann ベースのディスクリプタ Matcher．

この Matcherは，訓練ディスクリプタ集合に対して cv::flann::Index を学習させ，最適なマッチを見つけるためにその最近接探索メソッドを呼び出します．そのため，大規模な訓練コレクションをマッチングする場合，このマッチャは，ブルートフォース・マッチャよりも高速になる可能性があります．flann::Index がサポートしていないので，FlannBasedMatcher は，ディスクリプタ集合の許容されるマッチをマスクすることをサポートしません．


元関数名(C#): features2d_Ptr_FlannBasedMatcher_get
元DLLエクスポート名: features2d_Ptr_FlannBasedMatcher_get
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_FlannBasedMatcher_get(
    cv::Ptr&amp;lt;cv::FlannBasedMatcher&amp;gt; *ptr, cv::FlannBasedMatcher **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_Ptr_FlannBasedMatcher_delete
[32/64bit] cv::FlannBasedMatcher のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
Flann ベースのディスクリプタ Matcher．

この Matcherは，訓練ディスクリプタ集合に対して cv::flann::Index を学習させ，最適なマッチを見つけるためにその最近接探索メソッドを呼び出します．そのため，大規模な訓練コレクションをマッチングする場合，このマッチャは，ブルートフォース・マッチャよりも高速になる可能性があります．flann::Index がサポートしていないので，FlannBasedMatcher は，ディスクリプタ集合の許容されるマッチをマスクすることをサポートしません．


元関数名(C#): features2d_Ptr_FlannBasedMatcher_delete
元DLLエクスポート名: features2d_Ptr_FlannBasedMatcher_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_DescriptorMatcher.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_FlannBasedMatcher_delete(cv::Ptr&amp;lt;cv::FlannBasedMatcher&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_DescriptorMatcher

%index
features2d_Feature2D_detect_Mat1
[32/64bit] 画像（第1の形式）または画像集合（第2の形式）からキーポイントを検出します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr detector
p2 = sptr : IntPtr image
p3 = sptr : IntPtr keypoints
p4 = sptr : IntPtr mask
%inst
元関数名(C#): features2d_Feature2D_detect_Mat1
元DLLエクスポート名: features2d_Feature2D_detect_Mat1
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Feature2D_detect_Mat1(
    cv::Feature2D *detector,
    cv::Mat *image,
    std::vector&amp;lt;cv::KeyPoint&amp;gt; *keypoints,
    cv::Mat *mask)
{
    BEGIN_WRAP
    detector-&amp;gt;detect(*image, *keypoints, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Feature2D_detect_Mat2
[32/64bit] 画像（第1の形式）または画像集合（第2の形式）からキーポイントを検出します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr detector
p2 = sptr : IntPtr[] images
p3 = int : int imageLength
p4 = sptr : IntPtr keypoints
p5 = var : IntPtr[]? mask
%inst
元関数名(C#): features2d_Feature2D_detect_Mat2
元DLLエクスポート名: features2d_Feature2D_detect_Mat2
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Feature2D_detect_Mat2(
    cv::Feature2D *detector,
    cv::Mat **images, int imageLength,
    std::vector&amp;lt;std::vector&amp;lt;cv::KeyPoint&amp;gt; &amp;gt; *keypoints, 
    cv::Mat **mask)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; imageVec(imageLength);
    std::vector&amp;lt;cv::Mat&amp;gt; maskVec;
    
    for (auto i = 0; i &amp;lt; imageLength; i++)
        imageVec.push_back(*images[i]);
    
    if (mask != nullptr)
    {
        maskVec.reserve(imageLength);
        for (auto i = 0; i &amp;lt; imageLength; i++)
            maskVec.push_back(*mask[i]);
    }

    detector-&amp;gt;detect(imageVec, *keypoints, maskVec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Feature2D_detect_InputArray
[32/64bit] 画像（第1の形式）または画像集合（第2の形式）からキーポイントを検出します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr detector
p2 = sptr : IntPtr image
p3 = sptr : IntPtr keypoints
p4 = sptr : IntPtr mask
%inst
元関数名(C#): features2d_Feature2D_detect_InputArray
元DLLエクスポート名: features2d_Feature2D_detect_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Feature2D_detect_InputArray(
    cv::Feature2D *obj, cv::_InputArray *image, std::vector&amp;lt;cv::KeyPoint&amp;gt; *keypoints, cv::Mat *mask)
{
    BEGIN_WRAP
    obj-&amp;gt;detect(*image, *keypoints, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Feature2D_compute1
[32/64bit] 画像（第1の形式）または画像集合（第2の形式）から検出されたキーポイントの集合に対するディスクリプタを計算します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = sptr : IntPtr keypoints
p4 = sptr : IntPtr descriptors
%inst
cv::xfeatures2d::DAISYで再実装されています．

元関数名(C#): features2d_Feature2D_compute1
元DLLエクスポート名: features2d_Feature2D_compute1
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Feature2D_compute1(
    cv::Feature2D *obj,
    cv::_InputArray *image, std::vector&amp;lt;cv::KeyPoint&amp;gt; *keypoints, cv::_OutputArray *descriptors)
{
    BEGIN_WRAP
    obj-&amp;gt;compute(*image, *keypoints, *descriptors);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Feature2D_compute2
[32/64bit] 画像（第1の形式）または画像集合（第2の形式）から検出されたキーポイントの集合に対するディスクリプタを計算します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr detector
p2 = sptr : IntPtr[] images
p3 = int : int imageLength
p4 = sptr : IntPtr keypoints
p5 = sptr : IntPtr[] descriptors
p6 = int : int descriptorsLength
%inst
cv::xfeatures2d::DAISYで再実装されています．

元関数名(C#): features2d_Feature2D_compute2
元DLLエクスポート名: features2d_Feature2D_compute2
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Feature2D_compute2(
    cv::Feature2D *detector, cv::Mat **images, int imageLength,
    std::vector&amp;lt;std::vector&amp;lt;cv::KeyPoint&amp;gt; &amp;gt; *keypoints, cv::Mat **descriptors, int descriptorsLength)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; imageVec(imageLength);
    std::vector&amp;lt;cv::Mat&amp;gt; descriptorsVec(descriptorsLength);
    
    for (auto i = 0; i &amp;lt; imageLength; i++)
        imageVec.push_back(*images[i]);
    for (auto i = 0; i &amp;lt; descriptorsLength; i++)
        descriptorsVec.push_back(*descriptors[i]);

    detector-&amp;gt;compute(imageVec, *keypoints, descriptorsVec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Feature2D_detectAndCompute
[32/64bit] キーポイントを検出し，ディスクリプタを計算します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr detector
p2 = sptr : IntPtr image
p3 = sptr : IntPtr mask
p4 = sptr : IntPtr keypoints
p5 = sptr : IntPtr descriptors
p6 = int : int useProvidedKeypoints
%inst
元関数名(C#): features2d_Feature2D_detectAndCompute
元DLLエクスポート名: features2d_Feature2D_detectAndCompute
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Feature2D_detectAndCompute(
    cv::Feature2D *detector, cv::_InputArray *image, cv::_InputArray *mask, 
    std::vector&amp;lt;cv::KeyPoint&amp;gt; *keypoints, cv::_OutputArray *descriptors, int useProvidedKeypoints)
{
    BEGIN_WRAP
    detector-&amp;gt;detectAndCompute(entity(image), entity(mask), *keypoints, *descriptors, useProvidedKeypoints != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Feature2D_descriptorSize
[32/64bit] features2d_Feature2D_descriptorSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_Feature2D_descriptorSize
元DLLエクスポート名: features2d_Feature2D_descriptorSize
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Feature2D_descriptorSize(cv::Feature2D *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;descriptorSize();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Feature2D_descriptorType
[32/64bit] features2d_Feature2D_descriptorType
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_Feature2D_descriptorType
元DLLエクスポート名: features2d_Feature2D_descriptorType
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Feature2D_descriptorType(cv::Feature2D *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;descriptorType();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Feature2D_defaultNorm
[32/64bit] features2d_Feature2D_defaultNorm
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_Feature2D_defaultNorm
元DLLエクスポート名: features2d_Feature2D_defaultNorm
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Feature2D_defaultNorm(cv::Feature2D *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;defaultNorm();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Feature2D_empty
[32/64bit] 検出器オブジェクトが空の場合は，trueを返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
cv::Algorithm を再実装したものです．

元関数名(C#): features2d_Feature2D_empty
元DLLエクスポート名: features2d_Feature2D_empty
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Feature2D_empty(cv::Feature2D *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;empty() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Feature2D_write
[32/64bit] features2d_Feature2D_write
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string fileName
%inst
元関数名(C#): features2d_Feature2D_write
元DLLエクスポート名: features2d_Feature2D_write
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Feature2D_write(cv::Feature2D *obj, const char *fileName)
{
    BEGIN_WRAP
    const cv::String fileNameString(fileName);
    obj-&amp;gt;write(fileNameString);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Feature2D_read
[32/64bit] features2d_Feature2D_read
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string fileName
%inst
元関数名(C#): features2d_Feature2D_read
元DLLエクスポート名: features2d_Feature2D_read
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Feature2D_read(cv::Feature2D *obj, const char *fileName)
{
    BEGIN_WRAP
    obj-&amp;gt;read(fileName);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Feature2D_getDefaultName
[32/64bit] アルゴリズムの文字列識別子を返します．この文字列は，オブジェクトがファイルや文字列に保存される際に，xml/yml のトップレベルノードタグとして利用されます．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr returnValue
%inst
cv::Algorithm.Reimplemented from cv::AKAZE, cv::KAZE, cv::SimpleBlobDetector, cv::GFTTDetector, cv::AgastFeatureDetector, cv::FastFeatureDetector, cv::MSER, cv::ORB, cv::BRISK, cv::SIFT, and cv::AffineFeature.

元関数名(C#): features2d_Feature2D_getDefaultName
元DLLエクスポート名: features2d_Feature2D_getDefaultName
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Feature2D_getDefaultName(cv::Feature2D *obj, std::string *returnValue)
{
    BEGIN_WRAP
    returnValue-&amp;gt;assign(obj-&amp;gt;getDefaultName());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_SIFT_create
[32/64bit] 注意 フィルタリングが適用されると，コントラスト閾値は nOctaveLayers で割られます．nOctaveLayers がデフォルトに設定されていて，D. Lowe の論文で使われている値（0.03）を利用したい場合は，この引数を 0.09 に設定してください．
%prm
p1,p2,p3,p4,p5,p6
p1 = int : int nFeatures
p2 = int : int nOctaveLayers
p3 = double : double contrastThreshold
p4 = double : double edgeThreshold
p5 = double : double sigma
p6 = var : out IntPtr returnValue
%inst
元関数名(C#): features2d_SIFT_create
元DLLエクスポート名: features2d_SIFT_create
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_SIFT_create(
    int nfeatures, int nOctaveLayers,
    double contrastThreshold, double edgeThreshold, double sigma, 
    cv::Ptr&amp;lt;cv::SIFT&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::SIFT::create(
        nfeatures, nOctaveLayers, contrastThreshold, edgeThreshold, sigma);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_SIFT_delete
[32/64bit] cv::SIFT のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
D. LoweによるScale Invariant Feature Transform (SIFT) アルゴリズムを用いて，キーポイントを抽出し，ディスクリプタを計算するクラス [153] ．


元関数名(C#): features2d_Ptr_SIFT_delete
元DLLエクスポート名: features2d_Ptr_SIFT_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_SIFT_delete(cv::Ptr&amp;lt;cv::SIFT&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_SIFT_get
[32/64bit] cv::SIFT のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
D. LoweによるScale Invariant Feature Transform (SIFT) アルゴリズムを用いて，キーポイントを抽出し，ディスクリプタを計算するクラス [153] ．


元関数名(C#): features2d_Ptr_SIFT_get
元DLLエクスポート名: features2d_Ptr_SIFT_get
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_SIFT_get(cv::Ptr&amp;lt;cv::SIFT&amp;gt; *ptr, cv::SIFT **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_BRISK_create1
[32/64bit] BRISKのコンストラクタです．
%prm
p1,p2,p3,p4
p1 = int : int thresh
p2 = int : int octaves
p3 = float : float patternScale
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): features2d_BRISK_create1
元DLLエクスポート名: features2d_BRISK_create1
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BRISK_create1(
    int thresh, int octaves, float patternScale, cv::Ptr&amp;lt;cv::BRISK&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::BRISK::create(thresh, octaves, patternScale);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_BRISK_create2
[32/64bit] カスタムパターン用のBRISKコンストラクタです。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = var : float[] radiusList
p2 = int : int radiusListLength
p3 = var : int[] numberList
p4 = int : int numberListLength
p5 = float : float dMax
p6 = float : float dMin
p7 = var : int[]? indexChange
p8 = int : int indexChangeLength
p9 = var : out IntPtr returnValue
%inst
元関数名(C#): features2d_BRISK_create2
元DLLエクスポート名: features2d_BRISK_create2
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BRISK_create2(
    float *radiusList, int radiusListLength, 
    int *numberList, int numberListLength,
    float dMax, float dMin,
    int *indexChange, int indexChangeLength, 
    cv::Ptr&amp;lt;cv::BRISK&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const std::vector&amp;lt;float&amp;gt; radiusListVec(radiusList, radiusList + radiusListLength);
    const std::vector&amp;lt;int&amp;gt; numberListVec(numberList, numberList + numberListLength);
    std::vector&amp;lt;int&amp;gt; indexChangeVec;
    if (indexChange != nullptr)
        indexChangeVec = std::vector&amp;lt;int&amp;gt;(indexChange, indexChange + indexChangeLength);

    const auto ptr = cv::BRISK::create(radiusListVec, numberListVec, dMax, dMin, indexChangeVec);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_BRISK_create3
[32/64bit] カスタムパターン，検出閾値，オクターブのためのBRISKコンストラクタ．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11
p1 = int : int thresh
p2 = int : int octaves
p3 = var : float[] radiusList
p4 = int : int radiusListLength
p5 = var : int[] numberList
p6 = int : int numberListLength
p7 = float : float dMax
p8 = float : float dMin
p9 = var : int[]? indexChange
p10 = int : int indexChangeLength
p11 = var : out IntPtr returnValue
%inst
元関数名(C#): features2d_BRISK_create3
元DLLエクスポート名: features2d_BRISK_create3
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_BRISK_create3(
    int thresh, int octaves, 
    float *radiusList, int radiusListLength,
    int *numberList, int numberListLength,
    float dMax, float dMin,
    int *indexChange, int indexChangeLength, 
    cv::Ptr&amp;lt;cv::BRISK&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const std::vector&amp;lt;float&amp;gt; radiusListVec(radiusList, radiusList + radiusListLength);
    const std::vector&amp;lt;int&amp;gt; numberListVec(numberList, numberList + numberListLength);
    std::vector&amp;lt;int&amp;gt; indexChangeVec;
    if (indexChange != nullptr)
        indexChangeVec = std::vector&amp;lt;int&amp;gt;(indexChange, indexChange + indexChangeLength);

    const auto ptr = cv::BRISK::create(thresh, octaves, radiusListVec, numberListVec, dMax, dMin, indexChangeVec);
    *returnValue = clone(ptr);
    END_WRAP  
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_BRISK_delete
[32/64bit] cv::BRISK のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
139]で述べられている，BRISKキーポイント検出器とディスクリプタ抽出器を実装したクラス．


元関数名(C#): features2d_Ptr_BRISK_delete
元DLLエクスポート名: features2d_Ptr_BRISK_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_BRISK_delete(cv::Ptr&amp;lt;cv::BRISK&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_BRISK_get
[32/64bit] cv::BRISK のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
139]で述べられている，BRISKキーポイント検出器とディスクリプタ抽出器を実装したクラス．


元関数名(C#): features2d_Ptr_BRISK_get
元DLLエクスポート名: features2d_Ptr_BRISK_get
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_BRISK_get(cv::Ptr&amp;lt;cv::BRISK&amp;gt; *ptr, cv::BRISK **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_create
[32/64bit] ORB コンストラクタ．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = int : int nFeatures
p2 = float : float scaleFactor
p3 = int : int nlevels
p4 = int : int edgeThreshold
p5 = int : int firstLevel
p6 = int : int wtaK
p7 = int : int scoreType
p8 = int : int patchSize
p9 = int : int fastThreshold
p10 = var : out IntPtr returnValue
%inst
元関数名(C#): features2d_ORB_create
元DLLエクスポート名: features2d_ORB_create
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_create(
    int nFeatures, float scaleFactor, int nlevels, int edgeThreshold,
    int firstLevel, int wtaK, int scoreType, int patchSize, int fastThreshold,
    cv::Ptr&amp;lt;cv::ORB&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::ORB::create(
        nFeatures, scaleFactor, nlevels, edgeThreshold, firstLevel, wtaK, static_cast&amp;lt;cv::ORB::ScoreType&amp;gt;(scoreType), patchSize, fastThreshold);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_ORB_delete
[32/64bit] cv::ORB のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
ORB（oriented BRIEF）キーポイント検出器とディスクリプタ抽出器を実装したクラス．

は，[206]で説明されています．このアルゴリズムは，安定したキーポイントを検出するためにピラミッド状のFASTを利用し，FASTやHarris応答を利用して最も強い特徴を選択し，一次モーメントを利用してその向きを求め，BRIEF（ランダムな点のペア（またはk-タプル）の座標が，測定された向きに応じて回転する）を利用してディスクリプタを計算します．


元関数名(C#): features2d_Ptr_ORB_delete
元DLLエクスポート名: features2d_Ptr_ORB_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_ORB_delete(cv::Ptr&amp;lt;cv::ORB&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_ORB_get
[32/64bit] cv::ORB のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
ORB（oriented BRIEF）キーポイント検出器とディスクリプタ抽出器を実装したクラス．

は，[206]で説明されています．このアルゴリズムは，安定したキーポイントを検出するためにピラミッド状のFASTを利用し，FASTやHarris応答を利用して最も強い特徴を選択し，一次モーメントを利用してその向きを求め，BRIEF（ランダムな点のペア（またはk-タプル）の座標が，測定された向きに応じて回転する）を利用してディスクリプタを計算します．


元関数名(C#): features2d_Ptr_ORB_get
元DLLエクスポート名: features2d_Ptr_ORB_get
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_ORB_get(cv::Ptr&amp;lt;cv::ORB&amp;gt; *ptr, cv::ORB **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_setMaxFeatures
[32/64bit] features2d_ORB_setMaxFeatures
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_ORB_setMaxFeatures
元DLLエクスポート名: features2d_ORB_setMaxFeatures
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_setMaxFeatures(cv::ORB *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setMaxFeatures(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_getMaxFeatures
[32/64bit] features2d_ORB_getMaxFeatures
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_ORB_getMaxFeatures
元DLLエクスポート名: features2d_ORB_getMaxFeatures
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_getMaxFeatures(cv::ORB *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getMaxFeatures();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_setScaleFactor
[32/64bit] features2d_ORB_setScaleFactor
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): features2d_ORB_setScaleFactor
元DLLエクスポート名: features2d_ORB_setScaleFactor
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_setScaleFactor(cv::ORB *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setScaleFactor(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_getScaleFactor
[32/64bit] features2d_ORB_getScaleFactor
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): features2d_ORB_getScaleFactor
元DLLエクスポート名: features2d_ORB_getScaleFactor
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_getScaleFactor(cv::ORB *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getScaleFactor();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_setNLevels
[32/64bit] features2d_ORB_setNLevels
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_ORB_setNLevels
元DLLエクスポート名: features2d_ORB_setNLevels
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_setNLevels(cv::ORB *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setNLevels(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_getNLevels
[32/64bit] features2d_ORB_getNLevels
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_ORB_getNLevels
元DLLエクスポート名: features2d_ORB_getNLevels
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_getNLevels(cv::ORB *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getNLevels();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_setEdgeThreshold
[32/64bit] features2d_ORB_setEdgeThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_ORB_setEdgeThreshold
元DLLエクスポート名: features2d_ORB_setEdgeThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_setEdgeThreshold(cv::ORB *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setEdgeThreshold(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_getEdgeThreshold
[32/64bit] features2d_ORB_getEdgeThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_ORB_getEdgeThreshold
元DLLエクスポート名: features2d_ORB_getEdgeThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_getEdgeThreshold(cv::ORB *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getEdgeThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_setFirstLevel
[32/64bit] features2d_ORB_setFirstLevel
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_ORB_setFirstLevel
元DLLエクスポート名: features2d_ORB_setFirstLevel
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_setFirstLevel(cv::ORB *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setFirstLevel(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_getFirstLevel
[32/64bit] features2d_ORB_getFirstLevel
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_ORB_getFirstLevel
元DLLエクスポート名: features2d_ORB_getFirstLevel
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_getFirstLevel(cv::ORB *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getFirstLevel();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_setWTA_K
[32/64bit] features2d_ORB_setWTA_K
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_ORB_setWTA_K
元DLLエクスポート名: features2d_ORB_setWTA_K
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_setWTA_K(cv::ORB *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setWTA_K(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_getWTA_K
[32/64bit] features2d_ORB_getWTA_K
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_ORB_getWTA_K
元DLLエクスポート名: features2d_ORB_getWTA_K
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_getWTA_K(cv::ORB *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getWTA_K();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_setScoreType
[32/64bit] features2d_ORB_setScoreType
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_ORB_setScoreType
元DLLエクスポート名: features2d_ORB_setScoreType
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_setScoreType(cv::ORB *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setScoreType(static_cast&amp;lt;cv::ORB::ScoreType&amp;gt;(val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_getScoreType
[32/64bit] features2d_ORB_getScoreType
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_ORB_getScoreType
元DLLエクスポート名: features2d_ORB_getScoreType
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_getScoreType(cv::ORB *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;getScoreType());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_setPatchSize
[32/64bit] features2d_ORB_setPatchSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_ORB_setPatchSize
元DLLエクスポート名: features2d_ORB_setPatchSize
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_setPatchSize(cv::ORB *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setPatchSize(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_getPatchSize
[32/64bit] features2d_ORB_getPatchSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_ORB_getPatchSize
元DLLエクスポート名: features2d_ORB_getPatchSize
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_getPatchSize(cv::ORB *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getPatchSize();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_setFastThreshold
[32/64bit] features2d_ORB_setFastThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_ORB_setFastThreshold
元DLLエクスポート名: features2d_ORB_setFastThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_setFastThreshold(cv::ORB *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setFastThreshold(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_ORB_getFastThreshold
[32/64bit] features2d_ORB_getFastThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_ORB_getFastThreshold
元DLLエクスポート名: features2d_ORB_getFastThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_ORB_getFastThreshold(cv::ORB *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getFastThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_MSER_create
[32/64bit] MSER 検出器のフルコンストラクタ．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = int : int delta
p2 = int : int minArea
p3 = int : int maxArea
p4 = double : double maxVariation
p5 = double : double minDiversity
p6 = int : int maxEvolution
p7 = double : double areaThreshold
p8 = double : double minMargin
p9 = int : int edgeBlurSize
p10 = var : out IntPtr returnValue
%inst
元関数名(C#): features2d_MSER_create
元DLLエクスポート名: features2d_MSER_create
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_MSER_create(int delta, int minArea, int maxArea,
    double maxVariation, double minDiversity, int maxEvolution,
    double areaThreshold, double minMargin, int edgeBlurSize,
    cv::Ptr&amp;lt;cv::MSER&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::MSER::create(delta, minArea, maxArea, maxVariation, minDiversity, maxEvolution,
        areaThreshold, minMargin, edgeBlurSize);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_MSER_delete
[32/64bit] cv::MSER のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
最大限に安定した極値領域抽出器．

このクラスは，MSER抽出アルゴリズムのすべてのパラメータをカプセル化しています（wiki記事参照）．



MSERには，灰色画像用とカラー画像用の2種類の実装があります。

灰色画像のアルゴリズムは以下から引用されています: [185]; この論文では union-find 法よりも高速であると主張していますが、私の centrino L7200 1.2GHz ラップトップでは実際に 1.5~2m/s の速度が得られました。

カラー画像のアルゴリズムは以下から引用しています: [80] ;グレー画像法よりもはるかに遅いはずです ( 3~4倍 )。

(Python) MSER検出器の完全な使用例は、samples/python/mser.pyにあります。


元関数名(C#): features2d_Ptr_MSER_delete
元DLLエクスポート名: features2d_Ptr_MSER_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_MSER_delete(cv::Ptr&amp;lt;cv::MSER&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_MSER_get
[32/64bit] cv::MSER のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
最大限に安定した極値領域抽出器．

このクラスは，MSER抽出アルゴリズムのすべてのパラメータをカプセル化しています（wiki記事参照）．



MSERには，灰色画像用とカラー画像用の2種類の実装があります。

灰色画像のアルゴリズムは以下から引用されています: [185]; この論文では union-find 法よりも高速であると主張していますが、私の centrino L7200 1.2GHz ラップトップでは実際に 1.5~2m/s の速度が得られました。

カラー画像のアルゴリズムは以下から引用しています: [80] ;グレー画像法よりもはるかに遅いはずです ( 3~4倍 )。

(Python) MSER検出器の完全な使用例は、samples/python/mser.pyにあります。


元関数名(C#): features2d_Ptr_MSER_get
元DLLエクスポート名: features2d_Ptr_MSER_get
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_MSER_get(cv::Ptr&amp;lt;cv::MSER&amp;gt; *ptr, cv::MSER **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_MSER_detectRegions
[32/64bit] MSER領域を検出します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = sptr : IntPtr msers
p4 = sptr : IntPtr bboxes
%inst
元関数名(C#): features2d_MSER_detectRegions
元DLLエクスポート名: features2d_MSER_detectRegions
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_MSER_detectRegions(
    cv::MSER *obj,
    cv::_InputArray *image,
    std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt; &amp;gt; *msers,
    std::vector&amp;lt;cv::Rect&amp;gt; *bboxes)
{
    BEGIN_WRAP
    obj-&amp;gt;detectRegions(*image, *msers, *bboxes);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_MSER_setDelta
[32/64bit] features2d_MSER_setDelta
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int delta
%inst
元関数名(C#): features2d_MSER_setDelta
元DLLエクスポート名: features2d_MSER_setDelta
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_MSER_setDelta(cv::MSER *obj, int delta)
{
    BEGIN_WRAP
    obj-&amp;gt;setDelta(delta);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_MSER_getDelta
[32/64bit] features2d_MSER_getDelta
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_MSER_getDelta
元DLLエクスポート名: features2d_MSER_getDelta
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_MSER_getDelta(cv::MSER *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getDelta();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_MSER_setMinArea
[32/64bit] features2d_MSER_setMinArea
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int minArea
%inst
元関数名(C#): features2d_MSER_setMinArea
元DLLエクスポート名: features2d_MSER_setMinArea
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_MSER_setMinArea(cv::MSER *obj, int minArea)
{
    BEGIN_WRAP
    obj-&amp;gt;setMinArea(minArea);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_MSER_getMinArea
[32/64bit] features2d_MSER_getMinArea
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_MSER_getMinArea
元DLLエクスポート名: features2d_MSER_getMinArea
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_MSER_getMinArea(cv::MSER *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getMinArea();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_MSER_setMaxArea
[32/64bit] features2d_MSER_setMaxArea
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int maxArea
%inst
元関数名(C#): features2d_MSER_setMaxArea
元DLLエクスポート名: features2d_MSER_setMaxArea
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_MSER_setMaxArea(cv::MSER *obj, int maxArea)
{
    BEGIN_WRAP
    obj-&amp;gt;setMaxArea(maxArea);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_MSER_getMaxArea
[32/64bit] features2d_MSER_getMaxArea
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_MSER_getMaxArea
元DLLエクスポート名: features2d_MSER_getMaxArea
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_MSER_getMaxArea(cv::MSER *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getMaxArea();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_MSER_setPass2Only
[32/64bit] features2d_MSER_setPass2Only
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int f
%inst
元関数名(C#): features2d_MSER_setPass2Only
元DLLエクスポート名: features2d_MSER_setPass2Only
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_MSER_setPass2Only(cv::MSER *obj, int f)
{
    BEGIN_WRAP
    obj-&amp;gt;setPass2Only(f != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_MSER_getPass2Only
[32/64bit] features2d_MSER_getPass2Only
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_MSER_getPass2Only
元DLLエクスポート名: features2d_MSER_getPass2Only
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_MSER_getPass2Only(cv::MSER *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getPass2Only() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_FAST1
[32/64bit] FASTアルゴリズムを用いてコーナーを検出します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr image
p2 = sptr : IntPtr keypoints
p3 = int : int threshold
p4 = int : int nonmaxSupression
%inst
205] によるFASTアルゴリズムを用いてコーナーを検出します．メモPython APIでは， cv.FAST_FEATURE_DETECTOR_TYPE_5_8, cv.FAST_FEATURE_DETECTOR_TYPE_7_12, cv.FAST_FEATURE_DETECTOR_TYPE_9_16 のようにタイプが指定されています．コーナー検出には， cv.FAST.detect() メソッドを利用します．

元関数名(C#): features2d_FAST1
元DLLエクスポート名: features2d_FAST1
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_FAST1(cv::_InputArray *image, std::vector&amp;lt;cv::KeyPoint&amp;gt; *keypoints, int threshold, int nonmaxSupression)
{
    BEGIN_WRAP
    cv::FAST(*image, *keypoints, threshold, nonmaxSupression != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_FAST2
[32/64bit] FASTアルゴリズムを用いてコーナーを検出します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr image
p2 = sptr : IntPtr keypoints
p3 = int : int threshold
p4 = int : int nonmaxSupression
p5 = int : int type
%inst
205] によるFASTアルゴリズムを用いてコーナーを検出します．メモPython APIでは， cv.FAST_FEATURE_DETECTOR_TYPE_5_8, cv.FAST_FEATURE_DETECTOR_TYPE_7_12, cv.FAST_FEATURE_DETECTOR_TYPE_9_16 のようにタイプが指定されています．コーナー検出には， cv.FAST.detect() メソッドを利用します．

元関数名(C#): features2d_FAST2
元DLLエクスポート名: features2d_FAST2
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_FAST2(cv::_InputArray *image, std::vector&amp;lt;cv::KeyPoint&amp;gt; *keypoints, int threshold, int nonmaxSupression, int type)
{
    BEGIN_WRAP
    cv::FAST(*image, *keypoints, threshold, nonmaxSupression != 0, static_cast&amp;lt;cv::FastFeatureDetector::DetectorType&amp;gt;(type));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_FastFeatureDetector_create
[32/64bit] features2d_FastFeatureDetector_create
%prm
p1,p2,p3
p1 = int : int threshold
p2 = int : int nonmaxSuppression
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): features2d_FastFeatureDetector_create
元DLLエクスポート名: features2d_FastFeatureDetector_create
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_FastFeatureDetector_create(
    int threshold, int nonmaxSuppression, cv::Ptr&amp;lt;cv::FastFeatureDetector&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::FastFeatureDetector::create(threshold, nonmaxSuppression != 0);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_FastFeatureDetector_delete
[32/64bit] cv::FastFeatureDetector のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
FASTメソッドを用いた特徴検出のためのラッパークラス．


元関数名(C#): features2d_Ptr_FastFeatureDetector_delete
元DLLエクスポート名: features2d_Ptr_FastFeatureDetector_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_FastFeatureDetector_delete(cv::Ptr&amp;lt;cv::FastFeatureDetector&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_FastFeatureDetector_get
[32/64bit] cv::FastFeatureDetector のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
FASTメソッドを用いた特徴検出のためのラッパークラス．


元関数名(C#): features2d_Ptr_FastFeatureDetector_get
元DLLエクスポート名: features2d_Ptr_FastFeatureDetector_get
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_FastFeatureDetector_get(cv::Ptr&amp;lt;cv::FastFeatureDetector&amp;gt; *ptr, cv::FastFeatureDetector **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_FastFeatureDetector_setThreshold
[32/64bit] features2d_FastFeatureDetector_setThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int threshold
%inst
元関数名(C#): features2d_FastFeatureDetector_setThreshold
元DLLエクスポート名: features2d_FastFeatureDetector_setThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_FastFeatureDetector_setThreshold(cv::FastFeatureDetector *obj, int threshold)
{
    BEGIN_WRAP
    obj-&amp;gt;setThreshold(threshold);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_FastFeatureDetector_getThreshold
[32/64bit] features2d_FastFeatureDetector_getThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_FastFeatureDetector_getThreshold
元DLLエクスポート名: features2d_FastFeatureDetector_getThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_FastFeatureDetector_getThreshold(cv::FastFeatureDetector *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_FastFeatureDetector_setNonmaxSuppression
[32/64bit] features2d_FastFeatureDetector_setNonmaxSuppression
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int f
%inst
元関数名(C#): features2d_FastFeatureDetector_setNonmaxSuppression
元DLLエクスポート名: features2d_FastFeatureDetector_setNonmaxSuppression
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_FastFeatureDetector_setNonmaxSuppression(cv::FastFeatureDetector *obj, int f)
{
    BEGIN_WRAP
    obj-&amp;gt;setNonmaxSuppression(f != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_FastFeatureDetector_getNonmaxSuppression
[32/64bit] features2d_FastFeatureDetector_getNonmaxSuppression
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_FastFeatureDetector_getNonmaxSuppression
元DLLエクスポート名: features2d_FastFeatureDetector_getNonmaxSuppression
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_FastFeatureDetector_getNonmaxSuppression(cv::FastFeatureDetector *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getNonmaxSuppression() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_FastFeatureDetector_setType
[32/64bit] features2d_FastFeatureDetector_setType
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int type
%inst
元関数名(C#): features2d_FastFeatureDetector_setType
元DLLエクスポート名: features2d_FastFeatureDetector_setType
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_FastFeatureDetector_setType(cv::FastFeatureDetector *obj, int type)
{
    BEGIN_WRAP
    obj-&amp;gt;setType(static_cast&amp;lt;cv::FastFeatureDetector::DetectorType&amp;gt;(type));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_FastFeatureDetector_getType
[32/64bit] features2d_FastFeatureDetector_getType
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_FastFeatureDetector_getType
元DLLエクスポート名: features2d_FastFeatureDetector_getType
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_FastFeatureDetector_getType(cv::FastFeatureDetector *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;getType());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AGAST
[32/64bit] AGASTアルゴリズムを用いてコーナーを検出します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr image
p2 = sptr : IntPtr keypoints
p3 = int : int threshold
p4 = int : int nonmaxSuppression
p5 = int : int type
%inst
Intel以外のプラットフォームでは、同じ数値結果を持つAGASTのツリー最適化バリアントがあります。32ビットバイナリのツリーテーブルは、perlスクリプトを使ってオリジナルコードから自動的に生成されました。perlスクリプトとツリー生成の例はfeatures2d/docフォルダにあります。159]のAGASTアルゴリズムを用いてコーナーを検出します。

元関数名(C#): features2d_AGAST
元DLLエクスポート名: features2d_AGAST
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AGAST(
    cv::_InputArray *image, std::vector&amp;lt;cv::KeyPoint&amp;gt; *keypoints,
    int threshold, int nonmaxSuppression, int type)
{
    BEGIN_WRAP
    cv::AGAST(
        entity(image),
        *keypoints,
        threshold,
        nonmaxSuppression != 0, 
        static_cast&amp;lt;cv::AgastFeatureDetector::DetectorType&amp;gt;(type));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AgastFeatureDetector_create
[32/64bit] features2d_AgastFeatureDetector_create
%prm
p1,p2,p3,p4
p1 = int : int threshold
p2 = int : int nonmaxSuppression
p3 = int : int type
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): features2d_AgastFeatureDetector_create
元DLLエクスポート名: features2d_AgastFeatureDetector_create
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AgastFeatureDetector_create(
    int threshold, int nonmaxSuppression, int type, cv::Ptr&amp;lt;cv::AgastFeatureDetector&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::AgastFeatureDetector::create(
        threshold, nonmaxSuppression != 0, static_cast&amp;lt;cv::AgastFeatureDetector::DetectorType&amp;gt;(type));
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_AgastFeatureDetector_delete
[32/64bit] cv::AgastFeatureDetector のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
AGAST法を用いた特徴検出のためのラッピングクラス．


元関数名(C#): features2d_Ptr_AgastFeatureDetector_delete
元DLLエクスポート名: features2d_Ptr_AgastFeatureDetector_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_AgastFeatureDetector_delete(cv::Ptr&amp;lt;cv::AgastFeatureDetector&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_AgastFeatureDetector_get
[32/64bit] cv::AgastFeatureDetector のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
AGAST法を用いた特徴検出のためのラッピングクラス．


元関数名(C#): features2d_Ptr_AgastFeatureDetector_get
元DLLエクスポート名: features2d_Ptr_AgastFeatureDetector_get
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_AgastFeatureDetector_get(cv::Ptr&amp;lt;cv::AgastFeatureDetector&amp;gt; *ptr, cv::AgastFeatureDetector **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AgastFeatureDetector_setThreshold
[32/64bit] features2d_AgastFeatureDetector_setThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_AgastFeatureDetector_setThreshold
元DLLエクスポート名: features2d_AgastFeatureDetector_setThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AgastFeatureDetector_setThreshold(cv::AgastFeatureDetector *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setThreshold(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AgastFeatureDetector_getThreshold
[32/64bit] features2d_AgastFeatureDetector_getThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_AgastFeatureDetector_getThreshold
元DLLエクスポート名: features2d_AgastFeatureDetector_getThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AgastFeatureDetector_getThreshold(cv::AgastFeatureDetector *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AgastFeatureDetector_setNonmaxSuppression
[32/64bit] features2d_AgastFeatureDetector_setNonmaxSuppression
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_AgastFeatureDetector_setNonmaxSuppression
元DLLエクスポート名: features2d_AgastFeatureDetector_setNonmaxSuppression
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AgastFeatureDetector_setNonmaxSuppression(cv::AgastFeatureDetector *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setNonmaxSuppression(val != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AgastFeatureDetector_getNonmaxSuppression
[32/64bit] features2d_AgastFeatureDetector_getNonmaxSuppression
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_AgastFeatureDetector_getNonmaxSuppression
元DLLエクスポート名: features2d_AgastFeatureDetector_getNonmaxSuppression
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AgastFeatureDetector_getNonmaxSuppression(cv::AgastFeatureDetector *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getNonmaxSuppression() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AgastFeatureDetector_setType
[32/64bit] features2d_AgastFeatureDetector_setType
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_AgastFeatureDetector_setType
元DLLエクスポート名: features2d_AgastFeatureDetector_setType
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AgastFeatureDetector_setType(cv::AgastFeatureDetector *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setType(static_cast&amp;lt;cv::AgastFeatureDetector::DetectorType&amp;gt;(val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AgastFeatureDetector_getType
[32/64bit] features2d_AgastFeatureDetector_getType
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_AgastFeatureDetector_getType
元DLLエクスポート名: features2d_AgastFeatureDetector_getType
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AgastFeatureDetector_getType(cv::AgastFeatureDetector *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;getType());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_GFTTDetector_create
[32/64bit] features2d_GFTTDetector_create
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = int : int maxCorners
p2 = double : double qualityLevel
p3 = double : double minDistance
p4 = int : int blockSize
p5 = int : int useHarrisDetector
p6 = double : double k
p7 = var : out IntPtr returnValue
%inst
元関数名(C#): features2d_GFTTDetector_create
元DLLエクスポート名: features2d_GFTTDetector_create
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_GFTTDetector_create(
    int maxCorners, double qualityLevel, double minDistance,
    int blockSize, int useHarrisDetector, double k,
    cv::Ptr&amp;lt;cv::GFTTDetector&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::GFTTDetector::create(
        maxCorners, qualityLevel, minDistance,
        blockSize, useHarrisDetector != 0, k);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_GFTTDetector_get
[32/64bit] cv::GFTTDetector のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
goodFeaturesToTrack関数を用いた特徴検出のためのラッパークラス．


元関数名(C#): features2d_Ptr_GFTTDetector_get
元DLLエクスポート名: features2d_Ptr_GFTTDetector_get
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_GFTTDetector_get(cv::Ptr&amp;lt;cv::GFTTDetector&amp;gt; *ptr, cv::GFTTDetector **returnValue)
{
    BEGIN_WRAP
    *returnValue =  ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_GFTTDetector_delete
[32/64bit] cv::GFTTDetector のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
goodFeaturesToTrack関数を用いた特徴検出のためのラッパークラス．


元関数名(C#): features2d_Ptr_GFTTDetector_delete
元DLLエクスポート名: features2d_Ptr_GFTTDetector_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_GFTTDetector_delete(cv::Ptr&amp;lt;cv::GFTTDetector&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_GFTTDetector_setMaxFeatures
[32/64bit] features2d_GFTTDetector_setMaxFeatures
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int maxFeatures
%inst
元関数名(C#): features2d_GFTTDetector_setMaxFeatures
元DLLエクスポート名: features2d_GFTTDetector_setMaxFeatures
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_GFTTDetector_setMaxFeatures(cv::GFTTDetector *obj, int maxFeatures)
{
    BEGIN_WRAP
    obj-&amp;gt;setMaxFeatures(maxFeatures);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_GFTTDetector_getMaxFeatures
[32/64bit] features2d_GFTTDetector_getMaxFeatures
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_GFTTDetector_getMaxFeatures
元DLLエクスポート名: features2d_GFTTDetector_getMaxFeatures
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_GFTTDetector_getMaxFeatures(cv::GFTTDetector *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getMaxFeatures();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_GFTTDetector_setQualityLevel
[32/64bit] features2d_GFTTDetector_setQualityLevel
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double qLevel
%inst
元関数名(C#): features2d_GFTTDetector_setQualityLevel
元DLLエクスポート名: features2d_GFTTDetector_setQualityLevel
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_GFTTDetector_setQualityLevel(cv::GFTTDetector *obj, double qlevel)
{
    BEGIN_WRAP
    obj-&amp;gt;setQualityLevel(qlevel);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_GFTTDetector_getQualityLevel
[32/64bit] features2d_GFTTDetector_getQualityLevel
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): features2d_GFTTDetector_getQualityLevel
元DLLエクスポート名: features2d_GFTTDetector_getQualityLevel
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_GFTTDetector_getQualityLevel(cv::GFTTDetector *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getQualityLevel();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_GFTTDetector_setMinDistance
[32/64bit] features2d_GFTTDetector_setMinDistance
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double minDistance
%inst
元関数名(C#): features2d_GFTTDetector_setMinDistance
元DLLエクスポート名: features2d_GFTTDetector_setMinDistance
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_GFTTDetector_setMinDistance(cv::GFTTDetector *obj, double minDistance)
{
    BEGIN_WRAP
    obj-&amp;gt;setMinDistance(minDistance);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_GFTTDetector_getMinDistance
[32/64bit] features2d_GFTTDetector_getMinDistance
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): features2d_GFTTDetector_getMinDistance
元DLLエクスポート名: features2d_GFTTDetector_getMinDistance
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_GFTTDetector_getMinDistance(cv::GFTTDetector *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getMinDistance();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_GFTTDetector_setBlockSize
[32/64bit] features2d_GFTTDetector_setBlockSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int blockSize
%inst
元関数名(C#): features2d_GFTTDetector_setBlockSize
元DLLエクスポート名: features2d_GFTTDetector_setBlockSize
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_GFTTDetector_setBlockSize(cv::GFTTDetector *obj, int blockSize)
{
    BEGIN_WRAP
    obj-&amp;gt;setBlockSize(blockSize);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_GFTTDetector_getBlockSize
[32/64bit] features2d_GFTTDetector_getBlockSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_GFTTDetector_getBlockSize
元DLLエクスポート名: features2d_GFTTDetector_getBlockSize
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_GFTTDetector_getBlockSize(cv::GFTTDetector *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getBlockSize();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_GFTTDetector_setHarrisDetector
[32/64bit] features2d_GFTTDetector_setHarrisDetector
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_GFTTDetector_setHarrisDetector
元DLLエクスポート名: features2d_GFTTDetector_setHarrisDetector
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_GFTTDetector_setHarrisDetector(cv::GFTTDetector *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setHarrisDetector(val != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_GFTTDetector_getHarrisDetector
[32/64bit] features2d_GFTTDetector_getHarrisDetector
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_GFTTDetector_getHarrisDetector
元DLLエクスポート名: features2d_GFTTDetector_getHarrisDetector
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_GFTTDetector_getHarrisDetector(cv::GFTTDetector *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getHarrisDetector() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_GFTTDetector_setK
[32/64bit] features2d_GFTTDetector_setK
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double k
%inst
元関数名(C#): features2d_GFTTDetector_setK
元DLLエクスポート名: features2d_GFTTDetector_setK
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_GFTTDetector_setK(cv::GFTTDetector *obj, double k)
{
    BEGIN_WRAP
    obj-&amp;gt;setK(k);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_GFTTDetector_getK
[32/64bit] features2d_GFTTDetector_getK
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): features2d_GFTTDetector_getK
元DLLエクスポート名: features2d_GFTTDetector_getK
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_GFTTDetector_getK(cv::GFTTDetector *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getK();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_SimpleBlobDetector_create
[32/64bit] features2d_SimpleBlobDetector_create
%prm
p1,p2
p1 = var : ref SimpleBlobDetector.WParams parameters
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): features2d_SimpleBlobDetector_create
元DLLエクスポート名: features2d_SimpleBlobDetector_create
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_SimpleBlobDetector_create(
    SimpleBlobDetector_Params *p, cv::Ptr&amp;lt;cv::SimpleBlobDetector&amp;gt; **returnValue)
{
    BEGIN_WRAP
    cv::SimpleBlobDetector::Params p2;
    if (p != nullptr)
    {
        p2.thresholdStep = p-&amp;gt;thresholdStep;
        p2.minThreshold = p-&amp;gt;minThreshold;
        p2.maxThreshold = p-&amp;gt;maxThreshold;
        p2.minRepeatability = static_cast&amp;lt;size_t&amp;gt;(p-&amp;gt;minRepeatability);
        p2.minDistBetweenBlobs = p-&amp;gt;minDistBetweenBlobs;
        p2.filterByColor = p-&amp;gt;filterByColor != 0;
        p2.blobColor = p-&amp;gt;blobColor;
        p2.filterByArea = p-&amp;gt;filterByArea != 0;
        p2.minArea = p-&amp;gt;minArea;
        p2.maxArea = p-&amp;gt;maxArea;
        p2.filterByCircularity = p-&amp;gt;filterByCircularity != 0;
        p2.minCircularity = p-&amp;gt;minCircularity;
        p2.maxCircularity = p-&amp;gt;maxCircularity;
        p2.filterByInertia = p-&amp;gt;filterByInertia != 0;
        p2.minInertiaRatio = p-&amp;gt;minInertiaRatio;
        p2.maxInertiaRatio = p-&amp;gt;maxInertiaRatio;
        p2.filterByConvexity = p-&amp;gt;filterByConvexity != 0;
        p2.minConvexity = p-&amp;gt;minConvexity;
        p2.maxConvexity = p-&amp;gt;maxConvexity;
    }
    const auto ptr = cv::SimpleBlobDetector::create(p2);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_SimpleBlobDetector_delete
[32/64bit] cv::SimpleBlobDetector のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
画像からblobを抽出するためのクラス．

このクラスは，画像からblobを抽出するための簡単なアルゴリズムを実装しています．



minThreshold (including) から maxThreshold (exclusive) までの複数の閾値を用いて，隣接する閾値間の距離 thresholdStep で閾値処理を行い，元画像を2値画像に変換する．

findContoursにより各2値画像から連結成分を抽出し、その中心を算出する。

複数の2値画像の中心を、その座標によってグループ化する。近い中心は1つのグループを形成し、そのグループは1つのblobに対応します。

これらのグループから，blobの最終的な中心とその半径を推定し，キーポイントの位置とサイズとして返します．



このクラスは、返されたblobに対して、いくつかのフィルタリングを行います。filterBy*をtrue/falseに設定することで、対応するフィルタリングをオン/オフすることができます。利用可能なフィルタリング。



色によるフィルタ。このフィルタは、blobの中心にある2値画像の強度をblobColorと比較します。両者が異なる場合、そのblobはフィルタリングされます。暗いブロブを抽出する場合はblobColor = 0、明るいブロブを抽出する場合はblobColor = 255を使用します。

面積で抽出されたblobは、minArea（含む）とmaxArea（含む）の間の面積を持ちます。

円形度別。抽出されたblobはminCircularity(包含)とmaxCircularity(排他)の間の円形度( ????? )を持つ。

最小イナーシャと最大イナーシャの比で。抽出されたblobはこの比率がminInertiaRatio(包含)とmaxInertiaRatio(排他)の間にある。

凸性によるもの。抽出されたblobは、凸性（面積／blobの凸包の面積）がminConvexity（含む）からmaxConvexity（含む）の間にある。



パラメータのデフォルト値は、暗い円形のblobを抽出するように調整されています。


元関数名(C#): features2d_Ptr_SimpleBlobDetector_delete
元DLLエクスポート名: features2d_Ptr_SimpleBlobDetector_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_SimpleBlobDetector_delete(cv::Ptr&amp;lt;cv::SimpleBlobDetector&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_SimpleBlobDetector_get
[32/64bit] cv::SimpleBlobDetector のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
画像からblobを抽出するためのクラス．

このクラスは，画像からblobを抽出するための簡単なアルゴリズムを実装しています．



minThreshold (including) から maxThreshold (exclusive) までの複数の閾値を用いて，隣接する閾値間の距離 thresholdStep で閾値処理を行い，元画像を2値画像に変換する．

findContoursにより各2値画像から連結成分を抽出し、その中心を算出する。

複数の2値画像の中心を、その座標によってグループ化する。近い中心は1つのグループを形成し、そのグループは1つのblobに対応します。

これらのグループから，blobの最終的な中心とその半径を推定し，キーポイントの位置とサイズとして返します．



このクラスは、返されたblobに対して、いくつかのフィルタリングを行います。filterBy*をtrue/falseに設定することで、対応するフィルタリングをオン/オフすることができます。利用可能なフィルタリング。



色によるフィルタ。このフィルタは、blobの中心にある2値画像の強度をblobColorと比較します。両者が異なる場合、そのblobはフィルタリングされます。暗いブロブを抽出する場合はblobColor = 0、明るいブロブを抽出する場合はblobColor = 255を使用します。

面積で抽出されたblobは、minArea（含む）とmaxArea（含む）の間の面積を持ちます。

円形度別。抽出されたblobはminCircularity(包含)とmaxCircularity(排他)の間の円形度( ????? )を持つ。

最小イナーシャと最大イナーシャの比で。抽出されたblobはこの比率がminInertiaRatio(包含)とmaxInertiaRatio(排他)の間にある。

凸性によるもの。抽出されたblobは、凸性（面積／blobの凸包の面積）がminConvexity（含む）からmaxConvexity（含む）の間にある。



パラメータのデフォルト値は、暗い円形のblobを抽出するように調整されています。


元関数名(C#): features2d_Ptr_SimpleBlobDetector_get
元DLLエクスポート名: features2d_Ptr_SimpleBlobDetector_get
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_SimpleBlobDetector_get(
    cv::Ptr&amp;lt;cv::SimpleBlobDetector&amp;gt; *ptr, cv::SimpleBlobDetector **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_KAZE_create
[32/64bit] KAZEのコンストラクタです。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = int : int extended
p2 = int : int upright
p3 = float : float threshold
p4 = int : int nOctaves
p5 = int : int nOctaveLayers
p6 = int : int diffusivity
p7 = var : out IntPtr returnValue
%inst
元関数名(C#): features2d_KAZE_create
元DLLエクスポート名: features2d_KAZE_create
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KAZE_create(
    int extended, int upright, float threshold,
    int nOctaves, int nOctaveLayers, int diffusivity,
    cv::Ptr&amp;lt;cv::KAZE&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::KAZE::create(
        extended != 0, upright != 0, threshold,
        nOctaves, nOctaveLayers, static_cast&amp;lt;cv::KAZE::DiffusivityType&amp;gt;(diffusivity));
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_KAZE_delete
[32/64bit] cv::KAZE のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
10]で説明した KAZE キーポイント検出器とディスクリプタ抽出器を実装したクラス．

注AKAZE ディスクリプタは，KAZE または AKAZE キーポイントでのみ使用できます． [ABD12] KAZE の特徴Pablo F. Alcantarilla, Adrien Bartoli and Andrew J. Davison.In European Conference on Computer Vision (ECCV), Fiorenze, Italy, October 2012.


元関数名(C#): features2d_Ptr_KAZE_delete
元DLLエクスポート名: features2d_Ptr_KAZE_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_KAZE_delete(cv::Ptr&amp;lt;cv::KAZE&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_KAZE_get
[32/64bit] cv::KAZE のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
10]で説明した KAZE キーポイント検出器とディスクリプタ抽出器を実装したクラス．

注AKAZE ディスクリプタは，KAZE または AKAZE キーポイントでのみ使用できます． [ABD12] KAZE の特徴Pablo F. Alcantarilla, Adrien Bartoli and Andrew J. Davison.In European Conference on Computer Vision (ECCV), Fiorenze, Italy, October 2012.


元関数名(C#): features2d_Ptr_KAZE_get
元DLLエクスポート名: features2d_Ptr_KAZE_get
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_KAZE_get(cv::Ptr&amp;lt;cv::KAZE&amp;gt; *ptr, cv::KAZE **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_KAZE_setDiffusivity
[32/64bit] features2d_KAZE_setDiffusivity
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_KAZE_setDiffusivity
元DLLエクスポート名: features2d_KAZE_setDiffusivity
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KAZE_setDiffusivity(cv::KAZE *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setDiffusivity(static_cast&amp;lt;cv::KAZE::DiffusivityType&amp;gt;(val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_KAZE_getDiffusivity
[32/64bit] features2d_KAZE_getDiffusivity
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_KAZE_getDiffusivity
元DLLエクスポート名: features2d_KAZE_getDiffusivity
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KAZE_getDiffusivity(cv::KAZE *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;getDiffusivity());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_KAZE_setExtended
[32/64bit] features2d_KAZE_setExtended
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_KAZE_setExtended
元DLLエクスポート名: features2d_KAZE_setExtended
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KAZE_setExtended(cv::KAZE *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setExtended(val != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_KAZE_getExtended
[32/64bit] features2d_KAZE_getExtended
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_KAZE_getExtended
元DLLエクスポート名: features2d_KAZE_getExtended
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KAZE_getExtended(cv::KAZE *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getExtended() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_KAZE_setNOctaveLayers
[32/64bit] features2d_KAZE_setNOctaveLayers
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_KAZE_setNOctaveLayers
元DLLエクスポート名: features2d_KAZE_setNOctaveLayers
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KAZE_setNOctaveLayers(cv::KAZE *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setNOctaveLayers(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_KAZE_getNOctaveLayers
[32/64bit] features2d_KAZE_getNOctaveLayers
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_KAZE_getNOctaveLayers
元DLLエクスポート名: features2d_KAZE_getNOctaveLayers
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KAZE_getNOctaveLayers(cv::KAZE *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getNOctaveLayers();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_KAZE_setNOctaves
[32/64bit] features2d_KAZE_setNOctaves
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_KAZE_setNOctaves
元DLLエクスポート名: features2d_KAZE_setNOctaves
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KAZE_setNOctaves(cv::KAZE *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setNOctaves(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_KAZE_getNOctaves
[32/64bit] features2d_KAZE_getNOctaves
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_KAZE_getNOctaves
元DLLエクスポート名: features2d_KAZE_getNOctaves
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KAZE_getNOctaves(cv::KAZE *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getNOctaves();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_KAZE_setThreshold
[32/64bit] features2d_KAZE_setThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): features2d_KAZE_setThreshold
元DLLエクスポート名: features2d_KAZE_setThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KAZE_setThreshold(cv::KAZE *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setThreshold(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_KAZE_getThreshold
[32/64bit] features2d_KAZE_getThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): features2d_KAZE_getThreshold
元DLLエクスポート名: features2d_KAZE_getThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KAZE_getThreshold(cv::KAZE *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_KAZE_setUpright
[32/64bit] features2d_KAZE_setUpright
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_KAZE_setUpright
元DLLエクスポート名: features2d_KAZE_setUpright
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KAZE_setUpright(cv::KAZE *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setUpright(val != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_KAZE_getUpright
[32/64bit] features2d_KAZE_getUpright
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_KAZE_getUpright
元DLLエクスポート名: features2d_KAZE_getUpright
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_KAZE_getUpright(cv::KAZE *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getUpright() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AKAZE_create
[32/64bit] AKAZEのコンストラクタです。
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = int : int descriptor_type
p2 = int : int descriptor_size
p3 = int : int descriptor_channels
p4 = float : float threshold
p5 = int : int nOctaves
p6 = int : int nOctaveLayers
p7 = int : int diffusivity
p8 = var : out IntPtr returnValue
%inst
元関数名(C#): features2d_AKAZE_create
元DLLエクスポート名: features2d_AKAZE_create
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AKAZE_create(
    int descriptor_type, int descriptor_size, int descriptor_channels,
    float threshold, int nOctaves, int nOctaveLayers, int diffusivity,
    cv::Ptr&amp;lt;cv::AKAZE&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::AKAZE::create(
        static_cast&amp;lt;cv::AKAZE::DescriptorType&amp;gt;(descriptor_type), descriptor_size, descriptor_channels,
        threshold, nOctaves, nOctaveLayers, static_cast&amp;lt;cv::KAZE::DiffusivityType&amp;gt;(diffusivity));
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_AKAZE_delete
[32/64bit] cv::AKAZE のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
9]で述べた，AKAZEのキーポイント検出器とディスクリプタ抽出器を実装したクラス．

AKAZE ディスクリプタは，KAZE または AKAZE のキーポイントでのみ利用できます．このクラスはスレッドセーフです。

注意記述子が必要な場合は，性能の良い Feature2D::detectAndCompute を使用してください．Feature2D::detectの後にFeature2D::computeを使用すると、スケールスペースピラミッドが2回計算されます。



AKAZE は T-API を実装しています．画像が UMat として渡された場合，アルゴリズムの一部は OpenCL を使用します．



[ANB13] Fast Explicit Diffusion for Accelerated Features in Nonlinear Scale Spaces.Pablo F. Alcantarilla, Jesus Nuevo, Adrien Bartoli.British Machine Vision Conference (BMVC), Bristol, UK, September 2013 で発表しました。


元関数名(C#): features2d_Ptr_AKAZE_delete
元DLLエクスポート名: features2d_Ptr_AKAZE_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_AKAZE_delete(cv::Ptr&amp;lt;cv::AKAZE&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_Ptr_AKAZE_get
[32/64bit] cv::AKAZE のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
9]で述べた，AKAZEのキーポイント検出器とディスクリプタ抽出器を実装したクラス．

AKAZE ディスクリプタは，KAZE または AKAZE のキーポイントでのみ利用できます．このクラスはスレッドセーフです。

注意記述子が必要な場合は，性能の良い Feature2D::detectAndCompute を使用してください．Feature2D::detectの後にFeature2D::computeを使用すると、スケールスペースピラミッドが2回計算されます。



AKAZE は T-API を実装しています．画像が UMat として渡された場合，アルゴリズムの一部は OpenCL を使用します．



[ANB13] Fast Explicit Diffusion for Accelerated Features in Nonlinear Scale Spaces.Pablo F. Alcantarilla, Jesus Nuevo, Adrien Bartoli.British Machine Vision Conference (BMVC), Bristol, UK, September 2013 で発表しました。


元関数名(C#): features2d_Ptr_AKAZE_get
元DLLエクスポート名: features2d_Ptr_AKAZE_get
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_Ptr_AKAZE_get(cv::Ptr&amp;lt;cv::AKAZE&amp;gt; *ptr, cv::AKAZE **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AKAZE_setDescriptorType
[32/64bit] features2d_AKAZE_setDescriptorType
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_AKAZE_setDescriptorType
元DLLエクスポート名: features2d_AKAZE_setDescriptorType
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AKAZE_setDescriptorType(cv::AKAZE *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setDescriptorType(static_cast&amp;lt;cv::AKAZE::DescriptorType&amp;gt;(val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AKAZE_getDescriptorType
[32/64bit] features2d_AKAZE_getDescriptorType
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_AKAZE_getDescriptorType
元DLLエクスポート名: features2d_AKAZE_getDescriptorType
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AKAZE_getDescriptorType(cv::AKAZE *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;getDescriptorType());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AKAZE_setDescriptorSize
[32/64bit] features2d_AKAZE_setDescriptorSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_AKAZE_setDescriptorSize
元DLLエクスポート名: features2d_AKAZE_setDescriptorSize
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AKAZE_setDescriptorSize(cv::AKAZE *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setDescriptorSize(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AKAZE_getDescriptorSize
[32/64bit] features2d_AKAZE_getDescriptorSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_AKAZE_getDescriptorSize
元DLLエクスポート名: features2d_AKAZE_getDescriptorSize
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AKAZE_getDescriptorSize(cv::AKAZE *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getDescriptorSize();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AKAZE_setDescriptorChannels
[32/64bit] features2d_AKAZE_setDescriptorChannels
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_AKAZE_setDescriptorChannels
元DLLエクスポート名: features2d_AKAZE_setDescriptorChannels
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AKAZE_setDescriptorChannels(cv::AKAZE *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setDescriptorChannels(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AKAZE_getDescriptorChannels
[32/64bit] features2d_AKAZE_getDescriptorChannels
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_AKAZE_getDescriptorChannels
元DLLエクスポート名: features2d_AKAZE_getDescriptorChannels
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AKAZE_getDescriptorChannels(cv::AKAZE *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getDescriptorChannels();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AKAZE_setThreshold
[32/64bit] features2d_AKAZE_setThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): features2d_AKAZE_setThreshold
元DLLエクスポート名: features2d_AKAZE_setThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AKAZE_setThreshold(cv::AKAZE *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setThreshold(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AKAZE_getThreshold
[32/64bit] features2d_AKAZE_getThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): features2d_AKAZE_getThreshold
元DLLエクスポート名: features2d_AKAZE_getThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AKAZE_getThreshold(cv::AKAZE *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AKAZE_setNOctaves
[32/64bit] features2d_AKAZE_setNOctaves
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_AKAZE_setNOctaves
元DLLエクスポート名: features2d_AKAZE_setNOctaves
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AKAZE_setNOctaves(cv::AKAZE *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setNOctaves(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AKAZE_getNOctaves
[32/64bit] features2d_AKAZE_getNOctaves
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_AKAZE_getNOctaves
元DLLエクスポート名: features2d_AKAZE_getNOctaves
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AKAZE_getNOctaves(cv::AKAZE *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getNOctaves();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AKAZE_setNOctaveLayers
[32/64bit] features2d_AKAZE_setNOctaveLayers
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_AKAZE_setNOctaveLayers
元DLLエクスポート名: features2d_AKAZE_setNOctaveLayers
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AKAZE_setNOctaveLayers(cv::AKAZE *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setNOctaveLayers(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AKAZE_getNOctaveLayers
[32/64bit] features2d_AKAZE_getNOctaveLayers
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_AKAZE_getNOctaveLayers
元DLLエクスポート名: features2d_AKAZE_getNOctaveLayers
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AKAZE_getNOctaveLayers(cv::AKAZE *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getNOctaveLayers();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AKAZE_setDiffusivity
[32/64bit] features2d_AKAZE_setDiffusivity
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): features2d_AKAZE_setDiffusivity
元DLLエクスポート名: features2d_AKAZE_setDiffusivity
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AKAZE_setDiffusivity(cv::AKAZE *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setDiffusivity(static_cast&amp;lt;cv::KAZE::DiffusivityType&amp;gt;(val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
features2d_AKAZE_getDiffusivity
[32/64bit] features2d_AKAZE_getDiffusivity
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): features2d_AKAZE_getDiffusivity
元DLLエクスポート名: features2d_AKAZE_getDiffusivity
参照元CSファイル: Internal\PInvoke\NativeMethods\features2d\NativeMethods_features2d_Feature2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) features2d_AKAZE_getDiffusivity(cv::AKAZE *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;getDiffusivity());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_features2d_Feature2D

%index
imgproc_getGaussianKernel
[32/64bit] ガウスフィルターの係数を返します。
%prm
p1,p2,p3,p4
p1 = int : int ksize
p2 = double : double sigma
p3 = int : int ktype
p4 = var : out IntPtr returnValue
%inst
この関数は，ガウスフィルタ係数の行列を計算して返します：\[G_i= ????? *e^{-(i-( ????? )/2)^2/(2* ????? )}, ?????]ここで，(i=0..texttt{ksize}-1）、\（\alpha\）は、\（sum_i G_i=1\）となるように選ばれたスケールファクターです。このようにして生成された2つのカーネルは，sepFilter2Dに渡すことができます．これらの関数は，平滑化カーネル（重みの合計が1になるような対称的なカーネル）を自動的に認識して，それに応じた処理を行います．関連項目： sepFilter2D, getDerivKernels, getStructuringElement, GaussianBlur

元関数名(C#): imgproc_getGaussianKernel
元DLLエクスポート名: imgproc_getGaussianKernel
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_getGaussianKernel(int ksize, double sigma, int ktype, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::getGaussianKernel(ksize, sigma, ktype);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_getDerivKernels
[32/64bit] 画像の空間微分を計算するためのフィルタ係数を返します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr kx
p2 = sptr : IntPtr ky
p3 = int : int dx
p4 = int : int dy
p5 = int : int ksize
p6 = int : int normalize
p7 = int : int ktype
%inst
この関数は，空間画像導出のためのフィルタ係数を計算し，それを返します．ksize=FILTER_SCHARR の場合， Scharr ????? ("Scharr" を参照してください) カーネルが生成されます．それ以外の場合は，Sobelカーネルが生成されます（Sobel参照）．フィルタは，通常，sepFilter2D や，Sobel に渡されます．

元関数名(C#): imgproc_getDerivKernels
元DLLエクスポート名: imgproc_getDerivKernels
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_getDerivKernels(cv::_OutputArray *kx, cv::_OutputArray *ky,
    int dx, int dy, int ksize, int normalize, int ktype)
{
    BEGIN_WRAP
    cv::getDerivKernels(*kx, *ky, dx, dy, ksize, normalize != 0, ktype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_getGaborKernel
[32/64bit] ガボールフィルタの係数を返す。
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = ARGS_SIZE : Size ksize
p2 = double : double sigma
p3 = double : double theta
p4 = double : double lambd
p5 = double : double gamma
p6 = double : double psi
p7 = int : int ktype
p8 = var : out IntPtr returnValue
%inst
ガボールフィルターの方程式やパラメーターの詳細については，以下を参照してください。ガボールフィルタ

元関数名(C#): imgproc_getGaborKernel
元DLLエクスポート名: imgproc_getGaborKernel
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_getGaborKernel(MyCvSize ksize, double sigma, double theta,
    double lambd, double gamma, double psi, int ktype, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::getGaborKernel(cpp(ksize), sigma, theta, lambd, gamma, psi, ktype);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_getStructuringElement
[32/64bit] モフォロジカルな操作を行うために、指定されたサイズと形状の構造化要素を返します。
%prm
p1,p2,p3,p4
p1 = int : int shape
p2 = ARGS_SIZE : Size ksize
p3 = ARGS_POINT : Point anchor
p4 = var : out IntPtr returnValue
%inst
この関数は，構造化要素を作成して返します．この構造化要素は，さらに erode, dilate, morphologyEx に渡すことができます．サンプル: samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp.

元関数名(C#): imgproc_getStructuringElement
元DLLエクスポート名: imgproc_getStructuringElement
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_getStructuringElement(int shape, MyCvSize ksize, MyCvPoint anchor, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::getStructuringElement(shape, cpp(ksize), cpp(anchor));
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_medianBlur
[32/64bit] メディアンフィルターを使って，画像をぼかします．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int ksize
%inst
この関数は，メジアンフィルタを用いて画像を平滑化します．マルチチャンネル画像の各チャンネルは，独立して処理されます．インプレース操作に対応しています。注意中央値フィルタは、境界線のピクセルに対処するために、内部的にBORDER_REPLICATEを使用しています。

元関数名(C#): imgproc_medianBlur
元DLLエクスポート名: imgproc_medianBlur
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_medianBlur(cv::_InputArray *src, cv::_OutputArray *dst, int ksize)
{
    BEGIN_WRAP
    cv::medianBlur(*src, *dst, ksize);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_GaussianBlur
[32/64bit] ガウシアンフィルターを使って画像をぼかします。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = ARGS_SIZE : Size ksize
p4 = double : double sigmaX
p5 = double : double sigmaY
p6 = int : BorderTypes borderType
%inst
この関数は，入力画像を指定されたガウスカーネルで畳み込みます．参照：sosepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlurExamples: samples/cpp/laplace.cpp, samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp, and samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp.

元関数名(C#): imgproc_GaussianBlur
元DLLエクスポート名: imgproc_GaussianBlur
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GaussianBlur(cv::_InputArray *src, cv::_OutputArray *dst,
                                            MyCvSize ksize, double sigmaX, double sigmaY, int borderType)
{
    BEGIN_WRAP
    cv::GaussianBlur(*src, *dst, cpp(ksize), sigmaX, sigmaY, borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_bilateralFilter
[32/64bit] バイラテラルフィルターを画像に適用します。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int d
p4 = double : double sigmaColor
p5 = double : double sigmaSpace
p6 = int : BorderTypes borderType
%inst
この関数は， http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html で説明されているように，入力画像にバイラテラルフィルタリングを適用します．bilateralFilter は，エッジをかなりシャープに保ちつつ，不要なノイズを非常によく減らします．ただし、他のフィルタ.Sigmaに比べて、非常に低速です。簡単にするために、2つのシグマ値を同じにすることができます。シグマ値が小さい（10未満）とフィルターの効果はあまりなく、逆に大きい（150以上）と非常に強い効果が得られ、画像が「漫画的」になります。フィルターサイズ。大きなフィルタ（d > 5）は非常に遅いので、リアルタイムのアプリケーションにはd=5を、重いノイズフィルタを必要とするオフラインのアプリケーションにはd=9を使用することをお勧めします。

元関数名(C#): imgproc_bilateralFilter
元DLLエクスポート名: imgproc_bilateralFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_bilateralFilter(cv::_InputArray *src, cv::_OutputArray *dst,
                                    int d, double sigmaColor, double sigmaSpace, int borderType)
{
    BEGIN_WRAP
    cv::bilateralFilter(*src, *dst, d, sigmaColor, sigmaSpace, borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_boxFilter
[32/64bit] ボックスフィルターを使って、画像をぼかします。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int ddepth
p4 = ARGS_SIZE : Size ksize
p5 = ARGS_POINT : Point anchor
p6 = int : int normalize
p7 = int : BorderTypes borderType
%inst
この関数は，カーネルを用いて画像を平滑化します：??o???1 & 1 & 1 & ????? )\\ ♪♪〜\What's New Year!\normalize=true}。\\非正規化ボックスフィルターは，画像導関数の共分散行列（密なオプティカルフローアルゴリズムなどで使用される）など，各ピクセルの近傍におけるさまざまな積分特性を計算するのに便利です．他にも、oblur、bilateralFilter、GaussianBlur、medianBlur、integralがあります。

元関数名(C#): imgproc_boxFilter
元DLLエクスポート名: imgproc_boxFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_boxFilter(cv::_InputArray *src, cv::_OutputArray *dst, int ddepth,
                              MyCvSize ksize, MyCvPoint anchor, int normalize, int borderType)
{
    BEGIN_WRAP
    cv::boxFilter(*src, *dst, ddepth, cpp(ksize), cpp(anchor), normalize != 0, borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_sqrBoxFilter
[32/64bit] フィルタをかけた部分のピクセル値の正規化二乗和を計算します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int ddepth
p4 = ARGS_SIZE : Size ksize
p5 = ARGS_POINT : Point anchor
p6 = int : int normalize
p7 = int : BorderTypes borderType
%inst
この関数は，入力画像中の各ピクセル ?( (x, y) ? )に対して，そのピクセル上に配置されたフィルタと重なる隣接ピクセル値の2乗和を計算します．この正規化されていない正方形のボックスフィルタは，ピクセル周辺の局所的な分散や標準偏差など，画像の局所的な統計情報を計算するのに役立ちます．

元関数名(C#): imgproc_sqrBoxFilter
元DLLエクスポート名: imgproc_sqrBoxFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_sqrBoxFilter(
    cv::_InputArray *src, cv::_OutputArray *dst, int ddepth,
    MyCvSize ksize, MyCvPoint anchor, int normalize, int borderType)
{
    BEGIN_WRAP
    cv::sqrBoxFilter(*src, *dst, ddepth, cpp(ksize), cpp(anchor), normalize != 0, borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_blur
[32/64bit] 正規化されたボックスフィルターを使って、画像をぼかします。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = ARGS_SIZE : Size ksize
p4 = ARGS_POINT : Point anchor
p5 = int : int borderType
%inst
この関数は，カーネルを用いて画像を平滑化します．\????? )♪ 1 & 1 & 1 & ♪ 1 & 1 ♪ 1 & 1 ♪ ♪\\ Blur(src, dst, ksize, anchor, borderType)の呼び出しは、boxFilter(src, dst, src.type(), ksize, anchor, true, borderType)と同等です。alsoboxFilter, bilateralFilter, GaussianBlur, medianBlurExamples: samples/cpp/edge.cpp, samples/cpp/laplace.cpp, and samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cppをご参照ください。

元関数名(C#): imgproc_blur
元DLLエクスポート名: imgproc_blur
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_blur(cv::_InputArray *src, cv::_OutputArray *dst, CvSize ksize, CvPoint anchor, int borderType)
{
    BEGIN_WRAP
    cv::blur(*src, *dst, ksize, anchor, borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_filter2D
[32/64bit] 画像をカーネルで畳み込みます．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int ddepth
p4 = sptr : IntPtr kernel
p5 = ARGS_POINT : Point anchor
p6 = double : double delta
p7 = int : int borderType
%inst
この関数は，任意の線形フィルタを画像に適用します．インプレース操作がサポートされています．この関数は，畳み込みではなく，実際に相関を計算します．(x,y) = ????? < ????? < ????? )\♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪(x',y')* ????? )(x+x'- ????? ) ????? ) つまり、カーネルはアンカーポイントを中心にミラーリングされていないのです。この関数は，十分に大きなカーネル（?11 x 11 以上）の場合は DFT ベースのアルゴリズムを使い，小さなカーネルの場合は直接アルゴリズムを使います．参照：sosepFilter2D, dft, matchTemplate

元関数名(C#): imgproc_filter2D
元DLLエクスポート名: imgproc_filter2D
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_filter2D(cv::_InputArray *src, cv::_OutputArray *dst, int ddepth,
                             cv::_InputArray *kernel, MyCvPoint anchor, double delta, int borderType)
{
    BEGIN_WRAP
    cv::filter2D(*src, *dst, ddepth, *kernel, cpp(anchor), delta, borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_sepFilter2D
[32/64bit] 分離可能な線形フィルタを画像に適用します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int ddepth
p4 = sptr : IntPtr kernelX
p5 = sptr : IntPtr kernelY
p6 = ARGS_POINT : Point anchor
p7 = double : double delta
p8 = int : int borderType
%inst
この関数は，画像に分離可能な線形フィルタを適用します．つまり，まず src の各行が，1次元カーネル kernelX によってフィルタリングされます．そして，結果の各列は，1次元カーネルkernelYでフィルタリングされます．delta によってシフトされた最終結果が，dst に格納されます． 参照：filter2D, Sobel, GaussianBlur, boxFilter, blur

元関数名(C#): imgproc_sepFilter2D
元DLLエクスポート名: imgproc_sepFilter2D
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_sepFilter2D(cv::_InputArray *src, cv::_OutputArray *dst, int ddepth,
                                cv::_InputArray *kernelX, cv::_InputArray *kernelY,
                                MyCvPoint anchor, double delta, int borderType)
{
    BEGIN_WRAP
    cv::sepFilter2D(*src, *dst, ddepth, *kernelX, *kernelY, cpp(anchor), delta, borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_Sobel
[32/64bit] 拡張された Sobel 演算子を使って、画像の 1 次、2 次、3 次、または混合導関数を計算します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int ddepth
p4 = int : int dx
p5 = int : int dy
p6 = int : int ksize
p7 = double : double scale
p8 = double : double delta
p9 = int : int borderType
%inst
1つのケースを除いて、微分の計算には、Separable Kernel が使われます。ksize = 1 は、1 次または 2 次の x または y の微分にのみ使用できます。また、Sobelよりも正確な結果が得られる可能性のある Scharrフィルタに対応する特別な値 ksize = FILTER_SCHARR (-1)もあります。この関数は，画像を適切なカーネルで畳み込むことにより，画像微分を計算します．\????? )\Sobel演算子は，ガウス平滑化と微分を組み合わせたものなので，多少なりともノイズに強い結果が得られます．多くの場合，この関数は ( xorder = 1, yorder = 0, ksize = 3) または ( xorder = 0, yorder = 1, ksize = 3) で呼び出され，xまたはyの画像1次微分を計算します．第1のケースは、次のようなカーネルに対応しています。\See alsoScharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolarExamples: samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp.

元関数名(C#): imgproc_Sobel
元DLLエクスポート名: imgproc_Sobel
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Sobel(cv::_InputArray *src, cv::_OutputArray *dst, int ddepth,
                          int dx, int dy, int ksize, double scale, double delta, int borderType)
{
    BEGIN_WRAP
    cv::Sobel(*src, *dst, ddepth, dx, dy, ksize, scale, delta, borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_spatialGradient
[32/64bit] Sobel 演算子を使って、x と y の両方で画像の一次微分を計算します。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dx
p3 = sptr : IntPtr dy
p4 = int : int ksize
p5 = int : int borderType
%inst
以下のコマンドと同じです： Sobel( src, dx, CV_16SC1, 1, 0, 3 );Sobel( src, dy, CV_16SC1, 0, 1, 3 );fragmentSobel も参照してください．

元関数名(C#): imgproc_spatialGradient
元DLLエクスポート名: imgproc_spatialGradient
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_spatialGradient(
    cv::_InputArray *src, cv::_OutputArray *dx, cv::_OutputArray *dy, int ksize, int borderType)
{
    BEGIN_WRAP
    cv::spatialGradient(*src, *dx, *dy, ksize, borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_Scharr
[32/64bit] Scharr 演算子を用いて，画像の1次 x または y 導関数を求めます．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int ddepth
p4 = int : int dx
p5 = int : int dy
p6 = double : double scale
p7 = double : double delta
p8 = int : int borderType
%inst
この関数は，Scharr演算子を用いて，XまたはYの空間的な1次微分を計算します．call\[Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)}\]は，次のものと同じです：Sobel(src, dst, ddepth, dx, dy, FILTER_SCHARR, scale, delta, borderType)} .??]See alsocartToPolarExamples: samples/cpp/edge.cpp.

元関数名(C#): imgproc_Scharr
元DLLエクスポート名: imgproc_Scharr
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Scharr(cv::_InputArray *src, cv::_OutputArray *dst, int ddepth,
                           int dx, int dy, double scale, double delta, int borderType)
{
    BEGIN_WRAP
    cv::Scharr(*src, *dst, ddepth, dx, dy, scale, delta, borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_Laplacian
[32/64bit] 画像のラプラシアンを計算します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int ddepth
p4 = int : int ksize
p5 = double : double scale
p6 = double : double delta
p7 = int : int borderType
%inst
この関数は，Sobel演算子を用いて計算された2回目のx導関数とy導関数を足し合わせることで，入力画像のラプラシアンを計算します．+ ????? ) これは，ksize > 1のときに行う．ksize == 1のときは，次のようなアパーチャで画像をフィルタリングして，ラプラシアンを計算します♪See alsoSobel, ScharrExamples: samples/cpp/laplace.cpp.

元関数名(C#): imgproc_Laplacian
元DLLエクスポート名: imgproc_Laplacian
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Laplacian(cv::_InputArray *src, cv::_OutputArray *dst, int ddepth,
                              int ksize, double scale, double delta, int borderType)
{
    BEGIN_WRAP
    cv::Laplacian(*src, *dst, ddepth, ksize, scale, delta, borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_Canny1
[32/64bit] Cannyアルゴリズム[41]を用いて，画像のエッジを検出します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr edges
p3 = double : double threshold1
p4 = double : double threshold2
p5 = int : int apertureSize
p6 = int : int l2Gradient
%inst
この関数は，Cannyアルゴリズムを用いて，入力画像中のエッジを検出し，出力マップのエッジにマーキングします．threshold1 と threshold2 の間の最小値が，エッジの連結に利用されます．また，最大の値は，強いエッジの初期セグメントを見つけるために利用されます．http://en.wikipedia.org/wiki/Canny_edge_detectorExamples: samples/cpp/edge.cpp, samples/cpp/squares.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, and samples/tapi/squares.cpp を参照してください。

元関数名(C#): imgproc_Canny1
元DLLエクスポート名: imgproc_Canny1
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Canny1(cv::_InputArray *src, cv::_OutputArray *edges,
                          double threshold1, double threshold2, int apertureSize, int L2gradient)
{
    BEGIN_WRAP
    cv::Canny(*src, *edges, threshold1, threshold2, apertureSize, L2gradient != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_Canny2
[32/64bit] Cannyアルゴリズム[41]を用いて，画像のエッジを検出します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr dx
p2 = sptr : IntPtr dy
p3 = sptr : IntPtr edges
p4 = double : double threshold1
p5 = double : double threshold2
p6 = int : int l2Gradient
%inst
この関数は，Cannyアルゴリズムを用いて，入力画像中のエッジを検出し，出力マップのエッジにマーキングします．threshold1 と threshold2 の間の最小値が，エッジの連結に利用されます．また，最大の値は，強いエッジの初期セグメントを見つけるために利用されます．http://en.wikipedia.org/wiki/Canny_edge_detectorExamples: samples/cpp/edge.cpp, samples/cpp/squares.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp, and samples/tapi/squares.cpp を参照してください。

元関数名(C#): imgproc_Canny2
元DLLエクスポート名: imgproc_Canny2
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Canny2(
    cv::_InputArray *dx, cv::_InputArray *dy, cv::_OutputArray *edges,
    double threshold1, double threshold2, int L2gradient = false)
{
    BEGIN_WRAP
    cv::Canny(*dx, *dy, *edges, threshold1, threshold2, L2gradient != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_cornerMinEigenVal
[32/64bit] コーナー検出のために，勾配行列の最小固有値を計算します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int blockSize
p4 = int : int ksize
p5 = int : int borderType
%inst
この関数は， cornerEigenValsAndVecs と似ていますが， cornerEigenValsAndVecs の説明にある式を用いて，導関数の共分散行列の最小固有値，つまり， ?min(?lambda_1,?lambda_2)? を計算して保存します．

元関数名(C#): imgproc_cornerMinEigenVal
元DLLエクスポート名: imgproc_cornerMinEigenVal
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_cornerMinEigenVal(cv::_InputArray *src, cv::_OutputArray *dst,
                                      int blockSize, int ksize, int borderType)
{
    BEGIN_WRAP
    cv::cornerMinEigenVal(*src, *dst, blockSize, ksize, borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_cornerHarris
[32/64bit] Harris corner detector.
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int blockSize
p4 = int : int ksize
p5 = double : double  k
p6 = int : int borderType
%inst
この関数は，画像に対してハリスコーナー検出器を実行します．cornerMinEigenVal や cornerEigenValsAndVecs と同様に，各ピクセル ?((x, y)? )に対して，勾配共分散行列?((M^{(x,y)}? )を計算します．そして、次のような特性を計算します。(x,y) = ????? )M^{(x,y)} (x,y)- k cdot eldest ( ????? )M^{(x,y)}\画像の角は、この応答マップの局所的な最大値として見つけることができます。

元関数名(C#): imgproc_cornerHarris
元DLLエクスポート名: imgproc_cornerHarris
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_cornerHarris(cv::_InputArray *src, cv::_OutputArray *dst,
                                 int blockSize, int ksize, double k, int borderType)
{
    BEGIN_WRAP
    cv::cornerHarris(*src, *dst, blockSize, ksize, k, borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_cornerEigenValsAndVecs
[32/64bit] コーナー検出のために，画像ブロックの固有値と固有ベクトルを計算します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int blockSize
p4 = int : int ksize
p5 = int : int borderType
%inst
関数 cornerEigenValsAndVecs は，各ピクセル ????? ) に対して， blockSize ????? ) 近隣領域 ????? ) を考慮します．この近傍領域における導関数の共分散行列を計算します。\ここでは、Sobel演算子を用いて導関数を計算します。固有ベクトルと固有値を求め、デスティネーション画像に保存します ?((?lambda_1, ?lambda_2, x_1, y_1, x_2, y_2)?) ここで、?(?lambda_1, ?lambda_2?)は、非ソートの固有値です

\♪\\に対応する固有ベクトルは

\この関数の出力は，ロバストなエッジ検出やコーナー検出に利用できます． 他にも，ocornerMinEigenVal, cornerHarris, preCornerDetect を参照してください．

元関数名(C#): imgproc_cornerEigenValsAndVecs
元DLLエクスポート名: imgproc_cornerEigenValsAndVecs
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_cornerEigenValsAndVecs(cv::_InputArray *src, cv::_OutputArray *dst,
                                           int blockSize, int ksize, int borderType)
{
    BEGIN_WRAP
    cv::cornerEigenValsAndVecs(*src, *dst, blockSize, ksize, borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_preCornerDetect
[32/64bit] コーナー検出のための特徴量マップを計算します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int ksize
p4 = int : int borderType
%inst
この関数は，入力画像の複素空間微分関数を計算します\\ = (D_x texttt{src} )^2 ?? D_{yy}\♪♪♪♪♪♪♪♪♪♪♪♪♪+ (D_y ????? ) - D_{xx} ????? )-2 D_x ardor\D_y (D_texttt{src})\D_{xy}\ここで，\(D_x\)，\(D_y\)は1次微分，\(D_xx}?)，?(D_yy}?)は2次微分，\(D_{xy}?)は混合微分である．コーナーは，以下のように，関数の局所的な最大値として求められます： Mat corners, dilated_corners;preCornerDetect(image, corners, 3);// 3x3 の矩形構造による拡張 elementdilate(corner, dilated_corners, Mat(), 1);Mat corner_mask = corners == dilated_corners;fragment

元関数名(C#): imgproc_preCornerDetect
元DLLエクスポート名: imgproc_preCornerDetect
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_preCornerDetect(cv::_InputArray *src, cv::_OutputArray *dst, int ksize, int borderType)
{
    BEGIN_WRAP
    cv::preCornerDetect(*src, *dst, ksize, borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_cornerSubPix
[32bit] コーナーの位置を精細化します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr image
p2 = sptr : IntPtr corners
p3 = ARGS_SIZE : Size winSize
p4 = ARGS_SIZE : Size zeroZone
p5 = ARGS_TERMCRITERIA : TermCriteria criteria
%inst
この関数は，[81]で述べられているように，サブピクセル精度でコーナーや半径方向のサドルポイントの位置を求めるために，繰り返し処理を行います． imageサブピクセル精度のコーナーロケータは，画像ノイズや計測ノイズがあったとしても，中心\(q\)からその近傍に位置する点\(p\)までのすべてのベクトルが，画像の勾配に直交するという観測に基づいています．式を考えてみましょう：\\ = {DI_{p_i}}^T \cdot (q - p_i)\]ここで、\({DI_{p_i}}\)は、\(q\)の近傍にある点の一つの画像勾配です。q\の値は、\(epsilon_i\)が最小になるように求められます。????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? )\ここで、勾配の総和は、\(q\)の近傍（サーチウィンドウ）で行われます。第1グラディエント項を「G\」、第2グラディエント項を「b\」と呼ぶと、次のようになります。

元関数名(C#): imgproc_cornerSubPix
元DLLエクスポート名: imgproc_cornerSubPix
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_cornerSubPix(cv::_InputArray *image, std::vector&amp;lt;cv::Point2f&amp;gt; *corners,
                                 CvSize winSize, CvSize zeroZone, MyCvTermCriteria criteria)
{
    BEGIN_WRAP
    cv::cornerSubPix(*image, *corners, winSize, zeroZone, cpp(criteria));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_cornerSubPix
[64bit] コーナーの位置を精細化します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr image
p2 = sptr : IntPtr corners
p3 = ARGS_SIZE : Size winSize
p4 = ARGS_SIZE : Size zeroZone
p5 = var : TermCriteria criteria
%inst
この関数は，[81]で述べられているように，サブピクセル精度でコーナーや半径方向のサドルポイントの位置を求めるために，繰り返し処理を行います． imageサブピクセル精度のコーナーロケータは，画像ノイズや計測ノイズがあったとしても，中心\(q\)からその近傍に位置する点\(p\)までのすべてのベクトルが，画像の勾配に直交するという観測に基づいています．式を考えてみましょう：\\ = {DI_{p_i}}^T \cdot (q - p_i)\]ここで、\({DI_{p_i}}\)は、\(q\)の近傍にある点の一つの画像勾配です。q\の値は、\(epsilon_i\)が最小になるように求められます。????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? )\ここで、勾配の総和は、\(q\)の近傍（サーチウィンドウ）で行われます。第1グラディエント項を「G\」、第2グラディエント項を「b\」と呼ぶと、次のようになります。

元関数名(C#): imgproc_cornerSubPix
元DLLエクスポート名: imgproc_cornerSubPix
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_cornerSubPix(cv::_InputArray *image, std::vector&amp;lt;cv::Point2f&amp;gt; *corners,
                                 CvSize winSize, CvSize zeroZone, MyCvTermCriteria criteria)
{
    BEGIN_WRAP
    cv::cornerSubPix(*image, *corners, winSize, zeroZone, cpp(criteria));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_goodFeaturesToTrack
[32/64bit] 画像の強い角を判定します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr src
p2 = sptr : IntPtr corners
p3 = int : int maxCorners
p4 = double : double qualityLevel
p5 = double : double minDistance
p6 = sptr : IntPtr mask
p7 = int : int blockSize
p8 = int : int useHarrisDetector
p9 = double : double k
%inst
この関数は，[222]に記述されているように，画像中，あるいは指定された画像領域中の最も目立つコーナーを検出します． 関数は， cornerMinEigenVal または cornerHarris を用いて，すべての入力画像ピクセルにおけるコーナー品質尺度を計算します．

Functionは、非最大値抑制を行います（3×3近傍の局所的な最大値は保持されます）。

最小固有値が\(????? )以下のコーナーは\未満の最小固有値を持つコーナーは棄却されます。

残ったコーナーは、品質尺度の降順でソートされます。

この関数は，物体のポイントベーストラッカーを初期化するために利用できます．注意もし，パラメータ qualityLevel に異なる値 A と B を指定してこの関数を呼び出し，A > B とした場合， qualityLevel=A で返されるコーナーのベクトルは， qualityLevel=B で返される出力ベクトルの接頭辞となります． 他にも，ocornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform などの関数を参照してください．

元関数名(C#): imgproc_goodFeaturesToTrack
元DLLエクスポート名: imgproc_goodFeaturesToTrack
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_goodFeaturesToTrack(cv::_InputArray *src, std::vector&amp;lt;cv::Point2f&amp;gt; *corners,
                                        int maxCorners, double qualityLevel, double minDistance,
                                        cv::_InputArray *mask, int blockSize, int useHarrisDetector, double k)
{
    BEGIN_WRAP
    cv::goodFeaturesToTrack(*src, *corners, maxCorners, qualityLevel, minDistance, 
        entity(mask), blockSize, useHarrisDetector != 0, k);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_HoughLines
[32/64bit] 標準的なハフ変換を用いて，2 値画像中の線を検出します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr lines
p3 = double : double rho
p4 = double : double theta
p5 = int : int threshold
p6 = double : double srn
p7 = double : double stn
%inst
この関数は，線を検出するための標準的なハフ変換アルゴリズム，あるいは標準的なマルチスケールハフ変換アルゴリズムを実装しています．ハフ変換についての詳しい説明は，http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm を参照してください．例： samples/cpp/tutorial_code/mgTrans/houghlines.cpp.

元関数名(C#): imgproc_HoughLines
元DLLエクスポート名: imgproc_HoughLines
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_HoughLines(cv::_InputArray *src, std::vector&amp;lt;cv::Vec2f&amp;gt; *lines,
                               double rho, double theta, int threshold,
                               double srn, double stn)
{
    BEGIN_WRAP
    cv::HoughLines(*src, *lines, rho, theta, threshold, srn, stn);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_HoughLinesP
[32/64bit] 確率的ハフ変換を用いて2値画像の線分を検出します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr lines
p3 = double : double rho
p4 = double : double theta
p5 = int : int threshold
p6 = double : double minLineLength
p7 = double : double maxLineG
%inst
この関数は，[164]に記述されている，線検出のための確率的ハフ変換アルゴリズムを実装しています：#include <opencv2/imgproc.hpp>#include <opencv2/highgui.hpp>using namespace cv;using namespace std;int main(int argc, char** argv){ Mat src, dst, color_dst; if( argc != 2 || !(src=imread(argv[1], 0).data) return -1; Canny( src, dst, 50, 200, 3 ); cvtColor( dst, color_dst, COLOR_GRAY2BGR ); vector<Vec4i> lines; HoughLinesP( dst, lines, 1, CV_PI/180, 80, 30, 10 ); for( size_t i = 0; i < lines.size(); i++ ) { line( color_dst, Point(lines[i][0], lines[i][1]), Point( lines[i][2], lines[i][3]), Scalar(0,0,255), 3, 8 ); } namedWindow("Source", 1 ); imshow("Source", src );    namedWindow("Detected Lines", 1 ); imshow("Detected Lines", color_dst ); waitKey(0); return 0;}fragmentこれは、関数のパラメータを調整した画像のサンプルです。imageそして、これは確率的ハフ変換の場合の上記プログラムの出力です:imageSee alsoLineSegmentDetectorExamples: samples/cpp/tutorial_code/ImgTrans/houghlines.cppを参照してください。

元関数名(C#): imgproc_HoughLinesP
元DLLエクスポート名: imgproc_HoughLinesP
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_HoughLinesP(cv::_InputArray *src, std::vector&amp;lt;cv::Vec4i&amp;gt; *lines,
                                double rho, double theta, int threshold,
                                double minLineLength, double maxLineGap)
{
    BEGIN_WRAP
    cv::HoughLinesP(*src, *lines, rho, theta, threshold, minLineLength, maxLineGap);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_HoughLinesPointSet
[32/64bit] 標準的なハフ変換を利用して、点の集合の中の線を見つけます。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = sptr : IntPtr point
p2 = sptr : IntPtr lines
p3 = int : int linesMax
p4 = int : int threshold
p5 = double : double minRho
p6 = double : double maxRho
p7 = double : double rhoStep
p8 = double : double minTheta
p9 = double : double maxTheta
p10 = double : double thetaStep
%inst
この関数は，ハフ変換の改良版を用いて，点群から直線を見つけます．hpp>using namespace cv;using namespace std;int main(){ Mat lines; vector<Vec3d> line3d; vector<Point2f> point; const static float Points[20][2] = { { 0.0f, 369.0f }, { 10.0f, 364.0f }, { 20.0f, 358.0f }, { 30.0f, 352.0f }, { 40.0f, 346.0f }, { 50.0f, 341.0f }, { 60.0f, 335.0f }, { 70.0f, 329.0f }, { 80.0f, 323.0f }, { 90.0f, 318.0f }, { 100.0f, 312.0f }, { 110.0.0f, 306.0f }, { 120.0f, 300.0f }, { 130.0f, 295.0f }, { 140.0f, 289.0f }, { 150.0f, 284.0f }, { 160.0f, 277.0f }, { 170.0f, 271.0f }, { 180.0f, 266.0f }, { 190.0f, 260.0f }。    }; for (int i = 0; i < 20; i++) { point.push_back(Point2f(Points[i][0],Points[i][1])); } double rhoMin = 0.0f, rhoMax = 360.0f, rhoStep = 1; double thetaMin = 0.0f, thetaMax = CV_PI / 2.0f, thetaStep = CV_PI / 180.0f; HoughLinesPointSet(point, lines, 20, 1, rhoMin, rhoMax, rhoStep, thetaMin, thetaMax, thetaStep); lines.copyTo(line3d); printf("vots:%d, rho:%.7f, theta:%.7fn",(int)line3d.at(0).val[0], line3d.at(0).val[1], line3d.at(0).val[2]);}fragment

元関数名(C#): imgproc_HoughLinesPointSet
元DLLエクスポート名: imgproc_HoughLinesPointSet
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_HoughLinesPointSet(
    cv::_InputArray *_point, cv::_OutputArray *_lines, int lines_max, int threshold,
    double min_rho, double max_rho, double rho_step,
    double min_theta, double max_theta, double theta_step)
{
    BEGIN_WRAP
    cv::HoughLinesPointSet(*_point, *_lines, lines_max, threshold, min_rho, max_rho, rho_step, min_theta, max_theta, theta_step);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_HoughCircles
[32/64bit] ハフ変換を使ってグレースケール画像から円を見つけます。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr src
p2 = sptr : IntPtr circles
p3 = int : int method
p4 = double : double dp
p5 = double : double minDist
p6 = double : double param1
p7 = double : double param2
p8 = int : int minRadius
p9 = int : int maxRadius
%inst
この関数は，ハフ変換の修正を用いて，グレースケール画像中の円を求めます．例： :#include <opencv2/imgproc.hpp>#include <opencv2/highgui.hpp>#include <math.h>using namespace cv;using namespace std;int main(int argc, char** argv){ Mat img, gray; if( argc != 2 || !(img=imread(argv[1], 1)).data) return -1; cvtColor(img, gray, COLOR_BGR2GRAY); // 滑らかにしないと，たくさんの偽の円が検出される可能性があります． GaussianBlur( gray, gray, Size(9, 9), 2, 2 ); vector<Vec3f> circles; HoughCircles(gray, circles, HOUGH_GRADIENT, 2, gray.rows/4, 200, 100 ); for( size_t i = 0; i < circles.size(); i++ ) { Point center(cvRound(circcles[i][0]), cvRound(circcles[i][1])); int radius = cvRound(circcles[i][2]); // 円の中心を描く circle( img, center, 3, Scalar(0,255,0), -1, 8, 0 );         // 円の輪郭を描く circle( img, center, radius, Scalar(0,0,255), 3, 8, 0 ); } namedWindow( "circles", 1 ); imshow( "circles", img ); waitKey(0); return 0;}fragmentNote通常、この関数は円の中心をうまく検出します。しかし、正しい半径を見つけることができない場合があります。半径の範囲（minRadiusとmaxRadius）がわかっていれば、それを指定することで、この関数を補助することができます。また、HOUGH_GRADIENTメソッドの場合、maxRadiusを負の数に設定することで、半径検索を行わずに中心のみを返し、追加の手順で正しい半径を見つけることができます。また、画像がすでに柔らかい場合を除き、画像を少し滑らかにすることもできます。他にもfitEllipse, minEnclosingCircleExamples: samples/cpp/tutorial_code/ImgTrans/houghcircles.cppを参照してください。

元関数名(C#): imgproc_HoughCircles
元DLLエクスポート名: imgproc_HoughCircles
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_HoughCircles(cv::_InputArray *src, std::vector&amp;lt;cv::Vec3f&amp;gt; *circles,
                                 int method, double dp, double minDist,
                                 double param1, double param2, int minRadius, int maxRadius)
{
    BEGIN_WRAP
    cv::HoughCircles(*src, *circles, method, dp, minDist, param1, param2, minRadius, maxRadius);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_erode
[32bit] 特定の構造化要素を使って画像を消去します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr kernel
p4 = ARGS_POINT : Point anchor
p5 = int : int iterations
p6 = int : int borderType
p7 = ARGS_SCALAR : Scalar borderValue
%inst
この関数は，最小値を取るピクセル近傍の形状を決定する，指定された構造化要素を用いて，入力画像を侵食します：??o???(x,y) = ????? (x',y'):\♪ ♪♪ (x',y') ♪ ♪ (x',y') ♪ ♪ (x',y') ♪ ♪\♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪(x+x',y+y')??＞????*。エロージョンは，複数回（イタレーション）にわたって適用することができます．他にも，odilate, morphologyEx, getStructuringElementExamples: samples/cpp/segment_objects.cpp, and samples/cpp/tutorial_code/ImgProc/Morphology_1.cppを参照してください．

元関数名(C#): imgproc_erode
元DLLエクスポート名: imgproc_erode
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_erode(cv::_InputArray *src, cv::_OutputArray *dst, cv::_InputArray *kernel,
                          MyCvPoint anchor, int iterations,    int borderType, MyCvScalar borderValue)
{
    BEGIN_WRAP
    cv::erode(*src, *dst, entity(kernel), cpp(anchor), iterations, borderType, cpp(borderValue));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_erode
[64bit] 特定の構造化要素を使って画像を消去します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr kernel
p4 = ARGS_POINT : Point anchor
p5 = int : int iterations
p6 = int : int borderType
p7 = var : Scalar borderValue
%inst
この関数は，最小値を取るピクセル近傍の形状を決定する，指定された構造化要素を用いて，入力画像を侵食します：??o???(x,y) = ????? (x',y'):\♪ ♪♪ (x',y') ♪ ♪ (x',y') ♪ ♪ (x',y') ♪ ♪\♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪(x+x',y+y')??＞????*。エロージョンは，複数回（イタレーション）にわたって適用することができます．他にも，odilate, morphologyEx, getStructuringElementExamples: samples/cpp/segment_objects.cpp, and samples/cpp/tutorial_code/ImgProc/Morphology_1.cppを参照してください．

元関数名(C#): imgproc_erode
元DLLエクスポート名: imgproc_erode
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_erode(cv::_InputArray *src, cv::_OutputArray *dst, cv::_InputArray *kernel,
                          MyCvPoint anchor, int iterations,    int borderType, MyCvScalar borderValue)
{
    BEGIN_WRAP
    cv::erode(*src, *dst, entity(kernel), cpp(anchor), iterations, borderType, cpp(borderValue));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_dilate
[32bit] 特定の構造化要素を用いて画像を拡張します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr kernel
p4 = ARGS_POINT : Point anchor
p5 = int : int iterations
p6 = int : int borderType
p7 = ARGS_SCALAR : Scalar borderValue
%inst
この関数は，最大値が取られるピクセル近傍の形状を決定する，指定された構造化要素を用いて，入力画像を拡張します：????? )(x,y) = ″max _{(x',y') "です。\♪ ♪(x',y') ???????｝\♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪(x+x',y+y')???＞??*。ダイレーションは，複数回（イタレーション）行うことができます．See alsoerode, morphologyEx, getStructuringElementExamples: samples/cpp/segment_objects.cpp, samples/cpp/squares.cpp, samples/cpp/stitching_detailed.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, and samples/tapi/squares.cpp.

元関数名(C#): imgproc_dilate
元DLLエクスポート名: imgproc_dilate
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_dilate(cv::_InputArray *src, cv::_OutputArray *dst, cv::_InputArray *kernel,
                           CvPoint anchor, int iterations, int borderType, CvScalar borderValue)
{
    BEGIN_WRAP
    cv::dilate(*src, *dst, entity(kernel), anchor, iterations, borderType, borderValue);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_dilate
[64bit] 特定の構造化要素を用いて画像を拡張します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr kernel
p4 = ARGS_POINT : Point anchor
p5 = int : int iterations
p6 = int : int borderType
p7 = var : Scalar borderValue
%inst
この関数は，最大値が取られるピクセル近傍の形状を決定する，指定された構造化要素を用いて，入力画像を拡張します：????? )(x,y) = ″max _{(x',y') "です。\♪ ♪(x',y') ???????｝\♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪(x+x',y+y')???＞??*。ダイレーションは，複数回（イタレーション）行うことができます．See alsoerode, morphologyEx, getStructuringElementExamples: samples/cpp/segment_objects.cpp, samples/cpp/squares.cpp, samples/cpp/stitching_detailed.cpp, samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp, and samples/tapi/squares.cpp.

元関数名(C#): imgproc_dilate
元DLLエクスポート名: imgproc_dilate
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_dilate(cv::_InputArray *src, cv::_OutputArray *dst, cv::_InputArray *kernel,
                           CvPoint anchor, int iterations, int borderType, CvScalar borderValue)
{
    BEGIN_WRAP
    cv::dilate(*src, *dst, entity(kernel), anchor, iterations, borderType, borderValue);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_morphologyEx
[32bit] 高度なモルフォロジー変換を行います。
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int op
p4 = sptr : IntPtr kernel
p5 = ARGS_POINT : Point anchor
p6 = int : int iterations
p7 = int : int borderType
p8 = ARGS_SCALAR : Scalar borderValue
%inst
関数 cv::morphologyEx は，エロージョンとダイレーションを基本操作として，高度な形態素変換を行うことができます．また，odilate, erode, getStructuringElementも参照してください．注釈反復回数とは，侵食や拡張の操作が適用される回数です．例えば、2回の繰り返しによるオープニング操作(MORPH_OPEN)は、erode -> erode -> dilate -> dilate (erode -> dilate -> erode -> dilateではない)を連続して適用することに相当します。例：samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp.

元関数名(C#): imgproc_morphologyEx
元DLLエクスポート名: imgproc_morphologyEx
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_morphologyEx(cv::_InputArray *src, cv::_OutputArray *dst, int op, cv::_InputArray *kernel,
                                 MyCvPoint anchor, int iterations, int borderType, MyCvScalar borderValue)
{
    BEGIN_WRAP
    cv::morphologyEx(*src, *dst, op, entity(kernel), cpp(anchor), iterations, borderType, cpp(borderValue));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_morphologyEx
[64bit] 高度なモルフォロジー変換を行います。
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int op
p4 = sptr : IntPtr kernel
p5 = ARGS_POINT : Point anchor
p6 = int : int iterations
p7 = int : int borderType
p8 = var : Scalar borderValue
%inst
関数 cv::morphologyEx は，エロージョンとダイレーションを基本操作として，高度な形態素変換を行うことができます．また，odilate, erode, getStructuringElementも参照してください．注釈反復回数とは，侵食や拡張の操作が適用される回数です．例えば、2回の繰り返しによるオープニング操作(MORPH_OPEN)は、erode -> erode -> dilate -> dilate (erode -> dilate -> erode -> dilateではない)を連続して適用することに相当します。例：samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp.

元関数名(C#): imgproc_morphologyEx
元DLLエクスポート名: imgproc_morphologyEx
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_morphologyEx(cv::_InputArray *src, cv::_OutputArray *dst, int op, cv::_InputArray *kernel,
                                 MyCvPoint anchor, int iterations, int borderType, MyCvScalar borderValue)
{
    BEGIN_WRAP
    cv::morphologyEx(*src, *dst, op, entity(kernel), cpp(anchor), iterations, borderType, cpp(borderValue));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_resize
[32/64bit] 画像のリサイズを行います．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = ARGS_SIZE : Size dsize
p4 = double : double fx
p5 = double : double fy
p6 = int : int interpolation
%inst
関数 resize は，画像 src を指定されたサイズに縮小あるいは拡大します．ただし，初期状態の dst のタイプやサイズは考慮されません．代わりに， src,dsize,fx,fy からサイズとタイプが導かれます．あらかじめ作成された dst に合うように src のサイズを変更したい場合は，次のようにこの関数を呼び出します： // 明示的に dsize=dst.size() を指定します．fx とfy は，that.resize(src, dst, dst.size(), 0, 0, interpolation);fragment画像を各方向に2分の1ずつ縮小したい場合は，次のように関数を呼び出します： // fx とfy を指定して，関数に出力画像サイズを計算させます．5, interpolation);fragment画像を縮小する場合は，一般的にINTER_AREA補間が最適です．一方，画像を拡大する場合は，一般的にc::INTER_CUBIC（遅い）またはINTER_LINEAR（速いが，それでも問題ない）が最適です．alsowarpAffine, warpPerspective, remapExamples: samples/cpp/image_alignment.cpp, samples/cpp/train_HOG.cpp, samples/dnn/classification.cpp, samples/dnn/colorization.cpp, samples/dnn/object_detection.cpp, and samples/dnn/segmentation.cppを参照してください。

元関数名(C#): imgproc_resize
元DLLエクスポート名: imgproc_resize
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_resize(cv::_InputArray* src, cv::_OutputArray* dst, MyCvSize dsize, double fx, double fy, int interpolation)
{
    BEGIN_WRAP
    cv::resize(*src, *dst, cpp(dsize), fx, fy, interpolation);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_warpAffine
[32bit] 画像にアフィン変換を施します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr m
p4 = ARGS_SIZE : Size dsize
p5 = int : int flags
p6 = int : int borderMode
p7 = ARGS_SCALAR : Scalar borderValue
%inst
関数 warpAffine は，指定された行列を用いて入力画像を変換します．(x,y) = ??o??? ( ????? )_{11} x + ????? )_{12} y + ????? )_{13}, ????? )_{21} x + ?????_{22} y + ????? )_{23})は，フラグ WARP_INVERSE_MAP が設定されている場合に使用されます。他にも，owarpPerspective, resize, remap, getRectSubPix, transformExamples: samples/cpp/image_alignment.cpp を参照してください．

元関数名(C#): imgproc_warpAffine
元DLLエクスポート名: imgproc_warpAffine
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_warpAffine(cv::_InputArray* src, cv::_OutputArray* dst, cv::_InputArray* M, MyCvSize dsize,
                                          int flags, int borderMode, MyCvScalar borderValue)
{
    BEGIN_WRAP
    cv::warpAffine(*src, *dst, *M, cpp(dsize), flags, borderMode, cpp(borderValue));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_warpAffine
[64bit] 画像にアフィン変換を施します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr m
p4 = ARGS_SIZE : Size dsize
p5 = int : int flags
p6 = int : int borderMode
p7 = var : Scalar borderValue
%inst
関数 warpAffine は，指定された行列を用いて入力画像を変換します．(x,y) = ??o??? ( ????? )_{11} x + ????? )_{12} y + ????? )_{13}, ????? )_{21} x + ?????_{22} y + ????? )_{23})は，フラグ WARP_INVERSE_MAP が設定されている場合に使用されます。他にも，owarpPerspective, resize, remap, getRectSubPix, transformExamples: samples/cpp/image_alignment.cpp を参照してください．

元関数名(C#): imgproc_warpAffine
元DLLエクスポート名: imgproc_warpAffine
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_warpAffine(cv::_InputArray* src, cv::_OutputArray* dst, cv::_InputArray* M, MyCvSize dsize,
                                          int flags, int borderMode, MyCvScalar borderValue)
{
    BEGIN_WRAP
    cv::warpAffine(*src, *dst, *M, cpp(dsize), flags, borderMode, cpp(borderValue));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_warpPerspective_MisInputArray
[32bit] 画像に透視変換を施します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr m
p4 = ARGS_SIZE : Size dsize
p5 = int : int flags
p6 = int : int borderMode
p7 = ARGS_SCALAR : Scalar borderValue
%inst
関数 warpPerspective は，指定された行列を用いて入力画像を変換します：??o???(x,y) = ????? )\Left ( ????? )M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} ??????。\WARP_INVERSE_MAPフラグが設定されている場合は、[right )となります。他にも，owarpAffine, resize, remap, getRectSubPix, perspectiveTransformExamples: samples/cpp/image_alignment.cpp, and samples/dnn/text_detection.cpp を参照してください．

元関数名(C#): imgproc_warpPerspective_MisInputArray
元DLLエクスポート名: imgproc_warpPerspective_MisInputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_warpPerspective_MisInputArray(cv::_InputArray* src, cv::_OutputArray* dst, cv::_InputArray* m, MyCvSize dsize,
                                                             int flags, int borderMode, MyCvScalar borderValue)
{
    BEGIN_WRAP
    cv::warpPerspective(*src, *dst, *m, cpp(dsize), flags, borderMode, cpp(borderValue));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_warpPerspective_MisInputArray
[64bit] 画像に透視変換を施します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr m
p4 = ARGS_SIZE : Size dsize
p5 = int : int flags
p6 = int : int borderMode
p7 = var : Scalar borderValue
%inst
関数 warpPerspective は，指定された行列を用いて入力画像を変換します：??o???(x,y) = ????? )\Left ( ????? )M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} ??????。\WARP_INVERSE_MAPフラグが設定されている場合は、[right )となります。他にも，owarpAffine, resize, remap, getRectSubPix, perspectiveTransformExamples: samples/cpp/image_alignment.cpp, and samples/dnn/text_detection.cpp を参照してください．

元関数名(C#): imgproc_warpPerspective_MisInputArray
元DLLエクスポート名: imgproc_warpPerspective_MisInputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_warpPerspective_MisInputArray(cv::_InputArray* src, cv::_OutputArray* dst, cv::_InputArray* m, MyCvSize dsize,
                                                             int flags, int borderMode, MyCvScalar borderValue)
{
    BEGIN_WRAP
    cv::warpPerspective(*src, *dst, *m, cpp(dsize), flags, borderMode, cpp(borderValue));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_warpPerspective_MisArray
[32bit] 画像に透視変換を施します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = var : [MarshalAs(UnmanagedType.LPArray)] float[,] m
p4 = int : int mRow
p5 = int : int mCol
p6 = ARGS_SIZE : Size dsize
p7 = int : int flags
p8 = int : int borderMode
p9 = ARGS_SCALAR : Scalar borderValue
%inst
関数 warpPerspective は，指定された行列を用いて入力画像を変換します：??o???(x,y) = ????? )\Left ( ????? )M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} ??????。\WARP_INVERSE_MAPフラグが設定されている場合は、[right )となります。他にも，owarpAffine, resize, remap, getRectSubPix, perspectiveTransformExamples: samples/cpp/image_alignment.cpp, and samples/dnn/text_detection.cpp を参照してください．

元関数名(C#): imgproc_warpPerspective_MisArray
元DLLエクスポート名: imgproc_warpPerspective_MisArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_warpPerspective_MisArray(cv::_InputArray* src, cv::_OutputArray* dst, float* m, int mRow, int mCol, MyCvSize dsize,
                                                        int flags, int borderMode, MyCvScalar borderValue)
{
    BEGIN_WRAP
    const cv::Mat mmat(mRow, mCol, CV_32FC1, m);
    cv::warpPerspective(*src, *dst, mmat, cpp(dsize), flags, borderMode, cpp(borderValue));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_warpPerspective_MisArray
[64bit] 画像に透視変換を施します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = var : [MarshalAs(UnmanagedType.LPArray)] float[,] m
p4 = int : int mRow
p5 = int : int mCol
p6 = ARGS_SIZE : Size dsize
p7 = int : int flags
p8 = int : int borderMode
p9 = var : Scalar borderValue
%inst
関数 warpPerspective は，指定された行列を用いて入力画像を変換します：??o???(x,y) = ????? )\Left ( ????? )M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} ??????。\WARP_INVERSE_MAPフラグが設定されている場合は、[right )となります。他にも，owarpAffine, resize, remap, getRectSubPix, perspectiveTransformExamples: samples/cpp/image_alignment.cpp, and samples/dnn/text_detection.cpp を参照してください．

元関数名(C#): imgproc_warpPerspective_MisArray
元DLLエクスポート名: imgproc_warpPerspective_MisArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_warpPerspective_MisArray(cv::_InputArray* src, cv::_OutputArray* dst, float* m, int mRow, int mCol, MyCvSize dsize,
                                                        int flags, int borderMode, MyCvScalar borderValue)
{
    BEGIN_WRAP
    const cv::Mat mmat(mRow, mCol, CV_32FC1, m);
    cv::warpPerspective(*src, *dst, mmat, cpp(dsize), flags, borderMode, cpp(borderValue));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_remap
[32bit] 汎用的な幾何学変換を画像に適用します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr map1
p4 = sptr : IntPtr map2
p5 = int : int interpolation
p6 = int : int borderMode
p7 = ARGS_SCALAR : Scalar borderValue
%inst
関数 remap は，指定されたマップを用いて入力画像を変換します．ここで，非整数の座標を持つピクセルの値は，利用可能な補間手法の1つを用いて計算されます．\????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ??? )マップの浮動小数点表現から固定小数点表現に変換したい理由は、リマッピング操作をより高速（2倍）にできるからです。この関数は，インプレイス処理を行うことはできません． 注意現在の実装上の制限により，入出力画像のサイズは 32767x32767 以下でなければいけません．

元関数名(C#): imgproc_remap
元DLLエクスポート名: imgproc_remap
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_remap(cv::_InputArray* src, cv::_OutputArray* dst, cv::_InputArray* map1, cv::_InputArray* map2,
                                     int interpolation, int borderMode, MyCvScalar borderValue)
{
    BEGIN_WRAP
    cv::remap(*src, *dst, *map1, *map2, interpolation, borderMode, cpp(borderValue));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_remap
[64bit] 汎用的な幾何学変換を画像に適用します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr map1
p4 = sptr : IntPtr map2
p5 = int : int interpolation
p6 = int : int borderMode
p7 = var : Scalar borderValue
%inst
関数 remap は，指定されたマップを用いて入力画像を変換します．ここで，非整数の座標を持つピクセルの値は，利用可能な補間手法の1つを用いて計算されます．\????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ??? )マップの浮動小数点表現から固定小数点表現に変換したい理由は、リマッピング操作をより高速（2倍）にできるからです。この関数は，インプレイス処理を行うことはできません． 注意現在の実装上の制限により，入出力画像のサイズは 32767x32767 以下でなければいけません．

元関数名(C#): imgproc_remap
元DLLエクスポート名: imgproc_remap
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_remap(cv::_InputArray* src, cv::_OutputArray* dst, cv::_InputArray* map1, cv::_InputArray* map2,
                                     int interpolation, int borderMode, MyCvScalar borderValue)
{
    BEGIN_WRAP
    cv::remap(*src, *dst, *map1, *map2, interpolation, borderMode, cpp(borderValue));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_convertMaps
[32/64bit] 画像変換マップをある表現方法から別の表現方法に変換します。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr map1
p2 = sptr : IntPtr map2
p3 = sptr : IntPtr dstmap1
p4 = sptr : IntPtr dstmap2
p5 = int : int dstmap1Type
p6 = int : int nninterpolation
%inst
この関数は，リマップ用のマップのペアを，ある表現から別の表現に変換します．以下のオプション（ (map1.type(), map2.type())\(dstmap1.type(), dstmap2.type()) ) がサポートされています．\\\\\\\\\\\\\\\\これは，最も頻繁に利用される変換処理で，元の浮動小数点マップ（ リマップ を参照）を，よりコンパクトで高速な固定小数点表現に変換します．1 番目の出力配列には，丸められた座標が含まれ，2 番目の出力配列（nninterpolation=false の場合のみ作成）には，補間テーブルのインデックスが含まれます．

\(\texttt{(CV_32FC2)}\\\\\\\\\\\\上と同じですが，元のマップは1つの2チャンネルマトリックスに格納されます．

逆変換．参照：oremap, undistort, initUndistortRectifyMap

元関数名(C#): imgproc_convertMaps
元DLLエクスポート名: imgproc_convertMaps
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_convertMaps(cv::_InputArray* map1, cv::_InputArray* map2, cv::_OutputArray* dstmap1, cv::_OutputArray* dstmap2,
                                           int dstmap1type, int nnInterpolation)
{
    BEGIN_WRAP
    cv::convertMaps(*map1, *map2, *dstmap1, *dstmap2, dstmap1type, nnInterpolation != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_getRotationMatrix2D
[32/64bit] 2次元回転のアフィン変換行列を計算します．
%prm
p1,p2,p3,p4
p1 = ARGS_POINT2F : Point2f center
p2 = double : double angle
p3 = double : double scale
p4 = var : out IntPtr returnValue
%inst
この関数は，次のような行列を計算します．\(1- ????? ) ????? ) ????? ) ????? )- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\+ (1- ????? ) ????? )\end{bmatrix}\]where\[\begin{array}{l}\ardor\abruptly♪\\\\\\\\\end{array}\]この変換は、回転中心を自分自身にマッピングします。参照：getAffineTransform、warpAffine、transform

元関数名(C#): imgproc_getRotationMatrix2D
元DLLエクスポート名: imgproc_getRotationMatrix2D
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_getRotationMatrix2D(MyCvPoint2D32f center, double angle, double scale, cv::Mat** returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::getRotationMatrix2D(cpp(center), angle, scale);
    *returnValue = new cv::Mat(ret);
    END_WRAP

}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_invertAffineTransform
[32/64bit] アフィン変換を反転させます。
%prm
p1,p2
p1 = sptr : IntPtr m
p2 = sptr : IntPtr im
%inst
この関数は，M で表される逆アフィン変換を計算します：\[begin{bmatrix} a_{11} & a_{12} & b_1 ???????]結果は，M と同じ型の ??????? )行列です．

元関数名(C#): imgproc_invertAffineTransform
元DLLエクスポート名: imgproc_invertAffineTransform
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_invertAffineTransform(cv::_InputArray* M, cv::_OutputArray *iM)
{
    BEGIN_WRAP
    cv::invertAffineTransform(*M, *iM);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_getPerspectiveTransform1
[32/64bit] 4組の対応する点から，透視変換を計算します．
%prm
p1,p2,p3
p1 = var : Point2f[] src
p2 = var : Point2f[] dst
p3 = var : out IntPtr returnValue
%inst
この関数は，透視変換の行列を計算し，次のようになります．\How do you do?cpp、samples/dnn/text_detection.cpp。

元関数名(C#): imgproc_getPerspectiveTransform1
元DLLエクスポート名: imgproc_getPerspectiveTransform1
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_getPerspectiveTransform1(cv::Point2f *src, cv::Point2f *dst, cv::Mat** returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::getPerspectiveTransform(src, dst);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_getPerspectiveTransform2
[32/64bit] 4組の対応する点から，透視変換を計算します．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = var : out IntPtr returnValue
%inst
この関数は，透視変換の行列を計算し，次のようになります．\How do you do?cpp、samples/dnn/text_detection.cpp。

元関数名(C#): imgproc_getPerspectiveTransform2
元DLLエクスポート名: imgproc_getPerspectiveTransform2
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_getPerspectiveTransform2(cv::_InputArray *src, cv::_InputArray *dst, cv::Mat** returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::getPerspectiveTransform(*src, *dst);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_getAffineTransform1
[32/64bit] 3組の対応点からアフィン変換を計算します。
%prm
p1,p2,p3
p1 = var : Point2f[] src
p2 = var : Point2f[] dst
p3 = var : out IntPtr returnValue
%inst
この関数は，アフィン変換の行列を計算し，次のようになります．

元関数名(C#): imgproc_getAffineTransform1
元DLLエクスポート名: imgproc_getAffineTransform1
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_getAffineTransform1(cv::Point2f *src, cv::Point2f *dst, cv::Mat** returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::getAffineTransform(src, dst);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_getAffineTransform2
[32/64bit] 3組の対応点からアフィン変換を計算します。
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = var : out IntPtr returnValue
%inst
この関数は，アフィン変換の行列を計算し，次のようになります．

元関数名(C#): imgproc_getAffineTransform2
元DLLエクスポート名: imgproc_getAffineTransform2
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_getAffineTransform2(cv::_InputArray *src, cv::_InputArray *dst, cv::Mat** returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::getAffineTransform(*src, *dst);
    *returnValue = new cv::Mat(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_getRectSubPix
[32/64bit] 画像から，サブピクセル精度でピクセル矩形を抽出します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr image
p2 = ARGS_SIZE : Size patchSize
p3 = ARGS_POINT2F : Point2f center
p4 = sptr : IntPtr patch
p5 = int : int patchType
%inst
関数 getRectSubPix は， src からピクセルを抽出します：\[patch(x, y) = src(x + ??? -? ???)- ( ????? )[patch(x.y) = src(x + ????? ) ( ????? ), y + ????? )]ここで，非整数の座標におけるピクセル値は，バイリニア補間を用いて取得されます．マルチチャンネル画像の各チャンネルは，独立して処理されます．また，画像はシングルチャンネルまたは3チャンネルの画像でなければなりません。参照：owarpAffine, warpPerspective

元関数名(C#): imgproc_getRectSubPix
元DLLエクスポート名: imgproc_getRectSubPix
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_getRectSubPix(cv::_InputArray *image, MyCvSize patchSize, MyCvPoint2D32f center, cv::_OutputArray *patch, int patchType)
{
    BEGIN_WRAP
    cv::getRectSubPix(*image, cpp(patchSize), cpp(center), *patch, patchType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_logPolar
[32/64bit] 画像を半極座標空間に再マッピングします。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = ARGS_POINT2F : Point2f center
p4 = double : double m
p5 = int : int flags
%inst
Deprecated：この関数は， cv::warpPolar(src, dst, src.size(), center, maxRadius, flags+WARP_POLAR_LOG);と同じ結果になります．

元関数名(C#): imgproc_logPolar
元DLLエクスポート名: imgproc_logPolar
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_logPolar(cv::_InputArray *src, cv::_OutputArray *dst,
                             MyCvPoint2D32f center, double M, int flags)
{
    BEGIN_WRAP
    cv::logPolar(*src, *dst, cpp(center), M, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_linearPolar
[32/64bit] 画像を極座標空間に再マッピングします。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = ARGS_POINT2F : Point2f center
p4 = double : double maxRadius
p5 = int : int flags
%inst
Deprecated：この関数は， cv::warpPolar(src, dst, src.size(), center, maxRadius, flags) と同じ結果になります．

元関数名(C#): imgproc_linearPolar
元DLLエクスポート名: imgproc_linearPolar
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_linearPolar(cv::_InputArray *src, cv::_OutputArray *dst,
                                MyCvPoint2D32f center, double maxRadius, int flags)
{
    BEGIN_WRAP
    cv::linearPolar(*src, *dst, cpp(center), maxRadius, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_warpPolar
[32/64bit] 画像を極座標または半極座標空間に再マッピングします．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = ARGS_SIZE : Size dsize
p4 = ARGS_POINT2F : Point2f center
p5 = double : double maxRadius
p6 = int : int flags
%inst
Polar remaps reference次の変換を用いて、ソース画像を変換します。\(x - center.x, y - center.y) (phi)(♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪Klin (McDot)(with) & default ¶ Klog ¶ log_e(??? -? ???)(semilog ????????\♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪\♪♪♪♪♪♪♪〜Kangle = dsize.height / 2Pi ☆Klin = dsize.width / maxRadius ☆Klog = dsize.width / log_e(maxRadius) ☆end{array} ☆end{array} ☆end{array} ☆end{array}!\Linear vs semilog mappingPolar mappingにはlinearとsemi-logがあります。線形はデフォルトで、セミログマッピングは、人間の「小窩座」と呼ばれる視力を模したもので、周辺部の視力が低いのに対して、視線上の視力が非常に高いという特徴があります。

\dsize.width = ????? ) ????? ) ????? ) ????? )





dsize.height <= 0のみの場合、出力画像の領域は bounding circleの領域に比例しますが、Kx * Kxでスケーリングされます。

\dsize.height = ????? (dmsize.width ?????) ????? (frank)\]





dsize＞0の場合、出力画像は指定されたサイズになりますので、外接円の面積はdsizeに合わせて拡大されます。リバースマッピング flagsにWARP_INVERSE_MAPを追加することで、リバースマッピングを行うことができます//直接変換 warpPolar(src, lin_polar_img, Size(),center, maxRadius, flags);                     // linear Polar warpPolar(src, log_polar_img, Size(),center, maxRadius, flags + WARP_POLAR_LOG); // semilog Polar // 逆変換 warpPolar(lin_polar_img, recovered_lin_polar_img, src.size(), center, maxRadius, flags + WARP_INVERSE_MAP); warpPolar(log_polar_img, recovered_log_polar, src.size(), center, maxRadius, flags + WARP_POLAR_LOG + WARP_INVERSE_MAP);fragment追加で，極マップされた座標から元の座標を計算する方法 ?((rho, phi)->(x, y)?):double angleRad, magnitude; double Kangle = dst.rows / CV_2PI; angleRad = phi / Kangle; if (flags & WARP_POLAR_LOG) { double Klog = dst.cols / std::log(maxRadius); magnitude = std::exp(rho / Klog); } else { double Klin = dst.cols / maxRadius; magnitude = rho / Klin; } int x = cvRound(center.x + magnitude * cos(angleRad)); int y = cvRound(center.y + magnitude * sin(angleRad));fragmentNote

この関数は，置換して動作させることはできません．

大きさと角度を度単位で計算するために，内部では cartToPolar が利用され，角度は 0 から 360 まで，約 0.3 度の精度で測定されます．

この関数はリマップを使用します。alsocv::remapExamples: samples/cpp/polar_transforms.cpp を参照してください。

元関数名(C#): imgproc_warpPolar
元DLLエクスポート名: imgproc_warpPolar
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_warpPolar(
    cv::_InputArray *src, cv::_OutputArray *dst, MyCvSize dsize,
    MyCvPoint2D32f center, double maxRadius, int flags)
{
    BEGIN_WRAP
    cv::warpPolar(*src, *dst, cpp(dsize), cpp(center), maxRadius, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_integral1
[32/64bit] 画像の積分を計算します．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr sum
p3 = int : int sdepth
%inst
この関数は，入力画像に対する1つまたは複数の積分画像を次のように計算します：??? -? ??? ???? ???? ???? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ?????(X,Y) = ＼sum _{y<Y,abs(x-X+1) ＼Y-y-1}／ ＼texttt{image}／(x,y)??]これらの積分画像を使って、例えば、画像の上下左右に回転した特定の矩形領域の総和、平均、標準偏差を一定時間で計算することができます。\イメージ(x,y) = ????? )(x_2,y_2)-\\(x_1,y_2)-\\(x_2,y_1)+ ????????????。(x_1,y_1)】これにより，例えば，可変の窓サイズで高速ブラーリングや高速ブロック相関を行うことができる．マルチチャンネル画像の場合，各チャンネルの総和は独立に累積されます．次の図は，実際の例として，まっすぐな矩形Rect(3,3,3,2)と傾いた矩形Rect(5,1,2,3)の積分の計算を示しています．元画像の選択されたピクセルと，積分画像の和と傾斜の相対的なピクセルが示されています．積分計算の例

元関数名(C#): imgproc_integral1
元DLLエクスポート名: imgproc_integral1
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_integral1(cv::_InputArray *src, cv::_OutputArray *sum, int sdepth)
{
    BEGIN_WRAP
    cv::integral(*src, *sum, sdepth);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_integral2
[32/64bit] 画像の積分を計算します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr sum
p3 = sptr : IntPtr sqsum
p4 = int : int sdepth
%inst
この関数は，入力画像に対する1つまたは複数の積分画像を次のように計算します：??? -? ??? ???? ???? ???? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ?????(X,Y) = ＼sum _{y<Y,abs(x-X+1) ＼Y-y-1}／ ＼texttt{image}／(x,y)??]これらの積分画像を使って、例えば、画像の上下左右に回転した特定の矩形領域の総和、平均、標準偏差を一定時間で計算することができます。\イメージ(x,y) = ????? )(x_2,y_2)-\\(x_1,y_2)-\\(x_2,y_1)+ ????????????。(x_1,y_1)】これにより，例えば，可変の窓サイズで高速ブラーリングや高速ブロック相関を行うことができる．マルチチャンネル画像の場合，各チャンネルの総和は独立に累積されます．次の図は，実際の例として，まっすぐな矩形Rect(3,3,3,2)と傾いた矩形Rect(5,1,2,3)の積分の計算を示しています．元画像の選択されたピクセルと，積分画像の和と傾斜の相対的なピクセルが示されています．積分計算の例

元関数名(C#): imgproc_integral2
元DLLエクスポート名: imgproc_integral2
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_integral2(cv::_InputArray *src, cv::_OutputArray *sum, cv::_OutputArray *sqsum, int sdepth)
{
    BEGIN_WRAP
    cv::integral(*src, *sum, *sqsum, sdepth);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_integral3
[32/64bit] 画像の積分を計算します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr sum
p3 = sptr : IntPtr sqsum
p4 = sptr : IntPtr tilted
p5 = int : int sdepth
p6 = int : int sqdepth
%inst
この関数は，入力画像に対する1つまたは複数の積分画像を次のように計算します：??? -? ??? ???? ???? ???? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? ?????(X,Y) = ＼sum _{y<Y,abs(x-X+1) ＼Y-y-1}／ ＼texttt{image}／(x,y)??]これらの積分画像を使って、例えば、画像の上下左右に回転した特定の矩形領域の総和、平均、標準偏差を一定時間で計算することができます。\イメージ(x,y) = ????? )(x_2,y_2)-\\(x_1,y_2)-\\(x_2,y_1)+ ????????????。(x_1,y_1)】これにより，例えば，可変の窓サイズで高速ブラーリングや高速ブロック相関を行うことができる．マルチチャンネル画像の場合，各チャンネルの総和は独立に累積されます．次の図は，実際の例として，まっすぐな矩形Rect(3,3,3,2)と傾いた矩形Rect(5,1,2,3)の積分の計算を示しています．元画像の選択されたピクセルと，積分画像の和と傾斜の相対的なピクセルが示されています．積分計算の例

元関数名(C#): imgproc_integral3
元DLLエクスポート名: imgproc_integral3
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_integral3(cv::_InputArray *src, cv::_OutputArray *sum, cv::_OutputArray *sqsum, cv::_OutputArray *tilted, int sdepth, int sqdepth)
{
    BEGIN_WRAP
    cv::integral(*src, *sum, *sqsum, *tilted, sdepth, sqdepth);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_accumulate
[32/64bit] 画像をアキュムレータ画像に追加します．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr mask
%inst
この関数は， src またはその一部の要素を dst に追加します．(x,y) ???????(x,y) + ??? -? ????(x,y)\♪♪「マスク(x,y) ??????? マルチチャンネル画像に対応しています。関数 cv::acumulate は，例えば，スチルカメラで撮影されたシーンの背景の統計量を収集し，さらに前景と背景のセグメンテーションを行うために利用できます．

元関数名(C#): imgproc_accumulate
元DLLエクスポート名: imgproc_accumulate
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_accumulate(cv::_InputArray *src, cv::_InputOutputArray *dst, cv::_InputArray *mask)
{
    BEGIN_WRAP
    cv::accumulate(*src, *dst, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_accumulateSquare
[32/64bit] 入力画像の正方形をアキュムレータ画像に追加します．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr mask
%inst
この関数は，入力画像 src またはその選択領域を2の累乗にして，累算器 dst に加えます．(x,y) ???????(x,y) + ?????(x,y)^2\♪♪♪♪♪♪♪〜(x,y) ??? -? ??? マルチチャンネル画像に対応しています。関連項目：accumulateSquare，acumulateProduct，acumulateWeighted

元関数名(C#): imgproc_accumulateSquare
元DLLエクスポート名: imgproc_accumulateSquare
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_accumulateSquare(cv::_InputArray* src, cv::_InputOutputArray *dst, cv::_InputArray *mask)
{
    BEGIN_WRAP
    cv::accumulateSquare(*src, *dst, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_accumulateProduct
[32/64bit] 2つの入力画像の要素毎の積を，累算器画像に加算します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
p4 = sptr : IntPtr mask
%inst
この関数は，2つの画像またはその選択領域の積を，累算器 dst に加えます．(x,y) (x,y) + ????? )(x,y) + ?????(x,y) ♪\\\\(x,y) ♪\\\\mask(x,y) ??? -? ??? マルチチャンネル画像に対応しています。関連項目：accumulate，acumulateSquare，acumulateWeighted

元関数名(C#): imgproc_accumulateProduct
元DLLエクスポート名: imgproc_accumulateProduct
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_accumulateProduct(cv::_InputArray *src1, cv::_InputArray *src2, cv::_InputOutputArray *dst, cv::_InputArray *mask)
{
    BEGIN_WRAP
    cv::accumulateProduct(*src1, *src2, *dst, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_accumulateWeighted
[32/64bit] 移動平均を更新します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = double : double alpha
p4 = sptr : IntPtr mask
%inst
この関数は，入力画像 src と累算器 dst の加重和を計算し，dst がフレームシーケンスの走行平均になるようにします．(x,y) ¶leftarrow (1- ¶texttt{alpha} ) ¶cdot ¶texttt{dst} (x,y) + ¶texttt{dst} ¶leftarrow (1- ¶texttt{alpha} )(x,y) + ???д??? ????? ???д???(x,y) ♪♪♪＼(^o^)|mask} (x,y)(x,y) ????? ) つまり，αは，更新速度（以前の画像をどれだけ早く忘れるか）を調節します．この関数は，マルチチャンネル画像をサポートします．関連項目：accumulate, accumulateSquare, accumulateProduct

元関数名(C#): imgproc_accumulateWeighted
元DLLエクスポート名: imgproc_accumulateWeighted
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_accumulateWeighted(cv::_InputArray *src, cv::_InputOutputArray *dst, double alpha, cv::_InputArray *mask)
{
    BEGIN_WRAP
    cv::accumulateWeighted(*src, *dst, alpha, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_phaseCorrelate
[32/64bit] この関数は，2つの画像間で起こる並進方向のズレを検出するために利用されます．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr window
p4 = var : out double response
p5 = var : out Point2d returnValue
%inst
この操作は，周波数領域で並進シフトを検出するためのフーリエシフト定理を利用しています．これは、動きの推定だけでなく、高速な画像登録にも使用できます。詳しくは http://en.wikipedia.org/wiki/Phase_correlationCalculates the cross-power spectrum of two supplied source arrays をご覧ください。この関数は，次のような処理を行います：まず，各画像に対してハニング窓（ http://en.wikipedia.org/wiki/Hann_function を参照してください）を適用し，可能性のあるエッジ効果を取り除きます．この窓は，処理時間を短縮するために，配列のサイズが変わるまでキャッシュされます．

次に，各ソース配列のForward DFTを計算します．

\次のように計算します。



 ここで，\(mathcal{F}\)はForward DFTである．

次に、各周波数領域のアレイのクロスパワースペクトルを計算します。

\R = ????? )





次に、この相互相関を逆DFTにより時間領域に変換します。

\r = ???´Д｀???





最後に、ピークの位置を計算し、サブピクセルの精度を実現するために、ピークの周りに5x5の加重セントロイドを計算します。

\♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪\max{(x, y)}\{r\}\]となります。





0でない場合，応答パラメータは，ピーク位置の周りの5x5セントロイド内のrの要素の合計として計算されます．これは，最大値が1（ピークが1つの場合）になるように正規化され，複数のピークがある場合は小さくなります． 参照：odft, getOptimalDFTSize, idft, mulSpectrums createHanningWindow

元関数名(C#): imgproc_phaseCorrelate
元DLLエクスポート名: imgproc_phaseCorrelate
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_phaseCorrelate(cv::_InputArray *src1, cv::_InputArray *src2,
                                              cv::_InputArray *window, double* response, MyCvPoint2D64f* returnValue)
{
    BEGIN_WRAP
    const auto p = cv::phaseCorrelate(*src1, *src2, *window, response);
    *returnValue = { p.x, p.y };
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_createHanningWindow
[32/64bit] この関数は，2次元のハニング窓の係数を求めます．
%prm
p1,p2,p3
p1 = sptr : IntPtr dst
p2 = ARGS_SIZE : Size winSize
p3 = int : int type
%inst
詳細は (http://en.wikipedia.org/wiki/Hann_function) と (http://en.wikipedia.org/wiki/Window_function) を参照してください．例を以下に示します： // サイズが 100x100 でタイプが CV_32FMat のハニングウィンドウを作成 hann;createHanningWindow(hann, Size(100, 100), CV_32F);fragment

元関数名(C#): imgproc_createHanningWindow
元DLLエクスポート名: imgproc_createHanningWindow
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_createHanningWindow(cv::_OutputArray *dst, MyCvSize winSize, int type)
{
    BEGIN_WRAP
    cv::createHanningWindow(*dst, cpp(winSize), type);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_threshold
[32/64bit] 各配列要素に固定レベルの閾値を適用します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = double : double thresh
p4 = double : double maxval
p5 = int : int type
p6 = var : out double returnValue
%inst
この関数は，固定レベルの閾値をマルチチャンネル配列に適用します．この関数は，グレースケール画像から2値（バイナリ）画像を得るため，あるいはノイズを除去するため（つまり，値が小さすぎたり大きすぎたりするピクセルを除外するため）に利用されます．この関数がサポートする閾値処理には，いくつかの種類があります．また，特別な値である THRESH_OTSU や THRESH_TRIANGLE を，上記の値の1つと組み合わせることもできます．また，特別な値 THRESH_OTSU や THRESH_TRIANGLE と上記の値を組み合わせることもできます．これらの場合，この関数は，Otsu's または Triangle アルゴリズムを用いて最適な閾値を決定し，それを指定された閾値の代わりに利用します．注意現在，Otsu's および Triangle 法は，8ビットシングルチャンネル画像に対してのみ実装されています．参照：adaptiveThreshold, findContours, compare, min, maxExamples: samples/cpp/ffilldemo.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, and samples/tapi/squares.cpp.

元関数名(C#): imgproc_threshold
元DLLエクスポート名: imgproc_threshold
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_threshold(cv::_InputArray *src, cv::_OutputArray *dst,
                                double thresh, double maxVal, int type, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::threshold(*src, *dst, thresh, maxVal, type);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_adaptiveThreshold
[32/64bit] アダプティブスレッショルドを配列に適用します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = double : double maxValue
p4 = int : int adaptiveMethod
p5 = int : int thresholdType
p6 = int : int blockSize
p7 = double : double c
%inst
この関数は，次の式に従って，グレースケール画像を2値画像に変換します：THRESH_BINARY

\dst(x,y) = ??? -? ???}}{if ??? src(x,y) > T(x,y)??}{0}{otherwise}].





thresh_binary_inv

\dst(x,y) = ??? -? ???{0}{if ??? src(x,y) > T(x,y)??}{0}{otherwise}\ [dst(x,y) = ??? -? ???{0{maxValue}}{0}{otherwise}\] 。



 この関数は，画像をその場で処理することができます． 関連項目： しきい値，ブラー，ガウスブラー

元関数名(C#): imgproc_adaptiveThreshold
元DLLエクスポート名: imgproc_adaptiveThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_adaptiveThreshold(cv::_InputArray *src, cv::_OutputArray *dst,
                                      double maxValue, int adaptiveMethod,
                                      int thresholdType, int blockSize, double C)
{
    BEGIN_WRAP
    cv::adaptiveThreshold(*src, *dst, maxValue, adaptiveMethod, thresholdType, blockSize, C);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_pyrDown
[32/64bit] 画像をぼかし，ダウンサンプリングします．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = ARGS_SIZE : Size dstsize
p4 = int : int borderType
%inst
デフォルトでは，出力画像のサイズは Size((src.cols+1)/2, (src.rows+1)/2) として計算されますが，どのような場合でも，以下の条件を満たす必要があります：。| texttt{dstsize.width}.*2-src.cols| ??? -? ??? | ??? -? ??? | ??? -? ???*2-src.rows| ????? )]この関数は，ガウス型ピラミッドを構築する際のダウンサンプリング処理を行います．まず，入力画像をカーネルで畳み込みます：\[frac{1}{256}.\beegin{bmatrix} (1 & 4 & 6 & 4 & 4)1 & 4 & 6 & 4 & 1 ≒ 6 & 24 & 36 & 24 & 6 ≒ 4 & 16 & 24 & 16 & 4 ≒ 1 & 4 & 6 & 4 & 1 ≒ end{bmatrix}]その後、偶数行、偶数列を排除してダウンサンプリングを行います。例：samples/cpp/squares.cpp、samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp、samples/tapi/squares.cpp。

元関数名(C#): imgproc_pyrDown
元DLLエクスポート名: imgproc_pyrDown
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_pyrDown(cv::_InputArray *src, cv::_OutputArray *dst, MyCvSize dstSize, int borderType)
{
    BEGIN_WRAP
    cv::pyrDown(*src, *dst, cpp(dstSize), borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_pyrUp
[32/64bit] 画像をアップサンプリングし、それをぼかします。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = ARGS_SIZE : Size dstsize
p4 = int : int borderType
%inst
デフォルトでは，出力画像のサイズは Size(src.cols\*2, (src.rows\*2)) として計算されますが，どのような場合でも，以下の条件を満たす必要があります：??? -? ??? ???? ????????????。| ????? ( ????? ) | ????? ( ????? )height} ¶mod 2) end{array}\]この関数は，ガウス型ピラミッドを構成する際のアップサンプリングを行うものですが，実際にはラプラシアン型ピラミッドを構成するのにも使えます．例： samples/cpp/squares.cpp, samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp, and samples/tapi/squares.cpp.

元関数名(C#): imgproc_pyrUp
元DLLエクスポート名: imgproc_pyrUp
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_pyrUp(cv::_InputArray *src, cv::_OutputArray *dst, MyCvSize dstSize, int borderType)
{
    BEGIN_WRAP
    cv::pyrUp(*src, *dst, cpp(dstSize), borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_calcHist
[32/64bit] 配列の集合のヒストグラムを計算します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = sptr : IntPtr[] images
p2 = int : int nimages
p3 = var : int[] channels
p4 = sptr : IntPtr mask
p5 = sptr : IntPtr hist
p6 = int : int dims
p7 = var : int[] histSize
p8 = sptr : IntPtr[] ranges
p9 = int : int uniform
p10 = int : int accumulate
%inst
関数 cv::calcHist は，1 つまたは複数の配列のヒストグラムを計算します．ヒストグラムのビンを増加させるために用いられるタプルの要素は，対応する入力配列の同じ位置から取得されます．以下のサンプルは，カラー画像の2次元色相-彩度ヒストグラムを計算する方法を示しています． :#include <opencv2/imgproc.hpp>#include <opencv2/highgui.hpp>using namespace cv;int main( int argc, char** argv ){ Mat src, hsv; if( argc != 2 || !(src=imread(argv[1], 1)).data ) return -1; cvtColor(src, hsv, COLOR_BGR2HSV); // 色相を 30 レベルに，彩度を 32 レベルに量子化します int hbins = 30, sbins = 32; int histSize[] = {hbins, sbins};    // cvtColor を参照してください） float hranges[] = { 0, 180 }; // 彩度は，0（黒-灰色-白）から // 255（純粋なスペクトルカラー）まで変化します．    const float* ranges[] = { hranges, sranges }; MatND hist; // 0 番目と 1 番目のチャンネルからヒストグラムを計算します int channels[] = {0, 1};    calcHist( &hsv, 1, channels, Mat(), // マスクを使用しない hist, 2, histSize, ranges, true, // ヒストグラムは一様です false ); double maxVal=0; minMaxLoc(hist, 0, &maxVal, 0, 0); int scale = 10; Mat histImg = Mat::zeros(sbins*scale, hbins*10, CV_8UC3); for( int h = 0; h < hbins; h++ ) for( int s = 0; s < sbins; s++ ) { float binVal = hist.at<float>(h, s); int intensity = cvRound(binVal*255/maxVal); rectangle( histImg, Point(h*scale, s*scale), Point( (h+1)*scale - 1, (s+1)*scale - 1), Scalar::all(intensity), -1 ); } namedWindow("Source", 1 ); imshow("Source", src ); namedWindow("H-S Histogram", 1 ); imshow("H-S Histogram", histImg ); waitKey();}fragmentExamples: samples/cpp/camshiftdemo.cppとsamples/cpp/demhist.cppです。

元関数名(C#): imgproc_calcHist
元DLLエクスポート名: imgproc_calcHist
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_calcHist(cv::Mat **images, int nimages,
                              const int* channels, cv::_InputArray *mask,
                              cv::_OutputArray *hist, int dims, const int* histSize,
                              const float** ranges, int uniform, int accumulate)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; imagesVec(nimages);
    for (auto i = 0; i &amp;lt; nimages; i++)
        imagesVec[i] = *(images[i]);
    cv::calcHist(&amp;imagesVec[0], nimages, channels, entity(mask), *hist, dims, histSize, ranges, uniform != 0, accumulate != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_calcBackProject
[32/64bit] ヒストグラムのバックプロジェクションを計算します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr[] images
p2 = int : int nimages
p3 = var : int[] channels
p4 = sptr : IntPtr hist
p5 = sptr : IntPtr backProject
p6 = sptr : IntPtr[] ranges
p7 = int : int uniform
%inst
関数 cv::calcBackProject は，ヒストグラムのバックプロジェクションを計算します．つまり， calcHist と同様に，各位置 (x, y) において，入力画像の選択されたチャンネルの値を収集し，それに対応するヒストグラムのビンを求めます．しかし，この関数は，ビンの値をインクリメントするのではなく，ビンの値を読み込み，それを scale でスケーリングして backProject(x,y) に格納します．統計学の観点から言えば，この関数は，ヒストグラムで表される経験的な確率分布に関する各要素の値の確率を計算します．例えば，シーンの中の明るい色の物体を見つけて追跡する方法を見てみましょう．追跡する前に，物体がフレームのほぼ全体を覆うようにカメラに見せます．色相ヒストグラムを算出する。このヒストグラムには、物体の主要な色に対応する強い最大値が含まれています。

トラッキングの際には、事前に計算したヒストグラムを用いて、入力ビデオフレームの色相平面のバックプロジェクションを計算します。弱い色を抑制するために、バックプロジェクションの閾値を設定します。また、彩度が不十分な画素や、暗すぎる画素、明るすぎる画素を抑制することも有効です。

これはCamShiftカラーオブジェクトトラッカーの近似アルゴリズムです。socalcHist, compareHistExamples: samples/cpp/camshiftdemo.cpp.

元関数名(C#): imgproc_calcBackProject
元DLLエクスポート名: imgproc_calcBackProject
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_calcBackProject(cv::Mat **images, int nimages,
                                    const int* channels, cv::_InputArray *hist, cv::_OutputArray *backProject, 
                                    const float** ranges, int uniform)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; imagesVec(nimages);
    for (auto i = 0; i &amp;lt; nimages; i++)
        imagesVec[i] = *(images[i]);
    cv::calcBackProject(&amp;imagesVec[0], nimages, channels, *hist, *backProject, ranges, uniform != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_compareHist
[32/64bit] 2つのヒストグラムを比較します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr h1
p2 = sptr : IntPtr h2
p3 = int : int method
p4 = var : out double returnValue
%inst
関数 cv::compareHist は，指定された手法を用いて2つの密なヒストグラム，あるいは2つの疎なヒストグラムを比較します．この関数は，1次元，2次元，3次元の密なヒストグラムではうまく動作しますが，高次元の疎なヒストグラムには適していないかもしれません．このようなヒストグラムでは，エイリアシングやサンプリングの問題のために，非ゼロのヒストグラムビンの座標がわずかにずれることがあります．このようなヒストグラムや，より一般的な重み付けされた点の疎な構成を比較するには，EMD関数の使用を検討します．

元関数名(C#): imgproc_compareHist
元DLLエクスポート名: imgproc_compareHist
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_compareHist(cv::_InputArray *h1, cv::_InputArray *h2, int method, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::compareHist(*h1, *h2, method);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_equalizeHist
[32/64bit] グレースケール画像のヒストグラムを均等化します．
%prm
p1,p2
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
%inst
この関数は，以下のアルゴリズムを用いて，入力画像のヒストグラムを均等化します： src のヒストグラムを計算します．

ヒストグラムのビンの合計が 255 になるように，ヒストグラムを正規化します．

ヒストグラムの積分を計算します．

\H'_i = sum _{0 ? j < i} H(j)??」となります。





H(j)をルックアップテーブルにして、画像を変換します。\例：samples/cpp/facedetect.cpp.

元関数名(C#): imgproc_equalizeHist
元DLLエクスポート名: imgproc_equalizeHist
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_equalizeHist(cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::equalizeHist(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_EMD
[32/64bit] 2つの重み付けされた点構成の間の「最小作業」距離を計算します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr signature1
p2 = sptr : IntPtr signature2
p3 = int : int distType
p4 = sptr : IntPtr cost
p5 = var : out float lowerBound
p6 = sptr : IntPtr flow
p7 = var : out float returnValue
%inst
この関数は，地球移動距離と，2つの重み付けされた点群間の距離の下限値を計算します．207]，[208]に記載されている応用例の1つに，画像検索のための多次元ヒストグラム比較があります．EMDは、シンプレックスアルゴリズムの修正を用いて解決される輸送問題であるため、複雑さは最悪のケースで指数関数的になりますが、平均的にははるかに高速です。実際のメトリックの場合、下側の境界は（線形時間アルゴリズムを使用して）さらに高速に計算でき、2つのシグネチャが同じオブジェクトに関連しないほど離れているかどうかを大まかに判断するのに使用できます。

元関数名(C#): imgproc_EMD
元DLLエクスポート名: imgproc_EMD
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_EMD(cv::_InputArray *signature1, cv::_InputArray *signature2,
                         int distType, cv::_InputArray *cost, float* lowerBound, cv::_OutputArray *flow, float* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::EMD(*signature1, *signature2, distType, entity(cost), lowerBound, entity(flow));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_watershed
[32/64bit] watershed アルゴリズムを用いて、マーカーベースの画像セグメンテーションを行います。
%prm
p1,p2
p1 = sptr : IntPtr image
p2 = sptr : IntPtr markers
%inst
この関数は，[169]で述べられている，ノンパラメトリックなマーカーベースのセグメンテーションアルゴリズムである watershed のバリエーションの1つを実装しています． 画像をこの関数に渡す前に，画像中の希望する領域を正（>0）のインデックスを持つマーカーで大まかに表しておく必要があります．つまり，すべての領域は，ピクセル値が1，2，3...となっている1つ以上の連結成分として表現されます．このようなマーカーは，findContoursやdrawContoursを使ってバイナリマスクから取り出すことができます（watershed.cppのデモを参照）．これらのマーカーは，将来の画像領域の「種」となります．マーカー内の他のすべてのピクセルは，アウトライン化された領域との関係がわからず，アルゴリズムによって定義されるべきものなので，0に設定されるべきです．注意隣り合う2つの連結成分は，必ずしも流域の境界（-1のピクセル）で区切られているわけではありません．例えば，この関数に渡される最初のマーカー画像の中で，お互いに接していても構いません．

元関数名(C#): imgproc_watershed
元DLLエクスポート名: imgproc_watershed
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_watershed(cv::_InputArray *image, cv::_InputOutputArray *markers)
{
    BEGIN_WRAP
    cv::watershed(*image, *markers);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_pyrMeanShiftFiltering
[32bit] 画像に対して，Mean-Shift Segmentation の最初のステップを実行します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = double : double sp
p4 = double : double sr
p5 = int : int maxLevel
p6 = ARGS_TERMCRITERIA : TermCriteria termcrit
%inst
この関数は，Meanshiftセグメンテーションのフィルタリングステージを実装しています．つまり，この関数の出力は，色のグラデーションと細かいテクスチャが平坦になるようにフィルタリングされた「ポスタライズド」画像です．この関数は，入力画像（あるいは，ダウンサイズされた入力画像，下記参照）の各ピクセル（X,Y）に対して，Meanshiftの反復処理を行います．つまり，色のハイパースペースである結合空間におけるピクセル（X,Y）の近傍領域を考慮します．X- ????? X+ ????? Y- ????? Y+ ????? ||(R,G,B)-(r,g,b)|| ?????]ここで、(R,G,B)と(r,g,b)は、色空間のベクトルです。b）は、それぞれ(X,Y)と(x,y)における色成分のベクトルである（ただし、このアルゴリズムは使用する色空間に依存しないため、任意の3成分色空間を使用することができる）。近傍では、平均空間値(X',Y')と平均色ベクトル(R',G',B')が求められ、次の反復では、これらが近傍の中心として機能します：\[(X,Y)~(X',Y'),(R,G,B)~(R',G',B').I(X,Y) <- (R*,G*,B*)}\\\\\\その後、その結果をより大きな層に伝搬させ、ピラミッドの低解像度層と層の色がsr以上異なる画素のみを対象に、再度繰り返し実行します。これにより、色の領域の境界がより鮮明になります。なお、元の画像全体に対してMeanshift処理を実行した場合（つまりmaxLevel==0の場合）とは、実際には異なる結果となります。

元関数名(C#): imgproc_pyrMeanShiftFiltering
元DLLエクスポート名: imgproc_pyrMeanShiftFiltering
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_pyrMeanShiftFiltering(cv::_InputArray *src, cv::_InputOutputArray *dst,
                                          double sp, double sr, int maxLevel, MyCvTermCriteria termCrit)
{
    BEGIN_WRAP
    cv::pyrMeanShiftFiltering(*src, *dst, sp, sr, maxLevel, cpp(termCrit));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_pyrMeanShiftFiltering
[64bit] 画像に対して，Mean-Shift Segmentation の最初のステップを実行します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = double : double sp
p4 = double : double sr
p5 = int : int maxLevel
p6 = var : TermCriteria termcrit
%inst
この関数は，Meanshiftセグメンテーションのフィルタリングステージを実装しています．つまり，この関数の出力は，色のグラデーションと細かいテクスチャが平坦になるようにフィルタリングされた「ポスタライズド」画像です．この関数は，入力画像（あるいは，ダウンサイズされた入力画像，下記参照）の各ピクセル（X,Y）に対して，Meanshiftの反復処理を行います．つまり，色のハイパースペースである結合空間におけるピクセル（X,Y）の近傍領域を考慮します．X- ????? X+ ????? Y- ????? Y+ ????? ||(R,G,B)-(r,g,b)|| ?????]ここで、(R,G,B)と(r,g,b)は、色空間のベクトルです。b）は、それぞれ(X,Y)と(x,y)における色成分のベクトルである（ただし、このアルゴリズムは使用する色空間に依存しないため、任意の3成分色空間を使用することができる）。近傍では、平均空間値(X',Y')と平均色ベクトル(R',G',B')が求められ、次の反復では、これらが近傍の中心として機能します：\[(X,Y)~(X',Y'),(R,G,B)~(R',G',B').I(X,Y) <- (R*,G*,B*)}\\\\\\その後、その結果をより大きな層に伝搬させ、ピラミッドの低解像度層と層の色がsr以上異なる画素のみを対象に、再度繰り返し実行します。これにより、色の領域の境界がより鮮明になります。なお、元の画像全体に対してMeanshift処理を実行した場合（つまりmaxLevel==0の場合）とは、実際には異なる結果となります。

元関数名(C#): imgproc_pyrMeanShiftFiltering
元DLLエクスポート名: imgproc_pyrMeanShiftFiltering
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_pyrMeanShiftFiltering(cv::_InputArray *src, cv::_InputOutputArray *dst,
                                          double sp, double sr, int maxLevel, MyCvTermCriteria termCrit)
{
    BEGIN_WRAP
    cv::pyrMeanShiftFiltering(*src, *dst, sp, sr, maxLevel, cpp(termCrit));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_grabCut
[32bit] GrabCutアルゴリズムを実行します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr img
p2 = sptr : IntPtr mask
p3 = ARGS_RECT : Rect rect
p4 = sptr : IntPtr bgdModel
p5 = sptr : IntPtr fgdModel
p6 = int : int iterCount
p7 = int : int mode
%inst
この関数は，GrabCut画像分割アルゴリズムを実装しています．例：samples/cpp/grabcut.cpp.

元関数名(C#): imgproc_grabCut
元DLLエクスポート名: imgproc_grabCut
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_grabCut(cv::_InputArray *img, cv::_InputOutputArray *mask, CvRect rect,
                            cv::_InputOutputArray *bgdModel, cv::_InputOutputArray *fgdModel,
                            int iterCount, int mode)
{
    BEGIN_WRAP
    cv::grabCut(*img, *mask, rect, *bgdModel, *fgdModel, iterCount, mode);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_grabCut
[64bit] GrabCutアルゴリズムを実行します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr img
p2 = sptr : IntPtr mask
p3 = var : Rect rect
p4 = sptr : IntPtr bgdModel
p5 = sptr : IntPtr fgdModel
p6 = int : int iterCount
p7 = int : int mode
%inst
この関数は，GrabCut画像分割アルゴリズムを実装しています．例：samples/cpp/grabcut.cpp.

元関数名(C#): imgproc_grabCut
元DLLエクスポート名: imgproc_grabCut
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_grabCut(cv::_InputArray *img, cv::_InputOutputArray *mask, CvRect rect,
                            cv::_InputOutputArray *bgdModel, cv::_InputOutputArray *fgdModel,
                            int iterCount, int mode)
{
    BEGIN_WRAP
    cv::grabCut(*img, *mask, rect, *bgdModel, *fgdModel, iterCount, mode);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_distanceTransformWithLabels
[32/64bit] 入力画像の各ピクセルについて，最も近い0ピクセルまでの距離を計算します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr labels
p4 = int : int distanceType
p5 = int : int maskSize
p6 = int : int labelType
%inst
関数 cv::distanceTransform は，2値画像の各ピクセルから，最も近い0ピクセルまでのおおよその，あるいは正確な距離を計算します．maskSize == DIST_MASK_PRECISE かつ distanceType == DIST_L2 の場合，この関数は [72] で述べられているアルゴリズムを実行します．このアルゴリズムは，TBB ライブラリによって並列化されています．その他の場合は，アルゴリズム [28] が利用されます．つまり，この関数は，あるピクセルに対して，水平，垂直，斜め，騎士の動きという基本的なシフトからなる，最も近い0ピクセルへの最短経路を求めます（最新のものは，\\のマスクで利用可能です）．全体の距離は、これらの基本的な距離の合計として計算されます。距離関数は対称でなければならないので、水平方向と垂直方向のシフトはすべて同じコスト（aと表記）でなければならず、対角線方向のシフトはすべて同じコスト（bと表記）でなければならず、ナイトの動きはすべて同じコスト（cと表記）でなければなりません。DIST_C と DIST_L1 では、距離は正確に計算されますが、DIST_L2 (Euclidean distance) では、距離は相対的な誤差でしか計算できません (mask を使うとより正確な結果が得られます)。a,b,c に対して，OpenCV は原著論文で提案された値を使用します： DIST_L1: a = 1, b = 2

DIST_L2: a = 1, b = 2:

3×3: a=0.955, b=1.3693

5×5： a=1, b=1.4, c=2.1969





DIST_C: a = 1, b = 1通常、高速で粗い距離推定DIST_L2には、??? -? ???のマスクを使用する。より正確な距離推定DIST_L2のためには、\(5\)マスクや精密アルゴリズムを用いる。この関数は，各ピクセルの最小距離\((x, y)\)を計算するだけでなく，0個のピクセルで構成される最近接連結成分(labelType==DIST_LABEL_CCOMP)や最近接0ピクセル(labelType==DIST_LABEL_PIXEL)を特定します．labels(x, y)には，成分・画素のインデックスが格納されます．labelType==DIST_LABEL_CCOMP の場合，この関数は，入力画像中のゼロピクセルの連結成分を自動的に見つけ，それらに個別のラベルを付けます．labelType==DIST_LABEL_PIXEL の場合，この関数は入力画像を走査し，すべての0ピクセルを個別のラベルでマークします．このモードでは，複雑さは線形です．つまり，この関数は，2値画像のボロノイ図を非常に高速に計算する方法を提供します．現在のところ，2番目のモードでは，近似距離変換アルゴリズムしか利用できません．つまり， maskSize=DIST_MASK_PRECISE はまだサポートされていません．

元関数名(C#): imgproc_distanceTransformWithLabels
元DLLエクスポート名: imgproc_distanceTransformWithLabels
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_distanceTransformWithLabels(cv::_InputArray *src, cv::_OutputArray *dst,
                                                cv::_OutputArray *labels, int distanceType, int maskSize,
                                                int labelType)
{
    BEGIN_WRAP
    cv::distanceTransform(*src, *dst, *labels, distanceType, maskSize, labelType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_distanceTransform
[32/64bit] 入力画像の各ピクセルについて，最も近い0ピクセルまでの距離を計算します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int distanceType
p4 = int : int maskSize
p5 = int : int dstType
%inst
関数 cv::distanceTransform は，2値画像の各ピクセルから，最も近い0ピクセルまでのおおよその，あるいは正確な距離を計算します．maskSize == DIST_MASK_PRECISE かつ distanceType == DIST_L2 の場合，この関数は [72] で述べられているアルゴリズムを実行します．このアルゴリズムは，TBB ライブラリによって並列化されています．その他の場合は，アルゴリズム [28] が利用されます．つまり，この関数は，あるピクセルに対して，水平，垂直，斜め，騎士の動きという基本的なシフトからなる，最も近い0ピクセルへの最短経路を求めます（最新のものは，\\のマスクで利用可能です）．全体の距離は、これらの基本的な距離の合計として計算されます。距離関数は対称でなければならないので、水平方向と垂直方向のシフトはすべて同じコスト（aと表記）でなければならず、対角線方向のシフトはすべて同じコスト（bと表記）でなければならず、ナイトの動きはすべて同じコスト（cと表記）でなければなりません。DIST_C と DIST_L1 では、距離は正確に計算されますが、DIST_L2 (Euclidean distance) では、距離は相対的な誤差でしか計算できません (mask を使うとより正確な結果が得られます)。a,b,c に対して，OpenCV は原著論文で提案された値を使用します： DIST_L1: a = 1, b = 2

DIST_L2: a = 1, b = 2:

3×3: a=0.955, b=1.3693

5×5： a=1, b=1.4, c=2.1969





DIST_C: a = 1, b = 1通常、高速で粗い距離推定DIST_L2には、??? -? ???のマスクを使用する。より正確な距離推定DIST_L2のためには、\(5\)マスクや精密アルゴリズムを用いる。この関数は，各ピクセルの最小距離\((x, y)\)を計算するだけでなく，0個のピクセルで構成される最近接連結成分(labelType==DIST_LABEL_CCOMP)や最近接0ピクセル(labelType==DIST_LABEL_PIXEL)を特定します．labels(x, y)には，成分・画素のインデックスが格納されます．labelType==DIST_LABEL_CCOMP の場合，この関数は，入力画像中のゼロピクセルの連結成分を自動的に見つけ，それらに個別のラベルを付けます．labelType==DIST_LABEL_PIXEL の場合，この関数は入力画像を走査し，すべての0ピクセルを個別のラベルでマークします．このモードでは，複雑さは線形です．つまり，この関数は，2値画像のボロノイ図を非常に高速に計算する方法を提供します．現在のところ，2番目のモードでは，近似距離変換アルゴリズムしか利用できません．つまり， maskSize=DIST_MASK_PRECISE はまだサポートされていません．

元関数名(C#): imgproc_distanceTransform
元DLLエクスポート名: imgproc_distanceTransform
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_distanceTransformWithLabels(cv::_InputArray *src, cv::_OutputArray *dst,
                                                cv::_OutputArray *labels, int distanceType, int maskSize,
                                                int labelType)
{
    BEGIN_WRAP
    cv::distanceTransform(*src, *dst, *labels, distanceType, maskSize, labelType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_floodFill1
[32bit] 与えられた色で連結成分を塗りつぶします．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr image
p2 = ARGS_POINT : Point seedPoint
p3 = ARGS_SCALAR : Scalar newVal
p4 = var : out Rect rect
p5 = ARGS_SCALAR : Scalar loDiff
p6 = ARGS_SCALAR : Scalar upDiff
p7 = int : int flags
p8 = var : out int returnValue
%inst
関数 cv::floodFill は，種点から始まる連結成分を，指定された色で塗りつぶします．この連結性は，隣接するピクセルの色と明るさの近さによって決まります．このピクセルは，以下の場合に，塗り替え領域に属するとみなされます：グレースケール画像で，浮動小数点数の場合

\(x',y')-(x',y')-(x',y')(x',y')-\\\\\\(x,y)には、\\\が含まれます。(x',y')+ ??? -? ???





グレースケール画像で範囲が決まっている場合は

\♪♪〜( ????? )\\\\(x,y) ??? -? ????( ????? ) + ????? )





カラー画像でフローティングレンジの場合

\\\\(x',y')_r- ????Lo_Diff????_r ardor(x,y)_r ??? -? ???(x',y')_r+ ??? -? ????_r,\]



 

\♪♪〜(x',y')_g - ??? -? ????_g ??? -? ???(x,y)_g \\(x',y')_g+ ??? -? ????_g\]



 そして

\\\\(x',y')_b- ????Lo_Diff????_b wrestler's Mr.(x,y)_b ??? -? ???(x',y')_b+ ??? -? ????_b\]





カラー画像で範囲が固定されている場合

\♪♪〜( ????? )_r ardor(x,y)_r \\\( ??o??? )_r+ ??o??? )_r,\]



 

\♪♪♪♪♪〜( ????? ) _g- ?loDiff?_g ?????????????????????? 600(x,y)_g W\\\( ????? ) _g+ ????? )_g\]



 そして

\\\\( ????? ) _b- ?????_b ????? )(x,y)_b ??? -? ????( ??o??? )_b+ ??o??? )ここで，\(src(x',y')\)は，すでにコンポーネントに属することがわかっているピクセルネイバーの1つの値です．つまり，連結成分に追加されるためには，ピクセルの色や明るさが，次のように十分に近い必要があります：浮動小数点数の場合は，既に連結成分に属している隣のピクセルの色や明るさ．

これらの関数を利用して，指定した色で連結成分をその場でマークしたり，マスクを作成してから輪郭を抽出したり，その領域を別の画像にコピーしたりすることができます．注意：マスクは塗りつぶした画像よりも大きいので，画像中のピクセル ?((x, y)?)は，マスク中のピクセル ?((x+1, y+1)?)に相当します．

元関数名(C#): imgproc_floodFill1
元DLLエクスポート名: imgproc_floodFill1
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_floodFill1(cv::_InputOutputArray *image,
                              MyCvPoint seedPoint, MyCvScalar newVal, MyCvRect *rect,
                              MyCvScalar loDiff, MyCvScalar upDiff, int flags, int *returnValue)
{
    BEGIN_WRAP
    cv::Rect rect0;
    *returnValue = cv::floodFill(*image, cpp(seedPoint), cpp(newVal), &amp;rect0, cpp(loDiff), cpp(upDiff), flags);
    *rect = c(rect0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_floodFill1
[64bit] 与えられた色で連結成分を塗りつぶします．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr image
p2 = ARGS_POINT : Point seedPoint
p3 = var : Scalar newVal
p4 = var : out Rect rect
p5 = var : Scalar loDiff
p6 = var : Scalar upDiff
p7 = int : int flags
p8 = var : out int returnValue
%inst
関数 cv::floodFill は，種点から始まる連結成分を，指定された色で塗りつぶします．この連結性は，隣接するピクセルの色と明るさの近さによって決まります．このピクセルは，以下の場合に，塗り替え領域に属するとみなされます：グレースケール画像で，浮動小数点数の場合

\(x',y')-(x',y')-(x',y')(x',y')-\\\\\\(x,y)には、\\\が含まれます。(x',y')+ ??? -? ???





グレースケール画像で範囲が決まっている場合は

\♪♪〜( ????? )\\\\(x,y) ??? -? ????( ????? ) + ????? )





カラー画像でフローティングレンジの場合

\\\\(x',y')_r- ????Lo_Diff????_r ardor(x,y)_r ??? -? ???(x',y')_r+ ??? -? ????_r,\]



 

\♪♪〜(x',y')_g - ??? -? ????_g ??? -? ???(x,y)_g \\(x',y')_g+ ??? -? ????_g\]



 そして

\\\\(x',y')_b- ????Lo_Diff????_b wrestler's Mr.(x,y)_b ??? -? ???(x',y')_b+ ??? -? ????_b\]





カラー画像で範囲が固定されている場合

\♪♪〜( ????? )_r ardor(x,y)_r \\\( ??o??? )_r+ ??o??? )_r,\]



 

\♪♪♪♪♪〜( ????? ) _g- ?loDiff?_g ?????????????????????? 600(x,y)_g W\\\( ????? ) _g+ ????? )_g\]



 そして

\\\\( ????? ) _b- ?????_b ????? )(x,y)_b ??? -? ????( ??o??? )_b+ ??o??? )ここで，\(src(x',y')\)は，すでにコンポーネントに属することがわかっているピクセルネイバーの1つの値です．つまり，連結成分に追加されるためには，ピクセルの色や明るさが，次のように十分に近い必要があります：浮動小数点数の場合は，既に連結成分に属している隣のピクセルの色や明るさ．

これらの関数を利用して，指定した色で連結成分をその場でマークしたり，マスクを作成してから輪郭を抽出したり，その領域を別の画像にコピーしたりすることができます．注意：マスクは塗りつぶした画像よりも大きいので，画像中のピクセル ?((x, y)?)は，マスク中のピクセル ?((x+1, y+1)?)に相当します．

元関数名(C#): imgproc_floodFill1
元DLLエクスポート名: imgproc_floodFill1
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_floodFill1(cv::_InputOutputArray *image,
                              MyCvPoint seedPoint, MyCvScalar newVal, MyCvRect *rect,
                              MyCvScalar loDiff, MyCvScalar upDiff, int flags, int *returnValue)
{
    BEGIN_WRAP
    cv::Rect rect0;
    *returnValue = cv::floodFill(*image, cpp(seedPoint), cpp(newVal), &amp;rect0, cpp(loDiff), cpp(upDiff), flags);
    *rect = c(rect0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_floodFill2
[32bit] 与えられた色で連結成分を塗りつぶします．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr image
p2 = sptr : IntPtr mask
p3 = ARGS_POINT : Point seedPoint
p4 = ARGS_SCALAR : Scalar newVal
p5 = var : out Rect rect
p6 = ARGS_SCALAR : Scalar loDiff
p7 = ARGS_SCALAR : Scalar upDiff
p8 = int : int flags
p9 = var : out int returnValue
%inst
関数 cv::floodFill は，種点から始まる連結成分を，指定された色で塗りつぶします．この連結性は，隣接するピクセルの色と明るさの近さによって決まります．このピクセルは，以下の場合に，塗り替え領域に属するとみなされます：グレースケール画像で，浮動小数点数の場合

\(x',y')-(x',y')-(x',y')(x',y')-\\\\\\(x,y)には、\\\が含まれます。(x',y')+ ??? -? ???





グレースケール画像で範囲が決まっている場合は

\♪♪〜( ????? )\\\\(x,y) ??? -? ????( ????? ) + ????? )





カラー画像でフローティングレンジの場合

\\\\(x',y')_r- ????Lo_Diff????_r ardor(x,y)_r ??? -? ???(x',y')_r+ ??? -? ????_r,\]



 

\♪♪〜(x',y')_g - ??? -? ????_g ??? -? ???(x,y)_g \\(x',y')_g+ ??? -? ????_g\]



 そして

\\\\(x',y')_b- ????Lo_Diff????_b wrestler's Mr.(x,y)_b ??? -? ???(x',y')_b+ ??? -? ????_b\]





カラー画像で範囲が固定されている場合

\♪♪〜( ????? )_r ardor(x,y)_r \\\( ??o??? )_r+ ??o??? )_r,\]



 

\♪♪♪♪♪〜( ????? ) _g- ?loDiff?_g ?????????????????????? 600(x,y)_g W\\\( ????? ) _g+ ????? )_g\]



 そして

\\\\( ????? ) _b- ?????_b ????? )(x,y)_b ??? -? ????( ??o??? )_b+ ??o??? )ここで，\(src(x',y')\)は，すでにコンポーネントに属することがわかっているピクセルネイバーの1つの値です．つまり，連結成分に追加されるためには，ピクセルの色や明るさが，次のように十分に近い必要があります：浮動小数点数の場合は，既に連結成分に属している隣のピクセルの色や明るさ．

これらの関数を利用して，指定した色で連結成分をその場でマークしたり，マスクを作成してから輪郭を抽出したり，その領域を別の画像にコピーしたりすることができます．注意：マスクは塗りつぶした画像よりも大きいので，画像中のピクセル ?((x, y)?)は，マスク中のピクセル ?((x+1, y+1)?)に相当します．

元関数名(C#): imgproc_floodFill2
元DLLエクスポート名: imgproc_floodFill2
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_floodFill2(cv::_InputOutputArray *image, cv::_InputOutputArray *mask,
                              MyCvPoint seedPoint, MyCvScalar newVal, MyCvRect *rect,
                              MyCvScalar loDiff, MyCvScalar upDiff, int flags, int* returnValue)
{
    BEGIN_WRAP
    cv::Rect rect0;
    *returnValue = cv::floodFill(*image, *mask, cpp(seedPoint), cpp(newVal), &amp;rect0, cpp(loDiff), cpp(upDiff), flags);
    *rect = c(rect0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_floodFill2
[64bit] 与えられた色で連結成分を塗りつぶします．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr image
p2 = sptr : IntPtr mask
p3 = ARGS_POINT : Point seedPoint
p4 = var : Scalar newVal
p5 = var : out Rect rect
p6 = var : Scalar loDiff
p7 = var : Scalar upDiff
p8 = int : int flags
p9 = var : out int returnValue
%inst
関数 cv::floodFill は，種点から始まる連結成分を，指定された色で塗りつぶします．この連結性は，隣接するピクセルの色と明るさの近さによって決まります．このピクセルは，以下の場合に，塗り替え領域に属するとみなされます：グレースケール画像で，浮動小数点数の場合

\(x',y')-(x',y')-(x',y')(x',y')-\\\\\\(x,y)には、\\\が含まれます。(x',y')+ ??? -? ???





グレースケール画像で範囲が決まっている場合は

\♪♪〜( ????? )\\\\(x,y) ??? -? ????( ????? ) + ????? )





カラー画像でフローティングレンジの場合

\\\\(x',y')_r- ????Lo_Diff????_r ardor(x,y)_r ??? -? ???(x',y')_r+ ??? -? ????_r,\]



 

\♪♪〜(x',y')_g - ??? -? ????_g ??? -? ???(x,y)_g \\(x',y')_g+ ??? -? ????_g\]



 そして

\\\\(x',y')_b- ????Lo_Diff????_b wrestler's Mr.(x,y)_b ??? -? ???(x',y')_b+ ??? -? ????_b\]





カラー画像で範囲が固定されている場合

\♪♪〜( ????? )_r ardor(x,y)_r \\\( ??o??? )_r+ ??o??? )_r,\]



 

\♪♪♪♪♪〜( ????? ) _g- ?loDiff?_g ?????????????????????? 600(x,y)_g W\\\( ????? ) _g+ ????? )_g\]



 そして

\\\\( ????? ) _b- ?????_b ????? )(x,y)_b ??? -? ????( ??o??? )_b+ ??o??? )ここで，\(src(x',y')\)は，すでにコンポーネントに属することがわかっているピクセルネイバーの1つの値です．つまり，連結成分に追加されるためには，ピクセルの色や明るさが，次のように十分に近い必要があります：浮動小数点数の場合は，既に連結成分に属している隣のピクセルの色や明るさ．

これらの関数を利用して，指定した色で連結成分をその場でマークしたり，マスクを作成してから輪郭を抽出したり，その領域を別の画像にコピーしたりすることができます．注意：マスクは塗りつぶした画像よりも大きいので，画像中のピクセル ?((x, y)?)は，マスク中のピクセル ?((x+1, y+1)?)に相当します．

元関数名(C#): imgproc_floodFill2
元DLLエクスポート名: imgproc_floodFill2
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_floodFill2(cv::_InputOutputArray *image, cv::_InputOutputArray *mask,
                              MyCvPoint seedPoint, MyCvScalar newVal, MyCvRect *rect,
                              MyCvScalar loDiff, MyCvScalar upDiff, int flags, int* returnValue)
{
    BEGIN_WRAP
    cv::Rect rect0;
    *returnValue = cv::floodFill(*image, *mask, cpp(seedPoint), cpp(newVal), &amp;rect0, cpp(loDiff), cpp(upDiff), flags);
    *rect = c(rect0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_blendLinear
[32/64bit] 2つの画像の線形ブレンドを行います．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr weights1
p4 = sptr : IntPtr weights2
p5 = sptr : IntPtr dst
%inst
\????? ( ????? ) = ????? ( ????? ) + ????? ( ????? )

元関数名(C#): imgproc_blendLinear
元DLLエクスポート名: imgproc_blendLinear
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_blendLinear(
    cv::_InputArray* src1, cv::_InputArray* src2, cv::_InputArray* weights1, cv::_InputArray* weights2, cv::_OutputArray* dst)
{
    BEGIN_WRAP
        cv::blendLinear(*src1, *src2, *weights1, *weights2, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_cvtColor
[32/64bit] 画像を，ある色空間から別の色空間に変換します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int code
p4 = int : int dstCn
%inst
この関数は，入力画像をある色空間から別の色空間に変換します．RGB色空間からの変換の場合は，チャンネルの順番を明示的に指定する必要があります（RGBまたはBGR）．OpenCVのデフォルトの色形式は，しばしばRGBと呼ばれますが，実際にはBGR（バイトが逆）であることに注意してください．つまり，標準的な（24ビット）カラー画像の1バイト目は，8ビットの青成分，2バイト目は緑，3バイト目は赤になります．R、G、Bのチャンネル値の一般的な範囲は次のとおりです：CV_8U画像では0?255

CV_8U画像では0?255、CV_16U画像では0?65535

R、G、Bのチャンネル値の範囲は、CV_8U映像では0?255、CV_16U映像では0?65535、CV_32F映像では0?1です。しかし、非線形変換の場合、正しい結果を得るためには、入力RGB画像を適切な値の範囲に正規化する必要があります。例えば、RGB ????? L*u*v* 変換の場合です。例えば，8 ビット画像から直接変換された 32 ビット浮動小数点画像をスケーリングせずに入力した場合，この関数が想定している 0 〜 1 ではなく，0 〜 255 の値域を持つことになります．ですから， cvtColor を呼び出す前に，まず画像を縮小する必要があります： img *= 1./255;cvtColor(img, img, COLOR_BGR2Luv);fragment8 ビット画像に対して cvtColor を使用した場合，変換によって失われる情報があります．変換によってアルファチャンネルが追加された場合，その値は対応するチャンネル範囲の最大値に設定されます：CV_8Uでは255，CV_16Uでは65535，CV_32Fでは1です．参照：色の変換例サンプル：samples/cpp/camshiftdemo.cpp，samples/cpp/edge.cpp, samples/cpp/facedetect.cpp, samples/cpp/ffilldemo.cpp, samples/cpp/lkdemo.cpp, samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, samples/cpp/tutorial_code/ImgTrans/houghlines.cpp、samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp、samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp、samples/cpp/watershed.cpp、samples/dnn/colorization.cpp、samples/dnn/text_detection.cpp、samples/tapi/hog.cppがあります。

元関数名(C#): imgproc_cvtColor
元DLLエクスポート名: imgproc_cvtColor
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_cvtColor(cv::_InputArray *src, cv::_OutputArray *dst, int code, int dstCn)
{
    BEGIN_WRAP
    cv::cvtColor(*src, *dst, code, dstCn);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_cvtColorTwoPlane
[32/64bit] ソース画像が2つのプレーンに格納されている場合に，画像をある色空間から別の色空間に変換します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
p4 = int : int code
%inst
この関数は、現在のところ、YUV420からRGBへの変換のみに対応しています。

元関数名(C#): imgproc_cvtColorTwoPlane
元DLLエクスポート名: imgproc_cvtColorTwoPlane
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_cvtColorTwoPlane(cv::_InputArray *src1, cv::_InputArray *src2, cv::_OutputArray *dst, int code)
{
    BEGIN_WRAP
    cv::cvtColorTwoPlane(*src1, *src2, *dst, code);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_demosaicing
[32/64bit] 全てのデモザイク処理を行うメイン関数
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int code
p4 = int : int dstCn
%inst
この関数は，以下の変換を行うことができます： バイリニア補間を用いたデモザイク処理

COLOR_BayerBG2BGR , COLOR_BayerGB2BGR , COLOR_BayerRG2BGR , COLOR_BayerGR2BGR

COLOR_BayerBG2GRAY、COLOR_BayerGB2GRAY、COLOR_BayerRG2GRAY、COLOR_BayerGR2GRAY



可変グラデーション数を用いたデモザイキング。

COLOR_BayerBG2BGR_VNG , COLOR_BayerGB2BGR_VNG , COLOR_BayerRG2BGR_VNG , COLOR_BayerGR2BGR_VNG



エッジアウェア・デモザイキング。

COLOR_BayerBG2BGR_EA , COLOR_BayerGB2BGR_EA , COLOR_BayerRG2BGR_EA , COLOR_BayerGR2BGR_EA



アルファチャンネルによるデモザイキング

COLOR_BayerBG2BGRA , COLOR_BayerGB2BGRA , COLOR_BayerRG2BGRA , COLOR_BayerGR2BGRASee alsocvtColor

元関数名(C#): imgproc_demosaicing
元DLLエクスポート名: imgproc_demosaicing
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_demosaicing(cv::_InputArray *src, cv::_OutputArray *dst, int code, int dstCn)
{
    BEGIN_WRAP
    cv::demosaicing(*src, *dst, code, dstCn);
    END_WRAP    
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_moments
[32/64bit] ポリゴンやラスタライズされた形状の3次までのモーメントをすべて計算します。
%prm
p1,p2,p3
p1 = sptr : IntPtr arr
p2 = int : int binaryImage
p3 = var : out Moments.NativeStruct returnValue
%inst
この関数は，ベクトル形状やラスタライズされた形状の，3次までのモーメントを求めます．その結果は，構造体 cv::Moments として返されます．注意Pythonバインディングによる輪郭のモーメント計算にのみ適用されます．入力配列の numpy 型は，np.int32 か np.float32 であることに注意してください．

元関数名(C#): imgproc_moments
元DLLエクスポート名: imgproc_moments
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_moments(cv::_InputArray *arr, int binaryImage, MyCvMoments *returnValue)
{
    BEGIN_WRAP
    const auto m = cv::moments(*arr, binaryImage != 0);
    *returnValue = c(m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_matchTemplate
[32/64bit] 重ね合わせた画像領域に対してテンプレートを比較します。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr image
p2 = sptr : IntPtr templ
p3 = sptr : IntPtr result
p4 = int : int method
p5 = sptr : IntPtr mask
%inst
この関数は， image をスライドさせながら，指定された方法で， templ に対してサイズ \ (w times h\) のオーバーラップしたパッチを比較し，その比較結果を result に格納します．TemplateMatchModes は，利用可能な比較手法の式を記述したものです ( ??? -? ??? )。総和は、テンプレートや画像パッチに対して行われます。\関数が比較を終えた後、minMaxLoc関数を使って、グローバルな最小値（TM_SQDIFFを使った場合）や最大値（TM_CCORRやTM_CCOEFFを使った場合）として、ベストマッチを見つけることができます。カラー画像の場合、分子のテンプレート和と分母の各和は、すべてのチャンネルに対して行われ、各チャンネルに別々の平均値が使用されます。つまり，この関数は，カラーテンプレートとカラー画像を受け取ることができます．例： samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp.

元関数名(C#): imgproc_matchTemplate
元DLLエクスポート名: imgproc_matchTemplate
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_matchTemplate(cv::_InputArray *image, cv::_InputArray *templ,
                                  cv::_OutputArray *result, int method, cv::_InputArray *mask)
{
    BEGIN_WRAP
    cv::matchTemplate(*image, *templ, *result, method, entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_connectedComponentsWithAlgorithm
[32/64bit] ブーリアン画像の連結成分ラベル付き画像を計算します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr image
p2 = sptr : IntPtr labels
p3 = int : int connectivity
p4 = int : int ltype
p5 = int : int ccltype
p6 = var : out int returnValue
%inst
ltype は，出力ラベルの画像タイプを指定します．これは，ラベルの総数，あるいは，ソース画像の総ピクセル数に基づく重要な考慮事項です． ccltype は，使用する連結成分ラベリングアルゴリズムを指定します．現在，Grana (BBDT) と Wu (SAUF) [276] のアルゴリズムがサポートされており，詳細は ConnectedComponentsAlgorithmsTypes を参照してください．なお、SAUFアルゴリズムでは、BBDTがそうでないのに対し、ラベルの行の主要な順序が強制されます。この関数は，GranaおよびWuの両アルゴリズムの並列版を使用します．ただし，少なくとも1つの許可された並列フレームワークが有効であり，イメージの行数がgetNumberOfCPUsで返される数の少なくとも2倍である場合に限ります．

元関数名(C#): imgproc_connectedComponentsWithAlgorithm
元DLLエクスポート名: imgproc_connectedComponentsWithAlgorithm
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_connectedComponentsWithAlgorithm(
    cv::_InputArray *image, cv::_OutputArray *labels, int connectivity, int ltype, int ccltype, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::connectedComponents(entity(image), entity(labels), connectivity, ltype, ccltype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_connectedComponents
[32/64bit] ブーリアン画像の連結成分ラベル付き画像を計算します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr image
p2 = sptr : IntPtr labels
p3 = int : int connectivity
p4 = int : int ltype
p5 = var : out int returnValue
%inst
ltype は，出力ラベルの画像タイプを指定します．これは，ラベルの総数，あるいは，ソース画像の総ピクセル数に基づく重要な考慮事項です． ccltype は，使用する連結成分ラベリングアルゴリズムを指定します．現在，Grana (BBDT) と Wu (SAUF) [276] のアルゴリズムがサポートされており，詳細は ConnectedComponentsAlgorithmsTypes を参照してください．なお、SAUFアルゴリズムでは、BBDTがそうでないのに対し、ラベルの行の主要な順序が強制されます。この関数は，GranaおよびWuの両アルゴリズムの並列版を使用します．ただし，少なくとも1つの許可された並列フレームワークが有効であり，イメージの行数がgetNumberOfCPUsで返される数の少なくとも2倍である場合に限ります．

元関数名(C#): imgproc_connectedComponents
元DLLエクスポート名: imgproc_connectedComponents
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_connectedComponentsWithAlgorithm(
    cv::_InputArray *image, cv::_OutputArray *labels, int connectivity, int ltype, int ccltype, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::connectedComponents(entity(image), entity(labels), connectivity, ltype, ccltype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_connectedComponentsWithStatsWithAlgorithm
[32/64bit] boolean画像の連結成分ラベル付き画像を計算し，各ラベルの統計情報を出力します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr image
p2 = sptr : IntPtr labels
p3 = sptr : IntPtr stats
p4 = sptr : IntPtr centroids
p5 = int : int connectivity
p6 = int : int ltype
p7 = int : int ccltype
p8 = var : out int returnValue
%inst
ltype は，出力ラベルの画像タイプを指定します．これは，ラベルの総数，あるいは，ソース画像の総ピクセル数に基づく重要な考慮事項です． ccltype は，使用する連結成分ラベリングアルゴリズムを指定します．現在，Grana (BBDT) と Wu (SAUF) [276] のアルゴリズムがサポートされており，詳細は ConnectedComponentsAlgorithmsTypes を参照してください．なお，SAUFアルゴリズムはラベルの行の主要な順序を強制しますが，BBDTはそうではありません．この関数は，少なくとも1つの許可された並列フレームワークが有効であり，画像の行数がgetNumberOfCPUsで返される数の少なくとも2倍であれば，GranaとWuの両方のアルゴリズムの並列バージョン（統計情報を含む）を使用します．

元関数名(C#): imgproc_connectedComponentsWithStatsWithAlgorithm
元DLLエクスポート名: imgproc_connectedComponentsWithStatsWithAlgorithm
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_connectedComponentsWithStatsWithAlgorithm(
    cv::_InputArray *image, cv::_OutputArray *labels,
    cv::_OutputArray *stats, cv::_OutputArray *centroids,
    int connectivity, int ltype, int ccltype, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::connectedComponentsWithStats(
            entity(image), entity(labels), entity(stats), entity(centroids), connectivity, ltype, ccltype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_connectedComponentsWithStats
[32/64bit] boolean画像の連結成分ラベル付き画像を計算し，各ラベルの統計情報を出力します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr image
p2 = sptr : IntPtr labels
p3 = sptr : IntPtr stats
p4 = sptr : IntPtr centroids
p5 = int : int connectivity
p6 = int : int ltype
p7 = var : out int returnValue
%inst
ltype は，出力ラベルの画像タイプを指定します．これは，ラベルの総数，あるいは，ソース画像の総ピクセル数に基づく重要な考慮事項です． ccltype は，使用する連結成分ラベリングアルゴリズムを指定します．現在，Grana (BBDT) と Wu (SAUF) [276] のアルゴリズムがサポートされており，詳細は ConnectedComponentsAlgorithmsTypes を参照してください．なお，SAUFアルゴリズムはラベルの行の主要な順序を強制しますが，BBDTはそうではありません．この関数は，少なくとも1つの許可された並列フレームワークが有効であり，画像の行数がgetNumberOfCPUsで返される数の少なくとも2倍であれば，GranaとWuの両方のアルゴリズムの並列バージョン（統計情報を含む）を使用します．

元関数名(C#): imgproc_connectedComponentsWithStats
元DLLエクスポート名: imgproc_connectedComponentsWithStats
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_connectedComponentsWithStatsWithAlgorithm(
    cv::_InputArray *image, cv::_OutputArray *labels,
    cv::_OutputArray *stats, cv::_OutputArray *centroids,
    int connectivity, int ltype, int ccltype, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::connectedComponentsWithStats(
            entity(image), entity(labels), entity(stats), entity(centroids), connectivity, ltype, ccltype);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_findContours1_vector
[32/64bit] 2値画像の輪郭を検出します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr image
p2 = sptr : IntPtr contours
p3 = sptr : IntPtr hierarchy
p4 = int : int mode
p5 = int : int method
p6 = ARGS_POINT : Point offset
%inst
この関数は，アルゴリズム [233]を用いて，2値画像から輪郭を抽出します．輪郭は，形状分析や物体の検出・認識に役立つツールです．OpenCVのサンプルディレクトリにあるsquares.cppを参照してください．注意 opencv 3.2以降では，この関数によってソース画像が変更されることはありません．例： modules/shape/samples/shape_example.cpp, samples/cpp/contours2.cpp, samples/cpp/fitellipse.cpp、samples/cpp/segment_objects.cpp、samples/cpp/squares.cpp、samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp、samples/cpp/watershed.cpp、samples/tapi/squares.cppがあります。

元関数名(C#): imgproc_findContours1_vector
元DLLエクスポート名: imgproc_findContours1_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_findContours1_vector(cv::_InputArray *image, std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt; &amp;gt; *contours,
                                         std::vector&amp;lt;cv::Vec4i&amp;gt; *hierarchy, int mode, int method, MyCvPoint offset)
{
    BEGIN_WRAP
    cv::findContours(*image, *contours, *hierarchy, mode, method, cpp(offset));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_findContours1_OutputArray
[32/64bit] 2値画像の輪郭を検出します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr image
p2 = sptr : IntPtr contours
p3 = sptr : IntPtr hierarchy
p4 = int : int mode
p5 = int : int method
p6 = ARGS_POINT : Point offset
%inst
この関数は，アルゴリズム [233]を用いて，2値画像から輪郭を抽出します．輪郭は，形状分析や物体の検出・認識に役立つツールです．OpenCVのサンプルディレクトリにあるsquares.cppを参照してください．注意 opencv 3.2以降では，この関数によってソース画像が変更されることはありません．例： modules/shape/samples/shape_example.cpp, samples/cpp/contours2.cpp, samples/cpp/fitellipse.cpp、samples/cpp/segment_objects.cpp、samples/cpp/squares.cpp、samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp、samples/cpp/watershed.cpp、samples/tapi/squares.cppがあります。

元関数名(C#): imgproc_findContours1_OutputArray
元DLLエクスポート名: imgproc_findContours1_OutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_findContours1_OutputArray(cv::_InputArray *image, std::vector&amp;lt;cv::Mat&amp;gt; *contours,
                                              cv::_OutputArray *hierarchy, int mode, int method, MyCvPoint offset)
{
    BEGIN_WRAP
    cv::findContours(*image, *contours, *hierarchy, mode, method, cpp(offset));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_findContours2_vector
[32/64bit] 2値画像の輪郭を検出します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr image
p2 = sptr : IntPtr contours
p3 = int : int mode
p4 = int : int method
p5 = ARGS_POINT : Point offset
%inst
この関数は，アルゴリズム [233]を用いて，2値画像から輪郭を抽出します．輪郭は，形状分析や物体の検出・認識に役立つツールです．OpenCVのサンプルディレクトリにあるsquares.cppを参照してください．注意 opencv 3.2以降では，この関数によってソース画像が変更されることはありません．例： modules/shape/samples/shape_example.cpp, samples/cpp/contours2.cpp, samples/cpp/fitellipse.cpp、samples/cpp/segment_objects.cpp、samples/cpp/squares.cpp、samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp、samples/cpp/watershed.cpp、samples/tapi/squares.cppがあります。

元関数名(C#): imgproc_findContours2_vector
元DLLエクスポート名: imgproc_findContours2_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_findContours2_vector(cv::_InputArray *image, std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt; &amp;gt; *contours,
                                         int mode, int method, MyCvPoint offset)
{
    BEGIN_WRAP
    cv::findContours(*image, *contours, mode, method, cpp(offset));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_findContours2_OutputArray
[32/64bit] 2値画像の輪郭を検出します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr image
p2 = sptr : IntPtr contours
p3 = int : int mode
p4 = int : int method
p5 = ARGS_POINT : Point offset
%inst
この関数は，アルゴリズム [233]を用いて，2値画像から輪郭を抽出します．輪郭は，形状分析や物体の検出・認識に役立つツールです．OpenCVのサンプルディレクトリにあるsquares.cppを参照してください．注意 opencv 3.2以降では，この関数によってソース画像が変更されることはありません．例： modules/shape/samples/shape_example.cpp, samples/cpp/contours2.cpp, samples/cpp/fitellipse.cpp、samples/cpp/segment_objects.cpp、samples/cpp/squares.cpp、samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp、samples/cpp/watershed.cpp、samples/tapi/squares.cppがあります。

元関数名(C#): imgproc_findContours2_OutputArray
元DLLエクスポート名: imgproc_findContours2_OutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_findContours2_OutputArray(cv::_InputArray *image, std::vector&amp;lt;cv::Mat&amp;gt; *contours,
                                              int mode, int method, MyCvPoint offset)
{
    BEGIN_WRAP
    cv::findContours(*image, *contours, mode, method, cpp(offset));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_approxPolyDP_InputArray
[32/64bit] 多角形の曲線を指定された精度で近似します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr curve
p2 = sptr : IntPtr approxCurve
p3 = double : double epsilon
p4 = int : int closed
%inst
関数 cv::approxPolyDP は，曲線や多角形を，より少ない頂点を持つ別の曲線や多角形で近似し，それらの間の距離が指定された精度以下になるようにします．Douglas-Peucker アルゴリズムを利用します． http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithmExamples: samples/cpp/contours2.cpp, samples/cpp/squares.cpp, and samples/tapi/squares.cpp.

元関数名(C#): imgproc_approxPolyDP_InputArray
元DLLエクスポート名: imgproc_approxPolyDP_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_approxPolyDP_InputArray(cv::_InputArray *curve, cv::_OutputArray *approxCurve, double epsilon, int closed)
{
    BEGIN_WRAP
    cv::approxPolyDP(*curve, *approxCurve, epsilon, closed != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_approxPolyDP_Point
[32/64bit] 多角形の曲線を指定された精度で近似します。
%prm
p1,p2,p3,p4,p5
p1 = var : Point[] curve
p2 = int : int curveLength
p3 = sptr : IntPtr approxCurve
p4 = double : double epsilon
p5 = int : int closed
%inst
関数 cv::approxPolyDP は，曲線や多角形を，より少ない頂点を持つ別の曲線や多角形で近似し，それらの間の距離が指定された精度以下になるようにします．Douglas-Peucker アルゴリズムを利用します． http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithmExamples: samples/cpp/contours2.cpp, samples/cpp/squares.cpp, and samples/tapi/squares.cpp.

元関数名(C#): imgproc_approxPolyDP_Point
元DLLエクスポート名: imgproc_approxPolyDP_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_approxPolyDP_Point(cv::Point *curve, int curveLength, std::vector&amp;lt;cv::Point&amp;gt; *approxCurve, double epsilon, int closed)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point&amp;gt; curveMat(curveLength, 1, curve);
    cv::approxPolyDP(curveMat, *approxCurve, epsilon, closed != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_approxPolyDP_Point2f
[32/64bit] 多角形の曲線を指定された精度で近似します。
%prm
p1,p2,p3,p4,p5
p1 = var : Point2f[] curve
p2 = int : int curveLength
p3 = sptr : IntPtr approxCurve
p4 = double : double epsilon
p5 = int : int closed
%inst
関数 cv::approxPolyDP は，曲線や多角形を，より少ない頂点を持つ別の曲線や多角形で近似し，それらの間の距離が指定された精度以下になるようにします．Douglas-Peucker アルゴリズムを利用します． http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithmExamples: samples/cpp/contours2.cpp, samples/cpp/squares.cpp, and samples/tapi/squares.cpp.

元関数名(C#): imgproc_approxPolyDP_Point2f
元DLLエクスポート名: imgproc_approxPolyDP_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_approxPolyDP_Point2f(cv::Point2f *curve, int curveLength, std::vector&amp;lt;cv::Point2f&amp;gt; *approxCurve, double epsilon, int closed)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point2f&amp;gt; curveMat(curveLength, 1, curve);
    cv::approxPolyDP(curveMat, *approxCurve, epsilon, closed != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_arcLength_InputArray
[32/64bit] 輪郭の外周や曲線の長さを計算します。
%prm
p1,p2,p3
p1 = sptr : IntPtr curve
p2 = int : int closed
p3 = var : out double returnValue
%inst
例： samples/cpp/squares.cpp, samples/tapi/squares.cpp.

元関数名(C#): imgproc_arcLength_InputArray
元DLLエクスポート名: imgproc_arcLength_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_arcLength_InputArray(cv::_InputArray *curve, int closed, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::arcLength(*curve, closed != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_arcLength_Point
[32/64bit] 輪郭の外周や曲線の長さを計算します。
%prm
p1,p2,p3,p4
p1 = var : Point[] curve
p2 = int : int curveLength
p3 = int : int closed
p4 = var : out double returnValue
%inst
例： samples/cpp/squares.cpp, samples/tapi/squares.cpp.

元関数名(C#): imgproc_arcLength_Point
元DLLエクスポート名: imgproc_arcLength_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_arcLength_Point(cv::Point *curve, int curveLength, int closed, double* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point&amp;gt; curveMat(curveLength, 1, curve);
    *returnValue = cv::arcLength(curveMat, closed != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_arcLength_Point2f
[32/64bit] 輪郭の外周や曲線の長さを計算します。
%prm
p1,p2,p3,p4
p1 = var : Point2f[] curve
p2 = int : int curveLength
p3 = int : int closed
p4 = var : out double returnValue
%inst
例： samples/cpp/squares.cpp, samples/tapi/squares.cpp.

元関数名(C#): imgproc_arcLength_Point2f
元DLLエクスポート名: imgproc_arcLength_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_arcLength_Point2f(cv::Point2f *curve, int curveLength, int closed, double* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point2f&amp;gt; curveMat(curveLength, 1, curve);
    *returnValue = cv::arcLength(curveMat, closed != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_boundingRect_InputArray
[32/64bit] 点セットまたはグレースケール画像の非ゼロピクセルの右上境界矩形を計算します。
%prm
p1,p2
p1 = sptr : IntPtr curve
p2 = var : out Rect returnValue
%inst
この関数は，指定された点集合，あるいはグレースケール画像の非0ピクセルに対する最小の右上がりの外接矩形を計算して返します．

元関数名(C#): imgproc_boundingRect_InputArray
元DLLエクスポート名: imgproc_boundingRect_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_boundingRect_InputArray(cv::_InputArray *curve, MyCvRect* returnValue)
{
    BEGIN_WRAP
    *returnValue = c(cv::boundingRect(*curve));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_boundingRect_Point
[32/64bit] 点セットまたはグレースケール画像の非ゼロピクセルの右上境界矩形を計算します。
%prm
p1,p2,p3
p1 = var : Point[] curve
p2 = int : int curveLength
p3 = var : out Rect returnValue
%inst
この関数は，指定された点集合，あるいはグレースケール画像の非0ピクセルに対する最小の右上がりの外接矩形を計算して返します．

元関数名(C#): imgproc_boundingRect_Point
元DLLエクスポート名: imgproc_boundingRect_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_boundingRect_Point(cv::Point *curve, int curveLength, MyCvRect* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point&amp;gt; curveMat(curveLength, 1, curve);
    *returnValue = c(cv::boundingRect(curveMat));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_boundingRect_Point2f
[32/64bit] 点セットまたはグレースケール画像の非ゼロピクセルの右上境界矩形を計算します。
%prm
p1,p2,p3
p1 = var : Point2f[] curve
p2 = int : int curveLength
p3 = var : out Rect returnValue
%inst
この関数は，指定された点集合，あるいはグレースケール画像の非0ピクセルに対する最小の右上がりの外接矩形を計算して返します．

元関数名(C#): imgproc_boundingRect_Point2f
元DLLエクスポート名: imgproc_boundingRect_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_boundingRect_Point2f(cv::Point2f *curve, int curveLength, MyCvRect* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point2f&amp;gt; curveMat(curveLength, 1, curve);
    *returnValue = c(cv::boundingRect(curveMat));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_contourArea_InputArray
[32/64bit] 輪郭領域を計算します．
%prm
p1,p2,p3
p1 = sptr : IntPtr contour
p2 = int : int oriented
p3 = var : out double returnValue
%inst
この関数は，輪郭の面積を計算します．モーメントと同様に，面積は Green の式を用いて計算されます。したがって，drawContours や fillPoly を用いて輪郭を描いた場合，返される面積と，0ではないピクセル数は異なります．例：vector<Point> contour;contour.push_back(Point2f(0, 0));contour.push_back(Point2f(10, 0));contour.push_back(Point2f(10, 10));contour.push_back(Point2f(10, 10));contour.push_back(Point2f(5, 4));double area0 = contourArea(contour);vector<Point> approx;approxPolyDP(contour, approx, 5, true);double area1 = contourArea(approx);cout << "area0 =" << area0 << endl << "area1 =" << area1 << endl << "approx poly vertices" << approx.size() << endl;fragmentExamples: samples/cpp/segment_objects.cpp, samples/cpp/squares.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, and samples/tapi/squares.cpp.

元関数名(C#): imgproc_contourArea_InputArray
元DLLエクスポート名: imgproc_contourArea_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_contourArea_InputArray(cv::_InputArray *contour, int oriented, double* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::contourArea(*contour, oriented != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_contourArea_Point
[32/64bit] 輪郭領域を計算します．
%prm
p1,p2,p3,p4
p1 = var : [MarshalAs(UnmanagedType.LPArray)] Point[] contour
p2 = int : int contourLength
p3 = int : int oriented
p4 = var : out double returnValue
%inst
この関数は，輪郭の面積を計算します．モーメントと同様に，面積は Green の式を用いて計算されます。したがって，drawContours や fillPoly を用いて輪郭を描いた場合，返される面積と，0ではないピクセル数は異なります．例：vector<Point> contour;contour.push_back(Point2f(0, 0));contour.push_back(Point2f(10, 0));contour.push_back(Point2f(10, 10));contour.push_back(Point2f(10, 10));contour.push_back(Point2f(5, 4));double area0 = contourArea(contour);vector<Point> approx;approxPolyDP(contour, approx, 5, true);double area1 = contourArea(approx);cout << "area0 =" << area0 << endl << "area1 =" << area1 << endl << "approx poly vertices" << approx.size() << endl;fragmentExamples: samples/cpp/segment_objects.cpp, samples/cpp/squares.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, and samples/tapi/squares.cpp.

元関数名(C#): imgproc_contourArea_Point
元DLLエクスポート名: imgproc_contourArea_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_contourArea_Point(cv::Point *contour, int contourLength, int oriented, double* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point&amp;gt; contourMat(contourLength, 1, contour);
    *returnValue = cv::contourArea(contourMat, oriented != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_contourArea_Point2f
[32/64bit] 輪郭領域を計算します．
%prm
p1,p2,p3,p4
p1 = var : [MarshalAs(UnmanagedType.LPArray)] Point2f[] contour
p2 = int : int contourLength
p3 = int : int oriented
p4 = var : out double returnValue
%inst
この関数は，輪郭の面積を計算します．モーメントと同様に，面積は Green の式を用いて計算されます。したがって，drawContours や fillPoly を用いて輪郭を描いた場合，返される面積と，0ではないピクセル数は異なります．例：vector<Point> contour;contour.push_back(Point2f(0, 0));contour.push_back(Point2f(10, 0));contour.push_back(Point2f(10, 10));contour.push_back(Point2f(10, 10));contour.push_back(Point2f(5, 4));double area0 = contourArea(contour);vector<Point> approx;approxPolyDP(contour, approx, 5, true);double area1 = contourArea(approx);cout << "area0 =" << area0 << endl << "area1 =" << area1 << endl << "approx poly vertices" << approx.size() << endl;fragmentExamples: samples/cpp/segment_objects.cpp, samples/cpp/squares.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, and samples/tapi/squares.cpp.

元関数名(C#): imgproc_contourArea_Point2f
元DLLエクスポート名: imgproc_contourArea_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_contourArea_Point2f(cv::Point2f *contour, int contourLength, int oriented, double* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point2f&amp;gt; contourMat(contourLength, 1, contour);
    *returnValue = cv::contourArea(contourMat, oriented != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_minAreaRect_InputArray
[32/64bit] 入力された2D点セットを囲む最小面積の回転した長方形を見つけます。
%prm
p1,p2
p1 = sptr : IntPtr points
p2 = var : out RotatedRect returnValue
%inst
この関数は，指定された点群を囲む最小面積の外接矩形（回転している場合もあります）を計算して返します．データが含まれる Mat 要素の境界に近い場合，返される RotatedRect には負のインデックスが含まれる可能性があることに，開発者は留意する必要があります．例： samples/cpp/minarea.cpp．

元関数名(C#): imgproc_minAreaRect_InputArray
元DLLエクスポート名: imgproc_minAreaRect_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_minAreaRect_InputArray(cv::_InputArray *points, MyCvBox2D* returnValue)
{
    BEGIN_WRAP
    *returnValue = c(cv::minAreaRect(*points));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_minAreaRect_Point
[32/64bit] 入力された2D点セットを囲む最小面積の回転した長方形を見つけます。
%prm
p1,p2,p3
p1 = var : [MarshalAs(UnmanagedType.LPArray)] Point[] points
p2 = int : int pointsLength
p3 = var : out RotatedRect returnValue
%inst
この関数は，指定された点群を囲む最小面積の外接矩形（回転している場合もあります）を計算して返します．データが含まれる Mat 要素の境界に近い場合，返される RotatedRect には負のインデックスが含まれる可能性があることに，開発者は留意する必要があります．例： samples/cpp/minarea.cpp．

元関数名(C#): imgproc_minAreaRect_Point
元DLLエクスポート名: imgproc_minAreaRect_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_minAreaRect_Point(cv::Point *points, int pointsLength, MyCvBox2D* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point&amp;gt; pointsMat(pointsLength, 1, points);
    *returnValue = c(cv::minAreaRect(pointsMat));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_minAreaRect_Point2f
[32/64bit] 入力された2D点セットを囲む最小面積の回転した長方形を見つけます。
%prm
p1,p2,p3
p1 = var : [MarshalAs(UnmanagedType.LPArray)] Point2f[] points
p2 = int : int pointsLength
p3 = var : out RotatedRect returnValue
%inst
この関数は，指定された点群を囲む最小面積の外接矩形（回転している場合もあります）を計算して返します．データが含まれる Mat 要素の境界に近い場合，返される RotatedRect には負のインデックスが含まれる可能性があることに，開発者は留意する必要があります．例： samples/cpp/minarea.cpp．

元関数名(C#): imgproc_minAreaRect_Point2f
元DLLエクスポート名: imgproc_minAreaRect_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_minAreaRect_Point2f(cv::Point2f *points, int pointsLength, MyCvBox2D* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point2f&amp;gt; pointsMat(pointsLength, 1, points);
    *returnValue = c(cv::minAreaRect(pointsMat));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_boxPoints_OutputArray
[32bit] 回転した矩形の 4 つの頂点を求めます．回転した矩形の描画に役立ちます．
%prm
p1,p2
p1 = ARGS_ROTATEDRECT : RotatedRect box
p2 = sptr : IntPtr points
%inst
この関数は，回転した矩形の 4 つの頂点を求めます．この関数は，矩形の描画に役立ちます．C++ では，この関数を使う代わりに， RotatedRect::points メソッドを直接使うことができます．詳しくは、チュートリアルの「輪郭用の回転ボックスと楕円の作成」をご覧ください。

元関数名(C#): imgproc_boxPoints_OutputArray
元DLLエクスポート名: imgproc_boxPoints_OutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_boxPoints_OutputArray(MyCvBox2D box, cv::_OutputArray* points)
{
    BEGIN_WRAP
    cv::boxPoints(cpp(box), *points);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_boxPoints_OutputArray
[64bit] 回転した矩形の 4 つの頂点を求めます．回転した矩形の描画に役立ちます．
%prm
p1,p2
p1 = var : RotatedRect box
p2 = sptr : IntPtr points
%inst
この関数は，回転した矩形の 4 つの頂点を求めます．この関数は，矩形の描画に役立ちます．C++ では，この関数を使う代わりに， RotatedRect::points メソッドを直接使うことができます．詳しくは、チュートリアルの「輪郭用の回転ボックスと楕円の作成」をご覧ください。

元関数名(C#): imgproc_boxPoints_OutputArray
元DLLエクスポート名: imgproc_boxPoints_OutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_boxPoints_OutputArray(MyCvBox2D box, cv::_OutputArray* points)
{
    BEGIN_WRAP
    cv::boxPoints(cpp(box), *points);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_boxPoints_Point2f
[32bit] 回転した矩形の 4 つの頂点を求めます．回転した矩形の描画に役立ちます．
%prm
p1,p2
p1 = ARGS_ROTATEDRECT : RotatedRect box
p2 = var : [MarshalAs(UnmanagedType.LPArray), Out] Point2f[] points
%inst
この関数は，回転した矩形の 4 つの頂点を求めます．この関数は，矩形の描画に役立ちます．C++ では，この関数を使う代わりに， RotatedRect::points メソッドを直接使うことができます．詳しくは、チュートリアルの「輪郭用の回転ボックスと楕円の作成」をご覧ください。

元関数名(C#): imgproc_boxPoints_Point2f
元DLLエクスポート名: imgproc_boxPoints_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_boxPoints_Point2f(MyCvBox2D box, cv::Point2f points[4])
{
    BEGIN_WRAP
    cpp(box).points(points);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_boxPoints_Point2f
[64bit] 回転した矩形の 4 つの頂点を求めます．回転した矩形の描画に役立ちます．
%prm
p1,p2
p1 = var : RotatedRect box
p2 = var : [MarshalAs(UnmanagedType.LPArray), Out] Point2f[] points
%inst
この関数は，回転した矩形の 4 つの頂点を求めます．この関数は，矩形の描画に役立ちます．C++ では，この関数を使う代わりに， RotatedRect::points メソッドを直接使うことができます．詳しくは、チュートリアルの「輪郭用の回転ボックスと楕円の作成」をご覧ください。

元関数名(C#): imgproc_boxPoints_Point2f
元DLLエクスポート名: imgproc_boxPoints_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_boxPoints_Point2f(MyCvBox2D box, cv::Point2f points[4])
{
    BEGIN_WRAP
    cpp(box).points(points);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_minEnclosingCircle_InputArray
[32/64bit] 2次元点群を囲む最小面積の円を求めます。
%prm
p1,p2,p3
p1 = sptr : IntPtr points
p2 = var : out Point2f center
p3 = var : out float radius
%inst
この関数は，反復アルゴリズムを用いて，2 次元点集合を囲む最小の円を求めます．例： samples/cpp/minarea.cpp.

元関数名(C#): imgproc_minEnclosingCircle_InputArray
元DLLエクスポート名: imgproc_minEnclosingCircle_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_minEnclosingCircle_InputArray(cv::_InputArray *points, MyCvPoint2D32f *center, float *radius)
{
    BEGIN_WRAP
    cv::Point2f center0;
    float radius0;
    cv::minEnclosingCircle(*points, center0, radius0);
    *center = c(center0);
    *radius = radius0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_minEnclosingCircle_Point
[32/64bit] 2次元点群を囲む最小面積の円を求めます。
%prm
p1,p2,p3,p4
p1 = var : Point[] points
p2 = int : int pointsLength
p3 = var : out Point2f center
p4 = var : out float radius
%inst
この関数は，反復アルゴリズムを用いて，2 次元点集合を囲む最小の円を求めます．例： samples/cpp/minarea.cpp.

元関数名(C#): imgproc_minEnclosingCircle_Point
元DLLエクスポート名: imgproc_minEnclosingCircle_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_minEnclosingCircle_Point(cv::Point *points, int pointsLength, MyCvPoint2D32f*center, float *radius)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point&amp;gt; pointsMat(pointsLength, 1, points);
    cv::Point2f center0;
    float radius0;
    cv::minEnclosingCircle(pointsMat, center0, radius0);
    *center = c(center0);
    *radius = radius0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_minEnclosingCircle_Point2f
[32/64bit] 2次元点群を囲む最小面積の円を求めます。
%prm
p1,p2,p3,p4
p1 = var : Point2f[] points
p2 = int : int pointsLength
p3 = var : out Point2f center
p4 = var : out float radius
%inst
この関数は，反復アルゴリズムを用いて，2 次元点集合を囲む最小の円を求めます．例： samples/cpp/minarea.cpp.

元関数名(C#): imgproc_minEnclosingCircle_Point2f
元DLLエクスポート名: imgproc_minEnclosingCircle_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_minEnclosingCircle_Point2f(cv::Point2f *points, int pointsLength, MyCvPoint2D32f*center, float *radius)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point2f&amp;gt; pointsMat(pointsLength, 1, points);
    cv::Point2f center0;
    float radius0;
    cv::minEnclosingCircle(pointsMat, center0, radius0);
    *center = c(center0);
    *radius = radius0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_minEnclosingTriangle_InputOutputArray
[32/64bit] 2次元点群を囲む最小面積の三角形を求め、その面積を返す。
%prm
p1,p2,p3
p1 = sptr : IntPtr points
p2 = sptr : IntPtr triangle
p3 = var : out double returnValue
%inst
この関数は，与えられた2次元点群を囲む最小面積の三角形を求め，その面積を返します．与えられた2次元点群に対する出力は，以下の図のようになります．このアルゴリズムの実装は，O'Rourke[188]およびKlee and Laskowski[129]の論文に基づいています．O'Rourke氏は、n個の頂点を持つ2次元凸多角形の最小囲み三角形を求めるために、\(theta(n)\)アルゴリズムを提供しています。minEnclosingTriangle関数は入力として2Dポイントセットを取るので、2Dポイントセットの凸包を計算する追加の前処理ステップが必要です。convexHull関数の複雑さは、\(theta(n)\)よりも高い、\(O(n log(n))\です。）例： samples/cpp/minarea.cpp.

元関数名(C#): imgproc_minEnclosingTriangle_InputOutputArray
元DLLエクスポート名: imgproc_minEnclosingTriangle_InputOutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_minEnclosingTriangle_InputOutputArray(cv::_InputArray *points, cv::_OutputArray *triangle, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::minEnclosingTriangle(*points, *triangle);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_minEnclosingTriangle_Point
[32/64bit] 2次元点群を囲む最小面積の三角形を求め、その面積を返す。
%prm
p1,p2,p3,p4
p1 = var : [MarshalAs(UnmanagedType.LPArray), In] Point[] points
p2 = int : int pointsLength
p3 = sptr : IntPtr triangle
p4 = var : out double returnValue
%inst
この関数は，与えられた2次元点群を囲む最小面積の三角形を求め，その面積を返します．与えられた2次元点群に対する出力は，以下の図のようになります．このアルゴリズムの実装は，O'Rourke[188]およびKlee and Laskowski[129]の論文に基づいています．O'Rourke氏は、n個の頂点を持つ2次元凸多角形の最小囲み三角形を求めるために、\(theta(n)\)アルゴリズムを提供しています。minEnclosingTriangle関数は入力として2Dポイントセットを取るので、2Dポイントセットの凸包を計算する追加の前処理ステップが必要です。convexHull関数の複雑さは、\(theta(n)\)よりも高い、\(O(n log(n))\です。）例： samples/cpp/minarea.cpp.

元関数名(C#): imgproc_minEnclosingTriangle_Point
元DLLエクスポート名: imgproc_minEnclosingTriangle_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_minEnclosingTriangle_Point(cv::Point* points, int pointsLength, std::vector&amp;lt;cv::Point2f&amp;gt;* triangle, double* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point&amp;gt; pointsMat(pointsLength, 1, points);
    *returnValue = cv::minEnclosingTriangle(pointsMat, *triangle);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_minEnclosingTriangle_Point2f
[32/64bit] 2次元点群を囲む最小面積の三角形を求め、その面積を返す。
%prm
p1,p2,p3,p4
p1 = var : [MarshalAs(UnmanagedType.LPArray), In] Point2f[] points
p2 = int : int pointsLength
p3 = sptr : IntPtr triangle
p4 = var : out double returnValue
%inst
この関数は，与えられた2次元点群を囲む最小面積の三角形を求め，その面積を返します．与えられた2次元点群に対する出力は，以下の図のようになります．このアルゴリズムの実装は，O'Rourke[188]およびKlee and Laskowski[129]の論文に基づいています．O'Rourke氏は、n個の頂点を持つ2次元凸多角形の最小囲み三角形を求めるために、\(theta(n)\)アルゴリズムを提供しています。minEnclosingTriangle関数は入力として2Dポイントセットを取るので、2Dポイントセットの凸包を計算する追加の前処理ステップが必要です。convexHull関数の複雑さは、\(theta(n)\)よりも高い、\(O(n log(n))\です。）例： samples/cpp/minarea.cpp.

元関数名(C#): imgproc_minEnclosingTriangle_Point2f
元DLLエクスポート名: imgproc_minEnclosingTriangle_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_minEnclosingTriangle_Point2f(cv::Point2f* points, int pointsLength, std::vector&amp;lt;cv::Point2f&amp;gt;* triangle, double* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point2f&amp;gt; pointsMat(pointsLength, 1, points);
    *returnValue = cv::minEnclosingTriangle(pointsMat, *triangle);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_matchShapes_InputArray
[32/64bit] 2つの形状を比較します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr contour1
p2 = sptr : IntPtr contour2
p3 = int : int method
p4 = double : double parameter
p5 = var : out double returnValue
%inst
この関数は，2 つの形状を比較します．実装されている 3 つのメソッドは，いずれも Hu 不変量を利用しています（HuMoments 参照）．

元関数名(C#): imgproc_matchShapes_InputArray
元DLLエクスポート名: imgproc_matchShapes_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_matchShapes_InputArray(
    cv::_InputArray *contour1, cv::_InputArray *contour2, int method, double parameter, double* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::matchShapes(*contour1, *contour2, method, parameter);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_matchShapes_Point
[32/64bit] 2つの形状を比較します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = var : Point[] contour1
p2 = int : int contour1Length
p3 = var : Point[] contour2
p4 = int : int contour2Length
p5 = int : int method
p6 = double : double parameter
p7 = var : out double returnValue
%inst
この関数は，2 つの形状を比較します．実装されている 3 つのメソッドは，いずれも Hu 不変量を利用しています（HuMoments 参照）．

元関数名(C#): imgproc_matchShapes_Point
元DLLエクスポート名: imgproc_matchShapes_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_matchShapes_Point(
    cv::Point *contour1, int contour1Length, cv::Point *contour2, int contour2Length, int method, double parameter, double* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point&amp;gt; contour1Mat(contour1Length, 1, contour1);
    const cv::Mat_&amp;lt;cv::Point&amp;gt; contour2Mat(contour2Length, 1, contour2);
    *returnValue = cv::matchShapes(contour1Mat, contour2Mat, method, parameter);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_convexHull_InputArray
[32/64bit] 点集合の凸包を求める関数．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr points
p2 = sptr : IntPtr hull
p3 = int : int clockwise
p4 = int : int returnPoints
%inst
関数 cv::convexHull は，Sklansky のアルゴリズム [224] を用いて 2 次元点群の凸包を求めます．

元関数名(C#): imgproc_convexHull_InputArray
元DLLエクスポート名: imgproc_convexHull_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_convexHull_InputArray(cv::_InputArray *points, cv::_OutputArray *hull, int clockwise, int returnPoints)
{
    BEGIN_WRAP
    cv::convexHull(*points, *hull, clockwise != 0, returnPoints != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_convexHull_Point_ReturnsPoints
[32/64bit] 点集合の凸包を求める関数．
%prm
p1,p2,p3,p4
p1 = var : Point[] points
p2 = int : int pointsLength
p3 = sptr : IntPtr hull
p4 = int : int clockwise
%inst
関数 cv::convexHull は，Sklansky のアルゴリズム [224] を用いて 2 次元点群の凸包を求めます．

元関数名(C#): imgproc_convexHull_Point_ReturnsPoints
元DLLエクスポート名: imgproc_convexHull_Point_ReturnsPoints
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_convexHull_Point_ReturnsPoints(cv::Point *points, int pointsLength, std::vector&amp;lt;cv::Point&amp;gt; *hull, int clockwise)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point&amp;gt; pointsMat(pointsLength, 1, points);
    cv::convexHull(pointsMat, *hull, clockwise != 0, true);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_convexHull_Point2f_ReturnsPoints
[32/64bit] 点集合の凸包を求める関数．
%prm
p1,p2,p3,p4
p1 = var : Point2f[] points
p2 = int : int pointsLength
p3 = sptr : IntPtr hull
p4 = int : int clockwise
%inst
関数 cv::convexHull は，Sklansky のアルゴリズム [224] を用いて 2 次元点群の凸包を求めます．

元関数名(C#): imgproc_convexHull_Point2f_ReturnsPoints
元DLLエクスポート名: imgproc_convexHull_Point2f_ReturnsPoints
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_convexHull_Point2f_ReturnsPoints(cv::Point2f *points, int pointsLength, std::vector&amp;lt;cv::Point2f&amp;gt; *hull, int clockwise)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point2f&amp;gt; pointsMat(pointsLength, 1, points);
    cv::convexHull(pointsMat, *hull, clockwise != 0, true);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_convexHull_Point_ReturnsIndices
[32/64bit] 点集合の凸包を求める関数．
%prm
p1,p2,p3,p4
p1 = var : Point[] points
p2 = int : int pointsLength
p3 = sptr : IntPtr hull
p4 = int : int clockwise
%inst
関数 cv::convexHull は，Sklansky のアルゴリズム [224] を用いて 2 次元点群の凸包を求めます．

元関数名(C#): imgproc_convexHull_Point_ReturnsIndices
元DLLエクスポート名: imgproc_convexHull_Point_ReturnsIndices
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_convexHull_Point_ReturnsIndices(cv::Point *points, int pointsLength, std::vector&amp;lt;int&amp;gt; *hull, int clockwise)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point&amp;gt; pointsMat(pointsLength, 1, points);
    cv::convexHull(pointsMat, *hull, clockwise != 0, false);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_convexHull_Point2f_ReturnsIndices
[32/64bit] 点集合の凸包を求める関数．
%prm
p1,p2,p3,p4
p1 = var : Point2f[] points
p2 = int : int pointsLength
p3 = sptr : IntPtr hull
p4 = int : int clockwise
%inst
関数 cv::convexHull は，Sklansky のアルゴリズム [224] を用いて 2 次元点群の凸包を求めます．

元関数名(C#): imgproc_convexHull_Point2f_ReturnsIndices
元DLLエクスポート名: imgproc_convexHull_Point2f_ReturnsIndices
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_convexHull_Point2f_ReturnsIndices(cv::Point2f *points, int pointsLength, std::vector&amp;lt;int&amp;gt; *hull, int clockwise)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point2f&amp;gt; pointsMat(pointsLength, 1, points);
    cv::convexHull(pointsMat, *hull, clockwise != 0, false);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_convexityDefects_InputArray
[32/64bit] 輪郭の凸型欠陥を求めます．
%prm
p1,p2,p3
p1 = sptr : IntPtr contour
p2 = sptr : IntPtr convexHull
p3 = sptr : IntPtr convexityDefects
%inst
下の図は、手の輪郭の凸部の欠陥を表示しています：image

元関数名(C#): imgproc_convexityDefects_InputArray
元DLLエクスポート名: imgproc_convexityDefects_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_convexityDefects_InputArray(cv::_InputArray *contour, cv::_InputArray *convexHull,
                                                cv::_OutputArray *convexityDefects)
{
    BEGIN_WRAP
    cv::convexityDefects(*contour, *convexHull, *convexityDefects);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_convexityDefects_Point
[32/64bit] 輪郭の凸型欠陥を求めます．
%prm
p1,p2,p3,p4,p5
p1 = var : Point[] contour
p2 = int : int contourLength
p3 = var : int[] convexHull
p4 = int : int convexHullLength
p5 = sptr : IntPtr convexityDefects
%inst
下の図は、手の輪郭の凸部の欠陥を表示しています：image

元関数名(C#): imgproc_convexityDefects_Point
元DLLエクスポート名: imgproc_convexityDefects_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_convexityDefects_Point(cv::Point *contour, int contourLength, int *convexHull, int convexHullLength,
                                           std::vector&amp;lt;cv::Vec4i&amp;gt; *convexityDefects)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point&amp;gt; contourMat(contourLength, 1, contour);
    const cv::Mat_&amp;lt;int&amp;gt; convexHullMat(convexHullLength, 1,  convexHull);
    cv::convexityDefects(contourMat, convexHullMat, *convexityDefects);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_convexityDefects_Point2f
[32/64bit] 輪郭の凸型欠陥を求めます．
%prm
p1,p2,p3,p4,p5
p1 = var : Point2f[] contour
p2 = int : int contourLength
p3 = var : int[] convexHull
p4 = int : int convexHullLength
p5 = sptr : IntPtr convexityDefects
%inst
下の図は、手の輪郭の凸部の欠陥を表示しています：image

元関数名(C#): imgproc_convexityDefects_Point2f
元DLLエクスポート名: imgproc_convexityDefects_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_convexityDefects_Point2f(cv::Point2f *contour, int contourLength, int *convexHull, int convexHullLength,
                                             std::vector&amp;lt;cv::Vec4i&amp;gt; *convexityDefects)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point2f&amp;gt; contourMat(contourLength, 1, contour);
    const cv::Mat_&amp;lt;int&amp;gt; convexHullMat(convexHullLength, 1, convexHull);
    cv::convexityDefects(contourMat, convexHullMat, *convexityDefects);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_isContourConvex_InputArray
[32/64bit] 輪郭の凸性をテストします．
%prm
p1,p2
p1 = sptr : IntPtr contour
p2 = var : out int returnValue
%inst
この関数は，入力された輪郭が凸であるかどうかをテストします．輪郭は単純でなければならず，つまり，自己交差があってはいけません．例：samples/cpp/intersectExample.cpp，samples/cpp/squares.cpp，samples/tapi/squares.cpp．

元関数名(C#): imgproc_isContourConvex_InputArray
元DLLエクスポート名: imgproc_isContourConvex_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_isContourConvex_InputArray(cv::_InputArray *contour, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::isContourConvex(*contour) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_isContourConvex_Point
[32/64bit] 輪郭の凸性をテストします．
%prm
p1,p2,p3
p1 = var : Point[] contour
p2 = int : int contourLength
p3 = var : out int returnValue
%inst
この関数は，入力された輪郭が凸であるかどうかをテストします．輪郭は単純でなければならず，つまり，自己交差があってはいけません．例：samples/cpp/intersectExample.cpp，samples/cpp/squares.cpp，samples/tapi/squares.cpp．

元関数名(C#): imgproc_isContourConvex_Point
元DLLエクスポート名: imgproc_isContourConvex_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_isContourConvex_Point(cv::Point *contour, int contourLength, int* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point&amp;gt; contourMat(contourLength, 1, contour);
    *returnValue = cv::isContourConvex(contourMat) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_isContourConvex_Point2f
[32/64bit] 輪郭の凸性をテストします．
%prm
p1,p2,p3
p1 = var : Point2f[] contour
p2 = int : int contourLength
p3 = var : out int returnValue
%inst
この関数は，入力された輪郭が凸であるかどうかをテストします．輪郭は単純でなければならず，つまり，自己交差があってはいけません．例：samples/cpp/intersectExample.cpp，samples/cpp/squares.cpp，samples/tapi/squares.cpp．

元関数名(C#): imgproc_isContourConvex_Point2f
元DLLエクスポート名: imgproc_isContourConvex_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_isContourConvex_Point2f(cv::Point2f *contour, int contourLength, int* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point2f&amp;gt; contourMat(contourLength, 1, contour);
    *returnValue = cv::isContourConvex(contourMat) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_intersectConvexConvex_InputArray
[32/64bit] 2つの凸多角形の交点を求める関数です。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr p1
p2 = sptr : IntPtr p2
p3 = sptr : IntPtr p12
p4 = int : int handleNested
p5 = var : out float returnValue
%inst
注意intersectConvexConvexは、両方のポリゴンが凸であるかどうかを確認せず、凸でない場合は無効な結果を返します。

元関数名(C#): imgproc_intersectConvexConvex_InputArray
元DLLエクスポート名: imgproc_intersectConvexConvex_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_intersectConvexConvex_InputArray(cv::_InputArray *p1, cv::_InputArray *p2,
                                                      cv::_OutputArray *p12, int handleNested, float* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::intersectConvexConvex(*p1, *p2, *p12, handleNested != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_intersectConvexConvex_Point
[32/64bit] 2つの凸多角形の交点を求める関数です。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = var : Point[] p1
p2 = int : int p1Length
p3 = var : Point[] p2
p4 = int : int p2Length
p5 = sptr : IntPtr p12
p6 = int : int handleNested
p7 = var : out float returnValue
%inst
注意intersectConvexConvexは、両方のポリゴンが凸であるかどうかを確認せず、凸でない場合は無効な結果を返します。

元関数名(C#): imgproc_intersectConvexConvex_Point
元DLLエクスポート名: imgproc_intersectConvexConvex_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_intersectConvexConvex_Point(cv::Point *p1, int p1Length, cv::Point *p2, int p2Length,
                                                 std::vector&amp;lt;cv::Point&amp;gt; *p12, int handleNested, float* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point&amp;gt; p1Vec(p1Length, 1, p1);
    const cv::Mat_&amp;lt;cv::Point&amp;gt; p2Vec(p2Length, 1, p2);
    *returnValue = cv::intersectConvexConvex(p1Vec, p2Vec, *p12, handleNested != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_intersectConvexConvex_Point2f
[32/64bit] 2つの凸多角形の交点を求める関数です。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = var : Point2f[] p1
p2 = int : int p1Length
p3 = var : Point2f[] p2
p4 = int : int p2Length
p5 = sptr : IntPtr p12
p6 = int : int handleNested
p7 = var : out float returnValue
%inst
注意intersectConvexConvexは、両方のポリゴンが凸であるかどうかを確認せず、凸でない場合は無効な結果を返します。

元関数名(C#): imgproc_intersectConvexConvex_Point2f
元DLLエクスポート名: imgproc_intersectConvexConvex_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_intersectConvexConvex_Point2f(cv::Point2f *p1, int p1Length, cv::Point2f *p2, int p2Length,
                                                   std::vector&amp;lt;cv::Point2f&amp;gt; *p12, int handleNested, float *returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point2f&amp;gt; p1Vec(p1Length, 1, p1);
    const cv::Mat_&amp;lt;cv::Point2f&amp;gt; p2Vec(p2Length, 1, p2);
    *returnValue = cv::intersectConvexConvex(p1Vec, p2Vec, *p12, handleNested != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fitEllipse_InputArray
[32/64bit] 2次元の点の周りに楕円を描く関数です。
%prm
p1,p2
p1 = sptr : IntPtr points
p2 = var : out RotatedRect returnValue
%inst
この関数は，2次元点の集合に最もよくフィットする（最小二乗の意味で）楕円を計算します．そして，その楕円が内接する，回転した矩形を返します．ここでは，[78]で述べられている最初のアルゴリズムを使用しています．開発者は，データポイントが含まれる Mat 要素の境界に近いために，返される楕円/回転矩形データに負のインデックスが含まれる可能性があることに留意する必要があります．例： samples/cpp/fitellipse.cpp.

元関数名(C#): imgproc_fitEllipse_InputArray
元DLLエクスポート名: imgproc_fitEllipse_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fitEllipse_InputArray(cv::_InputArray *points, MyCvBox2D* returnValue)
{
    BEGIN_WRAP
    *returnValue = c(cv::fitEllipse(*points));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fitEllipse_Point
[32/64bit] 2次元の点の周りに楕円を描く関数です。
%prm
p1,p2,p3
p1 = var : Point[] points
p2 = int : int pointsLength
p3 = var : out RotatedRect returnValue
%inst
この関数は，2次元点の集合に最もよくフィットする（最小二乗の意味で）楕円を計算します．そして，その楕円が内接する，回転した矩形を返します．ここでは，[78]で述べられている最初のアルゴリズムを使用しています．開発者は，データポイントが含まれる Mat 要素の境界に近いために，返される楕円/回転矩形データに負のインデックスが含まれる可能性があることに留意する必要があります．例： samples/cpp/fitellipse.cpp.

元関数名(C#): imgproc_fitEllipse_Point
元DLLエクスポート名: imgproc_fitEllipse_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fitEllipse_Point(cv::Point *points, int pointsLength, MyCvBox2D* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point&amp;gt; pointsVec(pointsLength, 1, points);
    *returnValue = c(cv::fitEllipse(pointsVec));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fitEllipse_Point2f
[32/64bit] 2次元の点の周りに楕円を描く関数です。
%prm
p1,p2,p3
p1 = var : Point2f[] points
p2 = int : int pointsLength
p3 = var : out RotatedRect returnValue
%inst
この関数は，2次元点の集合に最もよくフィットする（最小二乗の意味で）楕円を計算します．そして，その楕円が内接する，回転した矩形を返します．ここでは，[78]で述べられている最初のアルゴリズムを使用しています．開発者は，データポイントが含まれる Mat 要素の境界に近いために，返される楕円/回転矩形データに負のインデックスが含まれる可能性があることに留意する必要があります．例： samples/cpp/fitellipse.cpp.

元関数名(C#): imgproc_fitEllipse_Point2f
元DLLエクスポート名: imgproc_fitEllipse_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fitEllipse_Point2f(cv::Point2f *points, int pointsLength, MyCvBox2D* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point2f&amp;gt; pointsVec(pointsLength, 1, points);
    *returnValue = c(cv::fitEllipse(pointsVec));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fitEllipseAMS_InputArray
[32/64bit] imgproc_fitEllipseAMS_InputArray
%prm
p1,p2
p1 = sptr : IntPtr points
p2 = var : out RotatedRect returnValue
%inst
元関数名(C#): imgproc_fitEllipseAMS_InputArray
元DLLエクスポート名: imgproc_fitEllipseAMS_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
%group
NativeMethods_imgproc

%index
imgproc_fitEllipseAMS_Point
[32/64bit] 2次元の点の周りに楕円を描く関数です。
%prm
p1,p2,p3
p1 = var : Point[] points
p2 = int : int pointsLength
p3 = var : out RotatedRect returnValue
%inst
この関数は，2 次元点の集合にフィットする楕円を計算します．そして，その楕円が内接する回転した矩形を返します．ここでは，[240]で提案された Approximate Mean Square (AMS) が用いられます．楕円の場合、この基底セットは、6つの自由係数の集合である \chi= \left(x^2, x y, y^2, x, y, 1\right) \( A^T=\left\{A_{text{xx}},A_{text{xy}},A_{text{yy}},A_x,A_y,A_0\right} ? ) です。しかし、楕円を指定するには、長軸と短軸の長さ\( (a,b) )、位置\( (x_0,y_0) )、方向\( ????? ) の5つの数字があればよいのです。これは、基底セットには、直線、二次曲線、放物線、双曲線のほか、楕円形の関数もフィットする可能性があるからです。フィットが放物線または双曲線関数であることが判明した場合、標準のfitEllipseメソッドが使用されます。AMS法では、フィットを放物線、双曲線、楕円曲線に限定するために、「A^T ( D_x^T D_x + D_y^T D_y) A = 1 ?????」という条件を課しています。このマトリクスは、セット内の各ポイントに以下のように適用して、行ごとに形成されます。D(i,:)&=Begin{x_i^2, x_i y_i, y_i^2, x_i, y_i, 1\\} & D_x(i,:)&=Begin{2 x_i,y_i,0,1,0,0\\} & D_y(i,:)&=Begin{0,x_i,2 y_i,0,1,0,0ｰ｝\end{align*}AMS法は、コスト関数を最小化します。\A^T D^T D A }{ A^T (D_x^T D_x + D_y^T D_y) A^T } E\end{equation*}最小コストは、一般化された固有値問題を解くことで求められます。D^T D A = ????? )

元関数名(C#): imgproc_fitEllipseAMS_Point
元DLLエクスポート名: imgproc_fitEllipseAMS_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fitEllipseAMS_Point(cv::Point* points, int pointsLength, MyCvBox2D* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point&amp;gt; pointsVec(pointsLength, 1, points);
    *returnValue = c(cv::fitEllipseAMS(pointsVec));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fitEllipseAMS_Point2f
[32/64bit] 2次元の点の周りに楕円を描く関数です。
%prm
p1,p2,p3
p1 = var : Point2f[] points
p2 = int : int pointsLength
p3 = var : out RotatedRect returnValue
%inst
この関数は，2 次元点の集合にフィットする楕円を計算します．そして，その楕円が内接する回転した矩形を返します．ここでは，[240]で提案された Approximate Mean Square (AMS) が用いられます．楕円の場合、この基底セットは、6つの自由係数の集合である \chi= \left(x^2, x y, y^2, x, y, 1\right) \( A^T=\left\{A_{text{xx}},A_{text{xy}},A_{text{yy}},A_x,A_y,A_0\right} ? ) です。しかし、楕円を指定するには、長軸と短軸の長さ\( (a,b) )、位置\( (x_0,y_0) )、方向\( ????? ) の5つの数字があればよいのです。これは、基底セットには、直線、二次曲線、放物線、双曲線のほか、楕円形の関数もフィットする可能性があるからです。フィットが放物線または双曲線関数であることが判明した場合、標準のfitEllipseメソッドが使用されます。AMS法では、フィットを放物線、双曲線、楕円曲線に限定するために、「A^T ( D_x^T D_x + D_y^T D_y) A = 1 ?????」という条件を課しています。このマトリクスは、セット内の各ポイントに以下のように適用して、行ごとに形成されます。D(i,:)&=Begin{x_i^2, x_i y_i, y_i^2, x_i, y_i, 1\\} & D_x(i,:)&=Begin{2 x_i,y_i,0,1,0,0\\} & D_y(i,:)&=Begin{0,x_i,2 y_i,0,1,0,0ｰ｝\end{align*}AMS法は、コスト関数を最小化します。\A^T D^T D A }{ A^T (D_x^T D_x + D_y^T D_y) A^T } E\end{equation*}最小コストは、一般化された固有値問題を解くことで求められます。D^T D A = ????? )

元関数名(C#): imgproc_fitEllipseAMS_Point2f
元DLLエクスポート名: imgproc_fitEllipseAMS_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fitEllipseAMS_Point2f(cv::Point2f* points, int pointsLength, MyCvBox2D* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point2f&amp;gt; pointsVec(pointsLength, 1, points);
    *returnValue = c(cv::fitEllipseAMS(pointsVec));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fitEllipseDirect_InputArray
[32/64bit] imgproc_fitEllipseDirect_InputArray
%prm
p1,p2
p1 = sptr : IntPtr points
p2 = var : out RotatedRect returnValue
%inst
元関数名(C#): imgproc_fitEllipseDirect_InputArray
元DLLエクスポート名: imgproc_fitEllipseDirect_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
%group
NativeMethods_imgproc

%index
imgproc_fitEllipseDirect_Point
[32/64bit] 2次元の点の周りに楕円を描く関数です。
%prm
p1,p2,p3
p1 = var : Point[] points
p2 = int : int pointsLength
p3 = var : out RotatedRect returnValue
%inst
この関数は，2 次元の点の集合にフィットする楕円を計算します．また，楕円が内接する回転した矩形を返します．ここでは，[79]のDirect least square（Direct）法を用いています．楕円の場合、この基底セットは、6つの自由係数の集合である \chi= \left(x^2, x y, y^2, x, y, 1\right) \( A^T=\left\{A_{text{xx}},A_{text{xy}},A_{text{yy}},A_x,A_y,A_0\right) ??となります。しかし、楕円を指定するには、長軸と短軸の長さ\( (a,b) )、位置\( (x_0,y_0) )、方向\( ????? ) の5つの数字があればよいのです。これは、基底セットには、直線、二次曲線、放物線、双曲線のほか、楕円形の関数もフィットする可能性があるからです。Direct法では、フィッティングの対象を楕円に限定するために、\( 4 A_{xx} A_{yy}- A_{xy}^2 > 0 ? )を確保します。この条件は、不等式を満足し、かつ係数を任意にスケーリングできることから、過度に制限するものではありません。\A^T D^T D A ??? -? ???\A^T C A =1\♪♪♪♪♪〜0＆0＆2＆0＆0＆0 0＆1＆0＆0＆0 2＆0＆0＆0＆0＆0＆0 0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0エンド{matrix}です。D^T D A = \lambda \left( C\right) A ??{equation*}このシステムでは、正の固有値は1つしかなく、その固有ベクトル\(mathbf{u}\)を解としています。これらを用いて、係数を求めます。A = ????? )\A^T C A =1」が保証されています。例： samples/cpp/fitellipse.cpp.

元関数名(C#): imgproc_fitEllipseDirect_Point
元DLLエクスポート名: imgproc_fitEllipseDirect_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fitEllipseDirect_Point(cv::Point* points, int pointsLength, MyCvBox2D* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point&amp;gt; pointsVec(pointsLength, 1, points);
    *returnValue = c(cv::fitEllipseDirect(pointsVec));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fitEllipseDirect_Point2f
[32/64bit] 2次元の点の周りに楕円を描く関数です。
%prm
p1,p2,p3
p1 = var : Point2f[] points
p2 = int : int pointsLength
p3 = var : out RotatedRect returnValue
%inst
この関数は，2 次元の点の集合にフィットする楕円を計算します．また，楕円が内接する回転した矩形を返します．ここでは，[79]のDirect least square（Direct）法を用いています．楕円の場合、この基底セットは、6つの自由係数の集合である \chi= \left(x^2, x y, y^2, x, y, 1\right) \( A^T=\left\{A_{text{xx}},A_{text{xy}},A_{text{yy}},A_x,A_y,A_0\right) ??となります。しかし、楕円を指定するには、長軸と短軸の長さ\( (a,b) )、位置\( (x_0,y_0) )、方向\( ????? ) の5つの数字があればよいのです。これは、基底セットには、直線、二次曲線、放物線、双曲線のほか、楕円形の関数もフィットする可能性があるからです。Direct法では、フィッティングの対象を楕円に限定するために、\( 4 A_{xx} A_{yy}- A_{xy}^2 > 0 ? )を確保します。この条件は、不等式を満足し、かつ係数を任意にスケーリングできることから、過度に制限するものではありません。\A^T D^T D A ??? -? ???\A^T C A =1\♪♪♪♪♪〜0＆0＆2＆0＆0＆0 0＆1＆0＆0＆0 2＆0＆0＆0＆0＆0＆0 0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0＆0エンド{matrix}です。D^T D A = \lambda \left( C\right) A ??{equation*}このシステムでは、正の固有値は1つしかなく、その固有ベクトル\(mathbf{u}\)を解としています。これらを用いて、係数を求めます。A = ????? )\A^T C A =1」が保証されています。例： samples/cpp/fitellipse.cpp.

元関数名(C#): imgproc_fitEllipseDirect_Point2f
元DLLエクスポート名: imgproc_fitEllipseDirect_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fitEllipseDirect_Point2f(cv::Point2f* points, int pointsLength, MyCvBox2D* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point2f&amp;gt; pointsVec(pointsLength, 1, points);
    *returnValue = c(cv::fitEllipseDirect(pointsVec));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fitLine_InputArray
[32/64bit] 2Dまたは3Dのポイントセットに直線をフィットさせます。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr points
p2 = sptr : IntPtr line
p3 = int : int distType
p4 = double : double param
p5 = double : double reps
p6 = double : double aeps
%inst
関数 fitLine は、2D または 3D の点群に直線をフィットさせるために、\(r_i\)を最小化します。 ここで、\(r_i\)は、点と直線との距離であり、\(rho(r)\)は、距離関数であり、次のいずれかです。

\rho (r) = r^2/2 \\{(the simplest and the fast least-squares method)}\]である。





DIST_L1

\rho (r) = r\





DIST_L12

\Rho (r) = 2 ????? ( ????? )





DIST_FAIR

\DIST_FAIR] DIST_FAIR- (1 + ???д???)\♪♪♪♪♪♪♪）\Here's nothing!\C=1.3998\]の





DIST_WELSCH

\♪♪♪♪♪♪〜\♪♪♪♪♪♪♪〜\♪♪〜C=2.9846\\］





DIST_HUBER

\Rho (r) = R^2/2}{if uriosity(r < C\)}{C cdot (r-C/2)}{otherwise}\\\\\このアルゴリズムは、M-estimator( http://en.wikipedia.org/wiki/M-estimator )という手法に基づいており、重み付き最小二乗法を用いて繰り返し直線をフィットさせます。反復後の重みは、反比例するように調整されています(w_i\)。

元関数名(C#): imgproc_fitLine_InputArray
元DLLエクスポート名: imgproc_fitLine_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fitLine_InputArray(cv::_InputArray *points, cv::_OutputArray *line,
                                       int distType, double param, double reps, double aeps)
{
    BEGIN_WRAP
    cv::fitLine(*points, *line, distType, param, reps, aeps);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fitLine_Point
[32/64bit] 2Dまたは3Dのポイントセットに直線をフィットさせます。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = var : Point[] points
p2 = int : int pointsLength
p3 = var : [In, Out] float[] line
p4 = int : int distType
p5 = double : double param
p6 = double : double reps
p7 = double : double aeps
%inst
関数 fitLine は、2D または 3D の点群に直線をフィットさせるために、\(r_i\)を最小化します。 ここで、\(r_i\)は、点と直線との距離であり、\(rho(r)\)は、距離関数であり、次のいずれかです。

\rho (r) = r^2/2 \\{(the simplest and the fast least-squares method)}\]である。





DIST_L1

\rho (r) = r\





DIST_L12

\Rho (r) = 2 ????? ( ????? )





DIST_FAIR

\DIST_FAIR] DIST_FAIR- (1 + ???д???)\♪♪♪♪♪♪♪）\Here's nothing!\C=1.3998\]の





DIST_WELSCH

\♪♪♪♪♪♪〜\♪♪♪♪♪♪♪〜\♪♪〜C=2.9846\\］





DIST_HUBER

\Rho (r) = R^2/2}{if uriosity(r < C\)}{C cdot (r-C/2)}{otherwise}\\\\\このアルゴリズムは、M-estimator( http://en.wikipedia.org/wiki/M-estimator )という手法に基づいており、重み付き最小二乗法を用いて繰り返し直線をフィットさせます。反復後の重みは、反比例するように調整されています(w_i\)。

元関数名(C#): imgproc_fitLine_Point
元DLLエクスポート名: imgproc_fitLine_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fitLine_Point(cv::Point *points, int pointsLength, float *line, int distType,
                                  double param, double reps, double aeps)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point&amp;gt; pointsVec(pointsLength, 1, points);
    cv::Mat_&amp;lt;float&amp;gt; lineVec(4, 1, line);
    cv::fitLine(pointsVec, lineVec, distType, param, reps, aeps);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fitLine_Point2f
[32/64bit] 2Dまたは3Dのポイントセットに直線をフィットさせます。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = var : Point2f[] points
p2 = int : int pointsLength
p3 = var : [In, Out] float[] line
p4 = int : int distType
p5 = double : double param
p6 = double : double reps
p7 = double : double aeps
%inst
関数 fitLine は、2D または 3D の点群に直線をフィットさせるために、\(r_i\)を最小化します。 ここで、\(r_i\)は、点と直線との距離であり、\(rho(r)\)は、距離関数であり、次のいずれかです。

\rho (r) = r^2/2 \\{(the simplest and the fast least-squares method)}\]である。





DIST_L1

\rho (r) = r\





DIST_L12

\Rho (r) = 2 ????? ( ????? )





DIST_FAIR

\DIST_FAIR] DIST_FAIR- (1 + ???д???)\♪♪♪♪♪♪♪）\Here's nothing!\C=1.3998\]の





DIST_WELSCH

\♪♪♪♪♪♪〜\♪♪♪♪♪♪♪〜\♪♪〜C=2.9846\\］





DIST_HUBER

\Rho (r) = R^2/2}{if uriosity(r < C\)}{C cdot (r-C/2)}{otherwise}\\\\\このアルゴリズムは、M-estimator( http://en.wikipedia.org/wiki/M-estimator )という手法に基づいており、重み付き最小二乗法を用いて繰り返し直線をフィットさせます。反復後の重みは、反比例するように調整されています(w_i\)。

元関数名(C#): imgproc_fitLine_Point2f
元DLLエクスポート名: imgproc_fitLine_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fitLine_Point2f(cv::Point2f *points, int pointsLength, float *line, int distType,
                                    double param, double reps, double aeps)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point2f&amp;gt; pointsVec(pointsLength, 1, points);
    cv::Mat_&amp;lt;float&amp;gt; lineVec(4, 1, line);
    cv::fitLine(pointsVec, lineVec, distType, param, reps, aeps);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fitLine_Point3i
[32/64bit] 2Dまたは3Dのポイントセットに直線をフィットさせます。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = var : Point3i[] points
p2 = int : int pointsLength
p3 = var : [In, Out] float[] line
p4 = int : int distType
p5 = double : double param
p6 = double : double reps
p7 = double : double aeps
%inst
関数 fitLine は、2D または 3D の点群に直線をフィットさせるために、\(r_i\)を最小化します。 ここで、\(r_i\)は、点と直線との距離であり、\(rho(r)\)は、距離関数であり、次のいずれかです。

\rho (r) = r^2/2 \\{(the simplest and the fast least-squares method)}\]である。





DIST_L1

\rho (r) = r\





DIST_L12

\Rho (r) = 2 ????? ( ????? )





DIST_FAIR

\DIST_FAIR] DIST_FAIR- (1 + ???д???)\♪♪♪♪♪♪♪）\Here's nothing!\C=1.3998\]の





DIST_WELSCH

\♪♪♪♪♪♪〜\♪♪♪♪♪♪♪〜\♪♪〜C=2.9846\\］





DIST_HUBER

\Rho (r) = R^2/2}{if uriosity(r < C\)}{C cdot (r-C/2)}{otherwise}\\\\\このアルゴリズムは、M-estimator( http://en.wikipedia.org/wiki/M-estimator )という手法に基づいており、重み付き最小二乗法を用いて繰り返し直線をフィットさせます。反復後の重みは、反比例するように調整されています(w_i\)。

元関数名(C#): imgproc_fitLine_Point3i
元DLLエクスポート名: imgproc_fitLine_Point3i
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fitLine_Point3i(cv::Point3i *points, int pointsLength, float *line, int distType,
                                    double param, double reps, double aeps)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point3i&amp;gt; pointsVec(pointsLength, 1, points);
    cv::Mat_&amp;lt;float&amp;gt; lineVec(6, 1, line);
    cv::fitLine(pointsVec, lineVec, distType, param, reps, aeps);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fitLine_Point3f
[32/64bit] 2Dまたは3Dのポイントセットに直線をフィットさせます。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = var : Point3f[] points
p2 = int : int pointsLength
p3 = var : [In, Out] float[] line
p4 = int : int distType
p5 = double : double param
p6 = double : double reps
p7 = double : double aeps
%inst
関数 fitLine は、2D または 3D の点群に直線をフィットさせるために、\(r_i\)を最小化します。 ここで、\(r_i\)は、点と直線との距離であり、\(rho(r)\)は、距離関数であり、次のいずれかです。

\rho (r) = r^2/2 \\{(the simplest and the fast least-squares method)}\]である。





DIST_L1

\rho (r) = r\





DIST_L12

\Rho (r) = 2 ????? ( ????? )





DIST_FAIR

\DIST_FAIR] DIST_FAIR- (1 + ???д???)\♪♪♪♪♪♪♪）\Here's nothing!\C=1.3998\]の





DIST_WELSCH

\♪♪♪♪♪♪〜\♪♪♪♪♪♪♪〜\♪♪〜C=2.9846\\］





DIST_HUBER

\Rho (r) = R^2/2}{if uriosity(r < C\)}{C cdot (r-C/2)}{otherwise}\\\\\このアルゴリズムは、M-estimator( http://en.wikipedia.org/wiki/M-estimator )という手法に基づいており、重み付き最小二乗法を用いて繰り返し直線をフィットさせます。反復後の重みは、反比例するように調整されています(w_i\)。

元関数名(C#): imgproc_fitLine_Point3f
元DLLエクスポート名: imgproc_fitLine_Point3f
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fitLine_Point3f(cv::Point3f *points, int pointsLength, float *line, int distType,
                                    double param, double reps, double aeps)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point3f&amp;gt; pointsVec(pointsLength, 1, points);
    cv::Mat_&amp;lt;float&amp;gt; lineVec(6, 1, line);
    cv::fitLine(pointsVec, lineVec, distType, param, reps, aeps);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_pointPolygonTest_InputArray
[32/64bit] point-in-contourテストを実行します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr contour
p2 = ARGS_POINT2F : Point2f pt
p3 = int : int measureDist
p4 = var : out double returnValue
%inst
この関数は，点が輪郭の内側にあるのか，外側にあるのか，あるいは辺上にあるのか（あるいは頂点と一致するのか）を判定します．それぞれ、正の値（内側）、負の値（外側）、ゼロ（エッジ上）が返されます。measureDist=false の場合、戻り値はそれぞれ +1、-1、0 です。それ以外の場合，戻り値は，点と最も近い輪郭のエッジとの符号付き距離になります．この関数の出力例を以下に示します．

元関数名(C#): imgproc_pointPolygonTest_InputArray
元DLLエクスポート名: imgproc_pointPolygonTest_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_pointPolygonTest_InputArray(
    cv::_InputArray* contour, MyCvPoint2D32f pt, int measureDist, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::pointPolygonTest(*contour, cpp(pt), measureDist != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_pointPolygonTest_Point
[32/64bit] point-in-contourテストを実行します。
%prm
p1,p2,p3,p4,p5
p1 = var : Point[] contour
p2 = int : int contourLength
p3 = ARGS_POINT2F : Point2f pt
p4 = int : int measureDist
p5 = var : out double returnValue
%inst
この関数は，点が輪郭の内側にあるのか，外側にあるのか，あるいは辺上にあるのか（あるいは頂点と一致するのか）を判定します．それぞれ、正の値（内側）、負の値（外側）、ゼロ（エッジ上）が返されます。measureDist=false の場合、戻り値はそれぞれ +1、-1、0 です。それ以外の場合，戻り値は，点と最も近い輪郭のエッジとの符号付き距離になります．この関数の出力例を以下に示します．

元関数名(C#): imgproc_pointPolygonTest_Point
元DLLエクスポート名: imgproc_pointPolygonTest_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_pointPolygonTest_Point(
    cv::Point *contour, int contourLength, MyCvPoint2D32f pt, int measureDist, double* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point&amp;gt; contourVec(contourLength, 1, contour);
    *returnValue = cv::pointPolygonTest(contourVec, cpp(pt), measureDist != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_pointPolygonTest_Point2f
[32/64bit] point-in-contourテストを実行します。
%prm
p1,p2,p3,p4,p5
p1 = var : Point2f[] contour
p2 = int : int contourLength
p3 = ARGS_POINT2F : Point2f pt
p4 = int : int measureDist
p5 = var : out double returnValue
%inst
この関数は，点が輪郭の内側にあるのか，外側にあるのか，あるいは辺上にあるのか（あるいは頂点と一致するのか）を判定します．それぞれ、正の値（内側）、負の値（外側）、ゼロ（エッジ上）が返されます。measureDist=false の場合、戻り値はそれぞれ +1、-1、0 です。それ以外の場合，戻り値は，点と最も近い輪郭のエッジとの符号付き距離になります．この関数の出力例を以下に示します．

元関数名(C#): imgproc_pointPolygonTest_Point2f
元DLLエクスポート名: imgproc_pointPolygonTest_Point2f
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_pointPolygonTest_Point2f(
    cv::Point2f *contour, int contourLength, MyCvPoint2D32f pt, int measureDist, double* returnValue)
{
    BEGIN_WRAP
    const cv::Mat_&amp;lt;cv::Point2f&amp;gt; contourVec(contourLength, 1, contour);
    *returnValue = cv::pointPolygonTest(contourVec, cpp(pt), measureDist != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_rotatedRectangleIntersection_OutputArray
[32bit] 回転させた2つの矩形の間に交点があるかどうかを調べます．
%prm
p1,p2,p3,p4
p1 = ARGS_ROTATEDRECT : RotatedRect rect1
p2 = ARGS_ROTATEDRECT : RotatedRect rect2
p3 = sptr : IntPtr intersectingRegion
p4 = var : out int returnValue
%inst
これがある場合は，交差する領域の頂点も同様に返されます．ハッチングされたパターンは交差領域を示し，赤の頂点はこの関数によって返されます．intersection の例

元関数名(C#): imgproc_rotatedRectangleIntersection_OutputArray
元DLLエクスポート名: imgproc_rotatedRectangleIntersection_OutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_rotatedRectangleIntersection_OutputArray(
    MyCvBox2D rect1, MyCvBox2D rect2, cv::_OutputArray *intersectingRegion, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::rotatedRectangleIntersection(cpp(rect1), cpp(rect2), *intersectingRegion);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_rotatedRectangleIntersection_OutputArray
[64bit] 回転させた2つの矩形の間に交点があるかどうかを調べます．
%prm
p1,p2,p3,p4
p1 = var : RotatedRect rect1
p2 = var : RotatedRect rect2
p3 = sptr : IntPtr intersectingRegion
p4 = var : out int returnValue
%inst
これがある場合は，交差する領域の頂点も同様に返されます．ハッチングされたパターンは交差領域を示し，赤の頂点はこの関数によって返されます．intersection の例

元関数名(C#): imgproc_rotatedRectangleIntersection_OutputArray
元DLLエクスポート名: imgproc_rotatedRectangleIntersection_OutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_rotatedRectangleIntersection_OutputArray(
    MyCvBox2D rect1, MyCvBox2D rect2, cv::_OutputArray *intersectingRegion, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::rotatedRectangleIntersection(cpp(rect1), cpp(rect2), *intersectingRegion);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_rotatedRectangleIntersection_vector
[32bit] 回転させた2つの矩形の間に交点があるかどうかを調べます．
%prm
p1,p2,p3,p4
p1 = ARGS_ROTATEDRECT : RotatedRect rect1
p2 = ARGS_ROTATEDRECT : RotatedRect rect2
p3 = sptr : IntPtr intersectingRegion
p4 = var : out int returnValue
%inst
これがある場合は，交差する領域の頂点も同様に返されます．ハッチングされたパターンは交差領域を示し，赤の頂点はこの関数によって返されます．intersection の例

元関数名(C#): imgproc_rotatedRectangleIntersection_vector
元DLLエクスポート名: imgproc_rotatedRectangleIntersection_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_rotatedRectangleIntersection_vector(
    MyCvBox2D rect1, MyCvBox2D rect2, std::vector&amp;lt;cv::Point2f&amp;gt; *intersectingRegion, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::rotatedRectangleIntersection(cpp(rect1), cpp(rect2), *intersectingRegion);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_rotatedRectangleIntersection_vector
[64bit] 回転させた2つの矩形の間に交点があるかどうかを調べます．
%prm
p1,p2,p3,p4
p1 = var : RotatedRect rect1
p2 = var : RotatedRect rect2
p3 = sptr : IntPtr intersectingRegion
p4 = var : out int returnValue
%inst
これがある場合は，交差する領域の頂点も同様に返されます．ハッチングされたパターンは交差領域を示し，赤の頂点はこの関数によって返されます．intersection の例

元関数名(C#): imgproc_rotatedRectangleIntersection_vector
元DLLエクスポート名: imgproc_rotatedRectangleIntersection_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_rotatedRectangleIntersection_vector(
    MyCvBox2D rect1, MyCvBox2D rect2, std::vector&amp;lt;cv::Point2f&amp;gt; *intersectingRegion, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::rotatedRectangleIntersection(cpp(rect1), cpp(rect2), *intersectingRegion);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_applyColorMap1
[32/64bit] GNU Octave/MATLAB と同等のカラーマップを，与えられた画像に適用します．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int colormap
%inst
例： samples/cpp/falecolor.cpp．

元関数名(C#): imgproc_applyColorMap1
元DLLエクスポート名: imgproc_applyColorMap1
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_applyColorMap1(cv::_InputArray *src, cv::_OutputArray *dst, int colorMap)
{
    BEGIN_WRAP
    cv::applyColorMap(*src, *dst, colorMap);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_applyColorMap2
[32/64bit] GNU Octave/MATLAB と同等のカラーマップを，与えられた画像に適用します．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr userColor
%inst
例： samples/cpp/falecolor.cpp．

元関数名(C#): imgproc_applyColorMap2
元DLLエクスポート名: imgproc_applyColorMap2
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_applyColorMap2(cv::_InputArray *src, cv::_OutputArray *dst, cv::_InputArray *userColor)
{
    BEGIN_WRAP
    cv::applyColorMap(*src, *dst, *userColor);
    END_WRAP    
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_line
[32bit] 画像を極座標空間に再マッピングします。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr img
p2 = ARGS_POINT : Point pt1
p3 = ARGS_POINT : Point pt2
p4 = ARGS_SCALAR : Scalar color
p5 = int : int thickness
p6 = int : int lineType
p7 = int : int shift
%inst
Deprecated：この関数は， cv::warpPolar(src, dst, src.size(), center, maxRadius, flags) と同じ結果になります．

元関数名(C#): imgproc_line
元DLLエクスポート名: imgproc_line
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_linearPolar(cv::_InputArray *src, cv::_OutputArray *dst,
                                MyCvPoint2D32f center, double maxRadius, int flags)
{
    BEGIN_WRAP
    cv::linearPolar(*src, *dst, cpp(center), maxRadius, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_line
[64bit] 画像を極座標空間に再マッピングします。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr img
p2 = ARGS_POINT : Point pt1
p3 = ARGS_POINT : Point pt2
p4 = var : Scalar color
p5 = int : int thickness
p6 = int : int lineType
p7 = int : int shift
%inst
Deprecated：この関数は， cv::warpPolar(src, dst, src.size(), center, maxRadius, flags) と同じ結果になります．

元関数名(C#): imgproc_line
元DLLエクスポート名: imgproc_line
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_linearPolar(cv::_InputArray *src, cv::_OutputArray *dst,
                                MyCvPoint2D32f center, double maxRadius, int flags)
{
    BEGIN_WRAP
    cv::linearPolar(*src, *dst, cpp(center), maxRadius, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_arrowedLine
[32bit] 1つ目の点から2つ目の点を指す矢印セグメントを描画します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr img
p2 = ARGS_POINT : Point pt1
p3 = ARGS_POINT : Point pt2
p4 = ARGS_SCALAR : Scalar color
p5 = int : int thickness
p6 = int : int lineType
p7 = int : int shift
p8 = double : double tipLength
%inst
関数 cv::arrowedLine は，画像上の点 pt1 と pt2 の間に矢印を描きます．line も参照してください．

元関数名(C#): imgproc_arrowedLine
元DLLエクスポート名: imgproc_arrowedLine
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_arrowedLine(
    cv::_InputOutputArray *img, MyCvPoint pt1, MyCvPoint pt2, MyCvScalar color,
    int thickness, int line_type, int shift, double tipLength)
{
    BEGIN_WRAP
    cv::arrowedLine(*img, cpp(pt1), cpp(pt2), cpp(color), thickness, line_type, shift, tipLength);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_arrowedLine
[64bit] 1つ目の点から2つ目の点を指す矢印セグメントを描画します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr img
p2 = ARGS_POINT : Point pt1
p3 = ARGS_POINT : Point pt2
p4 = var : Scalar color
p5 = int : int thickness
p6 = int : int lineType
p7 = int : int shift
p8 = double : double tipLength
%inst
関数 cv::arrowedLine は，画像上の点 pt1 と pt2 の間に矢印を描きます．line も参照してください．

元関数名(C#): imgproc_arrowedLine
元DLLエクスポート名: imgproc_arrowedLine
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_arrowedLine(
    cv::_InputOutputArray *img, MyCvPoint pt1, MyCvPoint pt2, MyCvScalar color,
    int thickness, int line_type, int shift, double tipLength)
{
    BEGIN_WRAP
    cv::arrowedLine(*img, cpp(pt1), cpp(pt2), cpp(color), thickness, line_type, shift, tipLength);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_rectangle_InputOutputArray_Point
[32bit] 単純な，太い，あるいは塗りつぶされた右上がりの矩形を描画します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr img
p2 = ARGS_POINT : Point pt1
p3 = ARGS_POINT : Point pt2
p4 = ARGS_SCALAR : Scalar color
p5 = int : int thickness
p6 = int : int lineType
p7 = int : int shift
%inst
例： samples/cpp/camshiftdemo.cpp, samples/cpp/demhist.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/grabcut.cpp, samples/cpp/intersectExample.cpp, samples/cpp/peopledetect.cpp, samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/dnn/object_detection.cpp, and samples/tapi/hog.cpp.

元関数名(C#): imgproc_rectangle_InputOutputArray_Point
元DLLエクスポート名: imgproc_rectangle_InputOutputArray_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_rectangle_InputOutputArray_Point(
    cv::_InputOutputArray *img, MyCvPoint pt1, MyCvPoint pt2,
    MyCvScalar color, int thickness, int lineType, int shift)
{
    BEGIN_WRAP
    cv::rectangle(*img, cpp(pt1), cpp(pt2), cpp(color), thickness, lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_rectangle_InputOutputArray_Point
[64bit] 単純な，太い，あるいは塗りつぶされた右上がりの矩形を描画します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr img
p2 = ARGS_POINT : Point pt1
p3 = ARGS_POINT : Point pt2
p4 = var : Scalar color
p5 = int : int thickness
p6 = int : int lineType
p7 = int : int shift
%inst
例： samples/cpp/camshiftdemo.cpp, samples/cpp/demhist.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/grabcut.cpp, samples/cpp/intersectExample.cpp, samples/cpp/peopledetect.cpp, samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/dnn/object_detection.cpp, and samples/tapi/hog.cpp.

元関数名(C#): imgproc_rectangle_InputOutputArray_Point
元DLLエクスポート名: imgproc_rectangle_InputOutputArray_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_rectangle_InputOutputArray_Point(
    cv::_InputOutputArray *img, MyCvPoint pt1, MyCvPoint pt2,
    MyCvScalar color, int thickness, int lineType, int shift)
{
    BEGIN_WRAP
    cv::rectangle(*img, cpp(pt1), cpp(pt2), cpp(color), thickness, lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_rectangle_InputOutputArray_Rect
[32bit] 単純な，太い，あるいは塗りつぶされた右上がりの矩形を描画します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr img
p2 = ARGS_RECT : Rect rect
p3 = ARGS_SCALAR : Scalar color
p4 = int : int thickness
p5 = int : int lineType
p6 = int : int shift
%inst
例： samples/cpp/camshiftdemo.cpp, samples/cpp/demhist.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/grabcut.cpp, samples/cpp/intersectExample.cpp, samples/cpp/peopledetect.cpp, samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/dnn/object_detection.cpp, and samples/tapi/hog.cpp.

元関数名(C#): imgproc_rectangle_InputOutputArray_Rect
元DLLエクスポート名: imgproc_rectangle_InputOutputArray_Rect
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_rectangle_InputOutputArray_Rect(
    cv::_InputOutputArray* img, MyCvRect rect,
    MyCvScalar color, int thickness, int lineType, int shift)
{
    BEGIN_WRAP
    cv::rectangle(*img, cpp(rect), cpp(color), thickness, lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_rectangle_InputOutputArray_Rect
[64bit] 単純な，太い，あるいは塗りつぶされた右上がりの矩形を描画します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr img
p2 = var : Rect rect
p3 = var : Scalar color
p4 = int : int thickness
p5 = int : int lineType
p6 = int : int shift
%inst
例： samples/cpp/camshiftdemo.cpp, samples/cpp/demhist.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/grabcut.cpp, samples/cpp/intersectExample.cpp, samples/cpp/peopledetect.cpp, samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/dnn/object_detection.cpp, and samples/tapi/hog.cpp.

元関数名(C#): imgproc_rectangle_InputOutputArray_Rect
元DLLエクスポート名: imgproc_rectangle_InputOutputArray_Rect
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_rectangle_InputOutputArray_Rect(
    cv::_InputOutputArray* img, MyCvRect rect,
    MyCvScalar color, int thickness, int lineType, int shift)
{
    BEGIN_WRAP
    cv::rectangle(*img, cpp(rect), cpp(color), thickness, lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_rectangle_Mat_Point
[32bit] 単純な，太い，あるいは塗りつぶされた右上がりの矩形を描画します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr img
p2 = ARGS_POINT : Point pt1
p3 = ARGS_POINT : Point pt2
p4 = ARGS_SCALAR : Scalar color
p5 = int : int thickness
p6 = int : int lineType
p7 = int : int shift
%inst
例： samples/cpp/camshiftdemo.cpp, samples/cpp/demhist.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/grabcut.cpp, samples/cpp/intersectExample.cpp, samples/cpp/peopledetect.cpp, samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/dnn/object_detection.cpp, and samples/tapi/hog.cpp.

元関数名(C#): imgproc_rectangle_Mat_Point
元DLLエクスポート名: imgproc_rectangle_Mat_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_rectangle_Mat_Point(
    cv::Mat* img, MyCvPoint pt1, MyCvPoint pt2,
    MyCvScalar color, int thickness, int lineType, int shift)
{
    BEGIN_WRAP
    cv::rectangle(*img, cpp(pt1), cpp(pt2), cpp(color), thickness, lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_rectangle_Mat_Point
[64bit] 単純な，太い，あるいは塗りつぶされた右上がりの矩形を描画します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr img
p2 = ARGS_POINT : Point pt1
p3 = ARGS_POINT : Point pt2
p4 = var : Scalar color
p5 = int : int thickness
p6 = int : int lineType
p7 = int : int shift
%inst
例： samples/cpp/camshiftdemo.cpp, samples/cpp/demhist.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/grabcut.cpp, samples/cpp/intersectExample.cpp, samples/cpp/peopledetect.cpp, samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/dnn/object_detection.cpp, and samples/tapi/hog.cpp.

元関数名(C#): imgproc_rectangle_Mat_Point
元DLLエクスポート名: imgproc_rectangle_Mat_Point
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_rectangle_Mat_Point(
    cv::Mat* img, MyCvPoint pt1, MyCvPoint pt2,
    MyCvScalar color, int thickness, int lineType, int shift)
{
    BEGIN_WRAP
    cv::rectangle(*img, cpp(pt1), cpp(pt2), cpp(color), thickness, lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_rectangle_Mat_Rect
[32bit] 単純な，太い，あるいは塗りつぶされた右上がりの矩形を描画します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr img
p2 = ARGS_RECT : Rect rect
p3 = ARGS_SCALAR : Scalar color
p4 = int : int thickness
p5 = int : int lineType
p6 = int : int shift
%inst
例： samples/cpp/camshiftdemo.cpp, samples/cpp/demhist.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/grabcut.cpp, samples/cpp/intersectExample.cpp, samples/cpp/peopledetect.cpp, samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/dnn/object_detection.cpp, and samples/tapi/hog.cpp.

元関数名(C#): imgproc_rectangle_Mat_Rect
元DLLエクスポート名: imgproc_rectangle_Mat_Rect
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_rectangle_Mat_Rect(
    cv::Mat *img, MyCvRect rect,
    MyCvScalar color, int thickness, int lineType, int shift)
{
    BEGIN_WRAP
    cv::rectangle(*img, cpp(rect), cpp(color), thickness, lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_rectangle_Mat_Rect
[64bit] 単純な，太い，あるいは塗りつぶされた右上がりの矩形を描画します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr img
p2 = var : Rect rect
p3 = var : Scalar color
p4 = int : int thickness
p5 = int : int lineType
p6 = int : int shift
%inst
例： samples/cpp/camshiftdemo.cpp, samples/cpp/demhist.cpp, samples/cpp/facedetect.cpp, samples/cpp/falecolor.cpp, samples/cpp/grabcut.cpp, samples/cpp/intersectExample.cpp, samples/cpp/peopledetect.cpp, samples/cpp/train_HOG.cpp, samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/dnn/object_detection.cpp, and samples/tapi/hog.cpp.

元関数名(C#): imgproc_rectangle_Mat_Rect
元DLLエクスポート名: imgproc_rectangle_Mat_Rect
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_rectangle_Mat_Rect(
    cv::Mat *img, MyCvRect rect,
    MyCvScalar color, int thickness, int lineType, int shift)
{
    BEGIN_WRAP
    cv::rectangle(*img, cpp(rect), cpp(color), thickness, lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_circle
[32bit] 円を描きます。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr img
p2 = ARGS_POINT : Point center
p3 = int : int radius
p4 = ARGS_SCALAR : Scalar color
p5 = int : int thickness
p6 = int : int lineType
p7 = int : int shift
%inst
例： samples/cpp/convexhull.cpp, samples/cpp/falecolor.cpp, samples/cpp/kmeans.cpp, samples/cpp/lkdemo.cpp, samples/cpp/minarea.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, and samples/dnn/openpose.cpp.

元関数名(C#): imgproc_circle
元DLLエクスポート名: imgproc_circle
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_circle(
    cv::_InputOutputArray *img, MyCvPoint center, int radius,
    MyCvScalar color, int thickness, int lineType, int shift)
{
    BEGIN_WRAP
    cv::circle(*img, cpp(center), radius, cpp(color), thickness, lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_circle
[64bit] 円を描きます。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr img
p2 = ARGS_POINT : Point center
p3 = int : int radius
p4 = var : Scalar color
p5 = int : int thickness
p6 = int : int lineType
p7 = int : int shift
%inst
例： samples/cpp/convexhull.cpp, samples/cpp/falecolor.cpp, samples/cpp/kmeans.cpp, samples/cpp/lkdemo.cpp, samples/cpp/minarea.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp, and samples/dnn/openpose.cpp.

元関数名(C#): imgproc_circle
元DLLエクスポート名: imgproc_circle
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_circle(
    cv::_InputOutputArray *img, MyCvPoint center, int radius,
    MyCvScalar color, int thickness, int lineType, int shift)
{
    BEGIN_WRAP
    cv::circle(*img, cpp(center), radius, cpp(color), thickness, lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_ellipse1
[32bit] 単純または太い楕円の円弧を描いたり、楕円のセクタを埋めたりします。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = sptr : IntPtr img
p2 = ARGS_POINT : Point center
p3 = ARGS_SIZE : Size axes
p4 = double : double angle
p5 = double : double startAngle
p6 = double : double endAngle
p7 = ARGS_SCALAR : Scalar color
p8 = int : int thickness
p9 = int : int lineType
p10 = int : int shift
%inst
関数 cv::ellipse は，より多くのパラメータを指定することで，楕円の輪郭，塗りつぶした楕円，楕円の円弧，塗りつぶした楕円のセクタを描画します．描画コードは，一般的なパラメトリック形式を利用しています．楕円弧の境界を近似するために、ピースウィズ線形曲線が使用されます。楕円の描画をより細かく制御する必要がある場合は、ellipse2Poly を使用して曲線を取得し、それをポリラインで描画したり、fillPoly で塗りつぶしたりすることができます。この関数の最初のバージョンを使用して、円弧ではなく楕円全体を描画したい場合は、startAngle=0 と endAngle=360 を渡します。startAngle が endAngle よりも大きい場合は、両者が入れ替わります。下図は、青い円弧.ellipse.svgを描くためのパラメータの意味を説明したものです。



楕円弧のパラメータExamples: fld_lines.cpp, samples/cpp/camshiftdemo.cpp, samples/cpp/contours2.cpp, samples/cpp/falecolor.cpp, samples/cpp/fitellipse.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, and samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp.

元関数名(C#): imgproc_ellipse1
元DLLエクスポート名: imgproc_ellipse1
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_ellipse1(
    cv::_InputOutputArray *img, MyCvPoint center, MyCvSize axes,
    double angle, double startAngle, double endAngle,
    MyCvScalar color, int thickness, int lineType, int shift)
{
    BEGIN_WRAP
    cv::ellipse(*img, cpp(center), cpp(axes), angle, startAngle, endAngle, cpp(color), thickness, lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_ellipse1
[64bit] 単純または太い楕円の円弧を描いたり、楕円のセクタを埋めたりします。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = sptr : IntPtr img
p2 = ARGS_POINT : Point center
p3 = ARGS_SIZE : Size axes
p4 = double : double angle
p5 = double : double startAngle
p6 = double : double endAngle
p7 = var : Scalar color
p8 = int : int thickness
p9 = int : int lineType
p10 = int : int shift
%inst
関数 cv::ellipse は，より多くのパラメータを指定することで，楕円の輪郭，塗りつぶした楕円，楕円の円弧，塗りつぶした楕円のセクタを描画します．描画コードは，一般的なパラメトリック形式を利用しています．楕円弧の境界を近似するために、ピースウィズ線形曲線が使用されます。楕円の描画をより細かく制御する必要がある場合は、ellipse2Poly を使用して曲線を取得し、それをポリラインで描画したり、fillPoly で塗りつぶしたりすることができます。この関数の最初のバージョンを使用して、円弧ではなく楕円全体を描画したい場合は、startAngle=0 と endAngle=360 を渡します。startAngle が endAngle よりも大きい場合は、両者が入れ替わります。下図は、青い円弧.ellipse.svgを描くためのパラメータの意味を説明したものです。



楕円弧のパラメータExamples: fld_lines.cpp, samples/cpp/camshiftdemo.cpp, samples/cpp/contours2.cpp, samples/cpp/falecolor.cpp, samples/cpp/fitellipse.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp, and samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp.

元関数名(C#): imgproc_ellipse1
元DLLエクスポート名: imgproc_ellipse1
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_ellipse1(
    cv::_InputOutputArray *img, MyCvPoint center, MyCvSize axes,
    double angle, double startAngle, double endAngle,
    MyCvScalar color, int thickness, int lineType, int shift)
{
    BEGIN_WRAP
    cv::ellipse(*img, cpp(center), cpp(axes), angle, startAngle, endAngle, cpp(color), thickness, lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_ellipse2
[32bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr img
p2 = ARGS_ROTATEDRECT : RotatedRect box
p3 = ARGS_SCALAR : Scalar color
p4 = int : int thickness
p5 = int : int lineType
%inst
元関数名(C#): imgproc_ellipse2
元DLLエクスポート名: imgproc_ellipse2
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_ellipse2(
    cv::_InputOutputArray *img, MyCvBox2D box, MyCvScalar color, int thickness, int lineType)
{
    BEGIN_WRAP
    cv::ellipse(*img, cpp(box), cpp(color), thickness, lineType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_ellipse2
[64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr img
p2 = var : RotatedRect box
p3 = var : Scalar color
p4 = int : int thickness
p5 = int : int lineType
%inst
元関数名(C#): imgproc_ellipse2
元DLLエクスポート名: imgproc_ellipse2
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_ellipse2(
    cv::_InputOutputArray *img, MyCvBox2D box, MyCvScalar color, int thickness, int lineType)
{
    BEGIN_WRAP
    cv::ellipse(*img, cpp(box), cpp(color), thickness, lineType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_drawMarker
[32bit] 画像内の定義済みの位置にマーカーを描画します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr img
p2 = ARGS_POINT : Point position
p3 = ARGS_SCALAR : Scalar color
p4 = int : int markerType
p5 = int : int markerSize
p6 = int : int thickness
p7 = int : int lineType
%inst
関数 cv::drawMarker は，画像中の指定された位置にマーカーを描画します．現時点では，複数のマーカータイプがサポートされています．詳細は MarkerTypes を参照してください．例： samples/cpp/polar_transforms.cpp.

元関数名(C#): imgproc_drawMarker
元DLLエクスポート名: imgproc_drawMarker
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_drawMarker(
    cv::_InputOutputArray *img, MyCvPoint position, MyCvScalar color,
    int markerType, int markerSize, int thickness, int lineType)
{
    BEGIN_WRAP
    cv::drawMarker(*img, cpp(position), cpp(color), markerType, markerSize, thickness, lineType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_drawMarker
[64bit] 画像内の定義済みの位置にマーカーを描画します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr img
p2 = ARGS_POINT : Point position
p3 = var : Scalar color
p4 = int : int markerType
p5 = int : int markerSize
p6 = int : int thickness
p7 = int : int lineType
%inst
関数 cv::drawMarker は，画像中の指定された位置にマーカーを描画します．現時点では，複数のマーカータイプがサポートされています．詳細は MarkerTypes を参照してください．例： samples/cpp/polar_transforms.cpp.

元関数名(C#): imgproc_drawMarker
元DLLエクスポート名: imgproc_drawMarker
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_drawMarker(
    cv::_InputOutputArray *img, MyCvPoint position, MyCvScalar color,
    int markerType, int markerSize, int thickness, int lineType)
{
    BEGIN_WRAP
    cv::drawMarker(*img, cpp(position), cpp(color), markerType, markerSize, thickness, lineType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fillConvexPoly_Mat
[32bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr img
p2 = var : Point[] pts
p3 = int : int npts
p4 = ARGS_SCALAR : Scalar color
p5 = int : int lineType
p6 = int : int shift
%inst
元関数名(C#): imgproc_fillConvexPoly_Mat
元DLLエクスポート名: imgproc_fillConvexPoly_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fillConvexPoly_Mat(
    cv::Mat *img, cv::Point *pts, int npts, MyCvScalar color, int lineType, int shift)
{
    BEGIN_WRAP
    cv::fillConvexPoly(*img, pts, npts, cpp(color), lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fillConvexPoly_Mat
[64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr img
p2 = var : Point[] pts
p3 = int : int npts
p4 = var : Scalar color
p5 = int : int lineType
p6 = int : int shift
%inst
元関数名(C#): imgproc_fillConvexPoly_Mat
元DLLエクスポート名: imgproc_fillConvexPoly_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fillConvexPoly_Mat(
    cv::Mat *img, cv::Point *pts, int npts, MyCvScalar color, int lineType, int shift)
{
    BEGIN_WRAP
    cv::fillConvexPoly(*img, pts, npts, cpp(color), lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fillConvexPoly_InputOutputArray
[32bit] 凸型の多角形を塗りつぶします。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr img
p2 = sptr : IntPtr points
p3 = ARGS_SCALAR : Scalar color
p4 = int : int lineType
p5 = int : int shift
%inst
関数 cv::fillConvexPoly は，塗りつぶした凸多角形を描画します．この関数は，関数 fillPoly よりもはるかに高速です．これは，凸多角形だけでなく，自己交差のない単調な多角形，つまり，輪郭がすべての水平線（走査線）と最大で2回交差する多角形を塗りつぶすことができます（ただし，最上端や最下端が水平である可能性もあります）．

元関数名(C#): imgproc_fillConvexPoly_InputOutputArray
元DLLエクスポート名: imgproc_fillConvexPoly_InputOutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fillConvexPoly_InputOutputArray(
    cv::_InputOutputArray *img, cv::_InputArray *points, MyCvScalar color, int lineType, int shift)
{
    BEGIN_WRAP
    cv::fillConvexPoly(*img, *points, cpp(color), lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fillConvexPoly_InputOutputArray
[64bit] 凸型の多角形を塗りつぶします。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr img
p2 = sptr : IntPtr points
p3 = var : Scalar color
p4 = int : int lineType
p5 = int : int shift
%inst
関数 cv::fillConvexPoly は，塗りつぶした凸多角形を描画します．この関数は，関数 fillPoly よりもはるかに高速です．これは，凸多角形だけでなく，自己交差のない単調な多角形，つまり，輪郭がすべての水平線（走査線）と最大で2回交差する多角形を塗りつぶすことができます（ただし，最上端や最下端が水平である可能性もあります）．

元関数名(C#): imgproc_fillConvexPoly_InputOutputArray
元DLLエクスポート名: imgproc_fillConvexPoly_InputOutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fillConvexPoly_InputOutputArray(
    cv::_InputOutputArray *img, cv::_InputArray *points, MyCvScalar color, int lineType, int shift)
{
    BEGIN_WRAP
    cv::fillConvexPoly(*img, *points, cpp(color), lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fillPoly_Mat
[32bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr img
p2 = sptr : IntPtr[] pts
p3 = var : int[] npts
p4 = int : int ncontours
p5 = ARGS_SCALAR : Scalar color
p6 = int : int lineType
p7 = int : int shift
p8 = ARGS_POINT : Point offset
%inst
例：samples/cpp/create_mask.cpp、samples/cpp/intersectExample.cpp、samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp、samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp。

元関数名(C#): imgproc_fillPoly_Mat
元DLLエクスポート名: imgproc_fillPoly_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fillPoly_Mat(cv::Mat *img, const cv::Point **pts, const int *npts,
                                 int ncontours, MyCvScalar color, int lineType, int shift, MyCvPoint offset)
{
    BEGIN_WRAP
    cv::fillPoly(*img, pts, npts, ncontours, cpp(color), lineType, shift, cpp(offset));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fillPoly_Mat
[64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr img
p2 = sptr : IntPtr[] pts
p3 = var : int[] npts
p4 = int : int ncontours
p5 = var : Scalar color
p6 = int : int lineType
p7 = int : int shift
p8 = ARGS_POINT : Point offset
%inst
例：samples/cpp/create_mask.cpp、samples/cpp/intersectExample.cpp、samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp、samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp。

元関数名(C#): imgproc_fillPoly_Mat
元DLLエクスポート名: imgproc_fillPoly_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fillPoly_Mat(cv::Mat *img, const cv::Point **pts, const int *npts,
                                 int ncontours, MyCvScalar color, int lineType, int shift, MyCvPoint offset)
{
    BEGIN_WRAP
    cv::fillPoly(*img, pts, npts, ncontours, cpp(color), lineType, shift, cpp(offset));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fillPoly_InputOutputArray
[32bit] 1つまたは複数のポリゴンで囲まれた領域を塗りつぶします。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr img
p2 = sptr : IntPtr pts
p3 = ARGS_SCALAR : Scalar color
p4 = int : int lineType
p5 = int : int shift
p6 = ARGS_POINT : Point offset
%inst
関数 cv::fillPoly は，複数の多角形の輪郭で囲まれた領域を塗りつぶします．この関数は，複雑な領域を塗りつぶすことができます．例えば，穴のある領域や，自己交差（部分的に）している輪郭などです．

元関数名(C#): imgproc_fillPoly_InputOutputArray
元DLLエクスポート名: imgproc_fillPoly_InputOutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fillPoly_InputOutputArray(cv::_InputOutputArray *img, cv::_InputArray *pts,
                                              MyCvScalar color, int lineType, int shift, MyCvPoint offset)
{
    BEGIN_WRAP
    cv::fillPoly(*img, *pts, cpp(color), lineType, shift, cpp(offset));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_fillPoly_InputOutputArray
[64bit] 1つまたは複数のポリゴンで囲まれた領域を塗りつぶします。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr img
p2 = sptr : IntPtr pts
p3 = var : Scalar color
p4 = int : int lineType
p5 = int : int shift
p6 = ARGS_POINT : Point offset
%inst
関数 cv::fillPoly は，複数の多角形の輪郭で囲まれた領域を塗りつぶします．この関数は，複雑な領域を塗りつぶすことができます．例えば，穴のある領域や，自己交差（部分的に）している輪郭などです．

元関数名(C#): imgproc_fillPoly_InputOutputArray
元DLLエクスポート名: imgproc_fillPoly_InputOutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_fillPoly_InputOutputArray(cv::_InputOutputArray *img, cv::_InputArray *pts,
                                              MyCvScalar color, int lineType, int shift, MyCvPoint offset)
{
    BEGIN_WRAP
    cv::fillPoly(*img, *pts, cpp(color), lineType, shift, cpp(offset));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_polylines_Mat
[32bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr img
p2 = sptr : IntPtr[] pts
p3 = var : int[] npts
p4 = int : int ncontours
p5 = int : int isClosed
p6 = ARGS_SCALAR : Scalar color
p7 = int : int thickness
p8 = int : int lineType
p9 = int : int shift
%inst
例：fld_lines.cpp、samples/cpp/create_mask.cpp、samples/cpp/intersectExample.cpp、samples/cpp/squares.cpp、samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp、samples/dnn/text_detection.cpp、samples/tapi/squares.cpp。

元関数名(C#): imgproc_polylines_Mat
元DLLエクスポート名: imgproc_polylines_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_polylines_Mat(
    cv::Mat *img, const cv::Point **pts, const int *npts,
    int ncontours, int isClosed, MyCvScalar color,
    int thickness, int lineType, int shift)
{
    BEGIN_WRAP
    cv::polylines(
        *img, pts, npts, ncontours, isClosed != 0, cpp(color), thickness, lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_polylines_Mat
[64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr img
p2 = sptr : IntPtr[] pts
p3 = var : int[] npts
p4 = int : int ncontours
p5 = int : int isClosed
p6 = var : Scalar color
p7 = int : int thickness
p8 = int : int lineType
p9 = int : int shift
%inst
例：fld_lines.cpp、samples/cpp/create_mask.cpp、samples/cpp/intersectExample.cpp、samples/cpp/squares.cpp、samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp、samples/dnn/text_detection.cpp、samples/tapi/squares.cpp。

元関数名(C#): imgproc_polylines_Mat
元DLLエクスポート名: imgproc_polylines_Mat
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_polylines_Mat(
    cv::Mat *img, const cv::Point **pts, const int *npts,
    int ncontours, int isClosed, MyCvScalar color,
    int thickness, int lineType, int shift)
{
    BEGIN_WRAP
    cv::polylines(
        *img, pts, npts, ncontours, isClosed != 0, cpp(color), thickness, lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_polylines_InputOutputArray
[32bit] いくつかの多角形の曲線を描画します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr img
p2 = sptr : IntPtr pts
p3 = int : int isClosed
p4 = ARGS_SCALAR : Scalar color
p5 = int : int thickness
p6 = int : int lineType
p7 = int : int shift
%inst
関数 cv::polylines は，1つあるいは複数の多角形の曲線を描画します．

元関数名(C#): imgproc_polylines_InputOutputArray
元DLLエクスポート名: imgproc_polylines_InputOutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_polylines_InputOutputArray(
    cv::_InputOutputArray *img, cv::_InputArray *pts, int isClosed, MyCvScalar color,
    int thickness, int lineType, int shift)
{
    BEGIN_WRAP
    cv::polylines(*img, *pts, isClosed != 0, cpp(color), thickness, lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_polylines_InputOutputArray
[64bit] いくつかの多角形の曲線を描画します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr img
p2 = sptr : IntPtr pts
p3 = int : int isClosed
p4 = var : Scalar color
p5 = int : int thickness
p6 = int : int lineType
p7 = int : int shift
%inst
関数 cv::polylines は，1つあるいは複数の多角形の曲線を描画します．

元関数名(C#): imgproc_polylines_InputOutputArray
元DLLエクスポート名: imgproc_polylines_InputOutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_polylines_InputOutputArray(
    cv::_InputOutputArray *img, cv::_InputArray *pts, int isClosed, MyCvScalar color,
    int thickness, int lineType, int shift)
{
    BEGIN_WRAP
    cv::polylines(*img, *pts, isClosed != 0, cpp(color), thickness, lineType, shift);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_drawContours_vector
[32bit] 輪郭のアウトラインや塗りつぶした輪郭を描画します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12
p1 = sptr : IntPtr image
p2 = sptr : IntPtr[] contours
p3 = int : int contoursSize1
p4 = var : int[] contoursSize2
p5 = int : int contourIdx
p6 = ARGS_SCALAR : Scalar color
p7 = int : int thickness
p8 = int : int lineType
p9 = var : Vec4i[] hierarchy
p10 = int : int hiearchyLength
p11 = int : int maxLevel
p12 = ARGS_POINT : Point offset
%inst
この関数は，画像に輪郭を描きます（\\）．以下の例では，2値画像から連結成分を取り出し，ラベルを付ける方法を示しています： :#include "opencv2/imgproc.hpp "#include "opencv2/highgui.hpp "using namespace cv;using namespace std;int main( int argc, char** argv ){ Mat src; // 最初のコマンドラインパラメータは，バイナリ（白黒）画像のファイル名でなければいけません // if( argc != 2 || !(src=imread(argv[1], 0).data) return -1; Mat dst = Mat::zeros(src.rows, src.cols, CV_8UC3); src = src > 1; namedWindow( "Source", 1 ); imshow( "Source", src ); vector<vector<Point> > contours; vector<Vec4i> hierarchy;    findContours( src, contours, hierarchy, RETR_CCOMP, CHAIN_APPROX_SIMPLE ); // すべてのトップレベルの輪郭を繰り返し処理して、 // 接続された各コンポーネントをそれぞれのランダムな色で描画します int idx = 0; for( ; idx >= 0;idx = hierarchy[idx][0] ) { Scalar color( rand()&255, rand()&255, rand()&255 ); drawContours( dst, contours, idx, color, FILLED, 8, hierarchy ); } namedWindow( "Components", 1 );    imshow( "Components", dst ); waitKey(0);}fragmentNote thickness=FILLEDにすると、階層の日付が指定されていなくても、穴の開いた連結部品を正しく扱えるようになっています。これは、偶奇則を用いてすべてのアウトラインをまとめて解析することで実現しています。これは、別々に検索された輪郭の共同コレクションがある場合、誤った結果を与える可能性があります。この問題を解決するには、輪郭のサブグループごとに別々に drawContours を呼び出すか、contourIdx パラメータを使ってコレクションを反復処理する必要があります。例: samples/cpp/contours2.cpp, samples/cpp/segment_objects.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/watershed.cpp.

元関数名(C#): imgproc_drawContours_vector
元DLLエクスポート名: imgproc_drawContours_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_drawContours_vector(cv::_InputOutputArray *image,
                                        cv::Point **contours, int contoursSize1, int *contoursSize2,
                                        int contourIdx, MyCvScalar color, int thickness, int lineType,
                                        cv::Vec4i *hierarchy, int hiearchyLength, int maxLevel, MyCvPoint offset)
{
    BEGIN_WRAP
    std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt; &amp;gt; contoursVec;
    for (auto i = 0; i &amp;lt; contoursSize1; i++)
    {
        std::vector&amp;lt;cv::Point&amp;gt; c1(contours[i], contours[i] + contoursSize2[i]);
        contoursVec.push_back(c1);
    }
    std::vector&amp;lt;cv::Vec4i&amp;gt; hierarchyVec;
    if (hierarchy != nullptr)
    {
        hierarchyVec = std::vector&amp;lt;cv::Vec4i&amp;gt;(hierarchy, hierarchy + hiearchyLength);
    }

    cv::drawContours(
        *image, contoursVec, contourIdx, cpp(color), thickness, lineType, hierarchyVec, maxLevel, cpp(offset));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_drawContours_vector
[64bit] 輪郭のアウトラインや塗りつぶした輪郭を描画します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12
p1 = sptr : IntPtr image
p2 = sptr : IntPtr[] contours
p3 = int : int contoursSize1
p4 = var : int[] contoursSize2
p5 = int : int contourIdx
p6 = var : Scalar color
p7 = int : int thickness
p8 = int : int lineType
p9 = var : Vec4i[] hierarchy
p10 = int : int hiearchyLength
p11 = int : int maxLevel
p12 = ARGS_POINT : Point offset
%inst
この関数は，画像に輪郭を描きます（\\）．以下の例では，2値画像から連結成分を取り出し，ラベルを付ける方法を示しています： :#include "opencv2/imgproc.hpp "#include "opencv2/highgui.hpp "using namespace cv;using namespace std;int main( int argc, char** argv ){ Mat src; // 最初のコマンドラインパラメータは，バイナリ（白黒）画像のファイル名でなければいけません // if( argc != 2 || !(src=imread(argv[1], 0).data) return -1; Mat dst = Mat::zeros(src.rows, src.cols, CV_8UC3); src = src > 1; namedWindow( "Source", 1 ); imshow( "Source", src ); vector<vector<Point> > contours; vector<Vec4i> hierarchy;    findContours( src, contours, hierarchy, RETR_CCOMP, CHAIN_APPROX_SIMPLE ); // すべてのトップレベルの輪郭を繰り返し処理して、 // 接続された各コンポーネントをそれぞれのランダムな色で描画します int idx = 0; for( ; idx >= 0;idx = hierarchy[idx][0] ) { Scalar color( rand()&255, rand()&255, rand()&255 ); drawContours( dst, contours, idx, color, FILLED, 8, hierarchy ); } namedWindow( "Components", 1 );    imshow( "Components", dst ); waitKey(0);}fragmentNote thickness=FILLEDにすると、階層の日付が指定されていなくても、穴の開いた連結部品を正しく扱えるようになっています。これは、偶奇則を用いてすべてのアウトラインをまとめて解析することで実現しています。これは、別々に検索された輪郭の共同コレクションがある場合、誤った結果を与える可能性があります。この問題を解決するには、輪郭のサブグループごとに別々に drawContours を呼び出すか、contourIdx パラメータを使ってコレクションを反復処理する必要があります。例: samples/cpp/contours2.cpp, samples/cpp/segment_objects.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/watershed.cpp.

元関数名(C#): imgproc_drawContours_vector
元DLLエクスポート名: imgproc_drawContours_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_drawContours_vector(cv::_InputOutputArray *image,
                                        cv::Point **contours, int contoursSize1, int *contoursSize2,
                                        int contourIdx, MyCvScalar color, int thickness, int lineType,
                                        cv::Vec4i *hierarchy, int hiearchyLength, int maxLevel, MyCvPoint offset)
{
    BEGIN_WRAP
    std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt; &amp;gt; contoursVec;
    for (auto i = 0; i &amp;lt; contoursSize1; i++)
    {
        std::vector&amp;lt;cv::Point&amp;gt; c1(contours[i], contours[i] + contoursSize2[i]);
        contoursVec.push_back(c1);
    }
    std::vector&amp;lt;cv::Vec4i&amp;gt; hierarchyVec;
    if (hierarchy != nullptr)
    {
        hierarchyVec = std::vector&amp;lt;cv::Vec4i&amp;gt;(hierarchy, hierarchy + hiearchyLength);
    }

    cv::drawContours(
        *image, contoursVec, contourIdx, cpp(color), thickness, lineType, hierarchyVec, maxLevel, cpp(offset));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_drawContours_InputArray
[32bit] 輪郭のアウトラインや塗りつぶした輪郭を描画します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = sptr : IntPtr image
p2 = sptr : IntPtr[] contours
p3 = int : int contoursLength
p4 = int : int contourIdx
p5 = ARGS_SCALAR : Scalar color
p6 = int : int thickness
p7 = int : int lineType
p8 = sptr : IntPtr hierarchy
p9 = int : int maxLevel
p10 = ARGS_POINT : Point offset
%inst
この関数は，画像に輪郭を描きます（\\）．以下の例では，2値画像から連結成分を取り出し，ラベルを付ける方法を示しています： :#include "opencv2/imgproc.hpp "#include "opencv2/highgui.hpp "using namespace cv;using namespace std;int main( int argc, char** argv ){ Mat src; // 最初のコマンドラインパラメータは，バイナリ（白黒）画像のファイル名でなければいけません // if( argc != 2 || !(src=imread(argv[1], 0).data) return -1; Mat dst = Mat::zeros(src.rows, src.cols, CV_8UC3); src = src > 1; namedWindow( "Source", 1 ); imshow( "Source", src ); vector<vector<Point> > contours; vector<Vec4i> hierarchy;    findContours( src, contours, hierarchy, RETR_CCOMP, CHAIN_APPROX_SIMPLE ); // すべてのトップレベルの輪郭を繰り返し処理して、 // 接続された各コンポーネントをそれぞれのランダムな色で描画します int idx = 0; for( ; idx >= 0;idx = hierarchy[idx][0] ) { Scalar color( rand()&255, rand()&255, rand()&255 ); drawContours( dst, contours, idx, color, FILLED, 8, hierarchy ); } namedWindow( "Components", 1 );    imshow( "Components", dst ); waitKey(0);}fragmentNote thickness=FILLEDにすると、階層の日付が指定されていなくても、穴の開いた連結部品を正しく扱えるようになっています。これは、偶奇則を用いてすべてのアウトラインをまとめて解析することで実現しています。これは、別々に検索された輪郭の共同コレクションがある場合、誤った結果を与える可能性があります。この問題を解決するには、輪郭のサブグループごとに別々に drawContours を呼び出すか、contourIdx パラメータを使ってコレクションを反復処理する必要があります。例: samples/cpp/contours2.cpp, samples/cpp/segment_objects.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/watershed.cpp.

元関数名(C#): imgproc_drawContours_InputArray
元DLLエクスポート名: imgproc_drawContours_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_drawContours_InputArray(cv::_InputOutputArray *image,
                                            cv::Mat **contours, int contoursLength,
                                            int contourIdx, MyCvScalar color, int thickness, int lineType,
                                            cv::_InputArray *hierarchy, int maxLevel, MyCvPoint offset)
{
    BEGIN_WRAP
    std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt; &amp;gt; contoursVec(contoursLength);
    for (auto i = 0; i &amp;lt; contoursLength; i++)
        contoursVec[i] = *contours[i];
    cv::drawContours(
        *image, contoursVec, contourIdx, cpp(color), thickness, lineType, entity(hierarchy), maxLevel, cpp(offset));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_drawContours_InputArray
[64bit] 輪郭のアウトラインや塗りつぶした輪郭を描画します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = sptr : IntPtr image
p2 = sptr : IntPtr[] contours
p3 = int : int contoursLength
p4 = int : int contourIdx
p5 = var : Scalar color
p6 = int : int thickness
p7 = int : int lineType
p8 = sptr : IntPtr hierarchy
p9 = int : int maxLevel
p10 = ARGS_POINT : Point offset
%inst
この関数は，画像に輪郭を描きます（\\）．以下の例では，2値画像から連結成分を取り出し，ラベルを付ける方法を示しています： :#include "opencv2/imgproc.hpp "#include "opencv2/highgui.hpp "using namespace cv;using namespace std;int main( int argc, char** argv ){ Mat src; // 最初のコマンドラインパラメータは，バイナリ（白黒）画像のファイル名でなければいけません // if( argc != 2 || !(src=imread(argv[1], 0).data) return -1; Mat dst = Mat::zeros(src.rows, src.cols, CV_8UC3); src = src > 1; namedWindow( "Source", 1 ); imshow( "Source", src ); vector<vector<Point> > contours; vector<Vec4i> hierarchy;    findContours( src, contours, hierarchy, RETR_CCOMP, CHAIN_APPROX_SIMPLE ); // すべてのトップレベルの輪郭を繰り返し処理して、 // 接続された各コンポーネントをそれぞれのランダムな色で描画します int idx = 0; for( ; idx >= 0;idx = hierarchy[idx][0] ) { Scalar color( rand()&255, rand()&255, rand()&255 ); drawContours( dst, contours, idx, color, FILLED, 8, hierarchy ); } namedWindow( "Components", 1 );    imshow( "Components", dst ); waitKey(0);}fragmentNote thickness=FILLEDにすると、階層の日付が指定されていなくても、穴の開いた連結部品を正しく扱えるようになっています。これは、偶奇則を用いてすべてのアウトラインをまとめて解析することで実現しています。これは、別々に検索された輪郭の共同コレクションがある場合、誤った結果を与える可能性があります。この問題を解決するには、輪郭のサブグループごとに別々に drawContours を呼び出すか、contourIdx パラメータを使ってコレクションを反復処理する必要があります。例: samples/cpp/contours2.cpp, samples/cpp/segment_objects.cpp, samples/cpp/tutorial_code/ml/introduction_to_pca/introduction_to_pca.cpp, samples/cpp/watershed.cpp.

元関数名(C#): imgproc_drawContours_InputArray
元DLLエクスポート名: imgproc_drawContours_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_drawContours_InputArray(cv::_InputOutputArray *image,
                                            cv::Mat **contours, int contoursLength,
                                            int contourIdx, MyCvScalar color, int thickness, int lineType,
                                            cv::_InputArray *hierarchy, int maxLevel, MyCvPoint offset)
{
    BEGIN_WRAP
    std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt; &amp;gt; contoursVec(contoursLength);
    for (auto i = 0; i &amp;lt; contoursLength; i++)
        contoursVec[i] = *contours[i];
    cv::drawContours(
        *image, contoursVec, contourIdx, cpp(color), thickness, lineType, entity(hierarchy), maxLevel, cpp(offset));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_clipLine1
[32/64bit] 画像の矩形に対して線をクリップします。
%prm
p1,p2,p3,p4
p1 = ARGS_SIZE : Size imgSize
p2 = var : ref Point pt1
p3 = var : ref Point pt2
p4 = var : out int returnValue
%inst
関数 cv::clipLine は，線分の一部が指定された矩形内に収まるように計算します．線分が完全に矩形の外側にある場合は false を返します．そうでない場合は，真を返します．

元関数名(C#): imgproc_clipLine1
元DLLエクスポート名: imgproc_clipLine1
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_clipLine1(MyCvSize imgSize, MyCvPoint *pt1, MyCvPoint *pt2, int* returnValue)
{
    BEGIN_WRAP
    auto pt1c = cpp(*pt1), pt2c = cpp(*pt2);
    const auto result = cv::clipLine(cpp(imgSize), pt1c, pt2c);
    *pt1 = c(pt1c);
    *pt2 = c(pt2c);
    *returnValue = result ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_clipLine2
[32bit] 画像の矩形に対して線をクリップします。
%prm
p1,p2,p3,p4
p1 = ARGS_RECT : Rect imgRect
p2 = var : ref Point pt1
p3 = var : ref Point pt2
p4 = var : out int returnValue
%inst
関数 cv::clipLine は，線分の一部が指定された矩形内に収まるように計算します．線分が完全に矩形の外側にある場合は false を返します．そうでない場合は，真を返します．

元関数名(C#): imgproc_clipLine2
元DLLエクスポート名: imgproc_clipLine2
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_clipLine2(MyCvRect imgRect, MyCvPoint *pt1, MyCvPoint *pt2, int* returnValue)
{
    BEGIN_WRAP
    auto pt1c = cpp(*pt1), pt2c = cpp(*pt2);
    const auto result = cv::clipLine(cpp(imgRect), pt1c, pt2c);
    *pt1 = c(pt1c);
    *pt2 = c(pt2c);
    *returnValue = result ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_clipLine2
[64bit] 画像の矩形に対して線をクリップします。
%prm
p1,p2,p3,p4
p1 = var : Rect imgRect
p2 = var : ref Point pt1
p3 = var : ref Point pt2
p4 = var : out int returnValue
%inst
関数 cv::clipLine は，線分の一部が指定された矩形内に収まるように計算します．線分が完全に矩形の外側にある場合は false を返します．そうでない場合は，真を返します．

元関数名(C#): imgproc_clipLine2
元DLLエクスポート名: imgproc_clipLine2
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_clipLine2(MyCvRect imgRect, MyCvPoint *pt1, MyCvPoint *pt2, int* returnValue)
{
    BEGIN_WRAP
    auto pt1c = cpp(*pt1), pt2c = cpp(*pt2);
    const auto result = cv::clipLine(cpp(imgRect), pt1c, pt2c);
    *pt1 = c(pt1c);
    *pt2 = c(pt2c);
    *returnValue = result ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_ellipse2Poly_int
[32/64bit] 楕円形の円弧をポリラインで近似します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = ARGS_POINT : Point center
p2 = ARGS_SIZE : Size axes
p3 = int : int angle
p4 = int : int arcStart
p5 = int : int arcEnd
p6 = int : int delta
p7 = sptr : IntPtr pts
%inst
関数 ellipse2Poly は，指定された楕円弧に近似するポリラインの頂点を計算します．この関数は，ellipse で使用されます．arcStart が arcEnd よりも大きい場合，それらは入れ替えられます。

元関数名(C#): imgproc_ellipse2Poly_int
元DLLエクスポート名: imgproc_ellipse2Poly_int
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_ellipse2Poly_int(
    MyCvPoint center, MyCvSize axes, int angle, int arcStart, int arcEnd,
    int delta, std::vector&amp;lt;cv::Point&amp;gt;* pts)
{
    BEGIN_WRAP
    cv::ellipse2Poly(cpp(center), cpp(axes), angle, arcStart, arcEnd, delta, *pts);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_ellipse2Poly_double
[32bit] 楕円形の円弧をポリラインで近似します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = ARGS_POINT2D : Point2d center
p2 = ARGS_SIZE2D : Size2d axes
p3 = int : int angle
p4 = int : int arcStart
p5 = int : int arcEnd
p6 = int : int delta
p7 = sptr : IntPtr pts
%inst
関数 ellipse2Poly は，指定された楕円弧に近似するポリラインの頂点を計算します．この関数は，ellipse で使用されます．arcStart が arcEnd よりも大きい場合，それらは入れ替えられます。

元関数名(C#): imgproc_ellipse2Poly_double
元DLLエクスポート名: imgproc_ellipse2Poly_double
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_ellipse2Poly_double(
    MyCvPoint2D64f center, MyCvSize2D64f axes, int angle, int arcStart, int arcEnd,
    int delta, std::vector&amp;lt;cv::Point2d&amp;gt;* pts)
{
    BEGIN_WRAP
    cv::ellipse2Poly(cpp(center), cpp(axes), angle, arcStart, arcEnd, delta, *pts);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_ellipse2Poly_double
[64bit] 楕円形の円弧をポリラインで近似します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = var : Point2d center
p2 = var : Size2d axes
p3 = int : int angle
p4 = int : int arcStart
p5 = int : int arcEnd
p6 = int : int delta
p7 = sptr : IntPtr pts
%inst
関数 ellipse2Poly は，指定された楕円弧に近似するポリラインの頂点を計算します．この関数は，ellipse で使用されます．arcStart が arcEnd よりも大きい場合，それらは入れ替えられます。

元関数名(C#): imgproc_ellipse2Poly_double
元DLLエクスポート名: imgproc_ellipse2Poly_double
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_ellipse2Poly_double(
    MyCvPoint2D64f center, MyCvSize2D64f axes, int angle, int arcStart, int arcEnd,
    int delta, std::vector&amp;lt;cv::Point2d&amp;gt;* pts)
{
    BEGIN_WRAP
    cv::ellipse2Poly(cpp(center), cpp(axes), angle, arcStart, arcEnd, delta, *pts);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_putText
[32bit] テキスト文字列を描画します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr img
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string text
p3 = ARGS_POINT : Point org
p4 = int : int fontFace
p5 = double : double fontScale
p6 = ARGS_SCALAR : Scalar color
p7 = int : int thickness
p8 = int : int lineType
p9 = int : int bottomLeftOrigin
%inst
関数 cv::putText は，指定された文字列を画像内にレンダリングします．指定されたフォントでは描画できない記号は，クエスチョンマークに置き換えられます．テキストレンダリングのコード例は，getTextSize を参照してください．例： samples/cpp/falecolor.cpp, samples/cpp/fitellipse.cpp, samples/cpp/intersectExample.cpp, samples/cpp/peopledetect.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp、samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp、samples/cpp/warpPerspective_demo.cpp、samples/dnn/classification.cpp、samples/dnn/object_detection.cpp、samples/dnn/segmentation.cpp、samples/dnn/text_detection.cpp、samples/tapi/hog.cppです。

元関数名(C#): imgproc_putText
元DLLエクスポート名: imgproc_putText
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_putText(cv::_InputOutputArray *img, const char *text, MyCvPoint org,
                         int fontFace, double fontScale, MyCvScalar color,
                         int thickness, int lineType, int bottomLeftOrigin)
{
    BEGIN_WRAP
    cv::putText(*img, text, cpp(org), fontFace, fontScale, cpp(color), thickness, lineType, bottomLeftOrigin != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_putText
[64bit] テキスト文字列を描画します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr img
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string text
p3 = ARGS_POINT : Point org
p4 = int : int fontFace
p5 = double : double fontScale
p6 = var : Scalar color
p7 = int : int thickness
p8 = int : int lineType
p9 = int : int bottomLeftOrigin
%inst
関数 cv::putText は，指定された文字列を画像内にレンダリングします．指定されたフォントでは描画できない記号は，クエスチョンマークに置き換えられます．テキストレンダリングのコード例は，getTextSize を参照してください．例： samples/cpp/falecolor.cpp, samples/cpp/fitellipse.cpp, samples/cpp/intersectExample.cpp, samples/cpp/peopledetect.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp、samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp、samples/cpp/warpPerspective_demo.cpp、samples/dnn/classification.cpp、samples/dnn/object_detection.cpp、samples/dnn/segmentation.cpp、samples/dnn/text_detection.cpp、samples/tapi/hog.cppです。

元関数名(C#): imgproc_putText
元DLLエクスポート名: imgproc_putText
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_putText(cv::_InputOutputArray *img, const char *text, MyCvPoint org,
                         int fontFace, double fontScale, MyCvScalar color,
                         int thickness, int lineType, int bottomLeftOrigin)
{
    BEGIN_WRAP
    cv::putText(*img, text, cpp(org), fontFace, fontScale, cpp(color), thickness, lineType, bottomLeftOrigin != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_getTextSize
[32/64bit] テキスト文字列の幅と高さを計算します。
%prm
p1,p2,p3,p4,p5,p6
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string text
p2 = int : int fontFace
p3 = double : double fontScale
p4 = int : int thickness
p5 = var : out int baseLine
p6 = var : out Size returnValue
%inst
関数 cv::getTextSize は，指定されたテキストを含むボックスのサイズを計算して返します．つまり，次のコードは，いくつかのテキストと，それを囲むタイトなボックス，そしてベースラインをレンダリングします： :String text = "Funny text inside the box";int fontFace = FONT_HERSHEY_SCRIPT_SIMPLEX;double fontScale = 2;int thickness = 3;Mat img(600, 800, CV_8UC3, Scalar::all(0));int baseline=0;Size textSize = getTextSize(text, fontFace, fontScale, thickness, &baseline);baseline += thickness;// textPoint を中央に配置 textOrg((img.cols - textSize.width)/2, (img.rows + textSize.height)/2);// boxrectangle(img, textOrg + Point(0, baseline), textOrg + Point(textSize.width, -textSize.height), Scalar(0,0,255));// ...そしてベースライン firstline(img, textOrg + Point(0, thickness), textOrg + Point(textSize.width, thickness), Scalar(0, 0, 255));// そしてテキスト自体を配置putText(img, text, textOrg, fontFace, fontScale, Scalar::all(255), thickness, 8);fragmentSee alsoputTextExamples: samples/cpp/fitellipse.cpp, samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp, and samples/dnn/object_detection.cpp.

元関数名(C#): imgproc_getTextSize
元DLLエクスポート名: imgproc_getTextSize
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_getTextSize(const char *text, int fontFace,
                                 double fontScale, int thickness, int *baseLine, MyCvSize *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(cv::getTextSize(text, fontFace, fontScale, thickness, baseLine));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_getFontScaleFromHeight
[32/64bit] 与えられた高さをピクセル単位で実現するために使用するフォント固有のサイズを計算します。
%prm
p1,p2,p3,p4
p1 = int : int fontFace
p2 = int : int pixelHeight
p3 = int : int thickness
p4 = var : out double returnValue
%inst
詳しくは putText を参照してください．

元関数名(C#): imgproc_getFontScaleFromHeight
元DLLエクスポート名: imgproc_getFontScaleFromHeight
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_getFontScaleFromHeight(
    int fontFace, int pixelHeight, int thickness, double* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::getFontScaleFromHeight(fontFace, pixelHeight, thickness);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc

%index
imgproc_createCLAHE
[32/64bit] cv::CLAHE クラスへのスマートポインタを作成し，それを初期化します．
%prm
p1,p2,p3
p1 = double : double clipLimit
p2 = ARGS_SIZE : Size tileGridSize
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): imgproc_createCLAHE
元DLLエクスポート名: imgproc_createCLAHE
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_CLAHE.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_createCLAHE(double clipLimit, MyCvSize tileGridSize, cv::Ptr&amp;lt;cv::CLAHE&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ret = cv::createCLAHE(clipLimit, cpp(tileGridSize));
    *returnValue = clone(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_CLAHE

%index
imgproc_Ptr_CLAHE_delete
[32/64bit] cv::CLAHE のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
Contrast Limited Adaptive Histogram Equalization（コントラスト限定適応ヒストグラム等化）の基底クラス．


元関数名(C#): imgproc_Ptr_CLAHE_delete
元DLLエクスポート名: imgproc_Ptr_CLAHE_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_CLAHE.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Ptr_CLAHE_delete(cv::Ptr&amp;lt;cv::CLAHE&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_CLAHE

%index
imgproc_Ptr_CLAHE_get
[32/64bit] cv::CLAHE のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
Contrast Limited Adaptive Histogram Equalization（コントラスト限定適応ヒストグラム等化）の基底クラス．


元関数名(C#): imgproc_Ptr_CLAHE_get
元DLLエクスポート名: imgproc_Ptr_CLAHE_get
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_CLAHE.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Ptr_CLAHE_get(cv::Ptr&amp;lt;cv::CLAHE&amp;gt; *obj, cv::CLAHE **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_CLAHE

%index
imgproc_CLAHE_apply
[32/64bit] Contrast Limited Adaptive Histogram Equalizationを用いて，グレースケール画像のヒストグラムを均等化します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
%inst
元関数名(C#): imgproc_CLAHE_apply
元DLLエクスポート名: imgproc_CLAHE_apply
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_CLAHE.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_CLAHE_apply(cv::CLAHE *obj, cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    obj-&amp;gt;apply(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_CLAHE

%index
imgproc_CLAHE_setClipLimit
[32/64bit] Contrast Limiting の閾値を設定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double clipLimit
%inst
元関数名(C#): imgproc_CLAHE_setClipLimit
元DLLエクスポート名: imgproc_CLAHE_setClipLimit
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_CLAHE.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_CLAHE_setClipLimit(cv::CLAHE *obj, double clipLimit)
{
    BEGIN_WRAP
    obj-&amp;gt;setClipLimit(clipLimit);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_CLAHE

%index
imgproc_CLAHE_getClipLimit
[32/64bit] コントラスト制限の閾値を返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): imgproc_CLAHE_getClipLimit
元DLLエクスポート名: imgproc_CLAHE_getClipLimit
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_CLAHE.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_CLAHE_getClipLimit(cv::CLAHE *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getClipLimit();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_CLAHE

%index
imgproc_CLAHE_setTilesGridSize
[32/64bit] ヒストグラム・イコライゼーションのためのグリッドのサイズを設定します．入力画像は，同じ大きさの長方形のタイルに分割されます．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = ARGS_SIZE : Size tileGridSize
%inst
元関数名(C#): imgproc_CLAHE_setTilesGridSize
元DLLエクスポート名: imgproc_CLAHE_setTilesGridSize
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_CLAHE.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_CLAHE_setTilesGridSize(cv::CLAHE *obj, MyCvSize tileGridSize)
{
    BEGIN_WRAP
    obj-&amp;gt;setTilesGridSize(cpp(tileGridSize));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_CLAHE

%index
imgproc_CLAHE_getTilesGridSize
[32/64bit] タイルグリッドサイズ ： 行と列のタイルの数を定義します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out Size returnValue
%inst
元関数名(C#): imgproc_CLAHE_getTilesGridSize
元DLLエクスポート名: imgproc_CLAHE_getTilesGridSize
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_CLAHE.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_CLAHE_getTilesGridSize(cv::CLAHE *obj, MyCvSize *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(obj-&amp;gt;getTilesGridSize());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_CLAHE

%index
imgproc_CLAHE_collectGarbage
[32/64bit] imgproc_CLAHE_collectGarbage
%prm
p1
p1 = sptr : IntPtr obj
%inst
元関数名(C#): imgproc_CLAHE_collectGarbage
元DLLエクスポート名: imgproc_CLAHE_collectGarbage
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_CLAHE.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_CLAHE_collectGarbage(cv::CLAHE *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;collectGarbage();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_CLAHE

%index
imgproc_GeneralizedHough_setTemplate1
[32/64bit] 検索するテンプレートの設定
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr templ
p3 = ARGS_POINT : Point templCenter
%inst
元関数名(C#): imgproc_GeneralizedHough_setTemplate1
元DLLエクスポート名: imgproc_GeneralizedHough_setTemplate1
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHough_setTemplate1(
    cv::GeneralizedHough *obj, cv::_InputArray *templ, MyCvPoint templCenter)
{
    BEGIN_WRAP
    obj-&amp;gt;setTemplate(*templ, cpp(templCenter));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHough_setTemplate2
[32/64bit] 検索するテンプレートの設定
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr edges
p3 = sptr : IntPtr dx
p4 = sptr : IntPtr dy
p5 = ARGS_POINT : Point templCenter
%inst
元関数名(C#): imgproc_GeneralizedHough_setTemplate2
元DLLエクスポート名: imgproc_GeneralizedHough_setTemplate2
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHough_setTemplate2(
    cv::GeneralizedHough *obj, cv::_InputArray *edges, cv::_InputArray *dx, cv::_InputArray *dy, MyCvPoint templCenter)
{
    BEGIN_WRAP
    obj-&amp;gt;setTemplate(*edges, *dx, *dy, cpp(templCenter));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHough_detect1
[32/64bit] 画像からテンプレートを探す
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = sptr : IntPtr positions
p4 = sptr : IntPtr votes
%inst
元関数名(C#): imgproc_GeneralizedHough_detect1
元DLLエクスポート名: imgproc_GeneralizedHough_detect1
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHough_detect1(
    cv::GeneralizedHough *obj, cv::_InputArray *image, cv::_OutputArray *positions, cv::_OutputArray *votes)
{
    BEGIN_WRAP
    obj-&amp;gt;detect(*image, *positions, entity(votes));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHough_detect2
[32/64bit] 画像からテンプレートを探す
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr edges
p3 = sptr : IntPtr dx
p4 = sptr : IntPtr dy
p5 = sptr : IntPtr positions
p6 = sptr : IntPtr votes
%inst
元関数名(C#): imgproc_GeneralizedHough_detect2
元DLLエクスポート名: imgproc_GeneralizedHough_detect2
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHough_detect2(
    cv::GeneralizedHough *obj, cv::_InputArray *edges, cv::_InputArray *dx, cv::_InputArray *dy, cv::_OutputArray *positions, cv::_OutputArray *votes)
{
    BEGIN_WRAP
    obj-&amp;gt;detect(*edges, *dx, *dy, *positions, entity(votes));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHough_setCannyLowThresh
[32/64bit] Canny low threshold.
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): imgproc_GeneralizedHough_setCannyLowThresh
元DLLエクスポート名: imgproc_GeneralizedHough_setCannyLowThresh
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHough_setCannyLowThresh(cv::GeneralizedHough *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setCannyLowThresh(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHough_getCannyLowThresh
[32/64bit] imgproc_GeneralizedHough_getCannyLowThresh
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): imgproc_GeneralizedHough_getCannyLowThresh
元DLLエクスポート名: imgproc_GeneralizedHough_getCannyLowThresh
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHough_getCannyLowThresh(cv::GeneralizedHough *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getCannyLowThresh();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHough_setCannyHighThresh
[32/64bit] Canny high threshold.
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): imgproc_GeneralizedHough_setCannyHighThresh
元DLLエクスポート名: imgproc_GeneralizedHough_setCannyHighThresh
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHough_setCannyHighThresh(cv::GeneralizedHough *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setCannyHighThresh(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHough_getCannyHighThresh
[32/64bit] imgproc_GeneralizedHough_getCannyHighThresh
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): imgproc_GeneralizedHough_getCannyHighThresh
元DLLエクスポート名: imgproc_GeneralizedHough_getCannyHighThresh
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHough_getCannyHighThresh(cv::GeneralizedHough *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getCannyHighThresh();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHough_setMinDist
[32/64bit] 検出されたオブジェクトの中心間の最小距離を指定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): imgproc_GeneralizedHough_setMinDist
元DLLエクスポート名: imgproc_GeneralizedHough_setMinDist
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHough_setMinDist(cv::GeneralizedHough *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setMinDist(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHough_getMinDist
[32/64bit] imgproc_GeneralizedHough_getMinDist
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): imgproc_GeneralizedHough_getMinDist
元DLLエクスポート名: imgproc_GeneralizedHough_getMinDist
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHough_getMinDist(cv::GeneralizedHough *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getMinDist();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHough_setDp
[32/64bit] 画像の解像度に対するアキュムレータの解像度の逆数
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): imgproc_GeneralizedHough_setDp
元DLLエクスポート名: imgproc_GeneralizedHough_setDp
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHough_setDp(cv::GeneralizedHough *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setDp(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHough_getDp
[32/64bit] imgproc_GeneralizedHough_getDp
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): imgproc_GeneralizedHough_getDp
元DLLエクスポート名: imgproc_GeneralizedHough_getDp
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHough_getDp(cv::GeneralizedHough *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getDp();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHough_setMaxBufferSize
[32/64bit] 内部バッファの最大サイズ．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): imgproc_GeneralizedHough_setMaxBufferSize
元DLLエクスポート名: imgproc_GeneralizedHough_setMaxBufferSize
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHough_setMaxBufferSize(cv::GeneralizedHough *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setMaxBufferSize(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHough_getMaxBufferSize
[32/64bit] imgproc_GeneralizedHough_getMaxBufferSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): imgproc_GeneralizedHough_getMaxBufferSize
元DLLエクスポート名: imgproc_GeneralizedHough_getMaxBufferSize
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHough_getMaxBufferSize(cv::GeneralizedHough *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getMaxBufferSize();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_createGeneralizedHoughBallard
[32/64bit] cv::GeneralizedHoughBallard クラスへのスマートポインタを作成し，それを初期化します．
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): imgproc_createGeneralizedHoughBallard
元DLLエクスポート名: imgproc_createGeneralizedHoughBallard
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_createGeneralizedHoughBallard(cv::Ptr&amp;lt;cv::GeneralizedHoughBallard&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::createGeneralizedHoughBallard();
    *returnValue = new cv::Ptr&amp;lt;cv::GeneralizedHoughBallard&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_Ptr_GeneralizedHoughBallard_get
[32/64bit] cv::GeneralizedHoughBallard のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
Generalized Hough Transform を用いて，グレースケール画像中の任意のテンプレートを見つけます．

並進と回転を行わずに，位置のみを検出します [14] ．


元関数名(C#): imgproc_Ptr_GeneralizedHoughBallard_get
元DLLエクスポート名: imgproc_Ptr_GeneralizedHoughBallard_get
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Ptr_GeneralizedHoughBallard_get(
    cv::Ptr&amp;lt;cv::GeneralizedHoughBallard&amp;gt; *obj, cv::GeneralizedHoughBallard **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_Ptr_GeneralizedHoughBallard_delete
[32/64bit] cv::GeneralizedHoughBallard のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
Generalized Hough Transform を用いて，グレースケール画像中の任意のテンプレートを見つけます．

並進と回転を行わずに，位置のみを検出します [14] ．


元関数名(C#): imgproc_Ptr_GeneralizedHoughBallard_delete
元DLLエクスポート名: imgproc_Ptr_GeneralizedHoughBallard_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Ptr_GeneralizedHoughBallard_delete(cv::Ptr&amp;lt;cv::GeneralizedHoughBallard&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughBallard_setLevels
[32/64bit] R-テーブルのレベル。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): imgproc_GeneralizedHoughBallard_setLevels
元DLLエクスポート名: imgproc_GeneralizedHoughBallard_setLevels
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughBallard_setLevels(cv::GeneralizedHoughBallard *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setLevels(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughBallard_getLevels
[32/64bit] imgproc_GeneralizedHoughBallard_getLevels
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): imgproc_GeneralizedHoughBallard_getLevels
元DLLエクスポート名: imgproc_GeneralizedHoughBallard_getLevels
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughBallard_getLevels(cv::GeneralizedHoughBallard *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getLevels();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughBallard_setVotesThreshold
[32/64bit] 検出段階でのテンプレートセンターのアキュムレータの閾値です．これが小さければ小さいほど，誤った位置が検出される可能性があります．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): imgproc_GeneralizedHoughBallard_setVotesThreshold
元DLLエクスポート名: imgproc_GeneralizedHoughBallard_setVotesThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughBallard_setVotesThreshold(cv::GeneralizedHoughBallard *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setVotesThreshold(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughBallard_getVotesThreshold
[32/64bit] imgproc_GeneralizedHoughBallard_getVotesThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): imgproc_GeneralizedHoughBallard_getVotesThreshold
元DLLエクスポート名: imgproc_GeneralizedHoughBallard_getVotesThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughBallard_getVotesThreshold(cv::GeneralizedHoughBallard *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getVotesThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_createGeneralizedHoughGuil
[32/64bit] cv::GeneralizedHoughGuil クラスへのスマートポインタを作成し，それを初期化します．
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): imgproc_createGeneralizedHoughGuil
元DLLエクスポート名: imgproc_createGeneralizedHoughGuil
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_createGeneralizedHoughGuil(cv::Ptr&amp;lt;cv::GeneralizedHoughGuil&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::createGeneralizedHoughGuil();
    *returnValue = new cv::Ptr&amp;lt;cv::GeneralizedHoughGuil&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_Ptr_GeneralizedHoughGuil_get
[32/64bit] cv::GeneralizedHoughGuil のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
Generalized Hough Transform を用いて，グレースケール画像中の任意のテンプレートを見つけます．

位置，並進，回転を検出します [100] ．


元関数名(C#): imgproc_Ptr_GeneralizedHoughGuil_get
元DLLエクスポート名: imgproc_Ptr_GeneralizedHoughGuil_get
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Ptr_GeneralizedHoughGuil_get(
    cv::Ptr&amp;lt;cv::GeneralizedHoughGuil&amp;gt; *obj, cv::GeneralizedHoughGuil **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_Ptr_GeneralizedHoughGuil_delete
[32/64bit] cv::GeneralizedHoughGuil のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
Generalized Hough Transform を用いて，グレースケール画像中の任意のテンプレートを見つけます．

位置，並進，回転を検出します [100] ．


元関数名(C#): imgproc_Ptr_GeneralizedHoughGuil_delete
元DLLエクスポート名: imgproc_Ptr_GeneralizedHoughGuil_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Ptr_GeneralizedHoughGuil_delete(cv::Ptr&amp;lt;cv::GeneralizedHoughGuil&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_setXi
[32/64bit] 特徴量内の2点間の角度差（度）．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_setXi
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_setXi
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_setXi(cv::GeneralizedHoughGuil *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setXi(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_getXi
[32/64bit] imgproc_GeneralizedHoughGuil_getXi
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_getXi
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_getXi
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_getXi(cv::GeneralizedHoughGuil *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getXi();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_setLevels
[32/64bit] 特徴表のレベル．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_setLevels
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_setLevels
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_setLevels(cv::GeneralizedHoughGuil *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setLevels(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_getLevels
[32/64bit] imgproc_GeneralizedHoughGuil_getLevels
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_getLevels
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_getLevels
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_getLevels(cv::GeneralizedHoughGuil *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getLevels();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_setAngleEpsilon
[32/64bit] 等しく扱われる角度の最大の差．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_setAngleEpsilon
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_setAngleEpsilon
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_setAngleEpsilon(cv::GeneralizedHoughGuil *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setAngleEpsilon(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_getAngleEpsilon
[32/64bit] imgproc_GeneralizedHoughGuil_getAngleEpsilon
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_getAngleEpsilon
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_getAngleEpsilon
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_getAngleEpsilon(cv::GeneralizedHoughGuil *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getAngleEpsilon();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_setMinAngle
[32/64bit] 回転を検出する最小角度（度）。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_setMinAngle
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_setMinAngle
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_setMinAngle(cv::GeneralizedHoughGuil *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setMinAngle(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_getMinAngle
[32/64bit] imgproc_GeneralizedHoughGuil_getMinAngle
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_getMinAngle
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_getMinAngle
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_getMinAngle(cv::GeneralizedHoughGuil *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getMinAngle();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_setMaxAngle
[32/64bit] 検出する回転角度の最大値（単位：度
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_setMaxAngle
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_setMaxAngle
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_setMaxAngle(cv::GeneralizedHoughGuil *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setMaxAngle(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_getMaxAngle
[32/64bit] imgproc_GeneralizedHoughGuil_getMaxAngle
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_getMaxAngle
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_getMaxAngle
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_getMaxAngle(cv::GeneralizedHoughGuil *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getMaxAngle();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_setAngleStep
[32/64bit] 角度ステップ(度)
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_setAngleStep
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_setAngleStep
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_setAngleStep(cv::GeneralizedHoughGuil *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setAngleStep(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_getAngleStep
[32/64bit] imgproc_GeneralizedHoughGuil_getAngleStep
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_getAngleStep
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_getAngleStep
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_getAngleStep(cv::GeneralizedHoughGuil *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getAngleStep();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_setAngleThresh
[32/64bit] 角度票の閾値
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_setAngleThresh
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_setAngleThresh
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_setAngleThresh(cv::GeneralizedHoughGuil *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setAngleThresh(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_getAngleThresh
[32/64bit] imgproc_GeneralizedHoughGuil_getAngleThresh
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_getAngleThresh
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_getAngleThresh
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_getAngleThresh(cv::GeneralizedHoughGuil *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getAngleThresh();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_setMinScale
[32/64bit] 検出する最小のスケール
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_setMinScale
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_setMinScale
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_setMinScale(cv::GeneralizedHoughGuil *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setMinScale(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_getMinScale
[32/64bit] imgproc_GeneralizedHoughGuil_getMinScale
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_getMinScale
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_getMinScale
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_getMinScale(cv::GeneralizedHoughGuil *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getMinScale();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_setMaxScale
[32/64bit] 検出する最大のスケール
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_setMaxScale
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_setMaxScale
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_setMaxScale(cv::GeneralizedHoughGuil *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setMaxScale(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_getMaxScale
[32/64bit] imgproc_GeneralizedHoughGuil_getMaxScale
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_getMaxScale
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_getMaxScale
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_getMaxScale(cv::GeneralizedHoughGuil *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getMaxScale();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_setScaleStep
[32/64bit] スケールステップ
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_setScaleStep
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_setScaleStep
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_setScaleStep(cv::GeneralizedHoughGuil *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setScaleStep(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_getScaleStep
[32/64bit] imgproc_GeneralizedHoughGuil_getScaleStep
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_getScaleStep
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_getScaleStep
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_getScaleStep(cv::GeneralizedHoughGuil *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getScaleStep();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_setScaleThresh
[32/64bit] スケール票のしきい値
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_setScaleThresh
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_setScaleThresh
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_setScaleThresh(cv::GeneralizedHoughGuil *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setScaleThresh(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_getScaleThresh
[32/64bit] imgproc_GeneralizedHoughGuil_getScaleThresh
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_getScaleThresh
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_getScaleThresh
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_getScaleThresh(cv::GeneralizedHoughGuil *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getScaleThresh();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_setPosThresh
[32/64bit] 位置のしきい値を指定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_setPosThresh
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_setPosThresh
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_setPosThresh(cv::GeneralizedHoughGuil *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setPosThresh(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_GeneralizedHoughGuil_getPosThresh
[32/64bit] imgproc_GeneralizedHoughGuil_getPosThresh
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): imgproc_GeneralizedHoughGuil_getPosThresh
元DLLエクスポート名: imgproc_GeneralizedHoughGuil_getPosThresh
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_GeneralizedHough.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_GeneralizedHoughGuil_getPosThresh(cv::GeneralizedHoughGuil *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getPosThresh();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_GeneralizedHough

%index
imgproc_LineIterator_new
[32/64bit] cv::LineIterator のインスタンスを生成します
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr img
p2 = ARGS_POINT : Point pt1
p3 = ARGS_POINT : Point pt2
p4 = int : int connectivity
p5 = int : int leftToRight
p6 = var : out IntPtr returnValue
%inst
ラインイテレータ。

このクラスは、指定した 2 点を結ぶラスター線分上のすべてのピクセルを反復処理します。

LineIterator クラスは、 ラスターラインの各ピクセルを取得するために使用します。これは、Bresenham アルゴリズムの汎用的な実装として扱うことができます。各ピクセルで停止して追加の処理を行うことができます。たとえば、線に沿ってピクセル値を取得したり、 XOR 演算などで効果的に線を描画したりすることができます。

線に沿ったピクセルの数が LineIterator::count に格納されます。メソッド LineIterator::pos は、画像内の現在の位置を返します。

// ラインに沿ったピクセルをつかむ (pt1, pt2)// 8 ビット 3 チャンネル画像からバッファへLineIterator it(img, pt1, pt2, 8);LineIterator it2 = it;vector<Vec3b> buf(it.count);for(int i = 0; i < it.count; i++, ++it) buf[i] = *(const Vec3b*)*it;// 別の方法で，ラインを繰り返し処理するfor(int i = 0; i < it2.count; i++, ++it2){ Vec3b val = img.at<Vec3b>(it2.pos()); CV_Assert(buf[i] == val);}．


元関数名(C#): imgproc_LineIterator_new
元DLLエクスポート名: imgproc_LineIterator_new
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_LineIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_LineIterator_new(
    cv::Mat *img, MyCvPoint pt1, MyCvPoint pt2, int connectivity, int leftToRight, cv::LineIterator** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::LineIterator(*img, cpp(pt1), cpp(pt2), connectivity, leftToRight != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_LineIterator

%index
imgproc_LineIterator_delete
[32/64bit] cv::LineIterator のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
ラインイテレータ。

このクラスは、指定した 2 点を結ぶラスター線分上のすべてのピクセルを反復処理します。

LineIterator クラスは、 ラスターラインの各ピクセルを取得するために使用します。これは、Bresenham アルゴリズムの汎用的な実装として扱うことができます。各ピクセルで停止して追加の処理を行うことができます。たとえば、線に沿ってピクセル値を取得したり、 XOR 演算などで効果的に線を描画したりすることができます。

線に沿ったピクセルの数が LineIterator::count に格納されます。メソッド LineIterator::pos は、画像内の現在の位置を返します。

// ラインに沿ったピクセルをつかむ (pt1, pt2)// 8 ビット 3 チャンネル画像からバッファへLineIterator it(img, pt1, pt2, 8);LineIterator it2 = it;vector<Vec3b> buf(it.count);for(int i = 0; i < it.count; i++, ++it) buf[i] = *(const Vec3b*)*it;// 別の方法で，ラインを繰り返し処理するfor(int i = 0; i < it2.count; i++, ++it2){ Vec3b val = img.at<Vec3b>(it2.pos()); CV_Assert(buf[i] == val);}．


元関数名(C#): imgproc_LineIterator_delete
元DLLエクスポート名: imgproc_LineIterator_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_LineIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_LineIterator_delete(cv::LineIterator *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_LineIterator

%index
imgproc_LineIterator_getValuePosAndShiftToNext
[32/64bit] imgproc_LineIterator_getValuePosAndShiftToNext
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
p3 = var : out Point returnPos
%inst
元関数名(C#): imgproc_LineIterator_getValuePosAndShiftToNext
元DLLエクスポート名: imgproc_LineIterator_getValuePosAndShiftToNext
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_LineIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_LineIterator_getValuePosAndShiftToNext(cv::LineIterator* obj, uchar** returnValue, MyCvPoint *returnPos)
{
    BEGIN_WRAP
    *returnValue = **obj;
    *returnPos = c(obj-&amp;gt;pos());
    (*obj)++;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_LineIterator

%index
imgproc_LineIterator_ptr_get
[32/64bit] cv::LineIterator のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
ラインイテレータ。

このクラスは、指定した 2 点を結ぶラスター線分上のすべてのピクセルを反復処理します。

LineIterator クラスは、 ラスターラインの各ピクセルを取得するために使用します。これは、Bresenham アルゴリズムの汎用的な実装として扱うことができます。各ピクセルで停止して追加の処理を行うことができます。たとえば、線に沿ってピクセル値を取得したり、 XOR 演算などで効果的に線を描画したりすることができます。

線に沿ったピクセルの数が LineIterator::count に格納されます。メソッド LineIterator::pos は、画像内の現在の位置を返します。

// ラインに沿ったピクセルをつかむ (pt1, pt2)// 8 ビット 3 チャンネル画像からバッファへLineIterator it(img, pt1, pt2, 8);LineIterator it2 = it;vector<Vec3b> buf(it.count);for(int i = 0; i < it.count; i++, ++it) buf[i] = *(const Vec3b*)*it;// 別の方法で，ラインを繰り返し処理するfor(int i = 0; i < it2.count; i++, ++it2){ Vec3b val = img.at<Vec3b>(it2.pos()); CV_Assert(buf[i] == val);}．


元関数名(C#): imgproc_LineIterator_ptr_get
元DLLエクスポート名: imgproc_LineIterator_ptr_get
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_LineIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_LineIterator_ptr_get(cv::LineIterator *obj, uchar **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_LineIterator

%index
imgproc_LineIterator_ptr0_get
[32/64bit] cv::LineIterator::ptr0 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): imgproc_LineIterator_ptr0_get
元DLLエクスポート名: imgproc_LineIterator_ptr0_get
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_LineIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_LineIterator_ptr0_get(cv::LineIterator *obj, const uchar** returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;ptr0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_LineIterator

%index
imgproc_LineIterator_step_get
[32/64bit] cv::LineIterator::step 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): imgproc_LineIterator_step_get
元DLLエクスポート名: imgproc_LineIterator_step_get
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_LineIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_LineIterator_step_get(cv::LineIterator *obj, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;step;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_LineIterator

%index
imgproc_LineIterator_elemSize_get
[32/64bit] cv::LineIterator::elemSize 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): imgproc_LineIterator_elemSize_get
元DLLエクスポート名: imgproc_LineIterator_elemSize_get
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_LineIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_LineIterator_elemSize_get(cv::LineIterator *obj, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;elemSize;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_LineIterator

%index
imgproc_LineIterator_err_get
[32/64bit] cv::LineIterator::err 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): imgproc_LineIterator_err_get
元DLLエクスポート名: imgproc_LineIterator_err_get
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_LineIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_LineIterator_err_get(cv::LineIterator *obj, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;err;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_LineIterator

%index
imgproc_LineIterator_count_get
[32/64bit] cv::LineIterator::count 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): imgproc_LineIterator_count_get
元DLLエクスポート名: imgproc_LineIterator_count_get
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_LineIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_LineIterator_count_get(cv::LineIterator *obj, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;count;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_LineIterator

%index
imgproc_LineIterator_minusDelta_get
[32/64bit] cv::LineIterator::minusDelta 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): imgproc_LineIterator_minusDelta_get
元DLLエクスポート名: imgproc_LineIterator_minusDelta_get
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_LineIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_LineIterator_minusDelta_get(cv::LineIterator *obj, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;minusDelta;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_LineIterator

%index
imgproc_LineIterator_plusDelta_get
[32/64bit] cv::LineIterator::plusDelta 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): imgproc_LineIterator_plusDelta_get
元DLLエクスポート名: imgproc_LineIterator_plusDelta_get
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_LineIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_LineIterator_plusDelta_get(cv::LineIterator *obj, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;plusDelta;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_LineIterator

%index
imgproc_LineIterator_minusStep_get
[32/64bit] cv::LineIterator::minusStep 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): imgproc_LineIterator_minusStep_get
元DLLエクスポート名: imgproc_LineIterator_minusStep_get
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_LineIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_LineIterator_minusStep_get(cv::LineIterator *obj, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;minusStep;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_LineIterator

%index
imgproc_LineIterator_plusStep_get
[32/64bit] cv::LineIterator::plusStep 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst



元関数名(C#): imgproc_LineIterator_plusStep_get
元DLLエクスポート名: imgproc_LineIterator_plusStep_get
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_LineIterator.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_LineIterator_plusStep_get(cv::LineIterator *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;plusStep;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_LineIterator

%index
imgproc_seg_ISMB_new
[32/64bit][関数名変更] cv::segmentation::IntelligentScissorsMB のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst
Intelligent Scissorsによる画像分割．

このクラスは，画像のセグメンテーションに利用できる2点間のパス（輪郭）を求めるために利用されます．

使用例： segmentation::IntelligentScissorsMB tool; tool.setEdgeFeatureCannyParameters(16, 100) // エッジ特徴抽出器としてCanny()を使用 .setGradientMagnitudeMaxLimit(200); // 画像特徴を計算 tool.applyImage(image); // 指定されたソースポイントのマップを計算 Point source_point(200, 100); tool.buildMap(source_point); // 指定されたターゲットポイントと事前に計算されたマップ（内部に保存されている）の輪郭を // 高速に取得する Point target_point(400, 300); std::vector<Point> pts; tool.getContour(target_point, pts); 参考にしてください。Eric N. MortensenとWilliam A. Barrettが設計したアルゴリズム「Intelligent Scissors for Image Composition」（Brigham Young University）[178]。


元関数名(C#): imgproc_segmentation_IntelligentScissorsMB_new
元DLLエクスポート名: imgproc_segmentation_IntelligentScissorsMB_new
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_segmentation_IntelligentScissorsMB_new(
    cv::segmentation::IntelligentScissorsMB** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::segmentation::IntelligentScissorsMB();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Segmentation

%index
imgproc_seg_ISMB_delete
[32/64bit][関数名変更] cv::segmentation::IntelligentScissorsMB のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
Intelligent Scissorsによる画像分割．

このクラスは，画像のセグメンテーションに利用できる2点間のパス（輪郭）を求めるために利用されます．

使用例： segmentation::IntelligentScissorsMB tool; tool.setEdgeFeatureCannyParameters(16, 100) // エッジ特徴抽出器としてCanny()を使用 .setGradientMagnitudeMaxLimit(200); // 画像特徴を計算 tool.applyImage(image); // 指定されたソースポイントのマップを計算 Point source_point(200, 100); tool.buildMap(source_point); // 指定されたターゲットポイントと事前に計算されたマップ（内部に保存されている）の輪郭を // 高速に取得する Point target_point(400, 300); std::vector<Point> pts; tool.getContour(target_point, pts); 参考にしてください。Eric N. MortensenとWilliam A. Barrettが設計したアルゴリズム「Intelligent Scissors for Image Composition」（Brigham Young University）[178]。


元関数名(C#): imgproc_segmentation_IntelligentScissorsMB_delete
元DLLエクスポート名: imgproc_segmentation_IntelligentScissorsMB_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_segmentation_IntelligentScissorsMB_delete(
    cv::segmentation::IntelligentScissorsMB *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Segmentation

%index
imgproc_seg_ISMB_setWeights
[32/64bit][関数名変更] 特徴関数の重みを指定する。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = float : float weight_non_edge
p3 = float : float weight_gradient_direction
p4 = float : float weight_gradient_magnitude
%inst
重みを正規化しておくことを考慮する（重みの合計が1.0になるように） 離散的な動的計画法（DP）の目標は、ピクセル間のコストを最小化することです。

元関数名(C#): imgproc_segmentation_IntelligentScissorsMB_setWeights
元DLLエクスポート名: imgproc_segmentation_IntelligentScissorsMB_setWeights
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_segmentation_IntelligentScissorsMB_setWeights(
    cv::segmentation::IntelligentScissorsMB *obj,
    float weight_non_edge, float weight_gradient_direction, float weight_gradient_magnitude)
{
    BEGIN_WRAP
    obj-&amp;gt;setWeights(weight_non_edge, weight_gradient_direction, weight_gradient_magnitude);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Segmentation

%index
imgproc_seg_ISMB_setGradientMagnitudeMaxLimit
[32/64bit][関数名変更] グラディエントマグニチュードの最大値の閾値を指定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float gradient_magnitude_threshold_max
%inst
0の制限値は、グラデーションの大きさのしきい値を無効にするために使用されます（元の記事に記載されているように、デフォルトの動作）。NoteThresholdingは、不規則な領域を持つ画像に使用する必要があります（埋め込まれたロゴのような、高契約領域からのパラメータに固執するのを避けるため）。

元関数名(C#): imgproc_segmentation_IntelligentScissorsMB_setGradientMagnitudeMaxLimit
元DLLエクスポート名: imgproc_segmentation_IntelligentScissorsMB_setGradientMagnitudeMaxLimit
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_segmentation_IntelligentScissorsMB_setGradientMagnitudeMaxLimit(
    cv::segmentation::IntelligentScissorsMB *obj,
    float gradient_magnitude_threshold_max)
{
    BEGIN_WRAP
    obj-&amp;gt;setGradientMagnitudeMaxLimit(gradient_magnitude_threshold_max);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Segmentation

%index
imgproc_seg_ISMB_setEdgeFeatureZeroCrossingParameters
[32/64bit][関数名変更] Laplacian Zero-Crossing "エッジ特徴抽出器に切り替え、そのパラメータを指定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float gradient_magnitude_min_value
%inst
この特徴抽出器は、記事によるとデフォルトで使用されています。実装では、低振幅のノイズがある領域に対する追加のフィルタリングがあります。このフィルタリングは、最小グラデーション振幅のパラメータで有効になります（いくつかの小さな値4、8、16を使用します）。注意この特徴抽出器の現在の実装は、グレースケール画像の処理に基づいています（カラー画像はまずグレースケール画像に変換されます）。



Cannyエッジ検出器は，少し遅いですが，より良い結果が得られます（特にカラー画像の場合）： setEdgeFeatureCannyParameters()を利用してください．

元関数名(C#): imgproc_segmentation_IntelligentScissorsMB_setEdgeFeatureZeroCrossingParameters
元DLLエクスポート名: imgproc_segmentation_IntelligentScissorsMB_setEdgeFeatureZeroCrossingParameters
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_segmentation_IntelligentScissorsMB_setEdgeFeatureZeroCrossingParameters(
    cv::segmentation::IntelligentScissorsMB *obj,
    float gradient_magnitude_min_value)
{
    BEGIN_WRAP
    obj-&amp;gt;setEdgeFeatureZeroCrossingParameters(gradient_magnitude_min_value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Segmentation

%index
imgproc_seg_ISMB_setEdgeFeatureCannyParameters
[32/64bit][関数名変更] エッジ特徴抽出器を，Cannyエッジ検出器を使うように切り替えます．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = double : double threshold1
p3 = double : double threshold2
p4 = int : int apertureSize
p5 = int : int L2gradient
%inst
注意：デフォルトでは、"Laplacian Zero-Crossing "特徴抽出器が使用されます（元の記事を参照してください）。

元関数名(C#): imgproc_segmentation_IntelligentScissorsMB_setEdgeFeatureCannyParameters
元DLLエクスポート名: imgproc_segmentation_IntelligentScissorsMB_setEdgeFeatureCannyParameters
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_segmentation_IntelligentScissorsMB_setEdgeFeatureCannyParameters(
    cv::segmentation::IntelligentScissorsMB *obj,
    double threshold1, double threshold2,
    int apertureSize, int L2gradient)
{
    BEGIN_WRAP
    obj-&amp;gt;setEdgeFeatureCannyParameters(threshold1, threshold2, apertureSize, L2gradient != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Segmentation

%index
imgproc_seg_ISMB_applyImage
[32/64bit][関数名変更] 入力画像を指定して、画像特徴を抽出します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
%inst
元関数名(C#): imgproc_segmentation_IntelligentScissorsMB_applyImage
元DLLエクスポート名: imgproc_segmentation_IntelligentScissorsMB_applyImage
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_segmentation_IntelligentScissorsMB_applyImage(
    cv::segmentation::IntelligentScissorsMB *obj,
    cv::_InputArray *image)
{
    BEGIN_WRAP
    obj-&amp;gt;applyImage(*image);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Segmentation

%index
imgproc_seg_ISMB_applyImageFeatures
[32/64bit][関数名変更] 入力画像のカスタム特徴を指定します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr non_edge
p3 = sptr : IntPtr gradient_direction
p4 = sptr : IntPtr gradient_magnitude
p5 = sptr : IntPtr image
%inst
applyImage() の呼び出しを，より高度なものにカスタマイズしたもの．

元関数名(C#): imgproc_segmentation_IntelligentScissorsMB_applyImageFeatures
元DLLエクスポート名: imgproc_segmentation_IntelligentScissorsMB_applyImageFeatures
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_segmentation_IntelligentScissorsMB_applyImageFeatures(
    cv::segmentation::IntelligentScissorsMB *obj,
    cv::_InputArray *non_edge,
    cv::_InputArray *gradient_direction,
    cv::_InputArray *gradient_magnitude,
    cv::_InputArray *image)
{
    BEGIN_WRAP
    obj-&amp;gt;applyImageFeatures(*non_edge, *gradient_direction, *gradient_magnitude, entity(image));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Segmentation

%index
imgproc_seg_ISMB_buildMap
[32/64bit][関数名変更] image上の与えられたソースポイントに対する最適経路のマップを作成します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = ARGS_POINT : Point sourcePt
%inst
注意：applyImage() / applyImageFeatures()は、このコールの前にコールする必要があります。

元関数名(C#): imgproc_segmentation_IntelligentScissorsMB_buildMap
元DLLエクスポート名: imgproc_segmentation_IntelligentScissorsMB_buildMap
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_segmentation_IntelligentScissorsMB_buildMap(
    cv::segmentation::IntelligentScissorsMB *obj,
    MyCvPoint sourcePt)
{
    BEGIN_WRAP
    obj-&amp;gt;buildMap(cpp(sourcePt));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Segmentation

%index
imgproc_seg_ISMB_getContour
[32/64bit][関数名変更] 画像上の指定されたターゲット点に対する最適な輪郭を抽出します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = ARGS_POINT : Point targetPt
p3 = sptr : IntPtr contour
p4 = int : int backward
%inst
この呼び出しの前にNotebuildMap()を呼び出す必要があります。

元関数名(C#): imgproc_segmentation_IntelligentScissorsMB_getContour
元DLLエクスポート名: imgproc_segmentation_IntelligentScissorsMB_getContour
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_segmentation_IntelligentScissorsMB_getContour(
    cv::segmentation::IntelligentScissorsMB *obj,
    MyCvPoint targetPt, cv::_OutputArray *contour, int backward)
{
    BEGIN_WRAP
    obj-&amp;gt;getContour(cpp(targetPt), *contour, backward != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Segmentation

%index
imgproc_Subdiv2D_new1
[32/64bit] cv::Subdiv2D のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst



元関数名(C#): imgproc_Subdiv2D_new1
元DLLエクスポート名: imgproc_Subdiv2D_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_new1(cv::Subdiv2D **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Subdiv2D;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_new2
[32bit] cv::Subdiv2D のインスタンスを生成します
%prm
p1,p2
p1 = ARGS_RECT : Rect rect
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): imgproc_Subdiv2D_new2
元DLLエクスポート名: imgproc_Subdiv2D_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_new2(MyCvRect rect, cv::Subdiv2D **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Subdiv2D(cpp(rect));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_new2
[64bit] cv::Subdiv2D のインスタンスを生成します
%prm
p1,p2
p1 = var : Rect rect
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): imgproc_Subdiv2D_new2
元DLLエクスポート名: imgproc_Subdiv2D_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_new2(MyCvRect rect, cv::Subdiv2D **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Subdiv2D(cpp(rect));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_delete
[32/64bit] cv::Subdiv2D のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): imgproc_Subdiv2D_delete
元DLLエクスポート名: imgproc_Subdiv2D_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_delete(cv::Subdiv2D *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_initDelaunay
[32bit] 新しい空のドロネー細分割を作成する．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = ARGS_RECT : Rect rect
%inst
元関数名(C#): imgproc_Subdiv2D_initDelaunay
元DLLエクスポート名: imgproc_Subdiv2D_initDelaunay
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_initDelaunay(cv::Subdiv2D *obj, CvRect rect)
{
    BEGIN_WRAP
    obj-&amp;gt;initDelaunay(rect);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_initDelaunay
[64bit] 新しい空のドロネー細分割を作成する．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : Rect rect
%inst
元関数名(C#): imgproc_Subdiv2D_initDelaunay
元DLLエクスポート名: imgproc_Subdiv2D_initDelaunay
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_initDelaunay(cv::Subdiv2D *obj, CvRect rect)
{
    BEGIN_WRAP
    obj-&amp;gt;initDelaunay(rect);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_insert1
[32/64bit] Delaunay Triangulationに1つの点を挿入します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = ARGS_POINT2F : Point2f pt
p3 = var : out int returnValue
%inst
この関数は，細分割に1つの点を挿入し，細分割のトポロジーを適切に変更します．同じ座標の点が既に存在する場合は、新しい点は追加されません。注意点点点が指定された三角測量の範囲外にある場合は、ランタイムエラーが発生します。

元関数名(C#): imgproc_Subdiv2D_insert1
元DLLエクスポート名: imgproc_Subdiv2D_insert1
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_insert1(cv::Subdiv2D *obj, MyCvPoint2D32f pt, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;insert(cpp(pt));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_insert2
[32/64bit] Delaunay Triangulationに1つの点を挿入します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = var : [MarshalAs(UnmanagedType.LPArray)] Point2f[] ptArray
p3 = int : int length
%inst
この関数は，細分割に1つの点を挿入し，細分割のトポロジーを適切に変更します．同じ座標の点が既に存在する場合は、新しい点は追加されません。注意点点点が指定された三角測量の範囲外にある場合は、ランタイムエラーが発生します。

元関数名(C#): imgproc_Subdiv2D_insert2
元DLLエクスポート名: imgproc_Subdiv2D_insert2
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_insert2(cv::Subdiv2D *obj, MyCvPoint2D32f *ptArray, int length)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Point2f&amp;gt; ptVec(length);
    for (int i = 0; i &amp;lt; length; i++)
    {
        ptVec[i] = cpp(ptArray[i]);
    }
    obj-&amp;gt;insert(ptVec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_locate
[32/64bit] ドロネー三角錐内の点の位置を返します。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = ARGS_POINT2F : Point2f pt
p3 = var : out int edge
p4 = var : out int vertex
p5 = var : out int returnValue
%inst
この関数は，入力点を細分化された領域内に配置し，三角形の辺または頂点のいずれかを与えます．

元関数名(C#): imgproc_Subdiv2D_locate
元DLLエクスポート名: imgproc_Subdiv2D_locate
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_locate(
    cv::Subdiv2D *obj, MyCvPoint2D32f pt, int *edge, int *vertex, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;locate(cpp(pt), *edge, *vertex);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_findNearest
[32/64bit] 与えられた点に最も近い細分化された頂点を見つけます．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = ARGS_POINT2F : Point2f pt
p3 = var : out Point2f nearestPt
p4 = var : out int returnValue
%inst
この関数は，入力点を細分割内に配置する別の関数です．入力点に最も近い細分化された頂点を見つけます．入力点を含むファセットの頂点とは限りませんが，そのファセット（locate()を用いて配置されたもの）が出発点として利用されます．

元関数名(C#): imgproc_Subdiv2D_findNearest
元DLLエクスポート名: imgproc_Subdiv2D_findNearest
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_findNearest(
    cv::Subdiv2D *obj, MyCvPoint2D32f pt, MyCvPoint2D32f* nearestPt, int *returnValue)
{
    BEGIN_WRAP
    cv::Point2f nearestPt0;
    *returnValue = obj-&amp;gt;findNearest(cpp(pt), &amp;nearestPt0);
    *nearestPt = c(nearestPt0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_getEdgeList
[32/64bit] すべてのエッジのリストを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr edgeList
%inst
org_x = v[0], org_y = v[1], dst_x = v[2], dst_y = v[3]のように、各エッジを4つの数字のベクトルで出力する。

元関数名(C#): imgproc_Subdiv2D_getEdgeList
元DLLエクスポート名: imgproc_Subdiv2D_getEdgeList
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_getEdgeList(cv::Subdiv2D *obj, std::vector&amp;lt;cv::Vec4f&amp;gt; *edgeList)
{
    BEGIN_WRAP
    obj-&amp;gt;getEdgeList(*edgeList);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_getLeadingEdgeList
[32/64bit] 各三角形に接続されたリーディングエッジIDのリストを返す。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr leadingEdgeList
%inst
この関数は，各三角形に対して1つのエッジIDを与えます．

元関数名(C#): imgproc_Subdiv2D_getLeadingEdgeList
元DLLエクスポート名: imgproc_Subdiv2D_getLeadingEdgeList
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_getLeadingEdgeList(cv::Subdiv2D *obj,  std::vector&amp;lt;int&amp;gt; *leadingEdgeList)
{
    BEGIN_WRAP
    obj-&amp;gt;getLeadingEdgeList(*leadingEdgeList);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_getTriangleList
[32/64bit] 全てのトライアングルのリストを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr triangleList
%inst
この関数は、各三角形を6つの数字のベクトルとして出力します。ここで、各2つは三角形の頂点の1つを表します。

元関数名(C#): imgproc_Subdiv2D_getTriangleList
元DLLエクスポート名: imgproc_Subdiv2D_getTriangleList
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_getTriangleList(cv::Subdiv2D *obj, std::vector&amp;lt;cv::Vec6f&amp;gt; *triangleList)
{
    BEGIN_WRAP
    obj-&amp;gt;getTriangleList(*triangleList);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_getVoronoiFacetList
[32/64bit] すべてのボロノイファセットのリストを返します。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = var : [MarshalAs(UnmanagedType.LPArray), In] int[]? idx
p3 = int : int idxCount
p4 = sptr : IntPtr facetList
p5 = sptr : IntPtr facetCenters
%inst
元関数名(C#): imgproc_Subdiv2D_getVoronoiFacetList
元DLLエクスポート名: imgproc_Subdiv2D_getVoronoiFacetList
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_getVoronoiFacetList(
    cv::Subdiv2D *obj, int *idx, int idxCount,
    std::vector&amp;lt;std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt; *facetList, std::vector&amp;lt;cv::Point2f&amp;gt; *facetCenters)
{
    BEGIN_WRAP
    std::vector&amp;lt;int&amp;gt; idxVec;
    if (idx != nullptr)
        idxVec = std::vector&amp;lt;int&amp;gt;(idx, idx + idxCount);
    obj-&amp;gt;getVoronoiFacetList(idxVec, *facetList, *facetCenters);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_getVertex
[32/64bit] vertex IDから頂点の位置を返します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = int : int vertex
p3 = var : out int firstEdge
p4 = var : out Point2f returnValue
%inst
元関数名(C#): imgproc_Subdiv2D_getVertex
元DLLエクスポート名: imgproc_Subdiv2D_getVertex
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_getVertex(cv::Subdiv2D *obj, int vertex, int* firstEdge, MyCvPoint2D32f *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(obj-&amp;gt;getVertex(vertex, firstEdge));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_getEdge
[32/64bit] すべてのエッジのリストを返します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = int : int edge
p3 = int : int nextEdgeType
p4 = var : out int returnValue
%inst
org_x = v[0], org_y = v[1], dst_x = v[2], dst_y = v[3]のように、各エッジを4つの数字のベクトルで出力する。

元関数名(C#): imgproc_Subdiv2D_getEdge
元DLLエクスポート名: imgproc_Subdiv2D_getEdge
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_getEdgeList(cv::Subdiv2D *obj, std::vector&amp;lt;cv::Vec4f&amp;gt; *edgeList)
{
    BEGIN_WRAP
    obj-&amp;gt;getEdgeList(*edgeList);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_nextEdge
[32/64bit] edge originを中心とした次の辺を返します。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = int : int edge
p3 = var : out int returnValue
%inst
元関数名(C#): imgproc_Subdiv2D_nextEdge
元DLLエクスポート名: imgproc_Subdiv2D_nextEdge
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_nextEdge(cv::Subdiv2D *obj, int edge, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;nextEdge(edge);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_rotateEdge
[32/64bit] 同じquad-edgeの別の辺を返します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = int : int edge
p3 = int : int rotate
p4 = var : out int returnValue
%inst
元関数名(C#): imgproc_Subdiv2D_rotateEdge
元DLLエクスポート名: imgproc_Subdiv2D_rotateEdge
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_rotateEdge(cv::Subdiv2D *obj, int edge, int rotate, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;rotateEdge(edge, rotate);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_symEdge
[32/64bit] imgproc_Subdiv2D_symEdge
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = int : int edge
p3 = var : out int returnValue
%inst
元関数名(C#): imgproc_Subdiv2D_symEdge
元DLLエクスポート名: imgproc_Subdiv2D_symEdge
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_symEdge(cv::Subdiv2D *obj, int edge, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;symEdge(edge);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_edgeOrg
[32/64bit] 辺の原点を返します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = int : int edge
p3 = var : out Point2f orgPt
p4 = var : out int returnValue
%inst
元関数名(C#): imgproc_Subdiv2D_edgeOrg
元DLLエクスポート名: imgproc_Subdiv2D_edgeOrg
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_edgeOrg(cv::Subdiv2D *obj, int edge, MyCvPoint2D32f *orgPt, int *returnValue)
{
    BEGIN_WRAP
    cv::Point2f orgPt0;
    *returnValue = obj-&amp;gt;edgeOrg(edge, &amp;orgPt0);
    *orgPt = c(orgPt0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
imgproc_Subdiv2D_edgeDst
[32/64bit] 辺のデスティネーションを返します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = int : int edge
p3 = var : out Point2f dstPt
p4 = var : out int returnValue
%inst
元関数名(C#): imgproc_Subdiv2D_edgeDst
元DLLエクスポート名: imgproc_Subdiv2D_edgeDst
参照元CSファイル: Internal\PInvoke\NativeMethods\imgproc\NativeMethods_imgproc_Subdiv2D.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) imgproc_Subdiv2D_edgeDst(cv::Subdiv2D *obj, int edge, MyCvPoint2D32f *dstPt, int *returnValue)
{
    BEGIN_WRAP
    cv::Point2f dstPt0;
    *returnValue = obj-&amp;gt;edgeDst(edge, &amp;dstPt0);
    *dstPt = c(dstPt0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_imgproc_Subdiv2D

%index
ml_ANN_MLP_setTrainMethod
[32/64bit] 学習方法と共通のパラメータを設定します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = int : int method
p3 = double : double param1
p4 = double : double param2
%inst
元関数名(C#): ml_ANN_MLP_setTrainMethod
元DLLエクスポート名: ml_ANN_MLP_setTrainMethod
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_setTrainMethod(cv::ml::ANN_MLP *obj, int method, double param1, double param2)
{
    BEGIN_WRAP
    obj-&amp;gt;setTrainMethod(method, param1, param2);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_getTrainMethod
[32/64bit] 現在の学習方法を返す
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ml_ANN_MLP_getTrainMethod
元DLLエクスポート名: ml_ANN_MLP_getTrainMethod
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_getTrainMethod(cv::ml::ANN_MLP *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getTrainMethod();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_setActivationFunction
[32/64bit] 各ニューロンの活性化関数を初期化します。現在、デフォルトであり、唯一完全にサポートされている活性化関数はANN_MLP::SIGMOID_SYMです。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = int : int type
p3 = double : double param1
p4 = double : double param2
%inst
元関数名(C#): ml_ANN_MLP_setActivationFunction
元DLLエクスポート名: ml_ANN_MLP_setActivationFunction
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_setActivationFunction(cv::ml::ANN_MLP *obj, int type, double param1, double param2)
{
    BEGIN_WRAP
    obj-&amp;gt;setActivationFunction(type, param1, param2);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_setLayerSizes
[32/64bit] 入力層、出力層を含む各層のニューロンの数を表す整数ベクトルです。一番最初の要素は、入力層の要素数を表します。最後の要素は，出力層の要素数です．デフォルト値は，空の Mat です．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr layerSizes
%inst
関連項目： getLayerSizes

元関数名(C#): ml_ANN_MLP_setLayerSizes
元DLLエクスポート名: ml_ANN_MLP_setLayerSizes
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_setLayerSizes(cv::ml::ANN_MLP *obj, cv::_InputArray *_layer_sizes)
{
    BEGIN_WRAP
    obj-&amp;gt;setLayerSizes(entity(_layer_sizes));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_getLayerSizes
[32/64bit] ml_ANN_MLP_getLayerSizes
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_ANN_MLP_getLayerSizes
元DLLエクスポート名: ml_ANN_MLP_getLayerSizes
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_getLayerSizes(cv::ml::ANN_MLP *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(obj-&amp;gt;getLayerSizes());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_getTermCriteria
[32/64bit] 学習アルゴリズムの終了基準．反復回数の最大値（maxCount）や，アルゴリズムを継続させるための反復間の誤差の変化量（epsilon）を指定できます．デフォルト値はTermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 1000, 0.01)です。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out TermCriteria returnValue
%inst
alsosetTermCriteriaを参照

元関数名(C#): ml_ANN_MLP_getTermCriteria
元DLLエクスポート名: ml_ANN_MLP_getTermCriteria
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_getTermCriteria(cv::ml::ANN_MLP *obj, MyCvTermCriteria *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(obj-&amp;gt;getTermCriteria());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_setTermCriteria
[32bit] 関連項目： 用語集の設定
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = ARGS_TERMCRITERIA : TermCriteria val
%inst
元関数名(C#): ml_ANN_MLP_setTermCriteria
元DLLエクスポート名: ml_ANN_MLP_setTermCriteria
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_setTermCriteria(cv::ml::ANN_MLP *obj, MyCvTermCriteria val)
{
    BEGIN_WRAP
    obj-&amp;gt;setTermCriteria(cpp(val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_setTermCriteria
[64bit] 関連項目： 用語集の設定
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : TermCriteria val
%inst
元関数名(C#): ml_ANN_MLP_setTermCriteria
元DLLエクスポート名: ml_ANN_MLP_setTermCriteria
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_setTermCriteria(cv::ml::ANN_MLP *obj, MyCvTermCriteria val)
{
    BEGIN_WRAP
    obj-&amp;gt;setTermCriteria(cpp(val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_getBackpropWeightScale
[32/64bit] BPROP: 重み付けの項の強さ。推奨値は0.1程度。デフォルト値は0.1です。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
alsosetBackpropWeightScaleを参照。

元関数名(C#): ml_ANN_MLP_getBackpropWeightScale
元DLLエクスポート名: ml_ANN_MLP_getBackpropWeightScale
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_getBackpropWeightScale(cv::ml::ANN_MLP *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getBackpropWeightScale();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_setBackpropWeightScale
[32/64bit] 参照：「バックプロップウェイトスケールの設定
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): ml_ANN_MLP_setBackpropWeightScale
元DLLエクスポート名: ml_ANN_MLP_setBackpropWeightScale
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_setBackpropWeightScale(cv::ml::ANN_MLP *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setBackpropWeightScale(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_getBackpropMomentumScale
[32/64bit] BPROP：モメンタム項の強さ（前の2回の反復での重みの差）。このパラメータは、重みのランダムな変動をスムーズにするための慣性を与えます。0（この機能は無効）から1、そしてそれ以上まで変化します。0.1程度の値であれば十分です。デフォルト値は0.1です。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
関連項目： alsosetBackpropMomentumScale

元関数名(C#): ml_ANN_MLP_getBackpropMomentumScale
元DLLエクスポート名: ml_ANN_MLP_getBackpropMomentumScale
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_getBackpropMomentumScale(cv::ml::ANN_MLP *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getBackpropMomentumScale();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_setBackpropMomentumScale
[32/64bit] alsogetBackpropMomentumScaleを参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): ml_ANN_MLP_setBackpropMomentumScale
元DLLエクスポート名: ml_ANN_MLP_setBackpropMomentumScale
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_setBackpropMomentumScale(cv::ml::ANN_MLP *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setBackpropMomentumScale(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_getRpropDW0
[32/64bit] RPROP：更新値の初期値\(Delta_{ij}\)です。初期値は0.1である。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
alsosetRpropDW0参照。

元関数名(C#): ml_ANN_MLP_getRpropDW0
元DLLエクスポート名: ml_ANN_MLP_getRpropDW0
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_getRpropDW0(cv::ml::ANN_MLP *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getRpropDW0();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_setRpropDW0
[32/64bit] alsogetRpropDW0を参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): ml_ANN_MLP_setRpropDW0
元DLLエクスポート名: ml_ANN_MLP_setRpropDW0
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_setRpropDW0(cv::ml::ANN_MLP *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setRpropDW0(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_getRpropDWPlus
[32/64bit] RPROP: Increase factor ????? )1以上でなければなりません。初期値は1.2です。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
alsosetRpropDWPlusを参照。

元関数名(C#): ml_ANN_MLP_getRpropDWPlus
元DLLエクスポート名: ml_ANN_MLP_getRpropDWPlus
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_getRpropDWPlus(cv::ml::ANN_MLP *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getRpropDWPlus();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_setRpropDWPlus
[32/64bit] See alsogetRpropDWPlus
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): ml_ANN_MLP_setRpropDWPlus
元DLLエクスポート名: ml_ANN_MLP_setRpropDWPlus
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_setRpropDWPlus(cv::ml::ANN_MLP *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setRpropDWPlus(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_getRpropDWMinus
[32/64bit] RPROPDecrease factor ????? )<1でなければならない。初期値は0.5です。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
alsosetRpropDWMinus参照。

元関数名(C#): ml_ANN_MLP_getRpropDWMinus
元DLLエクスポート名: ml_ANN_MLP_getRpropDWMinus
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_getRpropDWMinus(cv::ml::ANN_MLP *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getRpropDWMinus();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_setRpropDWMinus
[32/64bit] See alsogetRpropDWMinus
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): ml_ANN_MLP_setRpropDWMinus
元DLLエクスポート名: ml_ANN_MLP_setRpropDWMinus
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_setRpropDWMinus(cv::ml::ANN_MLP *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setRpropDWMinus(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_getRpropDWMin
[32/64bit] RPROPDecrease factor ????? )<1でなければならない。初期値は0.5です。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
alsosetRpropDWMinus参照。

元関数名(C#): ml_ANN_MLP_getRpropDWMin
元DLLエクスポート名: ml_ANN_MLP_getRpropDWMin
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_getRpropDWMinus(cv::ml::ANN_MLP *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getRpropDWMinus();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_setRpropDWMin
[32/64bit] See alsogetRpropDWMinus
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): ml_ANN_MLP_setRpropDWMin
元DLLエクスポート名: ml_ANN_MLP_setRpropDWMin
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_setRpropDWMinus(cv::ml::ANN_MLP *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setRpropDWMinus(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_getRpropDWMax
[32/64bit] RPROP：Update-values upper limit ???????。1以上でなければなりません。初期値は50です。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
alsosetRpropDWMax参照。

元関数名(C#): ml_ANN_MLP_getRpropDWMax
元DLLエクスポート名: ml_ANN_MLP_getRpropDWMax
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_getRpropDWMax(cv::ml::ANN_MLP *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getRpropDWMax();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_setRpropDWMax
[32/64bit] See alsogetRpropDWMax
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): ml_ANN_MLP_setRpropDWMax
元DLLエクスポート名: ml_ANN_MLP_setRpropDWMax
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_setRpropDWMax(cv::ml::ANN_MLP *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setRpropDWMax(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_getWeights
[32/64bit] ml_ANN_MLP_getWeights
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = int : int layerIdx
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_ANN_MLP_getWeights
元DLLエクスポート名: ml_ANN_MLP_getWeights
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_getWeights(cv::ml::ANN_MLP *obj, int layerIdx, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(obj-&amp;gt;getWeights(layerIdx));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_create
[32/64bit] 空のモデルを作成します。
%prm
p1
p1 = var : out IntPtr returnValue
%inst
モデルをトレーニングするには StatModel::train を、事前にトレーニングされたモデルをロードするには Algorithm::load<ANN_MLP>(filename) を使用してください。trainメソッドにはオプションのフラグがあることに注意してください。ANN_MLP::TrainFlagsです。

元関数名(C#): ml_ANN_MLP_create
元DLLエクスポート名: ml_ANN_MLP_create
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_create(cv::Ptr&amp;lt;cv::ml::ANN_MLP&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::ml::ANN_MLP::create();
    *returnValue = new cv::Ptr&amp;lt;cv::ml::ANN_MLP&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_Ptr_ANN_MLP_delete
[32/64bit] cv::ml::ANN_MLP のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
人工ニューラルネットワーク - 多層パーセプトロン（Multi-Layer Perceptrons）。

MLの他の多くのモデルが構築と学習を一度に行うのに対し，MLPモデルではこれらのステップが分離されています．まず，デフォルトではないコンストラクタやANN_MLP::createメソッドを使って，指定されたトポロジーのネットワークを作成します．重みはすべてゼロに設定されています。次に，入力ベクトルと出力ベクトルを用いてネットワークを学習します．この学習手順は複数回繰り返すことができ、つまり、新しい学習データに基づいて重みを調整することができます。

StatModel::train には追加のフラグが用意されています。ANN_MLP::TrainFlagsを参照してください。

ニューラルネットワーク もご覧ください。


元関数名(C#): ml_Ptr_ANN_MLP_delete
元DLLエクスポート名: ml_Ptr_ANN_MLP_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Ptr_ANN_MLP_delete(cv::Ptr&amp;lt;cv::ml::ANN_MLP&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_Ptr_ANN_MLP_get
[32/64bit] cv::ml::ANN_MLP のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
人工ニューラルネットワーク - 多層パーセプトロン（Multi-Layer Perceptrons）。

MLの他の多くのモデルが構築と学習を一度に行うのに対し，MLPモデルではこれらのステップが分離されています．まず，デフォルトではないコンストラクタやANN_MLP::createメソッドを使って，指定されたトポロジーのネットワークを作成します．重みはすべてゼロに設定されています。次に，入力ベクトルと出力ベクトルを用いてネットワークを学習します．この学習手順は複数回繰り返すことができ、つまり、新しい学習データに基づいて重みを調整することができます。

StatModel::train には追加のフラグが用意されています。ANN_MLP::TrainFlagsを参照してください。

ニューラルネットワーク もご覧ください。


元関数名(C#): ml_Ptr_ANN_MLP_get
元DLLエクスポート名: ml_Ptr_ANN_MLP_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Ptr_ANN_MLP_get(cv::Ptr&amp;lt;cv::ml::ANN_MLP&amp;gt; *obj, cv::ml::ANN_MLP **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_load
[32/64bit] ファイルからシリアル化された ANN を読み込み、作成します。
%prm
p1,p2
p1 = str : string filePath
p2 = var : out IntPtr returnValue
%inst
ANNをシリアル化してディスクに保存するにはANN::saveを使います。ファイルへのパスを指定してこの関数を呼び出すことで、このファイルから再びANNをロードする。

元関数名(C#): ml_ANN_MLP_load
元DLLエクスポート名: ml_ANN_MLP_load
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_load(const char *filePath, cv::Ptr&amp;lt;cv::ml::ANN_MLP&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::ml::ANN_MLP::load(filePath);
    *returnValue = new cv::Ptr&amp;lt;cv::ml::ANN_MLP&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_ANN_MLP_loadFromString
[32/64bit] ml_ANN_MLP_loadFromString
%prm
p1,p2
p1 = str : string strModel
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_ANN_MLP_loadFromString
元DLLエクスポート名: ml_ANN_MLP_loadFromString
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_ANN_MLP.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_ANN_MLP_loadFromString(const char *strModel, cv::Ptr&amp;lt;cv::ml::ANN_MLP&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto objName = cv::ml::ANN_MLP::create()-&amp;gt;getDefaultName();
    const auto ptr = cv::Algorithm::loadFromString&amp;lt;cv::ml::ANN_MLP&amp;gt;(strModel, objName);
    *returnValue = new cv::Ptr&amp;lt;cv::ml::ANN_MLP&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_ANN_MLP

%index
ml_Boost_getBoostType
[32/64bit] boostingアルゴリズムのタイプ。Boost::Typesを参照してください。デフォルト値は Boost::REAL です。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
alsosetBoostType を参照してください。

元関数名(C#): ml_Boost_getBoostType
元DLLエクスポート名: ml_Boost_getBoostType
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_Boost.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Boost_getBoostType(cv::ml::Boost *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getBoostType();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_Boost

%index
ml_Boost_setBoostType
[32/64bit] 関連項目： Boost::BoostType。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_Boost_setBoostType
元DLLエクスポート名: ml_Boost_setBoostType
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_Boost.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Boost_setBoostType(cv::ml::Boost *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setBoostType(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_Boost

%index
ml_Boost_getWeakCount
[32/64bit] 弱い分類器の数。デフォルト値は100です。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
alsosetWeakCountを参照してください。

元関数名(C#): ml_Boost_getWeakCount
元DLLエクスポート名: ml_Boost_getWeakCount
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_Boost.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Boost_getWeakCount(cv::ml::Boost *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getWeakCount();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_Boost

%index
ml_Boost_setWeakCount
[32/64bit] alsogetWeakCountを参照してください。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_Boost_setWeakCount
元DLLエクスポート名: ml_Boost_setWeakCount
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_Boost.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Boost_setWeakCount(cv::ml::Boost *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setWeakCount(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_Boost

%index
ml_Boost_getWeightTrimRate
[32/64bit] 計算時間を短縮するために使われる0と1の間のしきい値です。summary weight\(1 - weight_trim_rate\)を持つサンプルは、次の反復トレーニングに参加しない。この機能をオフにするには、このパラメータを0に設定します。デフォルト値は0.95です。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
関連項目： alsosetWeightTrimRate

元関数名(C#): ml_Boost_getWeightTrimRate
元DLLエクスポート名: ml_Boost_getWeightTrimRate
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_Boost.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Boost_getWeightTrimRate(cv::ml::Boost *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getWeightTrimRate();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_Boost

%index
ml_Boost_setWeightTrimRate
[32/64bit] alsogetWeightTrimRateを参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): ml_Boost_setWeightTrimRate
元DLLエクスポート名: ml_Boost_setWeightTrimRate
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_Boost.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Boost_setWeightTrimRate(cv::ml::Boost *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setWeightTrimRate(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_Boost

%index
ml_Boost_create
[32/64bit] 空のモデルを作成します。モデルの学習には StatModel::train を、学習済みのモデルの読み込みには Algorithm::load<Boost>(filename) を使用してください。
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_Boost_create
元DLLエクスポート名: ml_Boost_create
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_Boost.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Boost_create(cv::Ptr&amp;lt;cv::ml::Boost&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::ml::Boost::create();
    *returnValue = new cv::Ptr&amp;lt;cv::ml::Boost&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_Boost

%index
ml_Ptr_Boost_delete
[32/64bit] cv::ml::Boost のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
DTrees から派生したブーステッドツリー分類器です。

ブースティングの項も参照してください。


元関数名(C#): ml_Ptr_Boost_delete
元DLLエクスポート名: ml_Ptr_Boost_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_Boost.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Ptr_Boost_delete(cv::Ptr&amp;lt;cv::ml::Boost&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_Boost

%index
ml_Ptr_Boost_get
[32/64bit] cv::ml::Boost のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
DTrees から派生したブーステッドツリー分類器です。

ブースティングの項も参照してください。


元関数名(C#): ml_Ptr_Boost_get
元DLLエクスポート名: ml_Ptr_Boost_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_Boost.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Ptr_Boost_get(cv::Ptr&amp;lt;cv::ml::Boost&amp;gt;* obj, cv::ml::Boost **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_Boost

%index
ml_Boost_load
[32/64bit] ml_Boost_load
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string filePath
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_Boost_load
元DLLエクスポート名: ml_Boost_load
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_Boost.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Boost_load(const char *filePath, cv::Ptr&amp;lt;cv::ml::Boost&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::Algorithm::load&amp;lt;cv::ml::Boost&amp;gt;(filePath);
    *returnValue = new cv::Ptr&amp;lt;cv::ml::Boost&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_Boost

%index
ml_Boost_loadFromString
[32/64bit] ml_Boost_loadFromString
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string strModel
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_Boost_loadFromString
元DLLエクスポート名: ml_Boost_loadFromString
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_Boost.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Boost_loadFromString(const char *strModel, cv::Ptr&amp;lt;cv::ml::Boost&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto objName = cv::ml::Boost::create()-&amp;gt;getDefaultName();
    const auto ptr = cv::Algorithm::loadFromString&amp;lt;cv::ml::Boost&amp;gt;(strModel, objName);
    *returnValue = new cv::Ptr&amp;lt;cv::ml::Boost&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_Boost

%index
ml_DTrees_getMaxCategories
[32/64bit] ml_DTrees_getMaxCategories
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ml_DTrees_getMaxCategories
元DLLエクスポート名: ml_DTrees_getMaxCategories
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_getMaxCategories(cv::ml::DTrees *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getMaxCategories();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_setMaxCategories
[32/64bit] ml_DTrees_setMaxCategories
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_DTrees_setMaxCategories
元DLLエクスポート名: ml_DTrees_setMaxCategories
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_setMaxCategories(cv::ml::DTrees *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setMaxCategories(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_getMaxDepth
[32/64bit] ml_DTrees_getMaxDepth
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ml_DTrees_getMaxDepth
元DLLエクスポート名: ml_DTrees_getMaxDepth
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_getMaxDepth(cv::ml::DTrees *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getMaxDepth();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_setMaxDepth
[32/64bit] ml_DTrees_setMaxDepth
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_DTrees_setMaxDepth
元DLLエクスポート名: ml_DTrees_setMaxDepth
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_setMaxDepth(cv::ml::DTrees *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setMaxDepth(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_getMinSampleCount
[32/64bit] ml_DTrees_getMinSampleCount
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ml_DTrees_getMinSampleCount
元DLLエクスポート名: ml_DTrees_getMinSampleCount
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_getMinSampleCount(cv::ml::DTrees *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getMinSampleCount();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_setMinSampleCount
[32/64bit] ml_DTrees_setMinSampleCount
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_DTrees_setMinSampleCount
元DLLエクスポート名: ml_DTrees_setMinSampleCount
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_setMinSampleCount(cv::ml::DTrees *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setMinSampleCount(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_getCVFolds
[32/64bit] ml_DTrees_getCVFolds
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ml_DTrees_getCVFolds
元DLLエクスポート名: ml_DTrees_getCVFolds
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_getCVFolds(cv::ml::DTrees *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getCVFolds();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_setCVFolds
[32/64bit] ml_DTrees_setCVFolds
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_DTrees_setCVFolds
元DLLエクスポート名: ml_DTrees_setCVFolds
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_setCVFolds(cv::ml::DTrees *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setCVFolds(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_getUseSurrogates
[32/64bit] ml_DTrees_getUseSurrogates
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ml_DTrees_getUseSurrogates
元DLLエクスポート名: ml_DTrees_getUseSurrogates
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_getUseSurrogates(cv::ml::DTrees *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getUseSurrogates() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_setUseSurrogates
[32/64bit] ml_DTrees_setUseSurrogates
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_DTrees_setUseSurrogates
元DLLエクスポート名: ml_DTrees_setUseSurrogates
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_setUseSurrogates(cv::ml::DTrees *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setUseSurrogates(val != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_getUse1SERule
[32/64bit] ml_DTrees_getUse1SERule
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ml_DTrees_getUse1SERule
元DLLエクスポート名: ml_DTrees_getUse1SERule
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_getUse1SERule(cv::ml::DTrees *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getUse1SERule() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_setUse1SERule
[32/64bit] ml_DTrees_setUse1SERule
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_DTrees_setUse1SERule
元DLLエクスポート名: ml_DTrees_setUse1SERule
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_setUse1SERule(cv::ml::DTrees *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setUse1SERule(val != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_getTruncatePrunedTree
[32/64bit] ml_DTrees_getTruncatePrunedTree
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ml_DTrees_getTruncatePrunedTree
元DLLエクスポート名: ml_DTrees_getTruncatePrunedTree
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_getTruncatePrunedTree(cv::ml::DTrees *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getTruncatePrunedTree() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_setTruncatePrunedTree
[32/64bit] ml_DTrees_setTruncatePrunedTree
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_DTrees_setTruncatePrunedTree
元DLLエクスポート名: ml_DTrees_setTruncatePrunedTree
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_setTruncatePrunedTree(cv::ml::DTrees *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setTruncatePrunedTree(val != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_getRegressionAccuracy
[32/64bit] ml_DTrees_getRegressionAccuracy
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): ml_DTrees_getRegressionAccuracy
元DLLエクスポート名: ml_DTrees_getRegressionAccuracy
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_getRegressionAccuracy(cv::ml::DTrees *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getRegressionAccuracy();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_setRegressionAccuracy
[32/64bit] ml_DTrees_setRegressionAccuracy
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float val
%inst
元関数名(C#): ml_DTrees_setRegressionAccuracy
元DLLエクスポート名: ml_DTrees_setRegressionAccuracy
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_setRegressionAccuracy(cv::ml::DTrees *obj, float val)
{
    BEGIN_WRAP
    obj-&amp;gt;setRegressionAccuracy(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_getPriors
[32/64bit] ml_DTrees_getPriors
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_DTrees_getPriors
元DLLエクスポート名: ml_DTrees_getPriors
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_getPriors(cv::ml::DTrees *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto m = obj-&amp;gt;getPriors();
    *returnValue = new cv::Mat(m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_setPriors
[32/64bit] ml_DTrees_setPriors
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr val
%inst
元関数名(C#): ml_DTrees_setPriors
元DLLエクスポート名: ml_DTrees_setPriors
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_setPriors(cv::ml::DTrees *obj, cv::Mat *val)
{
    BEGIN_WRAP
    obj-&amp;gt;setPriors(*val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_getRoots
[32/64bit] ml_DTrees_getRoots
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr result
%inst
元関数名(C#): ml_DTrees_getRoots
元DLLエクスポート名: ml_DTrees_getRoots
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_getRoots(cv::ml::DTrees *obj, std::vector&amp;lt;int&amp;gt; *result)
{ 
    BEGIN_WRAP
    const auto&amp; org = obj-&amp;gt;getRoots();

    result-&amp;gt;clear();
    for (auto i : org)
    {
        result-&amp;gt;push_back(i);
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_getNodes
[32/64bit] ml_DTrees_getNodes
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr result
%inst
元関数名(C#): ml_DTrees_getNodes
元DLLエクスポート名: ml_DTrees_getNodes
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_getNodes(cv::ml::DTrees *obj, std::vector&amp;lt;DTrees_Node&amp;gt; *result)
{
    BEGIN_WRAP
    const auto&amp; org = obj-&amp;gt;getNodes();

    result-&amp;gt;clear();
    for (const auto&amp; i : org)
    {
        result-&amp;gt;push_back(c(i));
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_getSplits
[32/64bit] ml_DTrees_getSplits
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr result
%inst
元関数名(C#): ml_DTrees_getSplits
元DLLエクスポート名: ml_DTrees_getSplits
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_getSplits(cv::ml::DTrees *obj, std::vector&amp;lt;DTrees_Split&amp;gt; *result)
{
    BEGIN_WRAP
    const auto&amp; org = obj-&amp;gt;getSplits();

    result-&amp;gt;clear();
    for (const auto&amp; i : org)
    {
        result-&amp;gt;push_back(c(i));
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_getSubsets
[32/64bit] ml_DTrees_getSubsets
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr result
%inst
元関数名(C#): ml_DTrees_getSubsets
元DLLエクスポート名: ml_DTrees_getSubsets
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_getSubsets(cv::ml::DTrees *obj, std::vector&amp;lt;int&amp;gt; *result)
{
    BEGIN_WRAP
    const auto&amp; org = obj-&amp;gt;getSubsets();

    result-&amp;gt;clear();
    for (auto i : org)
    {
        result-&amp;gt;push_back(i);
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_create
[32/64bit] ml_DTrees_create
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_DTrees_create
元DLLエクスポート名: ml_DTrees_create
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_create(cv::Ptr&amp;lt;cv::ml::DTrees&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto  ptr = cv::ml::DTrees::create();
    *returnValue = new cv::Ptr&amp;lt;cv::ml::DTrees&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_Ptr_DTrees_delete
[32/64bit] cv::ml::Dtrees のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): ml_Ptr_DTrees_delete
元DLLエクスポート名: ml_Ptr_DTrees_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Ptr_DTrees_delete(cv::Ptr&amp;lt;cv::ml::DTrees&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_Ptr_DTrees_get
[32/64bit] cv::ml::Dtrees のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): ml_Ptr_DTrees_get
元DLLエクスポート名: ml_Ptr_DTrees_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Ptr_DTrees_get(cv::Ptr&amp;lt;cv::ml::DTrees&amp;gt; *obj, cv::ml::DTrees **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_load
[32/64bit] ml_DTrees_load
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string filePath
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_DTrees_load
元DLLエクスポート名: ml_DTrees_load
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_load(const char *filePath, cv::Ptr&amp;lt;cv::ml::DTrees&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::Algorithm::load&amp;lt;cv::ml::DTrees&amp;gt;(filePath);
    *returnValue = new cv::Ptr&amp;lt;cv::ml::DTrees&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_DTrees_loadFromString
[32/64bit] ml_DTrees_loadFromString
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string strModel
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_DTrees_loadFromString
元DLLエクスポート名: ml_DTrees_loadFromString
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_DTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_DTrees_loadFromString(const char *strModel, cv::Ptr&amp;lt;cv::ml::DTrees&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto objName = cv::ml::DTrees::create()-&amp;gt;getDefaultName();
    const auto  ptr = cv::Algorithm::loadFromString&amp;lt;cv::ml::DTrees&amp;gt;(strModel, objName);
    *returnValue = new cv::Ptr&amp;lt;cv::ml::DTrees&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_DTrees

%index
ml_EM_getClustersNumber
[32/64bit] ガウス混合モデルにおける混合成分の数を指定します。このパラメータのデフォルト値はEM::DEFAULT_NCLUSTERS=5です。EMの実装の中には，指定された値の範囲内で最適な混合成分の数を決定できるものもありますが，MLではまだそのようにはなっていません．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
関連項目： alsosetClustersNumber

元関数名(C#): ml_EM_getClustersNumber
元DLLエクスポート名: ml_EM_getClustersNumber
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_EM_getClustersNumber(cv::ml::EM *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getClustersNumber();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_EM_setClustersNumber
[32/64bit] alsogetClustersNumberを参照してください。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_EM_setClustersNumber
元DLLエクスポート名: ml_EM_setClustersNumber
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_EM_setClustersNumber(cv::ml::EM *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setClustersNumber(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_EM_getCovarianceMatrixType
[32/64bit] 共分散行列に対する制約で、行列の種類を定義します。EM::Typesを参照してください。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
alsosetCovarianceMatrixTypeを参照してください。

元関数名(C#): ml_EM_getCovarianceMatrixType
元DLLエクスポート名: ml_EM_getCovarianceMatrixType
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_EM_getCovarianceMatrixType(cv::ml::EM *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getCovarianceMatrixType();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_EM_setCovarianceMatrixType
[32/64bit] 共分散マトリクスタイプを参照してください。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_EM_setCovarianceMatrixType
元DLLエクスポート名: ml_EM_setCovarianceMatrixType
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_EM_setCovarianceMatrixType(cv::ml::EM *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setCovarianceMatrixType(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_EM_getTermCriteria
[32/64bit] EMアルゴリズムの終了基準。EMアルゴリズムは、反復回数 termCrit.maxCount（Mステップの数）、または尤度対数の相対的な変化が termCrit.epsilonより小さいときに終了させることができます。デフォルトの最大反復数はEM::DEFAULT_MAX_ITERS=100です。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out TermCriteria returnValue
%inst
alsosetTermCriteriaを参照

元関数名(C#): ml_EM_getTermCriteria
元DLLエクスポート名: ml_EM_getTermCriteria
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_EM_getTermCriteria(cv::ml::EM *obj, MyCvTermCriteria *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(obj-&amp;gt;getTermCriteria());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_EM_setTermCriteria
[32bit] 関連項目： 用語集の設定
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = ARGS_TERMCRITERIA : TermCriteria val
%inst
元関数名(C#): ml_EM_setTermCriteria
元DLLエクスポート名: ml_EM_setTermCriteria
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_EM_setTermCriteria(cv::ml::EM *obj, MyCvTermCriteria val)
{
    BEGIN_WRAP
    obj-&amp;gt;setTermCriteria(cpp(val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_EM_setTermCriteria
[64bit] 関連項目： 用語集の設定
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : TermCriteria val
%inst
元関数名(C#): ml_EM_setTermCriteria
元DLLエクスポート名: ml_EM_setTermCriteria
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_EM_setTermCriteria(cv::ml::EM *obj, MyCvTermCriteria val)
{
    BEGIN_WRAP
    obj-&amp;gt;setTermCriteria(cpp(val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_EM_getWeights
[32/64bit] 混合物の重みを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
混合物の数と同じ数の要素を持つベクトルを返します。

元関数名(C#): ml_EM_getWeights
元DLLエクスポート名: ml_EM_getWeights
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_EM_getWeights(cv::ml::EM *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto m = obj-&amp;gt;getWeights();
    *returnValue = new cv::Mat(m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_EM_getMeans
[32/64bit] クラスタ中心（ガウス混合の平均値）を返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
行数が混合の数に，列数が空間の次元に等しい行列を返します。

元関数名(C#): ml_EM_getMeans
元DLLエクスポート名: ml_EM_getMeans
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_EM_getMeans(cv::ml::EM *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto m = obj-&amp;gt;getMeans();
    *returnValue = new cv::Mat(m);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_EM_getCovs
[32/64bit] 共分散行列を返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr covs
%inst
共分散行列のベクトルを返します。行列の数はガウス混合の数で、各行列は浮動小数点の正方行列NxN（Nは空間の次元）です。

元関数名(C#): ml_EM_getCovs
元DLLエクスポート名: ml_EM_getCovs
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_EM_getCovs(cv::ml::EM *obj, std::vector&amp;lt;cv::Mat*&amp;gt; *covs)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; raw;
    obj-&amp;gt;getCovs(raw);
    covs-&amp;gt;resize(raw.size());
    for (size_t i = 0; i &amp;lt; raw.size(); i++)
    {
        covs-&amp;gt;at(i) = new cv::Mat(raw[i]);
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_EM_predict2
[32/64bit] 与えられたサンプルに対して，尤度対数の値と，最も確率の高い混合成分のインデックスを返します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr model
p2 = sptr : IntPtr sample
p3 = sptr : IntPtr probs
p4 = var : out Vec2d returnValue
%inst
このメソッドは，2要素のダブルベクトルを返します．0番目の要素は，サンプルに対する尤度対数の値です．1番目の要素は，与えられたサンプルに対して最も確率の高い混合成分のインデックスです．

元関数名(C#): ml_EM_predict2
元DLLエクスポート名: ml_EM_predict2
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_EM_predict2(
    cv::ml::EM *obj, cv::_InputArray *sample, cv::_OutputArray *probs, CvVec2d *returnValue)
{
    BEGIN_WRAP
    auto vec = obj-&amp;gt;predict2(*sample, *probs);
    CvVec2d ret;
    ret.val[0] = vec[0];
    ret.val[1] = vec[1];
    *returnValue = ret;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_EM_trainEM
[32/64bit] サンプルセットからガウス混合パラメータを推定します。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr samples
p3 = sptr : IntPtr logLikelihoods
p4 = sptr : IntPtr labels
p5 = sptr : IntPtr probs
p6 = var : out int returnValue
%inst
このバリエーションは，Expectationステップから始まります．多くのMLモデルとは異なり，EMは教師なし学習アルゴリズムであり，入力として応答（クラスラベルや関数値）を受け取りません．多くのMLモデルとは異なり，EMは教師なし学習アルゴリズムであり，入力としてレスポンス（クラスラベルや関数値）を受け取りません．代わりに，入力サンプルセットからガウス混合パラメータの最尤推定値を計算し，すべてのパラメータを構造体の内部に格納します．\そして、オプションとして、各サンプルの「クラスラベル」を計算して出力します。\クラスラベルを計算します。(訓練されたモデルは，他の分類器と同様に，予測のためにさらに使用することができます．学習されたモデルは，NormalBayesClassifierと同様です．

元関数名(C#): ml_EM_trainEM
元DLLエクスポート名: ml_EM_trainEM
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_EM_trainEM(
    cv::ml::EM *obj,
    cv::_InputArray *samples,
    cv::_OutputArray *logLikelihoods,
    cv::_OutputArray *labels,
    cv::_OutputArray *probs, 
    int *returnValue)
{
    BEGIN_WRAP
    const auto ret = obj-&amp;gt;trainEM(*samples, entity(logLikelihoods), entity(labels), entity(probs));
    *returnValue = ret ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_EM_trainE
[32/64bit] サンプルセットからガウス混合パラメータを推定します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr model
p2 = sptr : IntPtr samples
p3 = sptr : IntPtr means0
p4 = sptr : IntPtr covs0
p5 = sptr : IntPtr weights0
p6 = sptr : IntPtr logLikelihoods
p7 = sptr : IntPtr labels
p8 = sptr : IntPtr probs
p9 = var : out int returnValue
%inst
このバリエーションは，Expectationステップから始まります．多くのMLモデルとは異なり，EMは教師なし学習アルゴリズムであり，入力として応答（クラスラベルや関数値）を受け取りません．多くのMLモデルとは異なり，EMは教師なし学習アルゴリズムであり，入力としてレスポンス（クラスラベルや関数値）を受け取りません．代わりに，入力サンプルセットからガウス混合パラメータの最尤推定値を計算し，すべてのパラメータを構造体の内部に格納します．\そして、オプションとして、各サンプルの「クラスラベル」を計算して出力します。\クラスラベルを計算します。(訓練されたモデルは，他の分類器と同様に，予測のためにさらに使用することができます．学習されたモデルは，NormalBayesClassifierと同様です．

元関数名(C#): ml_EM_trainE
元DLLエクスポート名: ml_EM_trainE
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_EM_trainEM(
    cv::ml::EM *obj,
    cv::_InputArray *samples,
    cv::_OutputArray *logLikelihoods,
    cv::_OutputArray *labels,
    cv::_OutputArray *probs, 
    int *returnValue)
{
    BEGIN_WRAP
    const auto ret = obj-&amp;gt;trainEM(*samples, entity(logLikelihoods), entity(labels), entity(probs));
    *returnValue = ret ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_EM_trainM
[32/64bit] サンプルセットからガウス混合パラメータを推定します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr model
p2 = sptr : IntPtr samples
p3 = sptr : IntPtr probs0
p4 = sptr : IntPtr logLikelihoods
p5 = sptr : IntPtr labels
p6 = sptr : IntPtr probs
p7 = var : out int returnValue
%inst
このバリエーションは，最大化ステップから始まります．このオプションを利用するには，初期確率\(p_{i,k}\)を用意する必要があります．

元関数名(C#): ml_EM_trainM
元DLLエクスポート名: ml_EM_trainM
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_EM_trainM(
    cv::ml::EM *obj,
    cv::_InputArray *samples,
    cv::_InputArray *probs0,
    cv::_OutputArray *logLikelihoods,
    cv::_OutputArray *labels,
    cv::_OutputArray *probs, 
    int *returnValue)
{
    BEGIN_WRAP
    const auto ret = obj-&amp;gt;trainM(
        *samples, *probs0, entity(logLikelihoods), entity(labels), entity(probs));
    *returnValue = ret ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_EM_create
[32/64bit] 空のEMモデルを作成します．StatModel::train(traindata, flags)メソッドを用いてモデルを学習する必要があります。または、EM::train*メソッドを使用するか、Algorithm::load<EM>(filename)を用いてファイルからロードすることもできます。
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_EM_create
元DLLエクスポート名: ml_EM_create
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_EM_create(cv::Ptr&amp;lt;cv::ml::EM&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto obj = cv::ml::EM::create();
    *returnValue = new cv::Ptr&amp;lt;cv::ml::EM&amp;gt;(obj);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_Ptr_EM_get
[32/64bit] cv::ml::EM のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
このクラスは、期待値最大化アルゴリズムを実装しています。

関連項目： 期待値最大化法（Expectation Maximization


元関数名(C#): ml_Ptr_EM_get
元DLLエクスポート名: ml_Ptr_EM_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Ptr_EM_get(cv::Ptr&amp;lt;cv::ml::EM&amp;gt; *obj, cv::ml::EM **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_Ptr_EM_delete
[32/64bit] cv::ml::EM のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
このクラスは、期待値最大化アルゴリズムを実装しています。

関連項目： 期待値最大化法（Expectation Maximization


元関数名(C#): ml_Ptr_EM_delete
元DLLエクスポート名: ml_Ptr_EM_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Ptr_EM_delete(cv::Ptr&amp;lt;cv::ml::EM&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_EM_load
[32/64bit] ml_EM_load
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string filePath
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_EM_load
元DLLエクスポート名: ml_EM_load
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_EM_load(const char *filePath, cv::Ptr&amp;lt;cv::ml::EM&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::Algorithm::load&amp;lt;cv::ml::EM&amp;gt;(filePath);
    *returnValue = new cv::Ptr&amp;lt;cv::ml::EM&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_EM_loadFromString
[32/64bit] ml_EM_loadFromString
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string strModel
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_EM_loadFromString
元DLLエクスポート名: ml_EM_loadFromString
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_EM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_EM_loadFromString(const char *strModel, cv::Ptr&amp;lt;cv::ml::EM&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto objName = cv::ml::EM::create()-&amp;gt;getDefaultName();
    const auto ptr = cv::Algorithm::loadFromString&amp;lt;cv::ml::EM&amp;gt;(strModel, objName);
    *returnValue = new cv::Ptr&amp;lt;cv::ml::EM&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_EM

%index
ml_KNearest_getDefaultK
[32/64bit] ml_KNearest_getDefaultK
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ml_KNearest_getDefaultK
元DLLエクスポート名: ml_KNearest_getDefaultK
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_KNearest.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_KNearest_getDefaultK(cv::ml::KNearest *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getDefaultK();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_KNearest

%index
ml_KNearest_setDefaultK
[32/64bit] ml_KNearest_setDefaultK
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_KNearest_setDefaultK
元DLLエクスポート名: ml_KNearest_setDefaultK
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_KNearest.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_KNearest_setDefaultK(cv::ml::KNearest *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setDefaultK(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_KNearest

%index
ml_KNearest_getIsClassifier
[32/64bit] ml_KNearest_getIsClassifier
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ml_KNearest_getIsClassifier
元DLLエクスポート名: ml_KNearest_getIsClassifier
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_KNearest.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_KNearest_getIsClassifier(cv::ml::KNearest *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getIsClassifier() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_KNearest

%index
ml_KNearest_setIsClassifier
[32/64bit] ml_KNearest_setIsClassifier
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_KNearest_setIsClassifier
元DLLエクスポート名: ml_KNearest_setIsClassifier
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_KNearest.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_KNearest_setIsClassifier(cv::ml::KNearest *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setIsClassifier(val != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_KNearest

%index
ml_KNearest_getEmax
[32/64bit] ml_KNearest_getEmax
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ml_KNearest_getEmax
元DLLエクスポート名: ml_KNearest_getEmax
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_KNearest.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_KNearest_getEmax(cv::ml::KNearest *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getEmax();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_KNearest

%index
ml_KNearest_setEmax
[32/64bit] ml_KNearest_setEmax
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_KNearest_setEmax
元DLLエクスポート名: ml_KNearest_setEmax
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_KNearest.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_KNearest_setEmax(cv::ml::KNearest *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setEmax(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_KNearest

%index
ml_KNearest_getAlgorithmType
[32/64bit] ml_KNearest_getAlgorithmType
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ml_KNearest_getAlgorithmType
元DLLエクスポート名: ml_KNearest_getAlgorithmType
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_KNearest.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_KNearest_getAlgorithmType(cv::ml::KNearest *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getAlgorithmType();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_KNearest

%index
ml_KNearest_setAlgorithmType
[32/64bit] ml_KNearest_setAlgorithmType
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_KNearest_setAlgorithmType
元DLLエクスポート名: ml_KNearest_setAlgorithmType
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_KNearest.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_KNearest_setAlgorithmType(cv::ml::KNearest *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setAlgorithmType(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_KNearest

%index
ml_KNearest_findNearest
[32/64bit] ml_KNearest_findNearest
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr samples
p3 = int : int k
p4 = sptr : IntPtr results
p5 = sptr : IntPtr neighborResponses
p6 = sptr : IntPtr dist
p7 = var : out float returnValue
%inst
元関数名(C#): ml_KNearest_findNearest
元DLLエクスポート名: ml_KNearest_findNearest
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_KNearest.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_KNearest_findNearest(cv::ml::KNearest *obj, cv::_InputArray *samples, int k,
    cv::_OutputArray *results, cv::_OutputArray *neighborResponses, cv::_OutputArray *dist, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;findNearest(
        entity(samples), k, entity(results), entity(neighborResponses), entity(dist));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_KNearest

%index
ml_KNearest_create
[32/64bit] ml_KNearest_create
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_KNearest_create
元DLLエクスポート名: ml_KNearest_create
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_KNearest.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_KNearest_create(cv::Ptr&amp;lt;cv::ml::KNearest&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto  ptr = cv::ml::KNearest::create();
    *returnValue = new cv::Ptr&amp;lt;cv::ml::KNearest&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_KNearest

%index
ml_Ptr_KNearest_delete
[32/64bit] cv::ml::Knearest のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): ml_Ptr_KNearest_delete
元DLLエクスポート名: ml_Ptr_KNearest_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_KNearest.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Ptr_KNearest_delete(cv::Ptr&amp;lt;cv::ml::KNearest&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_KNearest

%index
ml_Ptr_KNearest_get
[32/64bit] cv::ml::Knearest のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): ml_Ptr_KNearest_get
元DLLエクスポート名: ml_Ptr_KNearest_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_KNearest.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Ptr_KNearest_get(cv::Ptr&amp;lt;cv::ml::KNearest&amp;gt;* obj, cv::ml::KNearest **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_KNearest

%index
ml_KNearest_load
[32/64bit] ml_KNearest_load
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string filePath
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_KNearest_load
元DLLエクスポート名: ml_KNearest_load
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_KNearest.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_KNearest_load(const char *filePath, cv::Ptr&amp;lt;cv::ml::KNearest&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto  ptr = cv::Algorithm::load&amp;lt;cv::ml::KNearest&amp;gt;(filePath);
    *returnValue = new cv::Ptr&amp;lt;cv::ml::KNearest&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_KNearest

%index
ml_KNearest_loadFromString
[32/64bit] ml_KNearest_loadFromString
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string strModel
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_KNearest_loadFromString
元DLLエクスポート名: ml_KNearest_loadFromString
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_KNearest.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_KNearest_loadFromString(const char *strModel, cv::Ptr&amp;lt;cv::ml::KNearest&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto objName = cv::ml::KNearest::create()-&amp;gt;getDefaultName();
    const auto  ptr = cv::Algorithm::loadFromString&amp;lt;cv::ml::KNearest&amp;gt;(strModel, objName);
    *returnValue = new cv::Ptr&amp;lt;cv::ml::KNearest&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_KNearest

%index
ml_LogisticRegression_getLearningRate
[32/64bit] 学習率。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
See alsosetLearningRate

元関数名(C#): ml_LogisticRegression_getLearningRate
元DLLエクスポート名: ml_LogisticRegression_getLearningRate
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_LogisticRegression_getLearningRate(cv::ml::LogisticRegression *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getLearningRate();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_LogisticRegression_setLearningRate
[32/64bit] alsogetLearningRate を参照してください。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): ml_LogisticRegression_setLearningRate
元DLLエクスポート名: ml_LogisticRegression_setLearningRate
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_LogisticRegression_setLearningRate(cv::ml::LogisticRegression *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setLearningRate(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_LogisticRegression_getIterations
[32/64bit] イテレーションの数。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
alsosetIterationsを参照。

元関数名(C#): ml_LogisticRegression_getIterations
元DLLエクスポート名: ml_LogisticRegression_getIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_LogisticRegression_getIterations(cv::ml::LogisticRegression *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getIterations();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_LogisticRegression_setIterations
[32/64bit] alsogetIterationsを参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_LogisticRegression_setIterations
元DLLエクスポート名: ml_LogisticRegression_setIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_LogisticRegression_setIterations(cv::ml::LogisticRegression *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setIterations(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_LogisticRegression_getRegularization
[32/64bit] 適用される正則化の種類。LogisticRegression::RegKindsを参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
alsosetRegularizationを参照。

元関数名(C#): ml_LogisticRegression_getRegularization
元DLLエクスポート名: ml_LogisticRegression_getRegularization
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_LogisticRegression_getRegularization(cv::ml::LogisticRegression *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getRegularization();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_LogisticRegression_setRegularization
[32/64bit] alsogetRegularizationを参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_LogisticRegression_setRegularization
元DLLエクスポート名: ml_LogisticRegression_setRegularization
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_LogisticRegression_setRegularization(cv::ml::LogisticRegression *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setRegularization(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_LogisticRegression_getTrainMethod
[32/64bit] 使用される学習方法の種類。LogisticRegression::Methodsを参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
alsosetTrainMethodを参照。

元関数名(C#): ml_LogisticRegression_getTrainMethod
元DLLエクスポート名: ml_LogisticRegression_getTrainMethod
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_LogisticRegression_getTrainMethod(cv::ml::LogisticRegression *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getTrainMethod();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_LogisticRegression_setTrainMethod
[32/64bit] alsogetTrainMethodを参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_LogisticRegression_setTrainMethod
元DLLエクスポート名: ml_LogisticRegression_setTrainMethod
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_LogisticRegression_setTrainMethod(cv::ml::LogisticRegression *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setTrainMethod(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_LogisticRegression_getMiniBatchSize
[32/64bit] Mini-Batch Gradient Descentの各ステップで取るトレーニングサンプルの数を指定します。LogisticRegression::MINI_BATCH学習アルゴリズムを使用する場合にのみ使用されます。トレーニングサンプルの総数よりも少ない値を取らなければならない。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
See alsosetMiniBatchSize

元関数名(C#): ml_LogisticRegression_getMiniBatchSize
元DLLエクスポート名: ml_LogisticRegression_getMiniBatchSize
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_LogisticRegression_getMiniBatchSize(cv::ml::LogisticRegression *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getMiniBatchSize();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_LogisticRegression_setMiniBatchSize
[32/64bit] alsogetMiniBatchSizeを参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_LogisticRegression_setMiniBatchSize
元DLLエクスポート名: ml_LogisticRegression_setMiniBatchSize
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_LogisticRegression_setMiniBatchSize(cv::ml::LogisticRegression *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setMiniBatchSize(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_LogisticRegression_getTermCriteria
[32/64bit] アルゴリズムの終了基準。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out TermCriteria returnValue
%inst
alsosetTermCriteriaを参照

元関数名(C#): ml_LogisticRegression_getTermCriteria
元DLLエクスポート名: ml_LogisticRegression_getTermCriteria
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_LogisticRegression_getTermCriteria(cv::ml::LogisticRegression *obj, MyCvTermCriteria *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(obj-&amp;gt;getTermCriteria());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_LogisticRegression_setTermCriteria
[32bit] 関連項目： 用語集の設定
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = ARGS_TERMCRITERIA : TermCriteria val
%inst
元関数名(C#): ml_LogisticRegression_setTermCriteria
元DLLエクスポート名: ml_LogisticRegression_setTermCriteria
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_LogisticRegression_setTermCriteria(cv::ml::LogisticRegression *obj, MyCvTermCriteria val)
{
    BEGIN_WRAP
    obj-&amp;gt;setTermCriteria(cpp(val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_LogisticRegression_setTermCriteria
[64bit] 関連項目： 用語集の設定
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : TermCriteria val
%inst
元関数名(C#): ml_LogisticRegression_setTermCriteria
元DLLエクスポート名: ml_LogisticRegression_setTermCriteria
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_LogisticRegression_setTermCriteria(cv::ml::LogisticRegression *obj, MyCvTermCriteria val)
{
    BEGIN_WRAP
    obj-&amp;gt;setTermCriteria(cpp(val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_LogisticRegression_predict
[32/64bit] 入力されたサンプルに対する応答を予測し、float 型で返す。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr samples
p3 = sptr : IntPtr results
p4 = int : int flags
p5 = var : out float returnValue
%inst
cv::ml::StatModel を実装しています．

元関数名(C#): ml_LogisticRegression_predict
元DLLエクスポート名: ml_LogisticRegression_predict
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_LogisticRegression_predict(
    cv::ml::LogisticRegression *obj, cv::_InputArray *samples, cv::_OutputArray *results, int flags, float *returnValue)
{ 
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;predict(entity(samples), entity(results), flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_LogisticRegression_get_learnt_thetas
[32/64bit] この関数は，学習されたパラメータを列方向に並べて返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
2クラス分類問題の場合は，行行列が返されます．これは，ロジスティック回帰の学習済みパラメータを CV_32F 型の行列として返します．

元関数名(C#): ml_LogisticRegression_get_learnt_thetas
元DLLエクスポート名: ml_LogisticRegression_get_learnt_thetas
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_LogisticRegression_get_learnt_thetas(cv::ml::LogisticRegression *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(obj-&amp;gt;get_learnt_thetas());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_LogisticRegression_create
[32/64bit] 空のモデルを作成します。
%prm
p1
p1 = var : out IntPtr returnValue
%inst
与えられたパラメータでロジスティック回帰モデルを作成します．

元関数名(C#): ml_LogisticRegression_create
元DLLエクスポート名: ml_LogisticRegression_create
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_LogisticRegression_create(cv::Ptr&amp;lt;cv::ml::LogisticRegression&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::ml::LogisticRegression::create();
    *returnValue = new cv::Ptr&amp;lt;cv::ml::LogisticRegression&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_Ptr_LogisticRegression_delete
[32/64bit] cv::ml::LogisticRegression のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
ロジスティック回帰分類器を実装します．

ロジスティック回帰 も参照してください．


元関数名(C#): ml_Ptr_LogisticRegression_delete
元DLLエクスポート名: ml_Ptr_LogisticRegression_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Ptr_LogisticRegression_delete(cv::Ptr&amp;lt;cv::ml::LogisticRegression&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_Ptr_LogisticRegression_get
[32/64bit] cv::ml::LogisticRegression のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
ロジスティック回帰分類器を実装します．

ロジスティック回帰 も参照してください．


元関数名(C#): ml_Ptr_LogisticRegression_get
元DLLエクスポート名: ml_Ptr_LogisticRegression_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Ptr_LogisticRegression_get(
    cv::Ptr&amp;lt;cv::ml::LogisticRegression&amp;gt; *obj, cv::ml::LogisticRegression **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_LogisticRegression_load
[32/64bit] ml_LogisticRegression_load
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string filePath
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_LogisticRegression_load
元DLLエクスポート名: ml_LogisticRegression_load
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_LogisticRegression_load(
    const char *filePath, cv::Ptr&amp;lt;cv::ml::LogisticRegression&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::Algorithm::load&amp;lt;cv::ml::LogisticRegression&amp;gt;(filePath);
    *returnValue = new cv::Ptr&amp;lt;cv::ml::LogisticRegression&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_LogisticRegression_loadFromString
[32/64bit] ml_LogisticRegression_loadFromString
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string strModel
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_LogisticRegression_loadFromString
元DLLエクスポート名: ml_LogisticRegression_loadFromString
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_LogisticRegression.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_LogisticRegression_loadFromString(
    const char *strModel, cv::Ptr&amp;lt;cv::ml::LogisticRegression&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto objName = cv::ml::LogisticRegression::create()-&amp;gt;getDefaultName();
    const auto ptr = cv::Algorithm::loadFromString&amp;lt;cv::ml::LogisticRegression&amp;gt;(strModel, objName);
    *returnValue = new cv::Ptr&amp;lt;cv::ml::LogisticRegression&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_LogisticRegression

%index
ml_NormalBayesClassifier_predictProb
[32/64bit] サンプルの応答を予測します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr inputs
p3 = sptr : IntPtr samples
p4 = sptr : IntPtr outputProbs
p5 = int : int flags
p6 = var : out float returnValue
%inst
このメソッドは，入力ベクトルに対して最も確率の高いクラスを推定します．入力ベクトル（1つまたは複数）は，行列inputsの行として格納されます．複数の入力ベクトルがある場合，出力ベクトルは1つでなければなりません．1つの入力ベクトルに対して予測されたクラスが，このメソッドによって返されます．ベクトル outputProbs には、result の各要素に対応する出力確率が含まれています。

元関数名(C#): ml_NormalBayesClassifier_predictProb
元DLLエクスポート名: ml_NormalBayesClassifier_predictProb
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_NormalBayesClassifier.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_NormalBayesClassifier_predictProb(
    cv::ml::NormalBayesClassifier *obj, cv::_InputArray *inputs, 
    cv::_OutputArray *samples, cv::_OutputArray *outputProbs, int flags, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;predictProb(entity(inputs), entity(samples), entity(outputProbs), flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_NormalBayesClassifier

%index
ml_NormalBayesClassifier_create
[32/64bit] 空のモデルを作成 StatModel::train を使用して、作成後のモデルをトレーニングします。
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_NormalBayesClassifier_create
元DLLエクスポート名: ml_NormalBayesClassifier_create
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_NormalBayesClassifier.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_NormalBayesClassifier_create(cv::Ptr&amp;lt;cv::ml::NormalBayesClassifier&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::ml::NormalBayesClassifier::create();
    *returnValue = new cv::Ptr&amp;lt;cv::ml::NormalBayesClassifier&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_NormalBayesClassifier

%index
ml_Ptr_NormalBayesClassifier_delete
[32/64bit] cv::ml::NormalBayesClassifier のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
正規分布データに対するベイズ分類器

関連項目： 正規ベイズ分類法


元関数名(C#): ml_Ptr_NormalBayesClassifier_delete
元DLLエクスポート名: ml_Ptr_NormalBayesClassifier_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_NormalBayesClassifier.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Ptr_NormalBayesClassifier_delete(cv::Ptr&amp;lt;cv::ml::NormalBayesClassifier&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_NormalBayesClassifier

%index
ml_Ptr_NormalBayesClassifier_get
[32/64bit] cv::ml::NormalBayesClassifier のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
正規分布データに対するベイズ分類器

関連項目： 正規ベイズ分類法


元関数名(C#): ml_Ptr_NormalBayesClassifier_get
元DLLエクスポート名: ml_Ptr_NormalBayesClassifier_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_NormalBayesClassifier.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Ptr_NormalBayesClassifier_get(
    cv::Ptr&amp;lt;cv::ml::NormalBayesClassifier&amp;gt;* obj, cv::ml::NormalBayesClassifier **returnValue)

{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_NormalBayesClassifier

%index
ml_NormalBayesClassifier_load
[32/64bit] ml_NormalBayesClassifier_load
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string filePath
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_NormalBayesClassifier_load
元DLLエクスポート名: ml_NormalBayesClassifier_load
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_NormalBayesClassifier.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_NormalBayesClassifier_load(const char *filePath, cv::Ptr&amp;lt;cv::ml::NormalBayesClassifier&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto  ptr = cv::Algorithm::load&amp;lt;cv::ml::NormalBayesClassifier&amp;gt;(filePath);
    *returnValue = new cv::Ptr&amp;lt;cv::ml::NormalBayesClassifier&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_NormalBayesClassifier

%index
ml_NormalBayesClassifier_loadFromString
[32/64bit] ml_NormalBayesClassifier_loadFromString
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string strModel
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_NormalBayesClassifier_loadFromString
元DLLエクスポート名: ml_NormalBayesClassifier_loadFromString
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_NormalBayesClassifier.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_NormalBayesClassifier_loadFromString(const char *strModel, cv::Ptr&amp;lt;cv::ml::NormalBayesClassifier&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto objName = cv::ml::NormalBayesClassifier::create()-&amp;gt;getDefaultName();
    const auto ptr = cv::Algorithm::loadFromString&amp;lt;cv::ml::NormalBayesClassifier&amp;gt;(strModel, objName);
    *returnValue = new cv::Ptr&amp;lt;cv::ml::NormalBayesClassifier&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_NormalBayesClassifier

%index
ml_RTrees_getCalculateVarImportance
[32/64bit] ml_RTrees_getCalculateVarImportance
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ml_RTrees_getCalculateVarImportance
元DLLエクスポート名: ml_RTrees_getCalculateVarImportance
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_RTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_RTrees_getCalculateVarImportance(cv::ml::RTrees *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getCalculateVarImportance() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_RTrees

%index
ml_RTrees_setCalculateVarImportance
[32/64bit] ml_RTrees_setCalculateVarImportance
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_RTrees_setCalculateVarImportance
元DLLエクスポート名: ml_RTrees_setCalculateVarImportance
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_RTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_RTrees_setCalculateVarImportance(cv::ml::RTrees *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setCalculateVarImportance(val != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_RTrees

%index
ml_RTrees_getActiveVarCount
[32/64bit] ml_RTrees_getActiveVarCount
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ml_RTrees_getActiveVarCount
元DLLエクスポート名: ml_RTrees_getActiveVarCount
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_RTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_RTrees_getActiveVarCount(cv::ml::RTrees *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getActiveVarCount();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_RTrees

%index
ml_RTrees_setActiveVarCount
[32/64bit] ml_RTrees_setActiveVarCount
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_RTrees_setActiveVarCount
元DLLエクスポート名: ml_RTrees_setActiveVarCount
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_RTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_RTrees_setActiveVarCount(cv::ml::RTrees *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setActiveVarCount(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_RTrees

%index
ml_RTrees_getTermCriteria
[32/64bit] ml_RTrees_getTermCriteria
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out TermCriteria returnValue
%inst
元関数名(C#): ml_RTrees_getTermCriteria
元DLLエクスポート名: ml_RTrees_getTermCriteria
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_RTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_RTrees_getTermCriteria(cv::ml::RTrees *obj, MyCvTermCriteria *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(obj-&amp;gt;getTermCriteria());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_RTrees

%index
ml_RTrees_setTermCriteria
[32bit] ml_RTrees_setTermCriteria
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = ARGS_TERMCRITERIA : TermCriteria val
%inst
元関数名(C#): ml_RTrees_setTermCriteria
元DLLエクスポート名: ml_RTrees_setTermCriteria
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_RTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_RTrees_setTermCriteria(cv::ml::RTrees *obj, MyCvTermCriteria val)
{
    BEGIN_WRAP
    obj-&amp;gt;setTermCriteria(cpp(val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_RTrees

%index
ml_RTrees_setTermCriteria
[64bit] ml_RTrees_setTermCriteria
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : TermCriteria val
%inst
元関数名(C#): ml_RTrees_setTermCriteria
元DLLエクスポート名: ml_RTrees_setTermCriteria
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_RTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_RTrees_setTermCriteria(cv::ml::RTrees *obj, MyCvTermCriteria val)
{
    BEGIN_WRAP
    obj-&amp;gt;setTermCriteria(cpp(val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_RTrees

%index
ml_RTrees_getVarImportance
[32/64bit] ml_RTrees_getVarImportance
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_RTrees_getVarImportance
元DLLエクスポート名: ml_RTrees_getVarImportance
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_RTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_RTrees_getVarImportance(cv::ml::RTrees *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(obj-&amp;gt;getVarImportance());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_RTrees

%index
ml_RTrees_create
[32/64bit] ml_RTrees_create
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_RTrees_create
元DLLエクスポート名: ml_RTrees_create
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_RTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_RTrees_create(cv::Ptr&amp;lt;cv::ml::RTrees&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::ml::RTrees::create();
    *returnValue = new cv::Ptr&amp;lt;cv::ml::RTrees&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_RTrees

%index
ml_Ptr_RTrees_delete
[32/64bit] cv::ml::Rtrees のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): ml_Ptr_RTrees_delete
元DLLエクスポート名: ml_Ptr_RTrees_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_RTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Ptr_RTrees_delete(cv::Ptr&amp;lt;cv::ml::RTrees&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_RTrees

%index
ml_Ptr_RTrees_get
[32/64bit] cv::ml::Rtrees のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): ml_Ptr_RTrees_get
元DLLエクスポート名: ml_Ptr_RTrees_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_RTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Ptr_RTrees_get(cv::Ptr&amp;lt;cv::ml::RTrees&amp;gt; *obj, cv::ml::RTrees **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_RTrees

%index
ml_RTrees_load
[32/64bit] ml_RTrees_load
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string filePath
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_RTrees_load
元DLLエクスポート名: ml_RTrees_load
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_RTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_RTrees_load(const char *filePath, cv::Ptr&amp;lt;cv::ml::RTrees&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::Algorithm::load&amp;lt;cv::ml::RTrees&amp;gt;(filePath);
    *returnValue = new cv::Ptr&amp;lt;cv::ml::RTrees&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_RTrees

%index
ml_RTrees_loadFromString
[32/64bit] ml_RTrees_loadFromString
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string strModel
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_RTrees_loadFromString
元DLLエクスポート名: ml_RTrees_loadFromString
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_RTrees.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_RTrees_loadFromString(const char *strModel, cv::Ptr&amp;lt;cv::ml::RTrees&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto objName = cv::ml::RTrees::create()-&amp;gt;getDefaultName();
    const auto ptr = cv::Algorithm::loadFromString&amp;lt;cv::ml::RTrees&amp;gt;(strModel, objName);
    *returnValue = new cv::Ptr&amp;lt;cv::ml::RTrees&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_RTrees

%index
ml_StatModel_clear
[32/64bit] ml_StatModel_clear
%prm
p1
p1 = sptr : IntPtr obj
%inst
元関数名(C#): ml_StatModel_clear
元DLLエクスポート名: ml_StatModel_clear
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_StatModel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_StatModel_clear(cv::ml::StatModel *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;clear();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_StatModel

%index
ml_StatModel_getVarCount
[32/64bit] トレーニングサンプルの変数の数を返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ml_StatModel_getVarCount
元DLLエクスポート名: ml_StatModel_getVarCount
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_StatModel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_StatModel_getVarCount(cv::ml::StatModel *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getVarCount();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_StatModel

%index
ml_StatModel_empty
[32/64bit] アルゴリズムが空の場合（例えば，最初の頃や読み込みに失敗した後など）は，真を返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
cv::Algorithm を再実装したものです．

元関数名(C#): ml_StatModel_empty
元DLLエクスポート名: ml_StatModel_empty
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_StatModel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_StatModel_empty(cv::ml::StatModel *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;empty() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_StatModel

%index
ml_StatModel_isTrained
[32/64bit] モデルがトレーニングされている場合は true を返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ml_StatModel_isTrained
元DLLエクスポート名: ml_StatModel_isTrained
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_StatModel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_StatModel_isTrained(cv::ml::StatModel *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;isTrained() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_StatModel

%index
ml_StatModel_isClassifier
[32/64bit] モデルが分類器の場合は true を返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ml_StatModel_isClassifier
元DLLエクスポート名: ml_StatModel_isClassifier
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_StatModel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_StatModel_isClassifier(cv::ml::StatModel *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;isClassifier() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_StatModel

%index
ml_StatModel_train2
[32/64bit] 統計モデルを学習します。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr samples
p3 = int : int layout
p4 = sptr : IntPtr responses
p5 = var : out int returnValue
%inst
元関数名(C#): ml_StatModel_train2
元DLLエクスポート名: ml_StatModel_train2
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_StatModel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_StatModel_train2(
    cv::ml::StatModel *obj, cv::_InputArray *samples, int layout, cv::_InputArray *responses, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;train(*samples, layout, *responses) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_StatModel

%index
ml_StatModel_predict
[32/64bit] 与えられたサンプルに対する応答を予測する
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr samples
p3 = sptr : IntPtr results
p4 = int : int flags
p5 = var : out float returnValue
%inst
cv::ml::LogisticRegression, および cv::ml::EM で実装されています．

元関数名(C#): ml_StatModel_predict
元DLLエクスポート名: ml_StatModel_predict
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_StatModel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_StatModel_predict(
    cv::ml::StatModel *obj, cv::_InputArray *samples, cv::_OutputArray *results, int flags, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;predict(entity(samples), entity(results), flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_StatModel

%index
ml_SVM_getType
[32/64bit] SVM の定式化の種類．SVM::Types を参照してください．デフォルト値は SVM::C_SVC です．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
alsosetType を参照。

元関数名(C#): ml_SVM_getType
元DLLエクスポート名: ml_SVM_getType
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_getType(cv::ml::SVM *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getType();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_setType
[32/64bit] alsogetType を参照してください。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ml_SVM_setType
元DLLエクスポート名: ml_SVM_setType
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_setType(cv::ml::SVM *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setType(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_getGamma
[32/64bit] カーネル関数のパラメータ ?????SVM::POLY, SVM::RBF, SVM::SIGMOID または SVM::CHI2 の場合。デフォルト値は 1。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
alsosetGamma を参照。

元関数名(C#): ml_SVM_getGamma
元DLLエクスポート名: ml_SVM_getGamma
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_getGamma(cv::ml::SVM *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getGamma();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_setGamma
[32/64bit] alsogetGamma を参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): ml_SVM_setGamma
元DLLエクスポート名: ml_SVM_setGamma
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_setGamma(cv::ml::SVM *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setGamma(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_getCoef0
[32/64bit] カーネル関数のパラメータ coef0。SVM::POLY または SVM::SIGMOID の場合。既定値は0。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
alsosetCoef0 を参照。

元関数名(C#): ml_SVM_getCoef0
元DLLエクスポート名: ml_SVM_getCoef0
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_getCoef0(cv::ml::SVM *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getCoef0();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_setCoef0
[32/64bit] alsogetCoef0 を参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): ml_SVM_setCoef0
元DLLエクスポート名: ml_SVM_setCoef0
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_setCoef0(cv::ml::SVM *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setCoef0(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_getDegree
[32/64bit] カーネル関数のパラメータ degree。SVM::POLY の場合。デフォルトの値は 0。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
alsosetDegree を参照。

元関数名(C#): ml_SVM_getDegree
元DLLエクスポート名: ml_SVM_getDegree
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_getDegree(cv::ml::SVM *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getDegree();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_setDegree
[32/64bit] alsogetDegree 参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): ml_SVM_setDegree
元DLLエクスポート名: ml_SVM_setDegree
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_setDegree(cv::ml::SVM *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setDegree(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_getC
[32/64bit] カーネル関数のパラメータ coef0。SVM::POLY または SVM::SIGMOID の場合。既定値は0。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
alsosetCoef0 を参照。

元関数名(C#): ml_SVM_getC
元DLLエクスポート名: ml_SVM_getC
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_getCoef0(cv::ml::SVM *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getCoef0();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_setC
[32/64bit] alsogetCoef0 を参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): ml_SVM_setC
元DLLエクスポート名: ml_SVM_setC
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_setCoef0(cv::ml::SVM *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setCoef0(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_getP
[32/64bit] SVM 最適化問題のパラメータ ????? ?????SVM::EPS_SVR の場合。デフォルト値は 0 です。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
参照：アルソセットP

元関数名(C#): ml_SVM_getP
元DLLエクスポート名: ml_SVM_getP
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_getP(cv::ml::SVM *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getP();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_setP
[32/64bit] alsogetP参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): ml_SVM_setP
元DLLエクスポート名: ml_SVM_setP
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_setP(cv::ml::SVM *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setP(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_getNu
[32/64bit] SVM 最適化問題のパラメータ ?nu?SVM::NU_SVC, SVM::ONE_CLASS, SVM::NU_SVR の場合。デフォルト値は 0。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
alsosetNu を参照。

元関数名(C#): ml_SVM_getNu
元DLLエクスポート名: ml_SVM_getNu
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_getNu(cv::ml::SVM *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getNu();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_setNu
[32/64bit] alsogetNu を参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): ml_SVM_setNu
元DLLエクスポート名: ml_SVM_setNu
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_setNu(cv::ml::SVM *obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setNu(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_getClassWeights
[32/64bit] ml_SVM_getClassWeights
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_SVM_getClassWeights
元DLLエクスポート名: ml_SVM_getClassWeights
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_getClassWeights(cv::ml::SVM *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(obj-&amp;gt;getClassWeights());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_setClassWeights
[32/64bit] alsogetClassWeights を参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr val
%inst
元関数名(C#): ml_SVM_setClassWeights
元DLLエクスポート名: ml_SVM_setClassWeights
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_setClassWeights(cv::ml::SVM *obj, cv::Mat *val)
{
    BEGIN_WRAP
    obj-&amp;gt;setClassWeights(*val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_getTermCriteria
[32/64bit] ml_SVM_getTermCriteria
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out TermCriteria returnValue
%inst
元関数名(C#): ml_SVM_getTermCriteria
元DLLエクスポート名: ml_SVM_getTermCriteria
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_getTermCriteria(cv::ml::SVM *obj, MyCvTermCriteria *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(obj-&amp;gt;getTermCriteria());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_setTermCriteria
[32bit] 関連項目： 用語集の設定
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = ARGS_TERMCRITERIA : TermCriteria val
%inst
元関数名(C#): ml_SVM_setTermCriteria
元DLLエクスポート名: ml_SVM_setTermCriteria
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_setTermCriteria(cv::ml::SVM *obj, MyCvTermCriteria val)
{
    BEGIN_WRAP
    obj-&amp;gt;setTermCriteria(cpp(val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_setTermCriteria
[64bit] 関連項目： 用語集の設定
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : TermCriteria val
%inst
元関数名(C#): ml_SVM_setTermCriteria
元DLLエクスポート名: ml_SVM_setTermCriteria
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_setTermCriteria(cv::ml::SVM *obj, MyCvTermCriteria val)
{
    BEGIN_WRAP
    obj-&amp;gt;setTermCriteria(cpp(val));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_getKernelType
[32/64bit] SVM カーネルの種類。SVM::KernelTypes を参照。デフォルト値は SVM::RBF。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ml_SVM_getKernelType
元DLLエクスポート名: ml_SVM_getKernelType
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_getKernelType(cv::ml::SVM *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getKernelType();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_setKernel
[32/64bit] 定義済みカーネルの1つで初期化。SVM::KernelTypes を参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int kernelType
%inst
元関数名(C#): ml_SVM_setKernel
元DLLエクスポート名: ml_SVM_setKernel
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_setKernel(cv::ml::SVM *obj, int kernelType)
{
    BEGIN_WRAP
    obj-&amp;gt;setKernel(kernelType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_getSupportVectors
[32/64bit] すべてのサポートベクターを取得。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
このメソッドは，すべてのサポートベクターを浮動小数点型の行列として返します．サポートベクターは行列の行として保存されます．

元関数名(C#): ml_SVM_getSupportVectors
元DLLエクスポート名: ml_SVM_getSupportVectors
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_getSupportVectors(cv::ml::SVM *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Mat(obj-&amp;gt;getSupportVectors());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_getDecisionFunction
[32/64bit] 決定関数を検索します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = int : int i
p3 = sptr : IntPtr alpha
p4 = sptr : IntPtr svidx
p5 = var : out double returnValue
%inst
このメソッドは、決定関数の rho パラメータ（カーネル応答の加重和から減算されたスカラー）を返します。

元関数名(C#): ml_SVM_getDecisionFunction
元DLLエクスポート名: ml_SVM_getDecisionFunction
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_getDecisionFunction(
    cv::ml::SVM *obj, int i, cv::_OutputArray *alpha, cv::_OutputArray *svidx, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getDecisionFunction(i, entity(alpha), entity(svidx));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_getDefaultGrid
[32/64bit] SVM パラメータのグリッドを生成します。
%prm
p1,p2
p1 = int : int paramId
p2 = var : out ParamGrid returnValue
%inst
この関数は SVM アルゴリズムの指定されたパラメータ用のグリッドを生成します。このグリッドは関数 SVM::trainAuto に渡すことができる。

元関数名(C#): ml_SVM_getDefaultGrid
元DLLエクスポート名: ml_SVM_getDefaultGrid
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_getDefaultGrid(int param_id, ParamGridStruct *returnValue)
{ 
    BEGIN_WRAP
    *returnValue = c(cv::ml::SVM::getDefaultGrid(param_id));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_create
[32/64bit] 空のモデルを作成します。モデルの学習には StatModel::train を使用します。SVM にはいくつかのパラメータがあるため、問題に最適なパラメータを見つけたい場合は、SVM::trainAuto で行うことができます。
%prm
p1
p1 = var : out IntPtr returnValue
%inst
例： samples/cpp/train_HOG.cpp.

元関数名(C#): ml_SVM_create
元DLLエクスポート名: ml_SVM_create
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_create(cv::Ptr&amp;lt;cv::ml::SVM&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::ml::SVM::create();
    *returnValue = new cv::Ptr&amp;lt;cv::ml::SVM&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_Ptr_SVM_delete
[32/64bit] cv::ml::SVM のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
サポートベクターマシン。

関連項目サポートベクターマシン


元関数名(C#): ml_Ptr_SVM_delete
元DLLエクスポート名: ml_Ptr_SVM_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Ptr_SVM_delete(cv::Ptr&amp;lt;cv::ml::SVM&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_Ptr_SVM_get
[32/64bit] cv::ml::SVM のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
サポートベクターマシン。

関連項目サポートベクターマシン


元関数名(C#): ml_Ptr_SVM_get
元DLLエクスポート名: ml_Ptr_SVM_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_Ptr_SVM_get(cv::Ptr&amp;lt;cv::ml::SVM&amp;gt;* obj, cv::ml::SVM **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_load
[32/64bit] シリアル化された SVM をファイルから読み込み、作成する。
%prm
p1,p2
p1 = str : string filePath
p2 = var : out IntPtr returnValue
%inst
SVM::save を使用して SVM をシリアル化してディスクに保存する。ファイルへのパスを指定してこの関数を呼び出すことにより、このファイルから再度 SVM を読み込む。

元関数名(C#): ml_SVM_load
元DLLエクスポート名: ml_SVM_load
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_load(const char *filePath, cv::Ptr&amp;lt;cv::ml::SVM&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::ml::SVM::load(filePath);
    *returnValue = new cv::Ptr&amp;lt;cv::ml::SVM&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
ml_SVM_loadFromString
[32/64bit] ml_SVM_loadFromString
%prm
p1,p2
p1 = str : string strModel
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ml_SVM_loadFromString
元DLLエクスポート名: ml_SVM_loadFromString
参照元CSファイル: Internal\PInvoke\NativeMethods\ml\NativeMethods_ml_SVM.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ml_SVM_loadFromString(const char *strModel, cv::Ptr&amp;lt;cv::ml::SVM&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto objName = cv::ml::SVM::create()-&amp;gt;getDefaultName();
    const auto ptr = cv::Algorithm::loadFromString&amp;lt;cv::ml::SVM&amp;gt;(strModel, objName);
    *returnValue = new cv::Ptr&amp;lt;cv::ml::SVM&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ml_SVM

%index
objdetect_groupRectangles1
[32/64bit] オブジェクト候補の矩形をグループ化する。
%prm
p1,p2,p3
p1 = sptr : IntPtr rectList
p2 = int : int groupThreshold
p3 = double : double eps
%inst
この関数は，汎用関数 partition のラッパーです．この関数は，類似したサイズと類似した位置にある矩形を結合する矩形等価基準を用いて，すべての入力矩形をクラスタリングします．この類似性は eps で定義されます．eps=0 の場合，クラスタリングは全く行われません．eps=0 の場合は，クラスタリングは行われません．また，(\{eps}\rightarrow +\inf\) の場合は，すべての長方形が1つのクラスタに入ります．そして，groupThreshold以下の矩形を含む小さなクラスタは拒否されます．他の各クラスタでは，平均的な矩形が計算され，出力矩形リストに入れられます．

元関数名(C#): objdetect_groupRectangles1
元DLLエクスポート名: objdetect_groupRectangles1
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_groupRectangles1(
    std::vector&amp;lt;cv::Rect&amp;gt; *rectList, int groupThreshold, double eps)
{
    BEGIN_WRAP
    cv::groupRectangles(*rectList, groupThreshold, eps);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect

%index
objdetect_groupRectangles2
[32/64bit] オブジェクト候補の矩形をグループ化する。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr rectList
p2 = sptr : IntPtr weights
p3 = int : int groupThreshold
p4 = double : double eps
%inst
この関数は，汎用関数 partition のラッパーです．この関数は，類似したサイズと類似した位置にある矩形を結合する矩形等価基準を用いて，すべての入力矩形をクラスタリングします．この類似性は eps で定義されます．eps=0 の場合，クラスタリングは全く行われません．eps=0 の場合は，クラスタリングは行われません．また，(\{eps}\rightarrow +\inf\) の場合は，すべての長方形が1つのクラスタに入ります．そして，groupThreshold以下の矩形を含む小さなクラスタは拒否されます．他の各クラスタでは，平均的な矩形が計算され，出力矩形リストに入れられます．

元関数名(C#): objdetect_groupRectangles2
元DLLエクスポート名: objdetect_groupRectangles2
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_groupRectangles2(
    std::vector&amp;lt;cv::Rect&amp;gt; *rectList, std::vector&amp;lt;int&amp;gt; *weights, int groupThreshold, double eps)
{
    BEGIN_WRAP
    cv::groupRectangles(*rectList, *weights, groupThreshold, eps);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect

%index
objdetect_groupRectangles3
[32/64bit] オブジェクト候補の矩形をグループ化する。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr rectList
p2 = int : int groupThreshold
p3 = double : double eps
p4 = sptr : IntPtr weights
p5 = sptr : IntPtr levelWeights
%inst
この関数は，汎用関数 partition のラッパーです．この関数は，類似したサイズと類似した位置にある矩形を結合する矩形等価基準を用いて，すべての入力矩形をクラスタリングします．この類似性は eps で定義されます．eps=0 の場合，クラスタリングは全く行われません．eps=0 の場合は，クラスタリングは行われません．また，(\{eps}\rightarrow +\inf\) の場合は，すべての長方形が1つのクラスタに入ります．そして，groupThreshold以下の矩形を含む小さなクラスタは拒否されます．他の各クラスタでは，平均的な矩形が計算され，出力矩形リストに入れられます．

元関数名(C#): objdetect_groupRectangles3
元DLLエクスポート名: objdetect_groupRectangles3
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_groupRectangles3(
    std::vector&amp;lt;cv::Rect&amp;gt; *rectList, int groupThreshold, double eps, std::vector&amp;lt;int&amp;gt; *weights, std::vector&amp;lt;double&amp;gt; *levelWeights)
{
    BEGIN_WRAP
    cv::groupRectangles(*rectList, groupThreshold, eps, weights, levelWeights);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect

%index
objdetect_groupRectangles4
[32/64bit] オブジェクト候補の矩形をグループ化する。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr rectList
p2 = sptr : IntPtr rejectLevels
p3 = sptr : IntPtr levelWeights
p4 = int : int groupThreshold
p5 = double : double eps
%inst
この関数は，汎用関数 partition のラッパーです．この関数は，類似したサイズと類似した位置にある矩形を結合する矩形等価基準を用いて，すべての入力矩形をクラスタリングします．この類似性は eps で定義されます．eps=0 の場合，クラスタリングは全く行われません．eps=0 の場合は，クラスタリングは行われません．また，(\{eps}\rightarrow +\inf\) の場合は，すべての長方形が1つのクラスタに入ります．そして，groupThreshold以下の矩形を含む小さなクラスタは拒否されます．他の各クラスタでは，平均的な矩形が計算され，出力矩形リストに入れられます．

元関数名(C#): objdetect_groupRectangles4
元DLLエクスポート名: objdetect_groupRectangles4
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_groupRectangles4(
    std::vector&amp;lt;cv::Rect&amp;gt; *rectList, std::vector&amp;lt;int&amp;gt; *rejectLevels, std::vector&amp;lt;double&amp;gt; *levelWeights, int groupThreshold, double eps)
{
    BEGIN_WRAP
    cv::groupRectangles(*rectList, *rejectLevels, *levelWeights, groupThreshold, eps);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect

%index
objdetect_groupRectangles_meanshift
[32/64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr rectList
p2 = sptr : IntPtr foundWeights
p3 = sptr : IntPtr foundScales
p4 = double : double detectThreshold
p5 = ARGS_SIZE : Size winDetSize
%inst
元関数名(C#): objdetect_groupRectangles_meanshift
元DLLエクスポート名: objdetect_groupRectangles_meanshift
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_groupRectangles_meanshift(
    std::vector&amp;lt;cv::Rect&amp;gt; *rectList, std::vector&amp;lt;double&amp;gt; *foundWeights, std::vector&amp;lt;double&amp;gt; *foundScales, double detectThreshold, MyCvSize winDetSize)
{
    BEGIN_WRAP
    cv::groupRectangles_meanshift(*rectList, *foundWeights, *foundScales, detectThreshold, cpp(winDetSize));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect

%index
objdetect_CascadeClassifier_new
[32/64bit] cv::CascadeClassifier のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst
オブジェクト検出用のカスケード分類器クラス．

例：samples/cpp/facedetect.cpp.


元関数名(C#): objdetect_CascadeClassifier_new
元DLLエクスポート名: objdetect_CascadeClassifier_new
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_CascadeClassfier.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_CascadeClassifier_new(cv::CascadeClassifier **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::CascadeClassifier;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_CascadeClassfier

%index
objdetect_CascadeClassifier_newFromFile
[32/64bit] cv::CascadeClassifier のインスタンスを生成します
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string fileName
p2 = var : out IntPtr returnValue
%inst
オブジェクト検出用のカスケード分類器クラス．

例：samples/cpp/facedetect.cpp.


元関数名(C#): objdetect_CascadeClassifier_newFromFile
元DLLエクスポート名: objdetect_CascadeClassifier_newFromFile
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_CascadeClassfier.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_CascadeClassifier_newFromFile(const char *fileName, cv::CascadeClassifier **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::CascadeClassifier(fileName);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_CascadeClassfier

%index
objdetect_CascadeClassifier_delete
[32/64bit] cv::CascadeClassifier のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
オブジェクト検出用のカスケード分類器クラス．

例：samples/cpp/facedetect.cpp.


元関数名(C#): objdetect_CascadeClassifier_delete
元DLLエクスポート名: objdetect_CascadeClassifier_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_CascadeClassfier.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_CascadeClassifier_delete(cv::CascadeClassifier *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_CascadeClassfier

%index
objdetect_CascadeClassifier_empty
[32/64bit] 分類器が読み込まれたかどうかをチェックします。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
例：samples/cpp/facedetect.cpp.

元関数名(C#): objdetect_CascadeClassifier_empty
元DLLエクスポート名: objdetect_CascadeClassifier_empty
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_CascadeClassfier.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_CascadeClassifier_empty(cv::CascadeClassifier *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;empty() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_CascadeClassfier

%index
objdetect_CascadeClassifier_load
[32/64bit] ファイルから分類器を読み込みます。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string fileName
p3 = var : out int returnValue
%inst
例：samples/cpp/facedetect.cpp.

元関数名(C#): objdetect_CascadeClassifier_load
元DLLエクスポート名: objdetect_CascadeClassifier_load
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_CascadeClassfier.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_CascadeClassifier_load(
    cv::CascadeClassifier *obj, const char *fileName, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;load(fileName) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_CascadeClassfier

%index
objdetect_CascadeClassifier_detectMultiScale1
[32/64bit] 入力画像中の異なるサイズの物体を検出します．検出されたオブジェクトは，矩形のリストとして返されます．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = sptr : IntPtr objects
p4 = double : double scaleFactor
p5 = int : int minNeighbors
p6 = int : int flags
p7 = ARGS_SIZE : Size minSize
p8 = ARGS_SIZE : Size maxSize
%inst
この関数は，TBB ライブラリを用いて並列化されています．

(Python) カスケード分類器を用いた顔検出の例は，opencv_source_code/samples/python/facedetect.pyExamples: samples/cpp/facedetect.cppに掲載されています．

元関数名(C#): objdetect_CascadeClassifier_detectMultiScale1
元DLLエクスポート名: objdetect_CascadeClassifier_detectMultiScale1
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_CascadeClassfier.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_CascadeClassifier_detectMultiScale1(
    cv::CascadeClassifier *obj,
    cv::Mat *image, std::vector&amp;lt;cv::Rect&amp;gt; *objects,
    double scaleFactor, int minNeighbors, int flags, MyCvSize minSize, MyCvSize maxSize)
{
    BEGIN_WRAP
    obj-&amp;gt;detectMultiScale(*image, *objects,
        scaleFactor, minNeighbors, flags, cpp(minSize), cpp(maxSize));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_CascadeClassfier

%index
objdetect_CascadeClassifier_detectMultiScale2
[32/64bit] 入力画像中の異なるサイズの物体を検出します．検出されたオブジェクトは，矩形のリストとして返されます．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = sptr : IntPtr objects
p4 = sptr : IntPtr rejectLevels
p5 = sptr : IntPtr levelWeights
p6 = double : double scaleFactor
p7 = int : int minNeighbors
p8 = int : int flags
p9 = ARGS_SIZE : Size minSize
p10 = ARGS_SIZE : Size maxSize
p11 = int : int outputRejectLevels
%inst
この関数は，TBB ライブラリを用いて並列化されています．

(Python) カスケード分類器を用いた顔検出の例は，opencv_source_code/samples/python/facedetect.pyExamples: samples/cpp/facedetect.cppに掲載されています．

元関数名(C#): objdetect_CascadeClassifier_detectMultiScale2
元DLLエクスポート名: objdetect_CascadeClassifier_detectMultiScale2
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_CascadeClassfier.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_CascadeClassifier_detectMultiScale2(
    cv::CascadeClassifier *obj,
    cv::Mat *image, 
    std::vector&amp;lt;cv::Rect&amp;gt; *objects,
    std::vector&amp;lt;int&amp;gt; *rejectLevels,
    std::vector&amp;lt;double&amp;gt; *levelWeights,
    double scaleFactor, int minNeighbors, int flags,
    MyCvSize minSize, MyCvSize maxSize, int outputRejectLevels)
{
    BEGIN_WRAP
    obj-&amp;gt;detectMultiScale(*image, *objects, *rejectLevels, *levelWeights,
        scaleFactor, minNeighbors, flags, cpp(minSize), cpp(maxSize), outputRejectLevels != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_CascadeClassfier

%index
objdetect_CascadeClassifier_isOldFormatCascade
[32/64bit] objdetect_CascadeClassifier_isOldFormatCascade
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): objdetect_CascadeClassifier_isOldFormatCascade
元DLLエクスポート名: objdetect_CascadeClassifier_isOldFormatCascade
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_CascadeClassfier.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_CascadeClassifier_isOldFormatCascade(cv::CascadeClassifier *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;isOldFormatCascade() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_CascadeClassfier

%index
objdetect_CascadeClassifier_getOriginalWindowSize
[32/64bit] objdetect_CascadeClassifier_getOriginalWindowSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out Size returnValue
%inst
元関数名(C#): objdetect_CascadeClassifier_getOriginalWindowSize
元DLLエクスポート名: objdetect_CascadeClassifier_getOriginalWindowSize
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_CascadeClassfier.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_CascadeClassifier_getOriginalWindowSize(cv::CascadeClassifier *obj, MyCvSize *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(obj-&amp;gt;getOriginalWindowSize());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_CascadeClassfier

%index
objdetect_CascadeClassifier_getFeatureType
[32/64bit] objdetect_CascadeClassifier_getFeatureType
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): objdetect_CascadeClassifier_getFeatureType
元DLLエクスポート名: objdetect_CascadeClassifier_getFeatureType
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_CascadeClassfier.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_CascadeClassifier_getFeatureType(cv::CascadeClassifier *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getFeatureType();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_CascadeClassfier

%index
objdetect_HOGDescriptor_new1
[32/64bit] cv::HOGDescriptor のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst
HOG (Histogram of Oriented Gradients) ディスクリプタとオブジェクト検出器の実装．

Navneet DalalとBill Triggsによって紹介されたHOGディスクリプタアルゴリズム[50]を使用しています．

便利なリンク集です．

https://hal.inria.fr/inria-00548512/document/

https://en.wikipedia.org/wiki/Histogram_of_oriented_gradients

https://software.intel.com/en-us/ipp-dev-reference-histogram-of-oriented-gradients-hog-descriptor

http://www.learnopencv.com/histogram-of-oriented-gradients

http://www.learnopencv.com/handwritten-digits-classification-an-opencv-c-python-tutorial

例：samples/cpp/peopledetect.cpp，samples/cpp/train_HOG.cpp，samples/tapi/hog.cpp．


元関数名(C#): objdetect_HOGDescriptor_new1
元DLLエクスポート名: objdetect_HOGDescriptor_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_new1(cv::HOGDescriptor **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::HOGDescriptor;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_new2
[32/64bit] cv::HOGDescriptor のインスタンスを生成します
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12
p1 = ARGS_SIZE : Size winSize
p2 = ARGS_SIZE : Size blockSize
p3 = ARGS_SIZE : Size blockStride
p4 = ARGS_SIZE : Size cellSize
p5 = int : int nbins
p6 = int : int derivAperture
p7 = double : double winSigma
p8 = int : [MarshalAs(UnmanagedType.I4)] HistogramNormType histogramNormType
p9 = double : double l2HysThreshold
p10 = int : int gammaCorrection
p11 = int : int nlevels
p12 = var : out IntPtr returnValue
%inst
HOG (Histogram of Oriented Gradients) ディスクリプタとオブジェクト検出器の実装．

Navneet DalalとBill Triggsによって紹介されたHOGディスクリプタアルゴリズム[50]を使用しています．

便利なリンク集です．

https://hal.inria.fr/inria-00548512/document/

https://en.wikipedia.org/wiki/Histogram_of_oriented_gradients

https://software.intel.com/en-us/ipp-dev-reference-histogram-of-oriented-gradients-hog-descriptor

http://www.learnopencv.com/histogram-of-oriented-gradients

http://www.learnopencv.com/handwritten-digits-classification-an-opencv-c-python-tutorial

例：samples/cpp/peopledetect.cpp，samples/cpp/train_HOG.cpp，samples/tapi/hog.cpp．


元関数名(C#): objdetect_HOGDescriptor_new2
元DLLエクスポート名: objdetect_HOGDescriptor_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_new2(
    MyCvSize winSize, MyCvSize blockSize, MyCvSize blockStride, MyCvSize cellSize,
    int nbins, int derivAperture, double winSigma, int histogramNormType, double L2HysThreshold, int gammaCorrection, int nlevels,
    cv::HOGDescriptor **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::HOGDescriptor(cpp(winSize), cpp(blockSize), cpp(blockStride), cpp(cellSize), nbins, derivAperture, 
                                 winSigma, static_cast&amp;lt;cv::HOGDescriptor::HistogramNormType&amp;gt;(histogramNormType), L2HysThreshold, gammaCorrection != 0, nlevels);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_new3
[32/64bit] cv::HOGDescriptor のインスタンスを生成します
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string fileName
p2 = var : out IntPtr returnValue
%inst
HOG (Histogram of Oriented Gradients) ディスクリプタとオブジェクト検出器の実装．

Navneet DalalとBill Triggsによって紹介されたHOGディスクリプタアルゴリズム[50]を使用しています．

便利なリンク集です．

https://hal.inria.fr/inria-00548512/document/

https://en.wikipedia.org/wiki/Histogram_of_oriented_gradients

https://software.intel.com/en-us/ipp-dev-reference-histogram-of-oriented-gradients-hog-descriptor

http://www.learnopencv.com/histogram-of-oriented-gradients

http://www.learnopencv.com/handwritten-digits-classification-an-opencv-c-python-tutorial

例：samples/cpp/peopledetect.cpp，samples/cpp/train_HOG.cpp，samples/tapi/hog.cpp．


元関数名(C#): objdetect_HOGDescriptor_new3
元DLLエクスポート名: objdetect_HOGDescriptor_new3
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_new3(const char *filename, cv::HOGDescriptor **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::HOGDescriptor(filename);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_delete
[32/64bit] cv::HOGDescriptor のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr self
%inst
HOG (Histogram of Oriented Gradients) ディスクリプタとオブジェクト検出器の実装．

Navneet DalalとBill Triggsによって紹介されたHOGディスクリプタアルゴリズム[50]を使用しています．

便利なリンク集です．

https://hal.inria.fr/inria-00548512/document/

https://en.wikipedia.org/wiki/Histogram_of_oriented_gradients

https://software.intel.com/en-us/ipp-dev-reference-histogram-of-oriented-gradients-hog-descriptor

http://www.learnopencv.com/histogram-of-oriented-gradients

http://www.learnopencv.com/handwritten-digits-classification-an-opencv-c-python-tutorial

例：samples/cpp/peopledetect.cpp，samples/cpp/train_HOG.cpp，samples/tapi/hog.cpp．


元関数名(C#): objdetect_HOGDescriptor_delete
元DLLエクスポート名: objdetect_HOGDescriptor_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_delete(cv::HOGDescriptor *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_getDescriptorSize
[32/64bit] 分類に必要な係数の数を返します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): objdetect_HOGDescriptor_getDescriptorSize
元DLLエクスポート名: objdetect_HOGDescriptor_getDescriptorSize
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_getDescriptorSize(cv::HOGDescriptor *obj, size_t *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getDescriptorSize();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_checkDetectorSize
[32/64bit] 検出器のサイズが記述子のサイズと等しいかどうかをチェックします．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
元関数名(C#): objdetect_HOGDescriptor_checkDetectorSize
元DLLエクスポート名: objdetect_HOGDescriptor_checkDetectorSize
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_checkDetectorSize(cv::HOGDescriptor *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;checkDetectorSize() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_getWinSigma
[32/64bit] winSigma の値を返します．
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out double returnValue
%inst
元関数名(C#): objdetect_HOGDescriptor_getWinSigma
元DLLエクスポート名: objdetect_HOGDescriptor_getWinSigma
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_getWinSigma(cv::HOGDescriptor *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getWinSigma();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_setSVMDetector
[32/64bit] 線形SVM分類器の係数を設定します。
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = sptr : IntPtr svmDetector
%inst
例：samples/cpp/peopledetect.cpp，samples/cpp/train_HOG.cpp，samples/tapi/hog.cpp．

元関数名(C#): objdetect_HOGDescriptor_setSVMDetector
元DLLエクスポート名: objdetect_HOGDescriptor_setSVMDetector
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_setSVMDetector(cv::HOGDescriptor *obj, std::vector&amp;lt;float&amp;gt; *svmDetector)
{
    BEGIN_WRAP
    obj-&amp;gt;setSVMDetector(*svmDetector);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_load
[32/64bit] HOGDescriptor のパラメータと線形 SVM 分類器の係数をファイルから読み込む。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
p3 = str : [MarshalAs(UnmanagedType.LPStr)] string? objName
p4 = var : out int returnValue
%inst
例： samples/cpp/train_HOG.cpp.

元関数名(C#): objdetect_HOGDescriptor_load
元DLLエクスポート名: objdetect_HOGDescriptor_load
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_load(cv::HOGDescriptor *obj, const char *filename, const char *objName, int *returnValue)
{
    BEGIN_WRAP
    std::string objNameStr;
    if (objName != nullptr)
        objNameStr = std::string(objName);
    *returnValue = obj-&amp;gt;load(filename, objNameStr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_save
[32/64bit] HOGDescriptorのパラメータと線形SVM分類器の係数をファイルに保存します。
%prm
p1,p2,p3
p1 = sptr : IntPtr self
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string filename
p3 = str : [MarshalAs(UnmanagedType.LPStr)] string? objName
%inst
例： samples/cpp/train_HOG.cpp.

元関数名(C#): objdetect_HOGDescriptor_save
元DLLエクスポート名: objdetect_HOGDescriptor_save
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_save(cv::HOGDescriptor *obj, const char *filename, const char *objName)
{
    BEGIN_WRAP
    std::string objNameStr;
    if (objName != nullptr)
        objNameStr = cv::String(objName);
    obj-&amp;gt;save(filename, objNameStr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_compute
[32/64bit] 与えられた画像の HOG ディスクリプタを計算します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr self
p2 = sptr : IntPtr img
p3 = sptr : IntPtr descriptors
p4 = ARGS_SIZE : Size winStride
p5 = ARGS_SIZE : Size padding
p6 = var : [In] Point[]? locations
p7 = int : int locationsLength
%inst
例： samples/cpp/train_HOG.cpp.

元関数名(C#): objdetect_HOGDescriptor_compute
元DLLエクスポート名: objdetect_HOGDescriptor_compute
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_compute(
    cv::HOGDescriptor *obj, cv::Mat *img, std::vector&amp;lt;float&amp;gt; *descriptors,
    MyCvSize winStride, MyCvSize padding, cv::Point* locations, int locationsLength)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Point&amp;gt; locationsVec;
    if (locations != nullptr)    
        locationsVec = std::vector&amp;lt;cv::Point&amp;gt;(locations, locations + locationsLength);    
    obj-&amp;gt;compute(*img, *descriptors, cpp(winStride), cpp(padding), locationsVec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_detect1
[32/64bit] マルチスケールウィンドウを利用せずに，物体検出を行います．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr self
p2 = sptr : IntPtr img
p3 = sptr : IntPtr foundLocations
p4 = double : double hitThreshold
p5 = ARGS_SIZE : Size winStride
p6 = ARGS_SIZE : Size padding
p7 = var : [In] Point[]? searchLocations
p8 = int : int searchLocationsLength
%inst
元関数名(C#): objdetect_HOGDescriptor_detect1
元DLLエクスポート名: objdetect_HOGDescriptor_detect1
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_detect1(
    cv::HOGDescriptor *obj, cv::Mat *img, std::vector&amp;lt;cv::Point&amp;gt; *foundLocations,
    double hitThreshold, MyCvSize winStride, MyCvSize padding, cv::Point* searchLocations, int searchLocationsLength)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Point&amp;gt; slVec;
    if (searchLocations != nullptr)    
        slVec = std::vector&amp;lt;cv::Point&amp;gt;(searchLocations, searchLocations + searchLocationsLength);    
    obj-&amp;gt;detect(*img, *foundLocations, hitThreshold, cpp(winStride), cpp(padding), slVec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_detect2
[32/64bit] マルチスケールウィンドウを利用せずに，物体検出を行います．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr self
p2 = sptr : IntPtr img
p3 = sptr : IntPtr foundLocations
p4 = sptr : IntPtr weights
p5 = double : double hitThreshold
p6 = ARGS_SIZE : Size winStride
p7 = ARGS_SIZE : Size padding
p8 = var : [In] Point[]? searchLocations
p9 = int : int searchLocationsLength
%inst
元関数名(C#): objdetect_HOGDescriptor_detect2
元DLLエクスポート名: objdetect_HOGDescriptor_detect2
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_detect2(
    cv::HOGDescriptor *obj, cv::Mat *img, 
    std::vector&amp;lt;cv::Point&amp;gt; *foundLocations, std::vector&amp;lt;double&amp;gt; *weights,
    double hitThreshold, MyCvSize winStride, MyCvSize padding, cv::Point* searchLocations, int searchLocationsLength)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Point&amp;gt; slVec;
    if (searchLocations != nullptr)    
        slVec = std::vector&amp;lt;cv::Point&amp;gt;(searchLocations, searchLocations + searchLocationsLength);    
    obj-&amp;gt;detect(*img, *foundLocations, *weights, hitThreshold, cpp(winStride), cpp(padding), slVec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_detectMultiScale1
[32/64bit] 入力画像中の異なるサイズの物体を検出します．検出されたオブジェクトは，矩形のリストとして返されます．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr self
p2 = sptr : IntPtr img
p3 = sptr : IntPtr foundLocations
p4 = double : double hitThreshold
p5 = ARGS_SIZE : Size winStride
p6 = ARGS_SIZE : Size padding
p7 = double : double scale
p8 = int : int groupThreshold
%inst
例：samples/cpp/peopledetect.cpp，samples/cpp/train_HOG.cpp，samples/tapi/hog.cpp．

元関数名(C#): objdetect_HOGDescriptor_detectMultiScale1
元DLLエクスポート名: objdetect_HOGDescriptor_detectMultiScale1
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_detectMultiScale1(
    cv::HOGDescriptor *obj, cv::Mat *img, 
    std::vector&amp;lt;cv::Rect&amp;gt; *foundLocations,
    double hitThreshold, MyCvSize winStride, MyCvSize padding, double scale, int groupThreshold)
{
    BEGIN_WRAP
    obj-&amp;gt;detectMultiScale(*img, *foundLocations, 
                          hitThreshold, cpp(winStride), cpp(padding), scale, groupThreshold);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_detectMultiScale2
[32/64bit] 入力画像中の異なるサイズの物体を検出します．検出されたオブジェクトは，矩形のリストとして返されます．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr self
p2 = sptr : IntPtr img
p3 = sptr : IntPtr foundLocations
p4 = sptr : IntPtr foundWeights
p5 = double : double hitThreshold
p6 = ARGS_SIZE : Size winStride
p7 = ARGS_SIZE : Size padding
p8 = double : double scale
p9 = int : int groupThreshold
%inst
元関数名(C#): objdetect_HOGDescriptor_detectMultiScale2
元DLLエクスポート名: objdetect_HOGDescriptor_detectMultiScale2
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_detectMultiScale2(
    cv::HOGDescriptor *obj, cv::Mat *img, 
    std::vector&amp;lt;cv::Rect&amp;gt; *foundLocations, std::vector&amp;lt;double&amp;gt; *foundWeights,
    double hitThreshold, MyCvSize winStride, MyCvSize padding, double scale, int groupThreshold)
{
    BEGIN_WRAP
    obj-&amp;gt;detectMultiScale(*img, *foundLocations, *foundWeights, 
                          hitThreshold, cpp(winStride), cpp(padding), scale, groupThreshold);    
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_computeGradient
[32/64bit] グラデーションと量子化されたグラデーションの向きを計算します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr self
p2 = sptr : IntPtr img
p3 = sptr : IntPtr grad
p4 = sptr : IntPtr angleOfs
p5 = ARGS_SIZE : Size paddingTL
p6 = ARGS_SIZE : Size paddingBR
%inst
元関数名(C#): objdetect_HOGDescriptor_computeGradient
元DLLエクスポート名: objdetect_HOGDescriptor_computeGradient
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_computeGradient(
    cv::HOGDescriptor *obj, cv::Mat* img, 
    cv::Mat* grad, cv::Mat* angleOfs, MyCvSize paddingTL, MyCvSize paddingBR)
{
    BEGIN_WRAP
    obj-&amp;gt;computeGradient(*img, *grad, *angleOfs, cpp(paddingTL), cpp(paddingBR));    
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_detectROI
[32/64bit] 指定されたROIを評価し，各位置に対する信頼値を返す
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr img
p3 = var : Point[] locations
p4 = int : int locationsLength
p5 = sptr : IntPtr foundLocations
p6 = sptr : IntPtr confidences
p7 = double : double hitThreshold
p8 = ARGS_SIZE : Size winStride
p9 = ARGS_SIZE : Size padding
%inst
元関数名(C#): objdetect_HOGDescriptor_detectROI
元DLLエクスポート名: objdetect_HOGDescriptor_detectROI
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_detectROI(
    cv::HOGDescriptor *obj, cv::Mat *img, cv::Point *locations, int locationsLength,
    std::vector&amp;lt;cv::Point&amp;gt; *foundLocations, std::vector&amp;lt;double&amp;gt; *confidences,
    double hitThreshold, MyCvSize winStride, MyCvSize padding)
{
    BEGIN_WRAP
    const std::vector&amp;lt;cv::Point&amp;gt; locationsVec(locations, locations + locationsLength);
    obj-&amp;gt;detectROI(*img, locationsVec, *foundLocations, *confidences, hitThreshold, cpp(winStride), cpp(padding));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_detectMultiScaleROI
[32/64bit] 指定されたROIを評価し、各位置の信頼値を複数のスケールで返す
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr img
p3 = sptr : IntPtr foundLocations
p4 = sptr : IntPtr roiScales
p5 = sptr : IntPtr roiLocations
p6 = sptr : IntPtr roiConfidences
p7 = double : double hitThreshold
p8 = int : int groupThreshold
%inst
元関数名(C#): objdetect_HOGDescriptor_detectMultiScaleROI
元DLLエクスポート名: objdetect_HOGDescriptor_detectMultiScaleROI
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_detectMultiScaleROI(
    cv::HOGDescriptor *obj, cv::Mat *img, std::vector&amp;lt;cv::Rect&amp;gt; *foundLocations,
    std::vector&amp;lt;double&amp;gt; *roiScales, std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt; &amp;gt; *roiLocations, std::vector&amp;lt;std::vector&amp;lt;double&amp;gt; &amp;gt; *roiConfidences,
    double hitThreshold, int groupThreshold)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::DetectionROI&amp;gt; locations;
    obj-&amp;gt;detectMultiScaleROI(*img, *foundLocations, locations, hitThreshold, groupThreshold);

    roiScales-&amp;gt;resize(locations.size());
    roiLocations-&amp;gt;resize(locations.size());
    roiConfidences-&amp;gt;resize(locations.size());
    for (size_t i = 0; i &amp;lt; locations.size(); i++)
    {
        (*roiScales)[i] = locations[i].scale;
        (*roiLocations)[i] = locations[i].locations;
        (*roiConfidences)[i] = locations[i].confidences;
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_groupRectangles
[32/64bit] オブジェクト候補の矩形をグループ化する。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr rectList
p3 = sptr : IntPtr weights
p4 = int : int groupThreshold
p5 = double : double eps
%inst
元関数名(C#): objdetect_HOGDescriptor_groupRectangles
元DLLエクスポート名: objdetect_HOGDescriptor_groupRectangles
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_groupRectangles(cv::HOGDescriptor *obj,
                                                    std::vector&amp;lt;cv::Rect&amp;gt; *rectList, std::vector&amp;lt;double&amp;gt; *weights, int groupThreshold, double eps)
{
    BEGIN_WRAP
    obj-&amp;gt;groupRectangles(*rectList, *weights, groupThreshold, eps);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_winSize_get
[32/64bit] cv::HOGDescriptor::winSize 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out Size returnValue
%inst
検出ウィンドウサイズ．ブロックサイズとブロックストライドに合わせます．デフォルト値は Size(64,128).
例： samples/cpp/train_HOG.cpp.

元関数名(C#): objdetect_HOGDescriptor_winSize_get
元DLLエクスポート名: objdetect_HOGDescriptor_winSize_get
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_winSize_get(cv::HOGDescriptor *obj, MyCvSize *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(obj-&amp;gt;winSize);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_blockSize_get
[32/64bit] cv::HOGDescriptor::blockSize 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out Size returnValue
%inst
ブロックサイズ（ピクセル）。セルサイズに合わせます。初期値はSize(16,16)です。


元関数名(C#): objdetect_HOGDescriptor_blockSize_get
元DLLエクスポート名: objdetect_HOGDescriptor_blockSize_get
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_blockSize_get(cv::HOGDescriptor *obj, MyCvSize *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(obj-&amp;gt;blockSize);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_blockStride_get
[32/64bit] cv::HOGDescriptor::blockStride 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out Size returnValue
%inst
ブロックのストライド。セルサイズの倍数である必要があります。初期値は Size(8,8) です。


元関数名(C#): objdetect_HOGDescriptor_blockStride_get
元DLLエクスポート名: objdetect_HOGDescriptor_blockStride_get
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_blockStride_get(cv::HOGDescriptor *obj, MyCvSize *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(obj-&amp;gt;blockStride);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_cellSize_get
[32/64bit] cv::HOGDescriptor::cellSize 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out Size returnValue
%inst
セルの大きさ。初期値はSize(8,8)です。


元関数名(C#): objdetect_HOGDescriptor_cellSize_get
元DLLエクスポート名: objdetect_HOGDescriptor_cellSize_get
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_cellSize_get(cv::HOGDescriptor *obj, MyCvSize *returnValue)
{
    BEGIN_WRAP
    *returnValue = c(obj-&amp;gt;cellSize);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_nbins_get
[32/64bit] cv::HOGDescriptor::nbins 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
グラデーションのヒストグラムの計算に使われるビンの数．既定値は9です．


元関数名(C#): objdetect_HOGDescriptor_nbins_get
元DLLエクスポート名: objdetect_HOGDescriptor_nbins_get
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_nbins_get(cv::HOGDescriptor *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;nbins;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_derivAperture_get
[32/64bit] cv::HOGDescriptor::derivAperture 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
ドキュメントなし


元関数名(C#): objdetect_HOGDescriptor_derivAperture_get
元DLLエクスポート名: objdetect_HOGDescriptor_derivAperture_get
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_derivAperture_get(cv::HOGDescriptor *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;derivAperture;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_winSigma_get
[32/64bit] cv::HOGDescriptor::winSigma 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out double returnValue
%inst
ガウス平滑化窓のパラメータ．


元関数名(C#): objdetect_HOGDescriptor_winSigma_get
元DLLエクスポート名: objdetect_HOGDescriptor_winSigma_get
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_winSigma_get(cv::HOGDescriptor *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;winSigma;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_histogramNormType_get
[32/64bit] cv::HOGDescriptor::histogramNormType 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
histogramNormType


元関数名(C#): objdetect_HOGDescriptor_histogramNormType_get
元DLLエクスポート名: objdetect_HOGDescriptor_histogramNormType_get
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_histogramNormType_get(cv::HOGDescriptor *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;histogramNormType;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_L2HysThreshold_get
[32/64bit] cv::HOGDescriptor::L2HysThreshold 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out double returnValue
%inst
L2-Hys正規化法の縮退．


元関数名(C#): objdetect_HOGDescriptor_L2HysThreshold_get
元DLLエクスポート名: objdetect_HOGDescriptor_L2HysThreshold_get
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_L2HysThreshold_get(cv::HOGDescriptor *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;L2HysThreshold;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_gammaCorrection_get
[32/64bit] cv::HOGDescriptor::gammaCorrection 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
ガンマ補正の前処理が必要かどうかを指定するフラグ．


元関数名(C#): objdetect_HOGDescriptor_gammaCorrection_get
元DLLエクスポート名: objdetect_HOGDescriptor_gammaCorrection_get
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_gammaCorrection_get(cv::HOGDescriptor *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;gammaCorrection ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_nlevels_get
[32/64bit] cv::HOGDescriptor::nlevels 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
検出窓の最大増加数．デフォルト値は64です。
例： samples/tapi/hog.cpp.

元関数名(C#): objdetect_HOGDescriptor_nlevels_get
元DLLエクスポート名: objdetect_HOGDescriptor_nlevels_get
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_nlevels_get(cv::HOGDescriptor *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;nlevels;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_signedGradient_get
[32/64bit] cv::HOGDescriptor::signedGradient 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = var : out int returnValue
%inst
符号付きグラデーションを使用するかどうかを示します。


元関数名(C#): objdetect_HOGDescriptor_signedGradient_get
元DLLエクスポート名: objdetect_HOGDescriptor_signedGradient_get
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_signedGradient_get(cv::HOGDescriptor *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;signedGradient;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_winSize_set
[32/64bit] cv::HOGDescriptor::winSize 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_SIZE : Size value
%inst
検出ウィンドウサイズ．ブロックサイズとブロックストライドに合わせます．デフォルト値は Size(64,128).
例： samples/cpp/train_HOG.cpp.

元関数名(C#): objdetect_HOGDescriptor_winSize_set
元DLLエクスポート名: objdetect_HOGDescriptor_winSize_set
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_winSize_set(cv::HOGDescriptor *obj, MyCvSize value)
{
    BEGIN_WRAP
    obj-&amp;gt;winSize = cpp(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_blockSize_set
[32/64bit] cv::HOGDescriptor::blockSize 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_SIZE : Size value
%inst
ブロックサイズ（ピクセル）。セルサイズに合わせます。初期値はSize(16,16)です。


元関数名(C#): objdetect_HOGDescriptor_blockSize_set
元DLLエクスポート名: objdetect_HOGDescriptor_blockSize_set
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_blockSize_set(cv::HOGDescriptor *obj, MyCvSize value)
{
    BEGIN_WRAP
    obj-&amp;gt;blockSize = cpp(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_blockStride_set
[32/64bit] cv::HOGDescriptor::blockStride 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_SIZE : Size value
%inst
ブロックのストライド。セルサイズの倍数である必要があります。初期値は Size(8,8) です。


元関数名(C#): objdetect_HOGDescriptor_blockStride_set
元DLLエクスポート名: objdetect_HOGDescriptor_blockStride_set
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_blockStride_set(cv::HOGDescriptor *obj, MyCvSize value)
{
    BEGIN_WRAP
    obj-&amp;gt;blockStride = cpp(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_cellSize_set
[32/64bit] cv::HOGDescriptor::cellSize 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = ARGS_SIZE : Size value
%inst
セルの大きさ。初期値はSize(8,8)です。


元関数名(C#): objdetect_HOGDescriptor_cellSize_set
元DLLエクスポート名: objdetect_HOGDescriptor_cellSize_set
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_cellSize_set(cv::HOGDescriptor *obj, MyCvSize value)
{
    BEGIN_WRAP
    obj-&amp;gt;cellSize = cpp(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_nbins_set
[32/64bit] cv::HOGDescriptor::nbins 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = int : int value
%inst
グラデーションのヒストグラムの計算に使われるビンの数．既定値は9です．


元関数名(C#): objdetect_HOGDescriptor_nbins_set
元DLLエクスポート名: objdetect_HOGDescriptor_nbins_set
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_nbins_set(cv::HOGDescriptor *obj, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;nbins = value;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_derivAperture_set
[32/64bit] cv::HOGDescriptor::derivAperture 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = int : int value
%inst
ドキュメントなし


元関数名(C#): objdetect_HOGDescriptor_derivAperture_set
元DLLエクスポート名: objdetect_HOGDescriptor_derivAperture_set
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_derivAperture_set(cv::HOGDescriptor *obj, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;derivAperture = value;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_winSigma_set
[32/64bit] cv::HOGDescriptor::winSigma 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = double : double value
%inst
ガウス平滑化窓のパラメータ．


元関数名(C#): objdetect_HOGDescriptor_winSigma_set
元DLLエクスポート名: objdetect_HOGDescriptor_winSigma_set
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_winSigma_set(cv::HOGDescriptor *obj, double value)
{
    BEGIN_WRAP
    obj-&amp;gt;winSigma = value;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_histogramNormType_set
[32/64bit] cv::HOGDescriptor::histogramNormType 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = int : int value
%inst
histogramNormType


元関数名(C#): objdetect_HOGDescriptor_histogramNormType_set
元DLLエクスポート名: objdetect_HOGDescriptor_histogramNormType_set
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_histogramNormType_set(cv::HOGDescriptor *obj, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;histogramNormType = static_cast&amp;lt;cv::HOGDescriptor::HistogramNormType&amp;gt;(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_L2HysThreshold_set
[32/64bit] cv::HOGDescriptor::L2HysThreshold 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = double : double value
%inst
L2-Hys正規化法の縮退．


元関数名(C#): objdetect_HOGDescriptor_L2HysThreshold_set
元DLLエクスポート名: objdetect_HOGDescriptor_L2HysThreshold_set
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_L2HysThreshold_set(cv::HOGDescriptor *obj, double value)
{
    BEGIN_WRAP
    obj-&amp;gt;L2HysThreshold = value;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_gammaCorrection_set
[32/64bit] cv::HOGDescriptor::gammaCorrection 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = int : int value
%inst
ガンマ補正の前処理が必要かどうかを指定するフラグ．


元関数名(C#): objdetect_HOGDescriptor_gammaCorrection_set
元DLLエクスポート名: objdetect_HOGDescriptor_gammaCorrection_set
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_gammaCorrection_set(cv::HOGDescriptor *obj, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;gammaCorrection = (value != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_nlevels_set
[32/64bit] cv::HOGDescriptor::nlevels 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = int : int value
%inst
検出窓の最大増加数．デフォルト値は64です。
例： samples/tapi/hog.cpp.

元関数名(C#): objdetect_HOGDescriptor_nlevels_set
元DLLエクスポート名: objdetect_HOGDescriptor_nlevels_set
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_nlevels_set(cv::HOGDescriptor *obj, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;nlevels = value;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_HOGDescriptor_signedGradient_set
[32/64bit] cv::HOGDescriptor::signedGradient 変数に格納します
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = int : int value
%inst
符号付きグラデーションを使用するかどうかを示します。


元関数名(C#): objdetect_HOGDescriptor_signedGradient_set
元DLLエクスポート名: objdetect_HOGDescriptor_signedGradient_set
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_HOGDescriptor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_HOGDescriptor_signedGradient_set(cv::HOGDescriptor *obj, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;signedGradient = (value != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_HOGDescriptor

%index
objdetect_QRCodeDetector_new
[32/64bit] cv::QRCodeDetector のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst



元関数名(C#): objdetect_QRCodeDetector_new
元DLLエクスポート名: objdetect_QRCodeDetector_new
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_QRCodeDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_QRCodeDetector_new(cv::QRCodeDetector **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::QRCodeDetector();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_QRCodeDetector

%index
objdetect_QRCodeDetector_delete
[32/64bit] cv::QRCodeDetector のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst



元関数名(C#): objdetect_QRCodeDetector_delete
元DLLエクスポート名: objdetect_QRCodeDetector_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_QRCodeDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_QRCodeDetector_delete(cv::QRCodeDetector *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_QRCodeDetector

%index
objdetect_QRCodeDetector_setEpsX
[32/64bit] QRコードのストップマーカー検出の水平走査時に使用するイプシロンを設定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double epsX
%inst
元関数名(C#): objdetect_QRCodeDetector_setEpsX
元DLLエクスポート名: objdetect_QRCodeDetector_setEpsX
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_QRCodeDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_QRCodeDetector_setEpsX(cv::QRCodeDetector *obj, double epsX)
{
    BEGIN_WRAP
    obj-&amp;gt;setEpsX(epsX);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_QRCodeDetector

%index
objdetect_QRCodeDetector_setEpsY
[32/64bit] は、QRコードのストップマーカ検出の垂直走査時に使用するイプシロンを設定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double epsY
%inst
元関数名(C#): objdetect_QRCodeDetector_setEpsY
元DLLエクスポート名: objdetect_QRCodeDetector_setEpsY
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_QRCodeDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_QRCodeDetector_setEpsY(cv::QRCodeDetector *obj, double epsY)
{
    BEGIN_WRAP
    obj-&amp;gt;setEpsY(epsY);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_QRCodeDetector

%index
objdetect_QRCodeDetector_detect
[32/64bit] 画像中のQRコードを検出し、そのコードを含む四角形を返します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr img
p3 = sptr : IntPtr points
p4 = var : out int returnValue
%inst
元関数名(C#): objdetect_QRCodeDetector_detect
元DLLエクスポート名: objdetect_QRCodeDetector_detect
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_QRCodeDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_QRCodeDetector_detect(
    cv::QRCodeDetector *obj, cv::_InputArray *img, std::vector&amp;lt;cv::Point2f&amp;gt; *points, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;detect(*img, *points) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_QRCodeDetector

%index
objdetect_QRCodeDetector_decode
[32/64bit] detect()メソッドで見つかった画像中のQRコードをデコードします。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr img
p3 = sptr : IntPtr points
p4 = sptr : IntPtr straightQrCode
p5 = sptr : IntPtr returnValue
%inst
UTF8 エンコードされた出力文字列、またはコードがデコードできない場合は空の文字列を返します。

元関数名(C#): objdetect_QRCodeDetector_decode
元DLLエクスポート名: objdetect_QRCodeDetector_decode
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_QRCodeDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_QRCodeDetector_decode(
    cv::QRCodeDetector *obj, cv::_InputArray *img, std::vector&amp;lt;cv::Point2f&amp;gt; *points, cv::_OutputArray *straight_qrcode, std::string *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;decode(*img, *points, entity(straight_qrcode));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_QRCodeDetector

%index
objdetect_QRCodeDetector_detectAndDecode
[32/64bit] QRコードの検出とデコードの両方を行います。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr img
p3 = sptr : IntPtr points
p4 = sptr : IntPtr straightQrCode
p5 = sptr : IntPtr returnValue
%inst
元関数名(C#): objdetect_QRCodeDetector_detectAndDecode
元DLLエクスポート名: objdetect_QRCodeDetector_detectAndDecode
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_QRCodeDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_QRCodeDetector_detectAndDecode(
    cv::QRCodeDetector *obj, cv::_InputArray *img, std::vector&amp;lt;cv::Point2f&amp;gt; *points,
    cv::_OutputArray *straight_qrcode, std::string *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;detectAndDecode(*img, *points, entity(straight_qrcode));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_QRCodeDetector

%index
objdetect_QRCodeDetector_detectMulti
[32/64bit] 画像中のQRコードを検出し，そのコードを含む四角形のベクトルを返す．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr img
p3 = sptr : IntPtr points
p4 = var : out int returnValue
%inst
元関数名(C#): objdetect_QRCodeDetector_detectMulti
元DLLエクスポート名: objdetect_QRCodeDetector_detectMulti
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_QRCodeDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_QRCodeDetector_detectMulti(
    cv::QRCodeDetector* obj, cv::_InputArray* img, std::vector&amp;lt;cv::Point2f&amp;gt;* points, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;detectMulti(*img, *points) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_QRCodeDetector

%index
objdetect_QRCodeDetector_decodeMulti
[32/64bit] detect()メソッドで見つかった画像のQRコードをデコードします。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr img
p3 = sptr : IntPtr points
p4 = sptr : IntPtr decodedInfo
p5 = sptr : IntPtr straightQrCode
p6 = var : out int returnValue
%inst
元関数名(C#): objdetect_QRCodeDetector_decodeMulti
元DLLエクスポート名: objdetect_QRCodeDetector_decodeMulti
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_QRCodeDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_QRCodeDetector_decodeMulti(
    cv::QRCodeDetector* obj, cv::_InputArray* img, std::vector&amp;lt;cv::Point2f&amp;gt;* points, std::vector&amp;lt;std::string&amp;gt;* decoded_info, std::vector&amp;lt;cv::Mat&amp;gt;* straight_qrcode, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;decodeMulti(*img, *points, *decoded_info, *straight_qrcode) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_QRCodeDetector

%index
objdetect_QRCodeDetector_decodeMulti_NoStraightQrCode
[32/64bit] detect()メソッドで見つかった画像のQRコードをデコードします。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr img
p3 = sptr : IntPtr points
p4 = sptr : IntPtr decodedInfo
p5 = var : out int returnValue
%inst
元関数名(C#): objdetect_QRCodeDetector_decodeMulti_NoStraightQrCode
元DLLエクスポート名: objdetect_QRCodeDetector_decodeMulti_NoStraightQrCode
参照元CSファイル: Internal\PInvoke\NativeMethods\objdetect\NativeMethods_objdetect_QRCodeDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) objdetect_QRCodeDetector_decodeMulti_NoStraightQrCode(
    cv::QRCodeDetector* obj, cv::_InputArray* img, std::vector&amp;lt;cv::Point2f&amp;gt;* points, std::vector&amp;lt;std::string&amp;gt;* decoded_info, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;decodeMulti(*img, *points, *decoded_info) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_objdetect_QRCodeDetector

%index
photo_inpaint
[32/64bit] region neighborhood を利用して，画像中の選択領域を復元します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = sptr : IntPtr inpaintMask
p3 = sptr : IntPtr dst
p4 = double : double inpaintRadius
p5 = int : int flags
%inst
この関数は，選択された画像領域を，その領域の境界付近のピクセルから再構成します．この関数は，スキャンした写真から埃や傷を除去したり，静止画像やビデオから望ましくないオブジェクトを除去したりするために利用できます．詳しくは http://en.wikipedia.org/wiki/Inpainting をご覧ください。

inpainting techniqueを使った例は，opencv_source_code/samples/cpp/inpaint.cppにあります．

(Python) inpainting technique を使用した例は、opencv_source_code/samples/python/inpaint.py にあります。

元関数名(C#): photo_inpaint
元DLLエクスポート名: photo_inpaint
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_inpaint(cv::_InputArray *src, cv::_InputArray *inpaintMask,
    cv::_OutputArray *dst, double inpaintRadius, int flags)
{
    BEGIN_WRAP
    cv::inpaint(*src, *inpaintMask, *dst, inpaintRadius, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo

%index
photo_fastNlMeansDenoising
[32/64bit] Non-Local Means Denoising アルゴリズム http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/ を使用して、いくつかの計算最適化を行い、画像のノイズ除去を実行します。ノイズは，ガウスホワイトノイズを想定しています．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = float : float h
p4 = int : int templateWindowSize
p5 = int : int searchWindowSize
%inst
この機能は、グレースケール画像に適用することを想定しています。色付きの画像の場合は、 fastNlMeansDenoisingColored をご覧ください。この関数の高度な利用法として，異なる色空間を持つカラー画像を手動でノイズ除去することができます．FastNlMeansDenoisingColoredでは，画像をCIELAB色空間に変換し，L成分とAB成分をそれぞれ異なるhパラメータで別々にノイズ除去するという手法が用いられています．

元関数名(C#): photo_fastNlMeansDenoising
元DLLエクスポート名: photo_fastNlMeansDenoising
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_fastNlMeansDenoising(cv::_InputArray *src, cv::_OutputArray *dst, float h,
    int templateWindowSize, int searchWindowSize)
{
    BEGIN_WRAP
    cv::fastNlMeansDenoising(*src, *dst, h, templateWindowSize, searchWindowSize);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo

%index
photo_fastNlMeansDenoisingColored
[32/64bit] fastNlMeansDenoising関数を，色付き画像用に改良します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = float : float h
p4 = float : float hColor
p5 = int : int templateWindowSize
p6 = int : int searchWindowSize
%inst
この関数は，画像を CIELAB 色空間に変換した後，fastNlMeansDenoising 関数を用いて，与えられた h パラメータで L 成分と AB 成分を個別にノイズ除去します．

元関数名(C#): photo_fastNlMeansDenoisingColored
元DLLエクスポート名: photo_fastNlMeansDenoisingColored
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_fastNlMeansDenoisingColored(cv::_InputArray *src, cv::_OutputArray *dst,
    float h, float hColor, int templateWindowSize, int searchWindowSize)
{
    BEGIN_WRAP
    cv::fastNlMeansDenoisingColored(*src, *dst, h, hColor, templateWindowSize, searchWindowSize);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo

%index
photo_fastNlMeansDenoisingMulti
[32/64bit] fastNlMeansDenoising関数を，短時間に連続して撮影された画像群用に変更しました．例えば、ビデオなどです。このバージョンの関数は，グレースケール画像や，色空間を使った手動操作のためのものです．詳細は， http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.131.6394 を参照してください．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr[] srcImgs
p2 = int : int srcImgsLength
p3 = sptr : IntPtr dst
p4 = int : int imgToDenoiseIndex
p5 = int : int temporalWindowSize
p6 = float : float h
p7 = int : int templateWindowSize
p8 = int : int searchWindowSize
%inst
元関数名(C#): photo_fastNlMeansDenoisingMulti
元DLLエクスポート名: photo_fastNlMeansDenoisingMulti
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_fastNlMeansDenoisingMulti(cv::_InputArray ** srcImgs, int srcImgsLength, 
    cv::_OutputArray *dst, int imgToDenoiseIndex, int temporalWindowSize,
    float h, int templateWindowSize, int searchWindowSize)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::_InputArray&amp;gt; srcImgsVec(srcImgsLength);
    for (int i = 0; i &amp;lt; srcImgsLength; i++)    
        srcImgsVec[i] = *srcImgs[i];
    cv::fastNlMeansDenoisingMulti(srcImgsVec, *dst, imgToDenoiseIndex, temporalWindowSize, h, templateWindowSize, searchWindowSize);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo

%index
photo_fastNlMeansDenoisingColoredMulti
[32/64bit] FastNlMeansDenoisingMulti 関数を，カラー画像シーケンス用に改良しました．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr[] srcImgs
p2 = int : int srcImgsLength
p3 = sptr : IntPtr dst
p4 = int : int imgToDenoiseIndex
p5 = int : int temporalWindowSize
p6 = float : float h
p7 = float : float hColor
p8 = int : int templateWindowSize
p9 = int : int searchWindowSize
%inst
この関数は，画像をCIELAB色空間に変換した後，fastNlMeansDenoisingMulti関数を用いて，与えられたhパラメータでL成分とAB成分を別々にノイズ除去します．

元関数名(C#): photo_fastNlMeansDenoisingColoredMulti
元DLLエクスポート名: photo_fastNlMeansDenoisingColoredMulti
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_fastNlMeansDenoisingColoredMulti(cv::_InputArray **srcImgs, int srcImgsLength, 
    cv::_OutputArray *dst, int imgToDenoiseIndex, int temporalWindowSize,
    float h, float hColor, int templateWindowSize, int searchWindowSize)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::_InputArray&amp;gt; srcImgsVec(srcImgsLength);
    for (int i = 0; i &amp;lt; srcImgsLength; i++)
        srcImgsVec[i] = *srcImgs[i];
    cv::fastNlMeansDenoisingColoredMulti(srcImgsVec, *dst, imgToDenoiseIndex, temporalWindowSize, h, hColor, templateWindowSize, searchWindowSize);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo

%index
photo_denoise_TVL1
[32/64bit] Primal-dualアルゴリズムは，特殊な変分問題（ある関数を最小化するための関数を求める問題）を解くためのアルゴリズムです．特に、画像のノイズ除去は、変分問題と見なすことができるので、プライマル・デュアル・アルゴリズムを使ってノイズ除去を行うことができ、まさにそれを実現しています。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr[] observations
p2 = int : int observationsSize
p3 = sptr : IntPtr result
p4 = double : double lambda
p5 = int : int niters
%inst
この実装は、2013年7月のブログエントリ[177]から取ったもので、Pythonですぐに使えるソースコードも含まれていたことに注意してください。その後，2013年7月末にVadim PisarevskyによってopenCVを用いてC++に書き直され，最終的には後続の著者によって若干の改良が加えられました．このアルゴリズムの詳細な議論と正当性は[42]に記載されていますが，ここでは[177]に倣ってざっと目を通すのがよいでしょう．まず，1バイトのグレイレベル画像を，画素の矩形領域からの関数と考えます（これは，集合 ??? -? ??? ????）。1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\このように考えて、同じ大きさの画像\(x\)が与えられたとき、ノイズ化された画像を\(f_i\)とします。どれくらいひどいかを式で表すと、[??＞?＜?＞?＜?＞]ということになります。最初の付記は，画像が滑らかであること（理想的には，勾配がゼロであること，つまり，一定であること）を示し，2番目の付記は，結果が我々が得た観測値に近いものであることを示しています。????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? )

元関数名(C#): photo_denoise_TVL1
元DLLエクスポート名: photo_denoise_TVL1
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_denoise_TVL1(
    cv::Mat **observations, int observationsSize, cv::Mat *result, double lambda, int niters)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; observationsVec(observationsSize);
    for (int i = 0; i &amp;lt; observationsSize; i++)
    {
        observationsVec[i] = *observations[i];
    }
    cv::denoise_TVL1(observationsVec, *result, lambda, niters);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo

%index
photo_decolor
[32/64bit] カラー画像をグレースケール画像に変換します。これは，デジタル印刷や白黒写真のレンダリングなどの基本的なツールであり，多くのシングルチャンネル画像処理アプリケーションでも使用されています[155]．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr grayscale
p3 = sptr : IntPtr color_boost
%inst
この機能は，カラー画像に適用されます．

元関数名(C#): photo_decolor
元DLLエクスポート名: photo_decolor
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_decolor(
    cv::_InputArray *src, cv::_OutputArray *grayscale, cv::_OutputArray *color_boost)
{
    BEGIN_WRAP
    cv::decolor(*src, *grayscale, *color_boost);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo

%index
photo_seamlessClone
[32/64bit] 画像編集作業には，大局的な変化（色や濃度の補正，フィルタ，変形）と，選択範囲に関わる局所的な変化があります．ここでは，手動で選択した領域（ROI）に限定した局所的な変更を，シームレスかつ容易に実現することに関心がある．その変化の程度は，わずかな歪みから新しいコンテンツへの完全な置き換えまで様々である[192]．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = sptr : IntPtr mask
p4 = ARGS_POINT : Point p
p5 = sptr : IntPtr blend
p6 = int : int flags
%inst
例： samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp．

元関数名(C#): photo_seamlessClone
元DLLエクスポート名: photo_seamlessClone
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_seamlessClone(
    cv::_InputArray *src, cv::_InputArray *dst, cv::_InputArray *mask, MyCvPoint p,
    cv::_OutputArray *blend, int flags)
{
    BEGIN_WRAP
    cv::seamlessClone(*src, *dst, entity(mask), cpp(p), *blend, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo

%index
photo_colorChange
[32/64bit] 元のカラー画像が与えられると，色の異なる2つのバージョンをシームレスに混合することができます．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr mask
p3 = sptr : IntPtr dst
p4 = float : float red_mul
p5 = float : float green_mul
p6 = float : float blue_mul
%inst
例：samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp.

元関数名(C#): photo_colorChange
元DLLエクスポート名: photo_colorChange
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_colorChange(
    cv::_InputArray *src, cv::_InputArray *mask, cv::_OutputArray *dst, float red_mul,
    float green_mul, float blue_mul)
{
    BEGIN_WRAP
    cv::colorChange(*src, entity(mask), *dst, red_mul, green_mul, blue_mul);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo

%index
photo_illuminationChange
[32/64bit] 選択範囲内のグラデーションフィールドに適切な非線形変換を適用し、ポアソンソルバーで積分し直すことで、画像の見かけ上の照明を局所的に変更します。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = sptr : IntPtr mask
p3 = sptr : IntPtr dst
p4 = float : float alpha
p5 = float : float beta
%inst
例：samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp.

元関数名(C#): photo_illuminationChange
元DLLエクスポート名: photo_illuminationChange
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_illuminationChange(
    cv::_InputArray *src, cv::_InputArray *mask, cv::_OutputArray *dst,
    float alpha, float beta = 0.4f)
{
    BEGIN_WRAP
    cv::illuminationChange(*src, entity(mask), *dst, alpha, beta);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo

%index
photo_textureFlattening
[32/64bit] ポアソンソルバーで積分する前に、エッジ位置のグラデーションのみを保持することで、選択された領域のテクスチャを洗い流し、その内容をフラットにすることができます。ここではCanny Edge Detectorを使用しています。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr mask
p3 = sptr : IntPtr dst
p4 = float : float low_threshold
p5 = float : float high_threshold
p6 = int : int kernel_size
%inst
注）このアルゴリズムは、ソース画像の色がデスティネーションの色に近いことを前提としています。例：samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp.

元関数名(C#): photo_textureFlattening
元DLLエクスポート名: photo_textureFlattening
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_textureFlattening(
    cv::_InputArray *src, cv::_InputArray *mask, cv::_OutputArray *dst,
    float low_threshold, float high_threshold, int kernel_size)
{
    BEGIN_WRAP
    cv::textureFlattening(*src, entity(mask), *dst, low_threshold, high_threshold, kernel_size);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo

%index
photo_edgePreservingFilter
[32/64bit] フィルタリングは、画像・映像処理の基本的な操作です。エッジを保持する平滑化フィルタは，さまざまな用途で使用されています[86]．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int flags
p4 = float : float sigma_s
p5 = float : float sigma_r
%inst
例： samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp.

元関数名(C#): photo_edgePreservingFilter
元DLLエクスポート名: photo_edgePreservingFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_edgePreservingFilter(
    cv::_InputArray *src, cv::_OutputArray *dst, int flags,    float sigma_s, float sigma_r)
{
    BEGIN_WRAP
    cv::edgePreservingFilter(*src, *dst, flags, sigma_s, sigma_r);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo

%index
photo_detailEnhance
[32/64bit] 特定の画像のディテールを強調するフィルタです。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = float : float sigma_s
p4 = float : float sigma_r
%inst
例： samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp.

元関数名(C#): photo_detailEnhance
元DLLエクスポート名: photo_detailEnhance
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_detailEnhance(
    cv::_InputArray *src, cv::_OutputArray *dst, float sigma_s,    float sigma_r)
{
    BEGIN_WRAP
    cv::detailEnhance(*src, *dst, sigma_s, sigma_r);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo

%index
photo_pencilSketch
[32/64bit] 鉛筆で描いたようなノンフォトリアリスティックな線画です。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst1
p3 = sptr : IntPtr dst2
p4 = float : float sigma_s
p5 = float : float sigma_r
p6 = float : float shade_factor
%inst
例： samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp.

元関数名(C#): photo_pencilSketch
元DLLエクスポート名: photo_pencilSketch
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_pencilSketch(
    cv::_InputArray *src, cv::_OutputArray *dst1, cv::_OutputArray *dst2,
    float sigma_s, float sigma_r, float shade_factor)
{
    BEGIN_WRAP
    cv::pencilSketch(*src, *dst1, *dst2, sigma_s, sigma_r, shade_factor);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo

%index
photo_stylization
[32/64bit] スタイライゼーションは、フォトリアリズムにこだわらず、多様な効果を持つデジタル画像を作り出すことを目的としています。エッジを考慮したフィルターは、コントラストの低い領域を抽象化する一方で、コントラストの高い特徴を維持または強調することができるため、スタイライゼーションに最適です。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = float : float sigma_s
p4 = float : float sigma_r
%inst
例： samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp.

元関数名(C#): photo_stylization
元DLLエクスポート名: photo_stylization
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_stylization(
    cv::_InputArray *src, cv::_OutputArray *dst, float sigma_s,    float sigma_r)
{
    BEGIN_WRAP
    cv::stylization(*src, *dst, sigma_s, sigma_r);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo

%index
photo_createCalibrateDebevec
[32/64bit] CalibrateDebevecオブジェクトを作成します。
%prm
p1,p2,p3,p4
p1 = int : int samples
p2 = float : float lambda
p3 = int : int random
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): photo_createCalibrateDebevec
元DLLエクスポート名: photo_createCalibrateDebevec
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_createCalibrateDebevec(
    int samples, float lambda, int random, cv::Ptr&amp;lt;cv::CalibrateDebevec&amp;gt; **returnValue) 
{
    BEGIN_WRAP
    *returnValue = clone(cv::createCalibrateDebevec(samples, lambda, random != 0));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_Ptr_CalibrateDebevec_delete
[32/64bit] cv::CalibrateDebevec のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
逆カメラ応答関数は，線形システムとしての目的関数を最小化することにより，各輝度値に対して抽出されます．目的関数は，すべての画像の同じ位置にあるピクセル値を用いて構成され，結果をより滑らかにするために追加の項が加えられます．

詳細は[55]を参照してください。


元関数名(C#): photo_Ptr_CalibrateDebevec_delete
元DLLエクスポート名: photo_Ptr_CalibrateDebevec_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_Ptr_CalibrateDebevec_delete(cv::Ptr&amp;lt;cv::CalibrateDebevec&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_Ptr_CalibrateDebevec_get
[32/64bit] cv::CalibrateDebevec のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
逆カメラ応答関数は，線形システムとしての目的関数を最小化することにより，各輝度値に対して抽出されます．目的関数は，すべての画像の同じ位置にあるピクセル値を用いて構成され，結果をより滑らかにするために追加の項が加えられます．

詳細は[55]を参照してください。


元関数名(C#): photo_Ptr_CalibrateDebevec_get
元DLLエクスポート名: photo_Ptr_CalibrateDebevec_get
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_Ptr_CalibrateDebevec_get(cv::Ptr&amp;lt;cv::CalibrateDebevec&amp;gt; *obj, cv::CalibrateDebevec **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_CalibrateDebevec_getLambda
[32/64bit] photo_CalibrateDebevec_getLambda
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): photo_CalibrateDebevec_getLambda
元DLLエクスポート名: photo_CalibrateDebevec_getLambda
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_CalibrateDebevec_getLambda(cv::CalibrateDebevec *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getLambda();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_CalibrateDebevec_setLambda
[32/64bit] photo_CalibrateDebevec_setLambda
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float value
%inst
元関数名(C#): photo_CalibrateDebevec_setLambda
元DLLエクスポート名: photo_CalibrateDebevec_setLambda
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_CalibrateDebevec_setLambda(cv::CalibrateDebevec *obj, float value)
{
    BEGIN_WRAP
    obj-&amp;gt;setLambda(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_CalibrateDebevec_getSamples
[32/64bit] photo_CalibrateDebevec_getSamples
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): photo_CalibrateDebevec_getSamples
元DLLエクスポート名: photo_CalibrateDebevec_getSamples
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_CalibrateDebevec_getSamples(cv::CalibrateDebevec *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getLambda();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_CalibrateDebevec_setSamples
[32/64bit] photo_CalibrateDebevec_setSamples
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): photo_CalibrateDebevec_setSamples
元DLLエクスポート名: photo_CalibrateDebevec_setSamples
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_CalibrateDebevec_setSamples(cv::CalibrateDebevec *obj, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;setLambda(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_CalibrateDebevec_getRandom
[32/64bit] photo_CalibrateDebevec_getRandom
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): photo_CalibrateDebevec_getRandom
元DLLエクスポート名: photo_CalibrateDebevec_getRandom
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_CalibrateDebevec_getRandom(cv::CalibrateDebevec *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getRandom() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_CalibrateDebevec_setRandom
[32/64bit] photo_CalibrateDebevec_setRandom
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): photo_CalibrateDebevec_setRandom
元DLLエクスポート名: photo_CalibrateDebevec_setRandom
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_CalibrateDebevec_setRandom(cv::CalibrateDebevec *obj, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;setRandom(value != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_createCalibrateRobertson
[32/64bit] CalibrateRobertson オブジェクトを作成します．
%prm
p1,p2,p3
p1 = int : int maxIter
p2 = float : float threshold
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): photo_createCalibrateRobertson
元DLLエクスポート名: photo_createCalibrateRobertson
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_createCalibrateRobertson(
    int max_iter, float threshold, cv::Ptr&amp;lt;cv::CalibrateRobertson&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(cv::createCalibrateRobertson(max_iter, threshold));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_Ptr_CalibrateRobertson_delete
[32/64bit] cv::CalibrateRobertson のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
逆カメラ応答関数は，線形システムとしての目的関数を最小化することにより，各輝度値に対して抽出されます．このアルゴリズムは，すべての画像ピクセルを使用します．

詳細は[204]を参照してください。


元関数名(C#): photo_Ptr_CalibrateRobertson_delete
元DLLエクスポート名: photo_Ptr_CalibrateRobertson_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_Ptr_CalibrateRobertson_delete(cv::Ptr&amp;lt;cv::CalibrateRobertson&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_Ptr_CalibrateRobertson_get
[32/64bit] cv::CalibrateRobertson のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
逆カメラ応答関数は，線形システムとしての目的関数を最小化することにより，各輝度値に対して抽出されます．このアルゴリズムは，すべての画像ピクセルを使用します．

詳細は[204]を参照してください。


元関数名(C#): photo_Ptr_CalibrateRobertson_get
元DLLエクスポート名: photo_Ptr_CalibrateRobertson_get
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_Ptr_CalibrateRobertson_get(cv::Ptr&amp;lt;cv::CalibrateRobertson&amp;gt; *obj, cv::CalibrateRobertson **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_CalibrateRobertson_getMaxIter
[32/64bit] photo_CalibrateRobertson_getMaxIter
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): photo_CalibrateRobertson_getMaxIter
元DLLエクスポート名: photo_CalibrateRobertson_getMaxIter
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_CalibrateRobertson_getMaxIter(cv::CalibrateRobertson *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getMaxIter();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_CalibrateRobertson_setMaxIter
[32/64bit] photo_CalibrateRobertson_setMaxIter
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): photo_CalibrateRobertson_setMaxIter
元DLLエクスポート名: photo_CalibrateRobertson_setMaxIter
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_CalibrateRobertson_setMaxIter(cv::CalibrateRobertson *obj, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;setMaxIter(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_CalibrateRobertson_getThreshold
[32/64bit] photo_CalibrateRobertson_getThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): photo_CalibrateRobertson_getThreshold
元DLLエクスポート名: photo_CalibrateRobertson_getThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_CalibrateRobertson_getThreshold(cv::CalibrateRobertson *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_CalibrateRobertson_setThreshold
[32/64bit] photo_CalibrateRobertson_setThreshold
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float value
%inst
元関数名(C#): photo_CalibrateRobertson_setThreshold
元DLLエクスポート名: photo_CalibrateRobertson_setThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_CalibrateRobertson_setThreshold(cv::CalibrateRobertson *obj, float value)
{
    BEGIN_WRAP
    obj-&amp;gt;setThreshold(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_CalibrateRobertson_getRadiance
[32/64bit] photo_CalibrateRobertson_getRadiance
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr returnValue
%inst
元関数名(C#): photo_CalibrateRobertson_getRadiance
元DLLエクスポート名: photo_CalibrateRobertson_getRadiance
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_CalibrateRobertson_getRadiance(cv::CalibrateRobertson *obj, cv::Mat *returnValue)
{
    BEGIN_WRAP
    obj-&amp;gt;getRadiance().copyTo(*returnValue);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_CalibrateCRF_process
[32/64bit] 逆カメラ応答関数を復元します．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr[] srcImgs
p3 = int : int srcImgsLength
p4 = sptr : IntPtr dst
p5 = var : [In, MarshalAs(UnmanagedType.LPArray)] float[] times
%inst
元関数名(C#): photo_CalibrateCRF_process
元DLLエクスポート名: photo_CalibrateCRF_process
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_CalibrateCRF_process(
    cv::CalibrateCRF *obj, 
    cv::Mat ** srcImgs, int srcImgsLength, cv::_OutputArray *dst, float* times)
{
    BEGIN_WRAP

    // Build Mat Vector of images
    std::vector&amp;lt;cv::Mat&amp;gt; srcImgsVec(srcImgsLength);

    // Build float Vector of times
    std::vector&amp;lt;float&amp;gt; times_vec(srcImgsLength);
    
    for (int i = 0; i &amp;lt; srcImgsLength; i++) {
        srcImgsVec[i] = *srcImgs[i];
        times_vec[i] = times[i];
    }

    obj-&amp;gt;process(srcImgsVec, *dst, times_vec);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_createMergeDebevec
[32/64bit] MergeDebevecオブジェクトを作成します。
%prm

%inst
元関数名(C#): photo_createMergeDebevec
元DLLエクスポート名: photo_createMergeDebevec
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::Ptr&amp;lt;cv::MergeDebevec&amp;gt;*) photo_createMergeDebevec()
{
    return clone(cv::createMergeDebevec());
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_Ptr_MergeDebevec_delete
[32/64bit] cv::MergeDebevec のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
結果として得られるHDR画像は、露出値とカメラレスポンスを考慮した露出の加重平均として計算されます。

詳細は[55]を参照してください。


元関数名(C#): photo_Ptr_MergeDebevec_delete
元DLLエクスポート名: photo_Ptr_MergeDebevec_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) photo_Ptr_MergeDebevec_delete(cv::Ptr&amp;lt;cv::MergeDebevec&amp;gt;* obj)
{
    delete obj;
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_Ptr_MergeDebevec_get
[32/64bit] cv::MergeDebevec をメモリコピーします
%prm
p1
p1 = sptr : IntPtr obj
%inst
結果として得られるHDR画像は、露出値とカメラレスポンスを考慮した露出の加重平均として計算されます。

詳細は[55]を参照してください。


元関数名(C#): photo_Ptr_MergeDebevec_get
元DLLエクスポート名: photo_Ptr_MergeDebevec_get
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::MergeDebevec*) photo_Ptr_MergeDebevec_get(cv::Ptr&amp;lt;cv::MergeDebevec&amp;gt;* obj)
{
    return obj-&amp;gt;get();
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_createMergeMertens
[32/64bit] MergeMertens オブジェクトを作成します。
%prm

%inst
元関数名(C#): photo_createMergeMertens
元DLLエクスポート名: photo_createMergeMertens
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::Ptr&amp;lt;cv::MergeMertens&amp;gt;*) photo_createMergeMertens()
{
    return clone(cv::createMergeMertens());
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_Ptr_MergeMertens_delete
[32/64bit] cv::MergeMertens のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
ピクセルは、コントラスト、彩度、および露出度測定値を使用して重み付けされ、画像はラプラシアン ピラミッドを使用して結合されます。

結果として得られる画像の重みは、コントラスト、彩度、および露出度の尺度の加重平均として構成されます。

結果として得られた画像はトーンマッピングを必要とせず、255 を乗じることで 8 ビット画像に変換できますが、ガンマ補正やリニアトーンマッピングを行うことが推奨されます。

詳細は [167] を参照してください。


元関数名(C#): photo_Ptr_MergeMertens_delete
元DLLエクスポート名: photo_Ptr_MergeMertens_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) photo_Ptr_MergeMertens_delete(cv::Ptr&amp;lt;cv::MergeMertens&amp;gt;* obj)
{
    delete obj;
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_Ptr_MergeMertens_get
[32/64bit] cv::MergeMertens のインスタンスポインタを取得します
%prm
p1
p1 = sptr : IntPtr obj
%inst
ピクセルは、コントラスト、彩度、および露出度測定値を使用して重み付けされ、画像はラプラシアン ピラミッドを使用して結合されます。

結果として得られる画像の重みは、コントラスト、彩度、および露出度の尺度の加重平均として構成されます。

結果として得られた画像はトーンマッピングを必要とせず、255 を乗じることで 8 ビット画像に変換できますが、ガンマ補正やリニアトーンマッピングを行うことが推奨されます。

詳細は [167] を参照してください。


元関数名(C#): photo_Ptr_MergeMertens_get
元DLLエクスポート名: photo_Ptr_MergeMertens_get
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(cv::MergeMertens*) photo_Ptr_MergeMertens_get(cv::Ptr&amp;lt;cv::MergeMertens&amp;gt;* obj)
{
    return obj-&amp;gt;get();
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_MergeExposures_process
[32/64bit] 画像を統合します。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr[] srcImgs
p3 = int : int srcImgsLength
p4 = sptr : IntPtr dst
p5 = var : [In, MarshalAs(UnmanagedType.LPArray)] float[] times
p6 = sptr : IntPtr response
%inst
cv::MergeRobertson, cv::MergeMertens, および cv::MergeDebevec で実装されています．

元関数名(C#): photo_MergeExposures_process
元DLLエクスポート名: photo_MergeExposures_process
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) photo_MergeExposures_process(
    cv::MergeExposures* obj,
    cv::Mat** srcImgs, int srcImgsLength, cv::_OutputArray* dst, float* times, cv::_InputArray* response)
{
    // Build Mat Vector of images
    std::vector&amp;lt;cv::Mat&amp;gt; srcImgsVec(srcImgsLength);

    // Build float Vector of times
    std::vector&amp;lt;float&amp;gt; times_vec(srcImgsLength);

    for (int i = 0; i &amp;lt; srcImgsLength; i++) {
        srcImgsVec[i] = *srcImgs[i];
        times_vec[i] = times[i];
    }

    obj-&amp;gt;process(srcImgsVec, *dst, times_vec, *response);
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_MergeMertens_process
[32/64bit] 画像を統合します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr[] srcImgs
p3 = int : int srcImgsLength
p4 = sptr : IntPtr dst
%inst
cv::MergeExposures を実装しています．

元関数名(C#): photo_MergeMertens_process
元DLLエクスポート名: photo_MergeMertens_process
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_HDR.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(void) photo_MergeMertens_process(
    cv::MergeMertens* obj,
    cv::Mat** srcImgs, int srcImgsLength, cv::_OutputArray* dst)
{
    // Build Mat Vector of images
    std::vector&amp;lt;cv::Mat&amp;gt; srcImgsVec(srcImgsLength);

    // Build float Vector of times
    std::vector&amp;lt;float&amp;gt; times_vec(srcImgsLength);

    for (int i = 0; i &amp;lt; srcImgsLength; i++) {
        srcImgsVec[i] = *srcImgs[i];
    }

    obj-&amp;gt;process(srcImgsVec, *dst);
}

</pre>
}html
%group
NativeMethods_photo_HDR

%index
photo_Tonemap_process
[32/64bit] 画像をトーンマップします．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
%inst
元関数名(C#): photo_Tonemap_process
元DLLエクスポート名: photo_Tonemap_process
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_Tonemap_process(cv::Tonemap *obj, cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    obj-&amp;gt;process(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_Tonemap_getGamma
[32/64bit] photo_Tonemap_getGamma
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): photo_Tonemap_getGamma
元DLLエクスポート名: photo_Tonemap_getGamma
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_Tonemap_getGamma(cv::Tonemap *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getGamma();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_Tonemap_setGamma
[32/64bit] photo_Tonemap_setGamma
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float gamma
%inst
元関数名(C#): photo_Tonemap_setGamma
元DLLエクスポート名: photo_Tonemap_setGamma
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_Tonemap_setGamma(cv::Tonemap *obj, float gamma)
{
    BEGIN_WRAP
    obj-&amp;gt;setGamma(gamma);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_createTonemap
[32/64bit] ガンマ補正を行うシンプルなリニアマッパーを作成します．
%prm
p1,p2
p1 = float : float gamma
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): photo_createTonemap
元DLLエクスポート名: photo_createTonemap
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_createTonemap(float gamma, cv::Ptr&amp;lt;cv::Tonemap&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto p = cv::createTonemap(gamma);
    *returnValue = clone(p);
    END_WRAP  
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_Ptr_Tonemap_delete
[32/64bit] cv::Tonemap のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
トーンマッピングアルゴリズムのベースクラスです。これは、HDR画像を8ビットの範囲にマッピングするためのツールです。


元関数名(C#): photo_Ptr_Tonemap_delete
元DLLエクスポート名: photo_Ptr_Tonemap_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_Ptr_Tonemap_delete(cv::Ptr&amp;lt;cv::Tonemap&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_Ptr_Tonemap_get
[32/64bit] cv::Tonemap のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
トーンマッピングアルゴリズムのベースクラスです。これは、HDR画像を8ビットの範囲にマッピングするためのツールです。


元関数名(C#): photo_Ptr_Tonemap_get
元DLLエクスポート名: photo_Ptr_Tonemap_get
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_Ptr_Tonemap_get(cv::Ptr&amp;lt;cv::Tonemap&amp;gt; *ptr, cv::Tonemap **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_TonemapDrago_getSaturation
[32/64bit] photo_TonemapDrago_getSaturation
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): photo_TonemapDrago_getSaturation
元DLLエクスポート名: photo_TonemapDrago_getSaturation
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_TonemapDrago_getSaturation(cv::TonemapDrago *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getSaturation();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_TonemapDrago_setSaturation
[32/64bit] photo_TonemapDrago_setSaturation
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float saturation
%inst
元関数名(C#): photo_TonemapDrago_setSaturation
元DLLエクスポート名: photo_TonemapDrago_setSaturation
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_TonemapDrago_setSaturation(cv::TonemapDrago *obj, float saturation)
{
    BEGIN_WRAP
    obj-&amp;gt;setSaturation(saturation);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_TonemapDrago_getBias
[32/64bit] photo_TonemapDrago_getBias
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): photo_TonemapDrago_getBias
元DLLエクスポート名: photo_TonemapDrago_getBias
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_TonemapDrago_getBias(cv::TonemapDrago *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getBias();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_TonemapDrago_setBias
[32/64bit] photo_TonemapDrago_setBias
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float bias
%inst
元関数名(C#): photo_TonemapDrago_setBias
元DLLエクスポート名: photo_TonemapDrago_setBias
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_TonemapDrago_setBias(cv::TonemapDrago *obj, float bias)
{
    BEGIN_WRAP
    obj-&amp;gt;setBias(bias);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_createTonemapDrago
[32/64bit] TonemapDragoオブジェクトを作成します。
%prm
p1,p2,p3,p4
p1 = float : float gamma
p2 = float : float saturation
p3 = float : float bias
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): photo_createTonemapDrago
元DLLエクスポート名: photo_createTonemapDrago
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_createTonemapDrago(float gamma, float saturation, float bias, cv::Ptr&amp;lt;cv::TonemapDrago&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto p = cv::createTonemapDrago(gamma, saturation, bias);
    *returnValue = clone(p);
    END_WRAP  
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_Ptr_TonemapDrago_delete
[32/64bit] cv::TonemapDrago のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
Adaptive Logarithmic Mapping は、画像を対数領域でスケーリングする高速なグローバルトーンマッピングアルゴリズムです。

これはグローバルな演算子なので、すべてのピクセルに同じ関数が適用されます。これはバイアスパラメータで制御されます。

オプションとして，[71]で説明されているように，彩度の向上が可能です．

詳細については，[58]を参照してください．


元関数名(C#): photo_Ptr_TonemapDrago_delete
元DLLエクスポート名: photo_Ptr_TonemapDrago_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_Ptr_TonemapDrago_delete(cv::Ptr&amp;lt;cv::TonemapDrago&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_Ptr_TonemapDrago_get
[32/64bit] cv::TonemapDrago のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
Adaptive Logarithmic Mapping は、画像を対数領域でスケーリングする高速なグローバルトーンマッピングアルゴリズムです。

これはグローバルな演算子なので、すべてのピクセルに同じ関数が適用されます。これはバイアスパラメータで制御されます。

オプションとして，[71]で説明されているように，彩度の向上が可能です．

詳細については，[58]を参照してください．


元関数名(C#): photo_Ptr_TonemapDrago_get
元DLLエクスポート名: photo_Ptr_TonemapDrago_get
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_Ptr_TonemapDrago_get(cv::Ptr&amp;lt;cv::TonemapDrago&amp;gt; *ptr, cv::TonemapDrago **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_TonemapReinhard_getIntensity
[32/64bit] photo_TonemapReinhard_getIntensity
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): photo_TonemapReinhard_getIntensity
元DLLエクスポート名: photo_TonemapReinhard_getIntensity
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_TonemapReinhard_getIntensity(cv::TonemapReinhard *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getIntensity();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_TonemapReinhard_setIntensity
[32/64bit] photo_TonemapReinhard_setIntensity
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float intensity
%inst
元関数名(C#): photo_TonemapReinhard_setIntensity
元DLLエクスポート名: photo_TonemapReinhard_setIntensity
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_TonemapReinhard_setIntensity(cv::TonemapReinhard *obj, float intensity)
{
    BEGIN_WRAP
    obj-&amp;gt;setIntensity(intensity);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_TonemapReinhard_getLightAdaptation
[32/64bit] photo_TonemapReinhard_getLightAdaptation
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): photo_TonemapReinhard_getLightAdaptation
元DLLエクスポート名: photo_TonemapReinhard_getLightAdaptation
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_TonemapReinhard_getLightAdaptation(cv::TonemapReinhard *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getLightAdaptation();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_TonemapReinhard_setLightAdaptation
[32/64bit] photo_TonemapReinhard_setLightAdaptation
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float light_adapt
%inst
元関数名(C#): photo_TonemapReinhard_setLightAdaptation
元DLLエクスポート名: photo_TonemapReinhard_setLightAdaptation
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_TonemapReinhard_setLightAdaptation(cv::TonemapReinhard *obj, float light_adapt)
{
    BEGIN_WRAP
    obj-&amp;gt;setLightAdaptation(light_adapt);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_TonemapReinhard_getColorAdaptation
[32/64bit] photo_TonemapReinhard_getColorAdaptation
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): photo_TonemapReinhard_getColorAdaptation
元DLLエクスポート名: photo_TonemapReinhard_getColorAdaptation
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_TonemapReinhard_getColorAdaptation(cv::TonemapReinhard *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getColorAdaptation();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_TonemapReinhard_setColorAdaptation
[32/64bit] photo_TonemapReinhard_setColorAdaptation
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float color_adapt
%inst
元関数名(C#): photo_TonemapReinhard_setColorAdaptation
元DLLエクスポート名: photo_TonemapReinhard_setColorAdaptation
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_TonemapReinhard_setColorAdaptation(cv::TonemapReinhard *obj, float color_adapt)
{
    BEGIN_WRAP
    obj-&amp;gt;setColorAdaptation(color_adapt);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_createTonemapReinhard
[32/64bit] TonemapReinhardオブジェクトを作成します。
%prm
p1,p2,p3,p4,p5
p1 = float : float gamma
p2 = float : float intensity
p3 = float : float light_adapt
p4 = float : float color_adapt
p5 = var : out IntPtr returnValue
%inst
元関数名(C#): photo_createTonemapReinhard
元DLLエクスポート名: photo_createTonemapReinhard
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_createTonemapReinhard(float gamma, float intensity, float light_adapt, float color_adapt, cv::Ptr&amp;lt;cv::TonemapReinhard&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto p = cv::createTonemapReinhard(gamma, intensity, light_adapt, color_adapt);
    *returnValue = clone(p);
    END_WRAP  
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_Ptr_TonemapReinhard_delete
[32/64bit] cv::TonemapReinhard のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
これは、人間の視覚システムをモデルとした、グローバルなトーンマッピング演算子です。

マッピング機能は，光適応と色適応を用いて計算された適応パラメータによって制御されます．

詳細については、[201]を参照してください。


元関数名(C#): photo_Ptr_TonemapReinhard_delete
元DLLエクスポート名: photo_Ptr_TonemapReinhard_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_Ptr_TonemapReinhard_delete(cv::Ptr&amp;lt;cv::TonemapReinhard&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_Ptr_TonemapReinhard_get
[32/64bit] cv::TonemapReinhard のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
これは、人間の視覚システムをモデルとした、グローバルなトーンマッピング演算子です。

マッピング機能は，光適応と色適応を用いて計算された適応パラメータによって制御されます．

詳細については、[201]を参照してください。


元関数名(C#): photo_Ptr_TonemapReinhard_get
元DLLエクスポート名: photo_Ptr_TonemapReinhard_get
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_Ptr_TonemapReinhard_get(cv::Ptr&amp;lt;cv::TonemapReinhard&amp;gt; *ptr, cv::TonemapReinhard **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_TonemapMantiuk_getScale
[32/64bit] photo_TonemapMantiuk_getScale
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): photo_TonemapMantiuk_getScale
元DLLエクスポート名: photo_TonemapMantiuk_getScale
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_TonemapMantiuk_getScale(cv::TonemapMantiuk *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getScale();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_TonemapMantiuk_setScale
[32/64bit] photo_TonemapMantiuk_setScale
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float scale
%inst
元関数名(C#): photo_TonemapMantiuk_setScale
元DLLエクスポート名: photo_TonemapMantiuk_setScale
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_TonemapMantiuk_setScale(cv::TonemapMantiuk *obj, float scale)
{
    BEGIN_WRAP
    obj-&amp;gt;setScale(scale);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_TonemapMantiuk_getSaturation
[32/64bit] photo_TonemapMantiuk_getSaturation
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): photo_TonemapMantiuk_getSaturation
元DLLエクスポート名: photo_TonemapMantiuk_getSaturation
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_TonemapMantiuk_getSaturation(cv::TonemapMantiuk *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getSaturation();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_TonemapMantiuk_setSaturation
[32/64bit] photo_TonemapMantiuk_setSaturation
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float saturation
%inst
元関数名(C#): photo_TonemapMantiuk_setSaturation
元DLLエクスポート名: photo_TonemapMantiuk_setSaturation
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_TonemapMantiuk_setSaturation(cv::TonemapMantiuk *obj, float saturation)
{
    BEGIN_WRAP
    obj-&amp;gt;setSaturation(saturation);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_createTonemapMantiuk
[32/64bit] TonemapMantiukオブジェクトを作成します。
%prm
p1,p2,p3,p4
p1 = float : float gamma
p2 = float : float scale
p3 = float : float saturation
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): photo_createTonemapMantiuk
元DLLエクスポート名: photo_createTonemapMantiuk
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_createTonemapMantiuk(float gamma, float scale, float saturation, cv::Ptr&amp;lt;cv::TonemapMantiuk&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto p = cv::createTonemapMantiuk(gamma, scale, saturation);
    *returnValue = clone(p);
    END_WRAP  
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_Ptr_TonemapMantiuk_delete
[32/64bit] cv::TonemapMantiuk のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
このアルゴリズムでは、ガウシアンピラミッドのすべてのレベルのグラデーションを使用して画像をコントラストに変換し、コントラスト値をHVSレスポンスに変換し、そのレスポンスをスケーリングします。その後，新しいコントラスト値から画像が再構成されます．

詳細は[161]を参照してください．


元関数名(C#): photo_Ptr_TonemapMantiuk_delete
元DLLエクスポート名: photo_Ptr_TonemapMantiuk_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_Ptr_TonemapMantiuk_delete(cv::Ptr&amp;lt;cv::TonemapMantiuk&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
photo_Ptr_TonemapMantiuk_get
[32/64bit] cv::TonemapMantiuk のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
このアルゴリズムでは、ガウシアンピラミッドのすべてのレベルのグラデーションを使用して画像をコントラストに変換し、コントラスト値をHVSレスポンスに変換し、そのレスポンスをスケーリングします。その後，新しいコントラスト値から画像が再構成されます．

詳細は[161]を参照してください．


元関数名(C#): photo_Ptr_TonemapMantiuk_get
元DLLエクスポート名: photo_Ptr_TonemapMantiuk_get
参照元CSファイル: Internal\PInvoke\NativeMethods\photo\NativeMethods_photo_Tonemap.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) photo_Ptr_TonemapMantiuk_get(cv::Ptr&amp;lt;cv::TonemapMantiuk&amp;gt; *ptr, cv::TonemapMantiuk **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_photo_Tonemap

%index
shape_ShapeDistanceExtractor_computeDistance
[32/64bit] 輪郭で定義される2つの形状間の形状距離を計算します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr contour1
p3 = sptr : IntPtr contour2
p4 = var : out float returnValue
%inst
元関数名(C#): shape_ShapeDistanceExtractor_computeDistance
元DLLエクスポート名: shape_ShapeDistanceExtractor_computeDistance
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeDistanceExtractor_computeDistance(
    cv::ShapeDistanceExtractor *obj, cv::_InputArray *contour1, cv::_InputArray *contour2, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;computeDistance(*contour1, *contour2);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_Ptr_ShapeContextDistanceExtract_delete
[32/64bit][関数名変更] cv::ShapeContextDistanceExtractor のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
Shape Context 記述子とマッチングアルゴリズムの実装。

Belongieらが "Shape Matching and Object Recognition Using Shape Contexts" (PAMI 2002)で提案したものです。この実装は、オリジナルのパイプラインの一般的なバリエーションの実装を可能にするために、汎用的なスキームでパッケージ化されています。


元関数名(C#): shape_Ptr_ShapeContextDistanceExtractor_delete
元DLLエクスポート名: shape_Ptr_ShapeContextDistanceExtractor_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_Ptr_ShapeContextDistanceExtractor_delete(
    cv::Ptr&amp;lt;cv::ShapeContextDistanceExtractor&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_Ptr_ShapeContextDistanceExtract_get
[32/64bit][関数名変更] cv::ShapeContextDistanceExtractor のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
Shape Context 記述子とマッチングアルゴリズムの実装。

Belongieらが "Shape Matching and Object Recognition Using Shape Contexts" (PAMI 2002)で提案したものです。この実装は、オリジナルのパイプラインの一般的なバリエーションの実装を可能にするために、汎用的なスキームでパッケージ化されています。


元関数名(C#): shape_Ptr_ShapeContextDistanceExtractor_get
元DLLエクスポート名: shape_Ptr_ShapeContextDistanceExtractor_get
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_Ptr_ShapeContextDistanceExtractor_get(
    cv::Ptr&amp;lt;cv::ShapeContextDistanceExtractor&amp;gt; *obj, cv::ShapeContextDistanceExtractor **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_setAngularBins
[32/64bit][関数名変更] 形状マッチングパイプラインで使用されるShape Context Descriptorの角度ビンの数を設定する。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_setAngularBins
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_setAngularBins
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_setAngularBins(
    cv::ShapeContextDistanceExtractor *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setAngularBins(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_getAngularBins
[32/64bit][関数名変更] shape_ShapeContextDistanceExtract_getAngularBins
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_getAngularBins
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_getAngularBins
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_getAngularBins(
    cv::ShapeContextDistanceExtractor *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getAngularBins();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_setRadialBins
[32/64bit][関数名変更] 形状マッチングパイプラインで使用されるShape Context DescriptorのRadial Binsの数を設定する。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_setRadialBins
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_setRadialBins
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_setRadialBins(
    cv::ShapeContextDistanceExtractor *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setRadialBins(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_getRadialBins
[32/64bit][関数名変更] shape_ShapeContextDistanceExtract_getRadialBins
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_getRadialBins
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_getRadialBins
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_getRadialBins(
    cv::ShapeContextDistanceExtractor *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getRadialBins();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_setInnerRadius
[32/64bit][関数名変更] 形状コンテキスト記述子の内側半径を設定する。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float val
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_setInnerRadius
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_setInnerRadius
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_setInnerRadius(
    cv::ShapeContextDistanceExtractor *obj, float val)
{
    BEGIN_WRAP
    obj-&amp;gt;setInnerRadius(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_getInnerRadius
[32/64bit][関数名変更] shape_ShapeContextDistanceExtract_getInnerRadius
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_getInnerRadius
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_getInnerRadius
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_getInnerRadius(
    cv::ShapeContextDistanceExtractor *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getInnerRadius();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_setOuterRadius
[32/64bit][関数名変更] シェイプコンテキスト記述子の外半径を設定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float val
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_setOuterRadius
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_setOuterRadius
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_setOuterRadius(
    cv::ShapeContextDistanceExtractor *obj, float val)
{
    BEGIN_WRAP
    obj-&amp;gt;setOuterRadius(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_getOuterRadius
[32/64bit][関数名変更] shape_ShapeContextDistanceExtract_getOuterRadius
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_getOuterRadius
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_getOuterRadius
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_getOuterRadius(
    cv::ShapeContextDistanceExtractor *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getOuterRadius();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_setRotationInvariant
[32/64bit][関数名変更] shape_ShapeContextDistanceExtract_setRotationInvariant
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_setRotationInvariant
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_setRotationInvariant
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_setRotationInvariant(
    cv::ShapeContextDistanceExtractor *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setRotationInvariant(val != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_getRotationInvariant
[32/64bit][関数名変更] shape_ShapeContextDistanceExtract_getRotationInvariant
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_getRotationInvariant
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_getRotationInvariant
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_getRotationInvariant(
    cv::ShapeContextDistanceExtractor *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getRotationInvariant() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_setShapeContextWeight
[32/64bit][関数名変更] 形状距離の最終値における形状コンテキスト距離の重みを設定する。2つの形状間の形状コンテクスト距離は、ベストマッチングポイントに対する形状コンテクストマッチングコストの対称的な合計として定義される。形状距離の最終値は、形状コンテキスト距離、画像出現距離、曲げエネルギーのユーザー定義の線形結合である。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float val
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_setShapeContextWeight
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_setShapeContextWeight
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_setShapeContextWeight(
    cv::ShapeContextDistanceExtractor *obj, float val)
{
    BEGIN_WRAP
    obj-&amp;gt;setShapeContextWeight(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_getShapeContextWeight
[32/64bit][関数名変更] shape_ShapeContextDistanceExtract_getShapeContextWeight
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_getShapeContextWeight
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_getShapeContextWeight
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_getShapeContextWeight(
    cv::ShapeContextDistanceExtractor *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getShapeContextWeight();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_setImageAppearanceWeight
[32/64bit][関数名変更] 形状距離の最終値における画像出現コストの重みを設定する。画像外観コストは、対応する画像ポイントの周りのガウス窓における輝度差の二乗の合計として定義される。形状距離の最終値は、形状コンテキスト距離、画像外観距離、および曲げエネルギーのユーザー定義の線形結合です。この値が0以外の数値に設定された場合、各形状に対応する画像の設定が必須となる。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float val
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_setImageAppearanceWeight
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_setImageAppearanceWeight
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_setImageAppearanceWeight(
    cv::ShapeContextDistanceExtractor *obj, float val)
{
    BEGIN_WRAP
    obj-&amp;gt;setImageAppearanceWeight(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_getImageAppearanceWeight
[32/64bit][関数名変更] shape_ShapeContextDistanceExtract_getImageAppearanceWeight
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_getImageAppearanceWeight
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_getImageAppearanceWeight
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_getImageAppearanceWeight(
    cv::ShapeContextDistanceExtractor *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getImageAppearanceWeight();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_setBendingEnergyWeight
[32/64bit][関数名変更] 形状距離の最終値における曲げエネルギーの重みを設定する。曲げエネルギーの定義は、形状の整列にどのような変換が使用されているかによって異なります。形状距離の最終値は、形状コンテキスト距離、画像外観距離、曲げエネルギーのユーザー定義の線形結合です。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float val
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_setBendingEnergyWeight
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_setBendingEnergyWeight
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_setBendingEnergyWeight(
    cv::ShapeContextDistanceExtractor *obj, float val)
{
    BEGIN_WRAP
    obj-&amp;gt;setBendingEnergyWeight(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_getBendingEnergyWeight
[32/64bit][関数名変更] shape_ShapeContextDistanceExtract_getBendingEnergyWeight
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_getBendingEnergyWeight
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_getBendingEnergyWeight
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_getBendingEnergyWeight(
    cv::ShapeContextDistanceExtractor *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getBendingEnergyWeight();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_setImages
[32/64bit][関数名変更] 各形状に対応する画像を設定します。この画像は、Image Appearance costの計算に使用されます。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image1
p3 = sptr : IntPtr image2
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_setImages
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_setImages
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_setImages(
    cv::ShapeContextDistanceExtractor *obj, cv::_InputArray *image1, cv::_InputArray *image2)
{
    BEGIN_WRAP
    obj-&amp;gt;setImages(*image1, *image2);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_getImages
[32/64bit][関数名変更] shape_ShapeContextDistanceExtract_getImages
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image1
p3 = sptr : IntPtr image2
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_getImages
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_getImages
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_getImages(
    cv::ShapeContextDistanceExtractor *obj, cv::_OutputArray *image1, cv::_OutputArray *image2)
{
    BEGIN_WRAP
    obj-&amp;gt;getImages(*image1, *image2);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_setIterations
[32/64bit][関数名変更] shape_ShapeContextDistanceExtract_setIterations
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_setIterations
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_setIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_setIterations(
    cv::ShapeContextDistanceExtractor *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setIterations(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_getIterations
[32/64bit][関数名変更] shape_ShapeContextDistanceExtract_getIterations
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_getIterations
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_getIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_getIterations(
    cv::ShapeContextDistanceExtractor *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getIterations();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_setStdDev
[32/64bit][関数名変更] 画像見栄えコストのためのガウス窓の標準偏差の値を設定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float val
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_setStdDev
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_setStdDev
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_setStdDev(
    cv::ShapeContextDistanceExtractor *obj, float val)
{
    BEGIN_WRAP
    obj-&amp;gt;setStdDev(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_ShapeContextDistanceExtract_getStdDev
[32/64bit][関数名変更] shape_ShapeContextDistanceExtract_getStdDev
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): shape_ShapeContextDistanceExtractor_getStdDev
元DLLエクスポート名: shape_ShapeContextDistanceExtractor_getStdDev
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_ShapeContextDistanceExtractor_getStdDev(
    cv::ShapeContextDistanceExtractor *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getStdDev();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_createShapeContextDistanceExtract
[32/64bit][関数名変更] 例： modules/shape/samples/shape_example.cpp.
%prm
p1,p2,p3,p4,p5,p6
p1 = int : int nAngularBins
p2 = int : int nRadialBins
p3 = float : float innerRadius
p4 = float : float outerRadius
p5 = int : int iterations
p6 = var : out IntPtr returnValue
%inst
元関数名(C#): shape_createShapeContextDistanceExtractor
元DLLエクスポート名: shape_createShapeContextDistanceExtractor
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_createShapeContextDistanceExtractor(
    int nAngularBins, int nRadialBins,
    float innerRadius, float outerRadius, int iterations/*,
    const Ptr&amp;lt;HistogramCostExtractor&amp;gt; &amp;comparer = createChiHistogramCostExtractor(),
    const Ptr&amp;lt;ShapeTransformer&amp;gt; &amp;transformer = createThinPlateSplineShapeTransformer()*/,
    cv::Ptr&amp;lt;cv::ShapeContextDistanceExtractor&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto p = cv::createShapeContextDistanceExtractor(
        nAngularBins, nRadialBins, innerRadius, outerRadius, iterations);
    *returnValue = clone(p);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_Ptr_HausdorffDistanceExtractor_delete
[32/64bit] cv::HausdorffDistanceExtractor のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
輪郭で定義された形状間の単純なハウズドルフ距離測定。

D.P. Huttenlocher, G.A. Klanderman, W.J. Rucklidge の論文 "Comparing Images using the Hausdorff distance." による。(PAMI 1993) を参照してください。


元関数名(C#): shape_Ptr_HausdorffDistanceExtractor_delete
元DLLエクスポート名: shape_Ptr_HausdorffDistanceExtractor_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_Ptr_HausdorffDistanceExtractor_delete(
    cv::Ptr&amp;lt;cv::HausdorffDistanceExtractor&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_Ptr_HausdorffDistanceExtractor_get
[32/64bit] cv::HausdorffDistanceExtractor のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
輪郭で定義された形状間の単純なハウズドルフ距離測定。

D.P. Huttenlocher, G.A. Klanderman, W.J. Rucklidge の論文 "Comparing Images using the Hausdorff distance." による。(PAMI 1993) を参照してください。


元関数名(C#): shape_Ptr_HausdorffDistanceExtractor_get
元DLLエクスポート名: shape_Ptr_HausdorffDistanceExtractor_get
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_Ptr_HausdorffDistanceExtractor_get(
    cv::Ptr&amp;lt;cv::HausdorffDistanceExtractor&amp;gt; *obj, cv::HausdorffDistanceExtractor **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_HausdorffDistanceExtractor_setDistanceFlag
[32/64bit] 2つの形状間のハウズドルフ値の計算に使用するノルムを設定します。L1ノルムまたはL2ノルムを指定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): shape_HausdorffDistanceExtractor_setDistanceFlag
元DLLエクスポート名: shape_HausdorffDistanceExtractor_setDistanceFlag
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_HausdorffDistanceExtractor_setDistanceFlag(
    cv::HausdorffDistanceExtractor *obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setDistanceFlag(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_HausdorffDistanceExtractor_getDistanceFlag
[32/64bit] shape_HausdorffDistanceExtractor_getDistanceFlag
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): shape_HausdorffDistanceExtractor_getDistanceFlag
元DLLエクスポート名: shape_HausdorffDistanceExtractor_getDistanceFlag
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_HausdorffDistanceExtractor_getDistanceFlag(
    cv::HausdorffDistanceExtractor *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getDistanceFlag();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_HausdorffDistanceExtractor_setRankProportion
[32/64bit] この方法では，部分ハウズドルフ距離のK番目のランク値を確定するランク比率（または分数値）を設定します．実験的には、0.6 が形状を比較するのに適した値であることがわかっています。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float val
%inst
元関数名(C#): shape_HausdorffDistanceExtractor_setRankProportion
元DLLエクスポート名: shape_HausdorffDistanceExtractor_setRankProportion
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_HausdorffDistanceExtractor_setRankProportion(
    cv::HausdorffDistanceExtractor *obj, float val)
{
    BEGIN_WRAP
    obj-&amp;gt;setRankProportion(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_HausdorffDistanceExtractor_getRankProportion
[32/64bit] shape_HausdorffDistanceExtractor_getRankProportion
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): shape_HausdorffDistanceExtractor_getRankProportion
元DLLエクスポート名: shape_HausdorffDistanceExtractor_getRankProportion
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_HausdorffDistanceExtractor_getRankProportion(
    cv::HausdorffDistanceExtractor *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getRankProportion();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
shape_createHausdorffDistanceExtractor
[32/64bit] shape_createHausdorffDistanceExtractor
%prm
p1,p2,p3
p1 = int : int distanceFlag
p2 = float : float rankProp
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): shape_createHausdorffDistanceExtractor
元DLLエクスポート名: shape_createHausdorffDistanceExtractor
参照元CSファイル: Internal\PInvoke\NativeMethods\shape\NativeMethods_shape_ShapeDistanceExtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) shape_createHausdorffDistanceExtractor(
    int distanceFlag, float rankProp, cv::Ptr&amp;lt;cv::HausdorffDistanceExtractor&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto p = cv::createHausdorffDistanceExtractor(
        distanceFlag, rankProp);
    *returnValue = clone(p);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_shape_ShapeDistanceExtractor

%index
stitching_Stitcher_create
[32/64bit] ステッチモードの一つに設定されたStitcherを作成します。
%prm
p1,p2
p1 = int : int mode
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): stitching_Stitcher_create
元DLLエクスポート名: stitching_Stitcher_create
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_create(int mode, cv::Ptr&amp;lt;cv::Stitcher&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::Stitcher::create(static_cast&amp;lt;cv::Stitcher::Mode&amp;gt;(mode));
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Ptr_Stitcher_delete
[32/64bit] cv::Stitcher のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
ハイレベルイメージステッチャ。

このクラスは、ステッチングパイプライン全体を意識することなく使用することができます。しかし、より高いスティッチングの安定性と最終画像の品質を得るためには、少なくともその理論に精通していることが推奨されます。

備考

画像のスティッチングの基本的な例は、opencv_source_code/samples/cpp/stitching.cpp にあります。

Python でのイメージスティッチングの基本的な例は、opencv_source_code/samples/python/stitching.py にあります。

画像のスティッチングの詳細な例は、opencv_source_code/samples/cpp/stitching_detailed.cpp にあります。


元関数名(C#): stitching_Ptr_Stitcher_delete
元DLLエクスポート名: stitching_Ptr_Stitcher_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Ptr_Stitcher_delete(cv::Ptr&amp;lt;cv::Stitcher&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Ptr_Stitcher_get
[32/64bit] cv::Stitcher のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
ハイレベルイメージステッチャ。

このクラスは、ステッチングパイプライン全体を意識することなく使用することができます。しかし、より高いスティッチングの安定性と最終画像の品質を得るためには、少なくともその理論に精通していることが推奨されます。

備考

画像のスティッチングの基本的な例は、opencv_source_code/samples/cpp/stitching.cpp にあります。

Python でのイメージスティッチングの基本的な例は、opencv_source_code/samples/python/stitching.py にあります。

画像のスティッチングの詳細な例は、opencv_source_code/samples/cpp/stitching_detailed.cpp にあります。


元関数名(C#): stitching_Ptr_Stitcher_get
元DLLエクスポート名: stitching_Ptr_Stitcher_get
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Ptr_Stitcher_get(cv::Ptr&amp;lt;cv::Stitcher&amp;gt; *obj, cv::Stitcher **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_registrationResol
[32/64bit] stitching_Stitcher_registrationResol
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): stitching_Stitcher_registrationResol
元DLLエクスポート名: stitching_Stitcher_registrationResol
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_registrationResol(cv::Stitcher *obj, double *returnValue)
{ 
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;registrationResol();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_setRegistrationResol
[32/64bit] stitching_Stitcher_setRegistrationResol
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double resolMpx
%inst
元関数名(C#): stitching_Stitcher_setRegistrationResol
元DLLエクスポート名: stitching_Stitcher_setRegistrationResol
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_setRegistrationResol(cv::Stitcher *obj, const double resol_mpx)
{
    BEGIN_WRAP
    obj-&amp;gt;setRegistrationResol(resol_mpx);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_seamEstimationResol
[32/64bit] stitching_Stitcher_seamEstimationResol
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): stitching_Stitcher_seamEstimationResol
元DLLエクスポート名: stitching_Stitcher_seamEstimationResol
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_seamEstimationResol(cv::Stitcher *obj, double *returnValue) 
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;seamEstimationResol();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_setSeamEstimationResol
[32/64bit] stitching_Stitcher_setSeamEstimationResol
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double resolMpx
%inst
元関数名(C#): stitching_Stitcher_setSeamEstimationResol
元DLLエクスポート名: stitching_Stitcher_setSeamEstimationResol
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_setSeamEstimationResol(cv::Stitcher *obj, const double resol_mpx)
{
    BEGIN_WRAP
    obj-&amp;gt;setSeamEstimationResol(resol_mpx); 
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_compositingResol
[32/64bit] stitching_Stitcher_compositingResol
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): stitching_Stitcher_compositingResol
元DLLエクスポート名: stitching_Stitcher_compositingResol
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_compositingResol(cv::Stitcher *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;compositingResol();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_setCompositingResol
[32/64bit] stitching_Stitcher_setCompositingResol
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double resolMpx
%inst
元関数名(C#): stitching_Stitcher_setCompositingResol
元DLLエクスポート名: stitching_Stitcher_setCompositingResol
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_setCompositingResol(cv::Stitcher *obj, const double resol_mpx)
{ 
    BEGIN_WRAP
    obj-&amp;gt;setCompositingResol(resol_mpx);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_panoConfidenceThresh
[32/64bit] stitching_Stitcher_panoConfidenceThresh
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): stitching_Stitcher_panoConfidenceThresh
元DLLエクスポート名: stitching_Stitcher_panoConfidenceThresh
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_panoConfidenceThresh(cv::Stitcher *obj, double *returnValue) 
{ 
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;panoConfidenceThresh();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_setPanoConfidenceThresh
[32/64bit] stitching_Stitcher_setPanoConfidenceThresh
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double confThresh
%inst
元関数名(C#): stitching_Stitcher_setPanoConfidenceThresh
元DLLエクスポート名: stitching_Stitcher_setPanoConfidenceThresh
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_setPanoConfidenceThresh(cv::Stitcher *obj, const double conf_thresh)
{
    BEGIN_WRAP
    obj-&amp;gt;setPanoConfidenceThresh(conf_thresh);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_waveCorrection
[32/64bit] stitching_Stitcher_waveCorrection
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): stitching_Stitcher_waveCorrection
元DLLエクスポート名: stitching_Stitcher_waveCorrection
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_waveCorrection(cv::Stitcher *obj, int *returnValue) 
{ 
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;waveCorrection() ? 1 : 0; 
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_setWaveCorrection
[32/64bit] stitching_Stitcher_setWaveCorrection
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int flag
%inst
元関数名(C#): stitching_Stitcher_setWaveCorrection
元DLLエクスポート名: stitching_Stitcher_setWaveCorrection
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_setWaveCorrection(cv::Stitcher *obj, const int flag)
{
    BEGIN_WRAP
    obj-&amp;gt;setWaveCorrection(flag != 0); 
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_waveCorrectKind
[32/64bit] stitching_Stitcher_waveCorrectKind
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): stitching_Stitcher_waveCorrectKind
元DLLエクスポート名: stitching_Stitcher_waveCorrectKind
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_waveCorrectKind(cv::Stitcher *obj, int *returnValue) 
{
    BEGIN_WRAP
    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;waveCorrectKind());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_setWaveCorrectKind
[32/64bit] stitching_Stitcher_setWaveCorrectKind
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int kind
%inst
元関数名(C#): stitching_Stitcher_setWaveCorrectKind
元DLLエクスポート名: stitching_Stitcher_setWaveCorrectKind
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_setWaveCorrectKind(cv::Stitcher *obj, int kind) 
{ 
    BEGIN_WRAP
    obj-&amp;gt;setWaveCorrectKind(static_cast&amp;lt;cv::detail::WaveCorrectKind&amp;gt;(kind)); 
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_estimateTransform_InputArray1
[32/64bit] これらの関数は、与えられた画像のマッチングと、各カメラの回転の推定を試みます。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr images
p3 = var : out int returnValue
%inst
注意これらの関数は，ステッチングパイプラインを意識している場合にのみ利用してください．

元関数名(C#): stitching_Stitcher_estimateTransform_InputArray1
元DLLエクスポート名: stitching_Stitcher_estimateTransform_InputArray1
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_estimateTransform_InputArray1(
    cv::Stitcher *obj, cv::_InputArray *images, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;estimateTransform(*images));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_estimateTransform_InputArray2
[32/64bit] これらの関数は、与えられた画像のマッチングと、各カメラの回転の推定を試みます。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr images
p3 = sptr : IntPtr[] rois
p4 = int : int roisSize1
p5 = var : int[] roisSize2
p6 = var : out int returnValue
%inst
注意これらの関数は，ステッチングパイプラインを意識している場合にのみ利用してください．

元関数名(C#): stitching_Stitcher_estimateTransform_InputArray2
元DLLエクスポート名: stitching_Stitcher_estimateTransform_InputArray2
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_estimateTransform_InputArray2(
    cv::Stitcher *obj, cv::_InputArray *images,
    const CvRect **rois, const int roisSize1, const int *roisSize2, int *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;std::vector&amp;lt;cv::Rect&amp;gt; &amp;gt; roisVec;
    toVec(rois, roisSize1, roisSize2, roisVec);

    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;estimateTransform(*images, roisVec));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_estimateTransform_MatArray1
[32/64bit] これらの関数は、与えられた画像のマッチングと、各カメラの回転の推定を試みます。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr[] images
p3 = int : int imagesSize
p4 = var : out int returnValue
%inst
注意これらの関数は，ステッチングパイプラインを意識している場合にのみ利用してください．

元関数名(C#): stitching_Stitcher_estimateTransform_MatArray1
元DLLエクスポート名: stitching_Stitcher_estimateTransform_MatArray1
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_estimateTransform_MatArray1(
    cv::Stitcher *obj, const cv::Mat **images, const int imagesSize, int *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; imagesVec;
    toVec(images, imagesSize, imagesVec);

    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;estimateTransform(imagesVec));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_estimateTransform_MatArray2
[32/64bit] これらの関数は、与えられた画像のマッチングと、各カメラの回転の推定を試みます。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr[] images
p3 = int : int imagesSize
p4 = sptr : IntPtr[] rois
p5 = int : int roisSize1
p6 = var : int[] roisSize2
p7 = var : out int returnValue
%inst
注意これらの関数は，ステッチングパイプラインを意識している場合にのみ利用してください．

元関数名(C#): stitching_Stitcher_estimateTransform_MatArray2
元DLLエクスポート名: stitching_Stitcher_estimateTransform_MatArray2
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_estimateTransform_MatArray2(
    cv::Stitcher *obj, const cv::Mat **images, const int imagesSize,
    const CvRect **rois, const int roisSize1, const int *roisSize2, int *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; imagesVec;
    toVec(images, imagesSize, imagesVec);

    std::vector&amp;lt;std::vector&amp;lt;cv::Rect&amp;gt; &amp;gt; roisVec;
    toVec(rois, roisSize1, roisSize2, roisVec);

    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;estimateTransform(imagesVec, roisVec));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_composePanorama1
[32/64bit] これらの関数は，与えられた画像（あるいは，他の関数呼び出しによって内部に保存された画像）を，あらかじめ画像変換が推定されていると仮定して，最終的なパノに合成しようとします．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr pano
p3 = var : out int returnValue
%inst
注意これらの関数は，ステッチングパイプラインを意識している場合にのみ利用してください．

元関数名(C#): stitching_Stitcher_composePanorama1
元DLLエクスポート名: stitching_Stitcher_composePanorama1
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_composePanorama1(
    cv::Stitcher *obj, cv::_OutputArray *pano, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;composePanorama(*pano));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_composePanorama2_InputArray
[32/64bit] これらの関数は，与えられた画像（あるいは，他の関数呼び出しによって内部に保存された画像）を，あらかじめ画像変換が推定されていると仮定して，最終的なパノに合成しようとします．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr images
p3 = sptr : IntPtr pano
p4 = var : out int returnValue
%inst
注意これらの関数は，ステッチングパイプラインを意識している場合にのみ利用してください．

元関数名(C#): stitching_Stitcher_composePanorama2_InputArray
元DLLエクスポート名: stitching_Stitcher_composePanorama2_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_composePanorama2_InputArray(
    cv::Stitcher *obj, cv::_InputArray *images, cv::_OutputArray *pano, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;composePanorama(*images, *pano));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_composePanorama2_MatArray
[32/64bit] これらの関数は，与えられた画像（あるいは，他の関数呼び出しによって内部に保存された画像）を，あらかじめ画像変換が推定されていると仮定して，最終的なパノに合成しようとします．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr[] images
p3 = int : int imagesSize
p4 = sptr : IntPtr pano
p5 = var : out int returnValue
%inst
注意これらの関数は，ステッチングパイプラインを意識している場合にのみ利用してください．

元関数名(C#): stitching_Stitcher_composePanorama2_MatArray
元DLLエクスポート名: stitching_Stitcher_composePanorama2_MatArray
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_composePanorama2_MatArray(
    cv::Stitcher *obj, const cv::Mat **images, const int imagesSize, 
    cv::_OutputArray *pano, int *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; imagesVec;
    toVec(images, imagesSize, imagesVec);

    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;composePanorama(imagesVec, *pano));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_stitch1_InputArray
[32/64bit] これらの関数は，与えられた画像をスティッチしようとします．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr images
p3 = sptr : IntPtr pano
p4 = var : out int returnValue
%inst
元関数名(C#): stitching_Stitcher_stitch1_InputArray
元DLLエクスポート名: stitching_Stitcher_stitch1_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_stitch1_InputArray(
    cv::Stitcher *obj, cv::_InputArray *images, 
    cv::_OutputArray *pano, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;stitch(*images, *pano));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_stitch1_MatArray
[32/64bit] これらの関数は，与えられた画像をスティッチしようとします．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : [MarshalAs(UnmanagedType.LPArray)] IntPtr[] images
p3 = int : int imagesSize
p4 = sptr : IntPtr pano
p5 = var : out int returnValue
%inst
元関数名(C#): stitching_Stitcher_stitch1_MatArray
元DLLエクスポート名: stitching_Stitcher_stitch1_MatArray
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_stitch1_MatArray(
    cv::Stitcher *obj, const cv::Mat **images, const int imagesSize, 
    cv::_OutputArray *pano, int *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; imagesVec;
    toVec(images, imagesSize, imagesVec);

    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;stitch(imagesVec, *pano));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_stitch2_InputArray
[32/64bit] これらの関数は，与えられた画像をスティッチしようとします．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr images
p3 = sptr : IntPtr[] rois
p4 = int : int roisSize1
p5 = var : int[] roisSize2
p6 = sptr : IntPtr pano
p7 = var : out int returnValue
%inst
元関数名(C#): stitching_Stitcher_stitch2_InputArray
元DLLエクスポート名: stitching_Stitcher_stitch2_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_stitch2_InputArray(
    cv::Stitcher *obj, cv::_InputArray *images, 
    const CvRect **rois, const int roisSize1, int *roisSize2,
    cv::_OutputArray *pano, int *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;std::vector&amp;lt;cv::Rect&amp;gt; &amp;gt; roisVec;
    toVec(rois, roisSize1, roisSize2, roisVec);

    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;stitch(*images, roisVec, *pano));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_stitch2_MatArray
[32/64bit] これらの関数は，与えられた画像をスティッチしようとします．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr[] images
p3 = int : int imagesSize
p4 = sptr : IntPtr[] rois
p5 = int : int roisSize1
p6 = var : int[] roisSize2
p7 = sptr : IntPtr pano
p8 = var : out int returnValue
%inst
元関数名(C#): stitching_Stitcher_stitch2_MatArray
元DLLエクスポート名: stitching_Stitcher_stitch2_MatArray
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_stitch2_MatArray(
    cv::Stitcher *obj, const cv::Mat **images, const int imagesSize,
    const CvRect **rois, const int roisSize1, int *roisSize2,
    cv::_OutputArray *pano, int *returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Mat&amp;gt; imagesVec;
    toVec(images, imagesSize, imagesVec);

    std::vector&amp;lt;std::vector&amp;lt;cv::Rect&amp;gt; &amp;gt; roisVec;
    toVec(rois, roisSize1, roisSize2, roisVec);

    *returnValue = static_cast&amp;lt;int&amp;gt;(obj-&amp;gt;stitch(imagesVec, roisVec, *pano));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_component
[32/64bit] stitching_Stitcher_component
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr returnValue
%inst
元関数名(C#): stitching_Stitcher_component
元DLLエクスポート名: stitching_Stitcher_component
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_component(cv::Stitcher *obj, std::vector&amp;lt;int&amp;gt;* returnValue) 
{ 
    BEGIN_WRAP
    const auto component = obj-&amp;gt;component();
    std::copy(component.begin(), component.end(), std::back_inserter(*returnValue));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_Stitcher_workScale
[32/64bit] stitching_Stitcher_workScale
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): stitching_Stitcher_workScale
元DLLエクスポート名: stitching_Stitcher_workScale
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_Stitcher_workScale(cv::Stitcher *obj, double *returnValue) 
{ 
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;workScale();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching

%index
stitching_computeImageFeatures1
[32/64bit] 例: samples/cpp/stitching_detailed.cpp.
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr featuresFinder
p2 = sptr : IntPtr[] images
p3 = int : int imagesLength
p4 = sptr : IntPtr featuresVec
p5 = var : IntPtr[]? masks
%inst
元関数名(C#): stitching_computeImageFeatures1
元DLLエクスポート名: stitching_computeImageFeatures1
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching_Matchers.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_computeImageFeatures1(
    cv::Feature2D *featuresFinder,
    cv::Mat **images,
    int imagesLength,
    std::vector&amp;lt;cv::detail::ImageFeatures&amp;gt; *featuresVec,
    cv::Mat **masks)
{
    BEGIN_WRAP

    // Do not free Feature2D
    const cv::Ptr&amp;lt;cv::Feature2D&amp;gt; featuresFinderPtr(featuresFinder, [](cv::Feature2D*){});

    std::vector&amp;lt;cv::Mat&amp;gt; imagesVec(imagesLength);
    for (int i = 0; i &amp;lt; imagesLength; i++)
    {
        imagesVec[i] = *images[i];
    }

    auto masksArrays = cv::noArray();
    std::vector&amp;lt;cv::Mat&amp;gt; masksVec(imagesLength);
    if (masks != nullptr)
    {
        for (int i = 0; i &amp;lt; imagesLength; i++)
        {
            masksVec[i] = *masks[i];
        }
        masksArrays = masksVec;
    }

    std::vector&amp;lt;cv::detail::ImageFeatures&amp;gt; rawFeatures;
    cv::detail::computeImageFeatures(featuresFinderPtr, imagesVec, *featuresVec, masksArrays);
    
    END_WRAP  
}

</pre>
}html
%group
NativeMethods_stitching_Matchers

%index
stitching_computeImageFeatures2
[32/64bit] 例: samples/cpp/stitching_detailed.cpp.
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr featuresFinder
p2 = sptr : IntPtr image
p3 = var : WImageFeatures* features
p4 = sptr : IntPtr mask
%inst
元関数名(C#): stitching_computeImageFeatures2
元DLLエクスポート名: stitching_computeImageFeatures2
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching_Matchers.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_computeImageFeatures2(
    cv::Feature2D *featuresFinder,
    cv::_InputArray *image,
    detail_ImageFeatures *features,
    cv::_InputArray *mask)
{
    BEGIN_WRAP

    // Do not free Feature2D
    const cv::Ptr&amp;lt;cv::Feature2D&amp;gt; featuresFinderPtr(featuresFinder, [](cv::Feature2D*){});
    
    cv::detail::ImageFeatures rawFeature;
    cv::detail::computeImageFeatures(featuresFinderPtr, *image, rawFeature, entity(mask));

    features-&amp;gt;img_idx = rawFeature.img_idx;
    features-&amp;gt;img_size = c(rawFeature.img_size);
    std::copy(rawFeature.keypoints.begin(), rawFeature.keypoints.end(), std::back_inserter(*features-&amp;gt;keypoints));
    rawFeature.descriptors.copyTo(*features-&amp;gt;descriptors); 

    END_WRAP  
}

</pre>
}html
%group
NativeMethods_stitching_Matchers

%index
stitching_FeaturesMatcher_apply
[32/64bit] stitching_FeaturesMatcher_apply
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = sptr : IntPtr obj
p2 = var : ref WImageFeatures features1
p3 = var : ref WImageFeatures features2
p4 = var : out int outSrcImgIdx
p5 = var : out int outDstImgIdx
p6 = sptr : IntPtr outMatches
p7 = sptr : IntPtr outInliersMask
p8 = var : out int outNumInliers
p9 = sptr : IntPtr outH
p10 = var : out double outConfidence
%inst
元関数名(C#): stitching_FeaturesMatcher_apply
元DLLエクスポート名: stitching_FeaturesMatcher_apply
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching_Matchers.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_FeaturesMatcher_apply(
    cv::detail::FeaturesMatcher* obj,
    detail_ImageFeatures *features1,
    detail_ImageFeatures *features2,
    int *out_src_img_idx, 
    int *out_dst_img_idx,
    std::vector&amp;lt;cv::DMatch&amp;gt; *out_matches, 
    std::vector&amp;lt;uchar&amp;gt; *out_inliers_mask,
    int *out_num_inliers,
    cv::Mat *out_H,
    double *out_confidence)
{
    BEGIN_WRAP
    cv::detail::ImageFeatures features1Cpp{
        features1-&amp;gt;img_idx,
        cpp(features1-&amp;gt;img_size),
        *features1-&amp;gt;keypoints,
        cv::UMat()
    };
    cv::detail::ImageFeatures features2Cpp{
        features2-&amp;gt;img_idx,
        cpp(features2-&amp;gt;img_size),
        *features2-&amp;gt;keypoints,
        cv::UMat()
    };
    features1-&amp;gt;descriptors-&amp;gt;copyTo(features1Cpp.descriptors);
    features2-&amp;gt;descriptors-&amp;gt;copyTo(features2Cpp.descriptors);

    cv::detail::MatchesInfo result;
    (*obj)(features1Cpp, features2Cpp, result);

    *out_src_img_idx = result.src_img_idx;
    *out_dst_img_idx = result.dst_img_idx;
    std::copy(result.matches.begin(), result.matches.end(), std::back_inserter(*out_matches));
    std::copy(result.inliers_mask.begin(), result.inliers_mask.end(), std::back_inserter(*out_inliers_mask));
    *out_num_inliers = result.num_inliers;
    result.H.copyTo(*out_H);
    *out_confidence = result.confidence;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching_Matchers

%index
stitching_FeaturesMatcher_apply2
[32/64bit] stitching_FeaturesMatcher_apply2
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11
p1 = sptr : IntPtr obj
p2 = var : WImageFeatures[] features
p3 = int : int featuresSize
p4 = sptr : IntPtr mask
p5 = sptr : IntPtr outSrcImgIdx
p6 = sptr : IntPtr outDstImgIdx
p7 = sptr : IntPtr outMatches
p8 = sptr : IntPtr outInliersMask
p9 = sptr : IntPtr outNumInliers
p10 = sptr : IntPtr outH
p11 = sptr : IntPtr outConfidence
%inst
元関数名(C#): stitching_FeaturesMatcher_apply2
元DLLエクスポート名: stitching_FeaturesMatcher_apply2
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching_Matchers.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_FeaturesMatcher_apply2(
    cv::detail::FeaturesMatcher* obj,
    detail_ImageFeatures* features, int featuresSize,
    cv::Mat *mask,
    std::vector&amp;lt;int&amp;gt; *out_src_img_idx,
    std::vector&amp;lt;int&amp;gt; *out_dst_img_idx,
    std::vector&amp;lt; std::vector&amp;lt;cv::DMatch&amp;gt; &amp;gt; *out_matches,
    std::vector&amp;lt; std::vector&amp;lt;uchar&amp;gt; &amp;gt; *out_inliers_mask,
    std::vector&amp;lt;int&amp;gt; *out_num_inliers,
    std::vector&amp;lt;cv::Mat&amp;gt; *out_H,
    std::vector&amp;lt;double&amp;gt; *out_confidence)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::detail::ImageFeatures&amp;gt; featuresVec(featuresSize);
    for (int i = 0; i &amp;lt; featuresSize; i++)
    {
        cv::detail::ImageFeatures featuresCpp {
            features[i].img_idx,
            cpp(features[i].img_size),
            *features[i].keypoints,
            cv::UMat() };
        features[i].descriptors-&amp;gt;copyTo(featuresCpp.descriptors);
        featuresVec.push_back(featuresCpp);
    }

    cv::UMat maskU;
    if (mask != nullptr)
    {
        mask-&amp;gt;copyTo(maskU);
    }

    std::vector&amp;lt;cv::detail::MatchesInfo&amp;gt; pairwise_matches;
    (*obj)(featuresVec, pairwise_matches, maskU);

    out_src_img_idx-&amp;gt;reserve(pairwise_matches.size());
    out_dst_img_idx-&amp;gt;reserve(pairwise_matches.size());
    out_matches-&amp;gt;reserve(pairwise_matches.size());
    out_inliers_mask-&amp;gt;reserve(pairwise_matches.size());
    out_num_inliers-&amp;gt;reserve(pairwise_matches.size());
    out_H-&amp;gt;reserve(pairwise_matches.size());
    out_confidence-&amp;gt;reserve(pairwise_matches.size());
    for (const auto &amp;m : pairwise_matches)
    {
        out_src_img_idx-&amp;gt;push_back(m.src_img_idx);
        out_dst_img_idx-&amp;gt;push_back(m.dst_img_idx);
        out_num_inliers-&amp;gt;push_back(m.num_inliers);
        out_matches-&amp;gt;push_back(m.matches);
        out_inliers_mask-&amp;gt;push_back(m.inliers_mask);
        out_H-&amp;gt;push_back(m.H);
        out_confidence-&amp;gt;push_back(m.confidence);
    }

    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching_Matchers

%index
stitching_FeaturesMatcher_isThreadSafe
[32/64bit] stitching_FeaturesMatcher_isThreadSafe
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): stitching_FeaturesMatcher_isThreadSafe
元DLLエクスポート名: stitching_FeaturesMatcher_isThreadSafe
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching_Matchers.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_FeaturesMatcher_isThreadSafe(
    cv::detail::FeaturesMatcher* obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;isThreadSafe() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching_Matchers

%index
stitching_FeaturesMatcher_collectGarbage
[32/64bit] 以前に割り当てられた未使用のメモリがあれば，それを解放します．
%prm
p1
p1 = sptr : IntPtr obj
%inst
cv::detail::BestOf2NearestMatcher で再実装されています．

元関数名(C#): stitching_FeaturesMatcher_collectGarbage
元DLLエクスポート名: stitching_FeaturesMatcher_collectGarbage
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching_Matchers.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_FeaturesMatcher_collectGarbage(
    cv::detail::FeaturesMatcher* obj)
{
    BEGIN_WRAP
    obj-&amp;gt;collectGarbage();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching_Matchers

%index
stitching_BestOf2NearestMatcher_new
[32/64bit] cv::detail::BestOf2NearestMatcher のインスタンスを生成します
%prm
p1,p2,p3,p4,p5
p1 = int : int tryUseGpu
p2 = float : float matchConf
p3 = int : int numMatchesThresh1
p4 = int : int numMatchesThresh2
p5 = var : out IntPtr returnValue
%inst
各特徴量に対して2つのベストマッチを見つけ，ディスクリプタ間の距離の比が閾値 match_conf よりも大きい場合にのみ，ベストマッチを残す特徴量マッチャ．

関連項目：odetail::FeaturesMatcher


元関数名(C#): stitching_BestOf2NearestMatcher_new
元DLLエクスポート名: stitching_BestOf2NearestMatcher_new
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching_Matchers.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_BestOf2NearestMatcher_new(
    int try_use_gpu, float match_conf, int num_matches_thresh1,int num_matches_thresh2,
    cv::detail::BestOf2NearestMatcher **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::detail::BestOf2NearestMatcher(
        try_use_gpu != 0, match_conf, num_matches_thresh1, num_matches_thresh2);
    END_WRAP    
}

</pre>
}html
%group
NativeMethods_stitching_Matchers

%index
stitching_BestOf2NearestMatcher_delete
[32/64bit] cv::detail::BestOf2NearestMatcher のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
各特徴量に対して2つのベストマッチを見つけ，ディスクリプタ間の距離の比が閾値 match_conf よりも大きい場合にのみ，ベストマッチを残す特徴量マッチャ．

関連項目：odetail::FeaturesMatcher


元関数名(C#): stitching_BestOf2NearestMatcher_delete
元DLLエクスポート名: stitching_BestOf2NearestMatcher_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching_Matchers.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_BestOf2NearestMatcher_delete(cv::detail::BestOf2NearestMatcher* obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching_Matchers

%index
stitching_BestOf2NearestMatcher_collectGarbage
[32/64bit] 以前に割り当てられた未使用のメモリがあれば，それを解放します．
%prm
p1
p1 = sptr : IntPtr obj
%inst
cv::detail::FeaturesMatcher を再実装したものです．

元関数名(C#): stitching_BestOf2NearestMatcher_collectGarbage
元DLLエクスポート名: stitching_BestOf2NearestMatcher_collectGarbage
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching_Matchers.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_BestOf2NearestMatcher_collectGarbage(
    cv::detail::BestOf2NearestMatcher* obj)
{
    BEGIN_WRAP
    obj-&amp;gt;collectGarbage();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching_Matchers

%index
stitching_AffineBestOf2NearestMatcher_new
[32/64bit] cv::detail::AffineBestOf2NearestMatcher のインスタンスを生成します
%prm
p1,p2,p3,p4,p5
p1 = int : int fullAffine
p2 = int : int tryUseGpu
p3 = float : float matchConf
p4 = int : int numMatchesThresh1
p5 = var : out IntPtr returnValue
%inst
cv::detail::BestOf2NearestMatcher に似た特徴量 matcher で，各特徴量に対して2つのベストマッチを見つけ，記述子の距離の比が閾値 match_conf よりも大きい場合にのみ，ベストマッチを残します．

cv::detail::BestOf2NearestMatcher とは異なり，この Matcher はアフィン変換を利用します（アフィン変換の推定値は matches_info に格納されます）．

関連項目： cv::detail::FeaturesMatcher， cv::detail::BestOf2NearestMatcher．


元関数名(C#): stitching_AffineBestOf2NearestMatcher_new
元DLLエクスポート名: stitching_AffineBestOf2NearestMatcher_new
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching_Matchers.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_AffineBestOf2NearestMatcher_new(
    int full_affine, int try_use_gpu, float match_conf, int num_matches_thresh1,
    cv::detail::AffineBestOf2NearestMatcher** returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::detail::AffineBestOf2NearestMatcher(
        full_affine != 0, try_use_gpu != 0, match_conf, num_matches_thresh1);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching_Matchers

%index
stitching_AffineBestOf2NearestMatcher_delete
[32/64bit] cv::detail::AffineBestOf2NearestMatcher のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
cv::detail::BestOf2NearestMatcher に似た特徴量 matcher で，各特徴量に対して2つのベストマッチを見つけ，記述子の距離の比が閾値 match_conf よりも大きい場合にのみ，ベストマッチを残します．

cv::detail::BestOf2NearestMatcher とは異なり，この Matcher はアフィン変換を利用します（アフィン変換の推定値は matches_info に格納されます）．

関連項目： cv::detail::FeaturesMatcher， cv::detail::BestOf2NearestMatcher．


元関数名(C#): stitching_AffineBestOf2NearestMatcher_delete
元DLLエクスポート名: stitching_AffineBestOf2NearestMatcher_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\stitching\NativeMethods_stitching_Matchers.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) stitching_AffineBestOf2NearestMatcher_delete(
    cv::detail::AffineBestOf2NearestMatcher* obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_stitching_Matchers

%index
superres_DenseOpticalFlowExt_calc
[32/64bit] superres_DenseOpticalFlowExt_calc
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr frame0
p3 = sptr : IntPtr frame1
p4 = sptr : IntPtr flow1
p5 = sptr : IntPtr flow2
%inst
元関数名(C#): superres_DenseOpticalFlowExt_calc
元DLLエクスポート名: superres_DenseOpticalFlowExt_calc
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_DenseOpticalFlowExt_calc(cv::superres::DenseOpticalFlowExt *obj,
    cv::_InputArray *frame0, cv::_InputArray *frame1, cv::_OutputArray *flow1, cv::_OutputArray *flow2)
{
    BEGIN_WRAP
    obj-&amp;gt;calc(*frame0, *frame1, *flow1, entity(flow2));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_DenseOpticalFlowExt_collectGarbage
[32/64bit] superres_DenseOpticalFlowExt_collectGarbage
%prm
p1
p1 = sptr : IntPtr obj
%inst
元関数名(C#): superres_DenseOpticalFlowExt_collectGarbage
元DLLエクスポート名: superres_DenseOpticalFlowExt_collectGarbage
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_DenseOpticalFlowExt_collectGarbage(cv::superres::DenseOpticalFlowExt *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;collectGarbage();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_createOptFlow_Farneback
[32/64bit] superres_createOptFlow_Farneback
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): superres_createOptFlow_Farneback
元DLLエクスポート名: superres_createOptFlow_Farneback
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_createOptFlow_Farneback(cv::Ptr&amp;lt;cv::superres::FarnebackOpticalFlow&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(cv::superres::createOptFlow_Farneback());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_createOptFlow_Farneback_CUDA
[32/64bit] superres_createOptFlow_Farneback_CUDA
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): superres_createOptFlow_Farneback_CUDA
元DLLエクスポート名: superres_createOptFlow_Farneback_CUDA
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_createOptFlow_Farneback_CUDA(cv::Ptr&amp;lt;cv::superres::FarnebackOpticalFlow&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(cv::superres::createOptFlow_Farneback_CUDA());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_Ptr_FarnebackOpticalFlow_get
[32/64bit] cv::superres::FarnebackOpticalFlow のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): superres_Ptr_FarnebackOpticalFlow_get
元DLLエクスポート名: superres_Ptr_FarnebackOpticalFlow_get
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_Ptr_FarnebackOpticalFlow_get(
    cv::Ptr&amp;lt;cv::superres::FarnebackOpticalFlow&amp;gt; *ptr, cv::superres::FarnebackOpticalFlow **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_Ptr_FarnebackOpticalFlow_delete
[32/64bit] cv::superres::FarnebackOpticalFlow のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst



元関数名(C#): superres_Ptr_FarnebackOpticalFlow_delete
元DLLエクスポート名: superres_Ptr_FarnebackOpticalFlow_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_Ptr_FarnebackOpticalFlow_delete(
    cv::Ptr&amp;lt;cv::superres::FarnebackOpticalFlow&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_FarnebackOpticalFlow_getPyrScale
[32/64bit] alsosetPyrScale を参照してください．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): superres_FarnebackOpticalFlow_getPyrScale
元DLLエクスポート名: superres_FarnebackOpticalFlow_getPyrScale
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_FarnebackOpticalFlow_getPyrScale(cv::superres::FarnebackOpticalFlow *obj, double *returnValue)  { BEGIN_WRAP *returnValue = obj-&amp;gt;getPyrScale(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_FarnebackOpticalFlow_setPyrScale
[32/64bit] alsogetPyrScale を参照してください．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): superres_FarnebackOpticalFlow_setPyrScale
元DLLエクスポート名: superres_FarnebackOpticalFlow_setPyrScale
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_FarnebackOpticalFlow_setPyrScale(cv::superres::FarnebackOpticalFlow *obj, double val)           { BEGIN_WRAP obj-&amp;gt;setPyrScale(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_FarnebackOpticalFlow_getLevelsNumber
[32/64bit] alsosetLevelsNumber を参照してください．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): superres_FarnebackOpticalFlow_getLevelsNumber
元DLLエクスポート名: superres_FarnebackOpticalFlow_getLevelsNumber
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_FarnebackOpticalFlow_getLevelsNumber(cv::superres::FarnebackOpticalFlow *obj, int *returnValue) { BEGIN_WRAP *returnValue = obj-&amp;gt;getLevelsNumber(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_FarnebackOpticalFlow_setLevelsNumber
[32/64bit] アルソージェットレベルズナンバー参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): superres_FarnebackOpticalFlow_setLevelsNumber
元DLLエクスポート名: superres_FarnebackOpticalFlow_setLevelsNumber
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_FarnebackOpticalFlow_setLevelsNumber(cv::superres::FarnebackOpticalFlow *obj, int val)          { BEGIN_WRAP obj-&amp;gt;setLevelsNumber(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_FarnebackOpticalFlow_getWindowSize
[32/64bit] アルソセットウィンドウサイズを見る
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): superres_FarnebackOpticalFlow_getWindowSize
元DLLエクスポート名: superres_FarnebackOpticalFlow_getWindowSize
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_FarnebackOpticalFlow_getWindowSize(cv::superres::FarnebackOpticalFlow *obj, int *returnValue)   { BEGIN_WRAP *returnValue = obj-&amp;gt;getWindowSize(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_FarnebackOpticalFlow_setWindowSize
[32/64bit] alsogetWindowSize参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): superres_FarnebackOpticalFlow_setWindowSize
元DLLエクスポート名: superres_FarnebackOpticalFlow_setWindowSize
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_FarnebackOpticalFlow_setWindowSize(cv::superres::FarnebackOpticalFlow *obj, int val)            { BEGIN_WRAP obj-&amp;gt;setWindowSize(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_FarnebackOpticalFlow_getIterations
[32/64bit] alsosetIterationsを参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): superres_FarnebackOpticalFlow_getIterations
元DLLエクスポート名: superres_FarnebackOpticalFlow_getIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_FarnebackOpticalFlow_getIterations(cv::superres::FarnebackOpticalFlow *obj, int *returnValue)   { BEGIN_WRAP *returnValue = obj-&amp;gt;getIterations(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_FarnebackOpticalFlow_setIterations
[32/64bit] alsogetIterationsを参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): superres_FarnebackOpticalFlow_setIterations
元DLLエクスポート名: superres_FarnebackOpticalFlow_setIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_FarnebackOpticalFlow_setIterations(cv::superres::FarnebackOpticalFlow *obj, int val)            { BEGIN_WRAP obj-&amp;gt;setIterations(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_FarnebackOpticalFlow_getPolyN
[32/64bit] アルソセットポリンを見る
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): superres_FarnebackOpticalFlow_getPolyN
元DLLエクスポート名: superres_FarnebackOpticalFlow_getPolyN
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_FarnebackOpticalFlow_getPolyN(cv::superres::FarnebackOpticalFlow *obj, int *returnValue)        { BEGIN_WRAP *returnValue = obj-&amp;gt;getPolyN(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_FarnebackOpticalFlow_setPolyN
[32/64bit] alsogetPolyNを参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): superres_FarnebackOpticalFlow_setPolyN
元DLLエクスポート名: superres_FarnebackOpticalFlow_setPolyN
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_FarnebackOpticalFlow_setPolyN(cv::superres::FarnebackOpticalFlow *obj, int val)                 { BEGIN_WRAP obj-&amp;gt;setPolyN(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_FarnebackOpticalFlow_getPolySigma
[32/64bit] アルソセットポリシグマを見る
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): superres_FarnebackOpticalFlow_getPolySigma
元DLLエクスポート名: superres_FarnebackOpticalFlow_getPolySigma
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_FarnebackOpticalFlow_getPolySigma(cv::superres::FarnebackOpticalFlow *obj, double *returnValue) { BEGIN_WRAP *returnValue = obj-&amp;gt;getPolySigma(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_FarnebackOpticalFlow_setPolySigma
[32/64bit] アルソゲートポリシグマ参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): superres_FarnebackOpticalFlow_setPolySigma
元DLLエクスポート名: superres_FarnebackOpticalFlow_setPolySigma
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_FarnebackOpticalFlow_setPolySigma(cv::superres::FarnebackOpticalFlow *obj, double val)          { BEGIN_WRAP obj-&amp;gt;setPolySigma(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_FarnebackOpticalFlow_getFlags
[32/64bit] アルソセットフラッグスを見る
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): superres_FarnebackOpticalFlow_getFlags
元DLLエクスポート名: superres_FarnebackOpticalFlow_getFlags
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_FarnebackOpticalFlow_getFlags(cv::superres::FarnebackOpticalFlow *obj, int *returnValue)        { BEGIN_WRAP *returnValue = obj-&amp;gt;getFlags(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_FarnebackOpticalFlow_setFlags
[32/64bit] alsogetFlagsを見る
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): superres_FarnebackOpticalFlow_setFlags
元DLLエクスポート名: superres_FarnebackOpticalFlow_setFlags
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_FarnebackOpticalFlow_setFlags(cv::superres::FarnebackOpticalFlow *obj, int val)                 { BEGIN_WRAP obj-&amp;gt;setFlags(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_createOptFlow_DualTVL1
[32/64bit] superres_createOptFlow_DualTVL1
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): superres_createOptFlow_DualTVL1
元DLLエクスポート名: superres_createOptFlow_DualTVL1
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_createOptFlow_DualTVL1(cv::Ptr&amp;lt;cv::superres::DualTVL1OpticalFlow&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(cv::superres::createOptFlow_DualTVL1());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_createOptFlow_DualTVL1_CUDA
[32/64bit] superres_createOptFlow_DualTVL1_CUDA
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): superres_createOptFlow_DualTVL1_CUDA
元DLLエクスポート名: superres_createOptFlow_DualTVL1_CUDA
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_createOptFlow_DualTVL1_CUDA(cv::Ptr&amp;lt;cv::superres::DualTVL1OpticalFlow&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(cv::superres::createOptFlow_DualTVL1_CUDA());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_Ptr_DualTVL1OpticalFlow_get
[32/64bit] cv::superres::DualTVL1OpticalFlow のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): superres_Ptr_DualTVL1OpticalFlow_get
元DLLエクスポート名: superres_Ptr_DualTVL1OpticalFlow_get
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_Ptr_DualTVL1OpticalFlow_get(
    cv::Ptr&amp;lt;cv::superres::DualTVL1OpticalFlow&amp;gt; *ptr, cv::superres::DualTVL1OpticalFlow **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_Ptr_DualTVL1OpticalFlow_delete
[32/64bit] cv::superres::DualTVL1OpticalFlow のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst



元関数名(C#): superres_Ptr_DualTVL1OpticalFlow_delete
元DLLエクスポート名: superres_Ptr_DualTVL1OpticalFlow_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_Ptr_DualTVL1OpticalFlow_delete(
    cv::Ptr&amp;lt;cv::superres::DualTVL1OpticalFlow&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_DualTVL1OpticalFlow_getTau
[32/64bit] アルソセットタウを見る
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): superres_DualTVL1OpticalFlow_getTau
元DLLエクスポート名: superres_DualTVL1OpticalFlow_getTau
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_DualTVL1OpticalFlow_getTau(cv::superres::DualTVL1OpticalFlow *obj, double *returnValue)         { BEGIN_WRAP *returnValue = obj-&amp;gt;getTau(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_DualTVL1OpticalFlow_setTau
[32/64bit] アルソージェットタウを見る
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): superres_DualTVL1OpticalFlow_setTau
元DLLエクスポート名: superres_DualTVL1OpticalFlow_setTau
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_DualTVL1OpticalFlow_setTau(cv::superres::DualTVL1OpticalFlow *obj, double val)                  { BEGIN_WRAP obj-&amp;gt;setTau(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_DualTVL1OpticalFlow_getLambda
[32/64bit] アルソセットラムダを見る
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): superres_DualTVL1OpticalFlow_getLambda
元DLLエクスポート名: superres_DualTVL1OpticalFlow_getLambda
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_DualTVL1OpticalFlow_getLambda(cv::superres::DualTVL1OpticalFlow *obj, double *returnValue)      { BEGIN_WRAP *returnValue = obj-&amp;gt;getLambda(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_DualTVL1OpticalFlow_setLambda
[32/64bit] アルソゲトラムダを見る
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): superres_DualTVL1OpticalFlow_setLambda
元DLLエクスポート名: superres_DualTVL1OpticalFlow_setLambda
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_DualTVL1OpticalFlow_setLambda(cv::superres::DualTVL1OpticalFlow *obj, double val)               { BEGIN_WRAP obj-&amp;gt;setLambda(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_DualTVL1OpticalFlow_getTheta
[32/64bit] アルソセットシータを見る
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): superres_DualTVL1OpticalFlow_getTheta
元DLLエクスポート名: superres_DualTVL1OpticalFlow_getTheta
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_DualTVL1OpticalFlow_getTheta(cv::superres::DualTVL1OpticalFlow *obj, double *returnValue)       { BEGIN_WRAP *returnValue = obj-&amp;gt;getTheta(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_DualTVL1OpticalFlow_setTheta
[32/64bit] アルソゲトシータを参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): superres_DualTVL1OpticalFlow_setTheta
元DLLエクスポート名: superres_DualTVL1OpticalFlow_setTheta
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_DualTVL1OpticalFlow_setTheta(cv::superres::DualTVL1OpticalFlow *obj, double val)                { BEGIN_WRAP obj-&amp;gt;setTheta(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_DualTVL1OpticalFlow_getScalesNumber
[32/64bit] アルソセットスケールナンバーを見る
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): superres_DualTVL1OpticalFlow_getScalesNumber
元DLLエクスポート名: superres_DualTVL1OpticalFlow_getScalesNumber
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_DualTVL1OpticalFlow_getScalesNumber(cv::superres::DualTVL1OpticalFlow *obj, int *returnValue)   { BEGIN_WRAP *returnValue = obj-&amp;gt;getScalesNumber(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_DualTVL1OpticalFlow_setScalesNumber
[32/64bit] アルソジェットスケールナンバー参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): superres_DualTVL1OpticalFlow_setScalesNumber
元DLLエクスポート名: superres_DualTVL1OpticalFlow_setScalesNumber
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_DualTVL1OpticalFlow_setScalesNumber(cv::superres::DualTVL1OpticalFlow *obj, int val)            { BEGIN_WRAP obj-&amp;gt;setScalesNumber(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_DualTVL1OpticalFlow_getWarpingsNumber
[32/64bit] アルソセットワッピングナンバーを見る
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): superres_DualTVL1OpticalFlow_getWarpingsNumber
元DLLエクスポート名: superres_DualTVL1OpticalFlow_getWarpingsNumber
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_DualTVL1OpticalFlow_getWarpingsNumber(cv::superres::DualTVL1OpticalFlow *obj, int *returnValue) { BEGIN_WRAP *returnValue = obj-&amp;gt;getWarpingsNumber(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_DualTVL1OpticalFlow_setWarpingsNumber
[32/64bit] alsogetWarpingsNumber参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): superres_DualTVL1OpticalFlow_setWarpingsNumber
元DLLエクスポート名: superres_DualTVL1OpticalFlow_setWarpingsNumber
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_DualTVL1OpticalFlow_setWarpingsNumber(cv::superres::DualTVL1OpticalFlow *obj, int val)          { BEGIN_WRAP obj-&amp;gt;setWarpingsNumber(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_DualTVL1OpticalFlow_getEpsilon
[32/64bit] アルソセットイプシロン参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): superres_DualTVL1OpticalFlow_getEpsilon
元DLLエクスポート名: superres_DualTVL1OpticalFlow_getEpsilon
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_DualTVL1OpticalFlow_getEpsilon(cv::superres::DualTVL1OpticalFlow *obj, double *returnValue)     { BEGIN_WRAP *returnValue = obj-&amp;gt;getEpsilon(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_DualTVL1OpticalFlow_setEpsilon
[32/64bit] alsogetEpsilonを参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): superres_DualTVL1OpticalFlow_setEpsilon
元DLLエクスポート名: superres_DualTVL1OpticalFlow_setEpsilon
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_DualTVL1OpticalFlow_setEpsilon(cv::superres::DualTVL1OpticalFlow *obj, double val)              { BEGIN_WRAP obj-&amp;gt;setEpsilon(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_DualTVL1OpticalFlow_getIterations
[32/64bit] alsosetIterationsを参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): superres_DualTVL1OpticalFlow_getIterations
元DLLエクスポート名: superres_DualTVL1OpticalFlow_getIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_DualTVL1OpticalFlow_getIterations(cv::superres::DualTVL1OpticalFlow *obj, int *returnValue)     { BEGIN_WRAP *returnValue = obj-&amp;gt;getIterations(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_DualTVL1OpticalFlow_setIterations
[32/64bit] alsogetIterationsを参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): superres_DualTVL1OpticalFlow_setIterations
元DLLエクスポート名: superres_DualTVL1OpticalFlow_setIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_DualTVL1OpticalFlow_setIterations(cv::superres::DualTVL1OpticalFlow *obj, int val)              { BEGIN_WRAP obj-&amp;gt;setIterations(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_DualTVL1OpticalFlow_getUseInitialFlow
[32/64bit] アルソセットユーズイニシャルフロー参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): superres_DualTVL1OpticalFlow_getUseInitialFlow
元DLLエクスポート名: superres_DualTVL1OpticalFlow_getUseInitialFlow
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_DualTVL1OpticalFlow_getUseInitialFlow(cv::superres::DualTVL1OpticalFlow *obj, int *returnValue) { BEGIN_WRAP *returnValue = obj-&amp;gt;getUseInitialFlow() ? 1 : 0; END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_DualTVL1OpticalFlow_setUseInitialFlow
[32/64bit] alsogetUseInitialFlow参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): superres_DualTVL1OpticalFlow_setUseInitialFlow
元DLLエクスポート名: superres_DualTVL1OpticalFlow_setUseInitialFlow
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_DualTVL1OpticalFlow_setUseInitialFlow(cv::superres::DualTVL1OpticalFlow *obj, int val)          { BEGIN_WRAP obj-&amp;gt;setUseInitialFlow(val != 0); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_createOptFlow_Brox_CUDA
[32/64bit] superres_createOptFlow_Brox_CUDA
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): superres_createOptFlow_Brox_CUDA
元DLLエクスポート名: superres_createOptFlow_Brox_CUDA
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_createOptFlow_Brox_CUDA(cv::Ptr&amp;lt;cv::superres::BroxOpticalFlow&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(cv::superres::createOptFlow_Brox_CUDA());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_Ptr_BroxOpticalFlow_get
[32/64bit] cv::superres::BroxOpticalFlow のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): superres_Ptr_BroxOpticalFlow_get
元DLLエクスポート名: superres_Ptr_BroxOpticalFlow_get
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_Ptr_BroxOpticalFlow_get(
    cv::Ptr&amp;lt;cv::superres::BroxOpticalFlow&amp;gt; *ptr, cv::superres::BroxOpticalFlow **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_Ptr_BroxOpticalFlow_delete
[32/64bit] cv::superres::BroxOpticalFlow のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst



元関数名(C#): superres_Ptr_BroxOpticalFlow_delete
元DLLエクスポート名: superres_Ptr_BroxOpticalFlow_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_Ptr_BroxOpticalFlow_delete(
    cv::Ptr&amp;lt;cv::superres::BroxOpticalFlow&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_BroxOpticalFlow_getAlpha
[32/64bit] フローの滑らかさ。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
アルソセットアルファー参照

元関数名(C#): superres_BroxOpticalFlow_getAlpha
元DLLエクスポート名: superres_BroxOpticalFlow_getAlpha
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_BroxOpticalFlow_getAlpha(cv::superres::BroxOpticalFlow *obj, double *returnValue)         { BEGIN_WRAP *returnValue = obj-&amp;gt;getAlpha(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_BroxOpticalFlow_setAlpha
[32/64bit] フローの滑らかさ。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
alsogetAlpha参照

元関数名(C#): superres_BroxOpticalFlow_setAlpha
元DLLエクスポート名: superres_BroxOpticalFlow_setAlpha
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_BroxOpticalFlow_setAlpha(cv::superres::BroxOpticalFlow *obj, double val)                  { BEGIN_WRAP obj-&amp;gt;setAlpha(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_BroxOpticalFlow_getGamma
[32/64bit] superres_BroxOpticalFlow_getGamma
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): superres_BroxOpticalFlow_getGamma
元DLLエクスポート名: superres_BroxOpticalFlow_getGamma
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_BroxOpticalFlow_getGamma(cv::superres::BroxOpticalFlow *obj, double *returnValue)         { BEGIN_WRAP *returnValue = obj-&amp;gt;getGamma(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_BroxOpticalFlow_setGamma
[32/64bit] 勾配の恒常性の重要性。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
alsogetGamma を参照。

元関数名(C#): superres_BroxOpticalFlow_setGamma
元DLLエクスポート名: superres_BroxOpticalFlow_setGamma
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_BroxOpticalFlow_setGamma(cv::superres::BroxOpticalFlow *obj, double val)                  { BEGIN_WRAP obj-&amp;gt;setGamma(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_BroxOpticalFlow_getScaleFactor
[32/64bit] ピラミッドのスケールファクター。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
alsosetScaleFactorを参照してください。

元関数名(C#): superres_BroxOpticalFlow_getScaleFactor
元DLLエクスポート名: superres_BroxOpticalFlow_getScaleFactor
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_BroxOpticalFlow_getScaleFactor(cv::superres::BroxOpticalFlow *obj, double *returnValue)   { BEGIN_WRAP *returnValue = obj-&amp;gt;getScaleFactor(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_BroxOpticalFlow_setScaleFactor
[32/64bit] ピラミッドのスケールファクター。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
alsogetScaleFactorを参照

元関数名(C#): superres_BroxOpticalFlow_setScaleFactor
元DLLエクスポート名: superres_BroxOpticalFlow_setScaleFactor
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_BroxOpticalFlow_setScaleFactor(cv::superres::BroxOpticalFlow *obj, double val)            { BEGIN_WRAP obj-&amp;gt;setScaleFactor(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_BroxOpticalFlow_getInnerIterations
[32/64bit] 遅れた非線形性の反復回数（内側ループ）
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
alsosetInnerIterationsを参照。

元関数名(C#): superres_BroxOpticalFlow_getInnerIterations
元DLLエクスポート名: superres_BroxOpticalFlow_getInnerIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_BroxOpticalFlow_getInnerIterations(cv::superres::BroxOpticalFlow *obj, int *returnValue)  { BEGIN_WRAP *returnValue = obj-&amp;gt;getInnerIterations(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_BroxOpticalFlow_setInnerIterations
[32/64bit] 遅れた非線形性の反復回数（内側ループ）
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
alsogetInnerIterationsを参照。

元関数名(C#): superres_BroxOpticalFlow_setInnerIterations
元DLLエクスポート名: superres_BroxOpticalFlow_setInnerIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_BroxOpticalFlow_setInnerIterations(cv::superres::BroxOpticalFlow *obj, int val)           { BEGIN_WRAP obj-&amp;gt;setInnerIterations(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_BroxOpticalFlow_getOuterIterations
[32/64bit] ワープの反復回数（ピラミッドのレベル数）
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
alsosetOuterIterationsを参照。

元関数名(C#): superres_BroxOpticalFlow_getOuterIterations
元DLLエクスポート名: superres_BroxOpticalFlow_getOuterIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_BroxOpticalFlow_getOuterIterations(cv::superres::BroxOpticalFlow *obj, int *returnValue)  { BEGIN_WRAP *returnValue = obj-&amp;gt;getOuterIterations(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_BroxOpticalFlow_setOuterIterations
[32/64bit] ワープの反復回数（ピラミッドのレベル数）
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
alsogetOuterIterationsを参照。

元関数名(C#): superres_BroxOpticalFlow_setOuterIterations
元DLLエクスポート名: superres_BroxOpticalFlow_setOuterIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_BroxOpticalFlow_setOuterIterations(cv::superres::BroxOpticalFlow *obj, int val)           { BEGIN_WRAP obj-&amp;gt;setOuterIterations(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_BroxOpticalFlow_getSolverIterations
[32/64bit] 線形システムソルバーのイテレーション数。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
alsosetSolverIterationsを参照。

元関数名(C#): superres_BroxOpticalFlow_getSolverIterations
元DLLエクスポート名: superres_BroxOpticalFlow_getSolverIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_BroxOpticalFlow_getSolverIterations(cv::superres::BroxOpticalFlow *obj, int *returnValue) { BEGIN_WRAP *returnValue = obj-&amp;gt;getSolverIterations(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_BroxOpticalFlow_setSolverIterations
[32/64bit] 線形システムソルバーのイテレーション数。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
alsogetSolverIterationsを参照。

元関数名(C#): superres_BroxOpticalFlow_setSolverIterations
元DLLエクスポート名: superres_BroxOpticalFlow_setSolverIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_BroxOpticalFlow_setSolverIterations(cv::superres::BroxOpticalFlow *obj, int val)          { BEGIN_WRAP obj-&amp;gt;setSolverIterations(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_createOptFlow_PyrLK_CUDA
[32/64bit] superres_createOptFlow_PyrLK_CUDA
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): superres_createOptFlow_PyrLK_CUDA
元DLLエクスポート名: superres_createOptFlow_PyrLK_CUDA
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_createOptFlow_PyrLK_CUDA(cv::Ptr&amp;lt;cv::superres::PyrLKOpticalFlow&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(cv::superres::createOptFlow_PyrLK_CUDA());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_Ptr_PyrLKOpticalFlow_get
[32/64bit] cv::superres::PyrLKOpticalFlow のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): superres_Ptr_PyrLKOpticalFlow_get
元DLLエクスポート名: superres_Ptr_PyrLKOpticalFlow_get
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_Ptr_PyrLKOpticalFlow_get(
    cv::Ptr&amp;lt;cv::superres::PyrLKOpticalFlow&amp;gt; *ptr, cv::superres::PyrLKOpticalFlow **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_Ptr_PyrLKOpticalFlow_delete
[32/64bit] cv::superres::PyrLKOpticalFlow のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst



元関数名(C#): superres_Ptr_PyrLKOpticalFlow_delete
元DLLエクスポート名: superres_Ptr_PyrLKOpticalFlow_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_Ptr_PyrLKOpticalFlow_delete(
    cv::Ptr&amp;lt;cv::superres::PyrLKOpticalFlow&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_PyrLKOpticalFlow_getWindowSize
[32/64bit] アルソセットウィンドウサイズを見る
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): superres_PyrLKOpticalFlow_getWindowSize
元DLLエクスポート名: superres_PyrLKOpticalFlow_getWindowSize
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_PyrLKOpticalFlow_getWindowSize(cv::superres::PyrLKOpticalFlow *obj, int *returnValue) { BEGIN_WRAP *returnValue = obj-&amp;gt;getWindowSize(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_PyrLKOpticalFlow_setWindowSize
[32/64bit] alsogetWindowSize参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): superres_PyrLKOpticalFlow_setWindowSize
元DLLエクスポート名: superres_PyrLKOpticalFlow_setWindowSize
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_PyrLKOpticalFlow_setWindowSize(cv::superres::PyrLKOpticalFlow *obj, int val)          { BEGIN_WRAP obj-&amp;gt;setWindowSize(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_PyrLKOpticalFlow_getMaxLevel
[32/64bit] 参照：アルソセットマックスレベル
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): superres_PyrLKOpticalFlow_getMaxLevel
元DLLエクスポート名: superres_PyrLKOpticalFlow_getMaxLevel
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_PyrLKOpticalFlow_getMaxLevel(cv::superres::PyrLKOpticalFlow *obj, int *returnValue)   { BEGIN_WRAP *returnValue = obj-&amp;gt;getMaxLevel(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_PyrLKOpticalFlow_setMaxLevel
[32/64bit] alsogetMaxLevel を参照してください．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): superres_PyrLKOpticalFlow_setMaxLevel
元DLLエクスポート名: superres_PyrLKOpticalFlow_setMaxLevel
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_PyrLKOpticalFlow_setMaxLevel(cv::superres::PyrLKOpticalFlow *obj, int val)            { BEGIN_WRAP obj-&amp;gt;setMaxLevel(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_PyrLKOpticalFlow_getIterations
[32/64bit] alsosetIterationsを参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): superres_PyrLKOpticalFlow_getIterations
元DLLエクスポート名: superres_PyrLKOpticalFlow_getIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_PyrLKOpticalFlow_getIterations(cv::superres::PyrLKOpticalFlow *obj, int *returnValue) { BEGIN_WRAP *returnValue = obj-&amp;gt;getIterations(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_PyrLKOpticalFlow_setIterations
[32/64bit] alsogetIterationsを参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): superres_PyrLKOpticalFlow_setIterations
元DLLエクスポート名: superres_PyrLKOpticalFlow_setIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_DenseOpticalFlowExt.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_PyrLKOpticalFlow_setIterations(cv::superres::PyrLKOpticalFlow *obj, int val)          { BEGIN_WRAP obj-&amp;gt;setIterations(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_DenseOpticalFlowExt

%index
superres_FrameSource_nextFrame
[32/64bit] cv::superres::SuperResolution で実装されています．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr frame
%inst
元関数名(C#): superres_FrameSource_nextFrame
元DLLエクスポート名: superres_FrameSource_nextFrame
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_FrameSource.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_FrameSource_nextFrame(
    cv::Ptr&amp;lt;cv::superres::FrameSource&amp;gt; *obj, cv::_OutputArray *frame)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;nextFrame(*frame);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_FrameSource

%index
superres_FrameSource_reset
[32/64bit] cv::superres::SuperResolution で実装されています．
%prm
p1
p1 = sptr : IntPtr obj
%inst
元関数名(C#): superres_FrameSource_reset
元DLLエクスポート名: superres_FrameSource_reset
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_FrameSource.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_FrameSource_reset(
    cv::Ptr&amp;lt;cv::superres::FrameSource&amp;gt; *obj)
{
    BEGIN_WRAP
    (*obj)-&amp;gt;reset();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_FrameSource

%index
superres_createFrameSource_Empty
[32/64bit] superres_createFrameSource_Empty
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): superres_createFrameSource_Empty
元DLLエクスポート名: superres_createFrameSource_Empty
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_FrameSource.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_createFrameSource_Empty(cv::Ptr&amp;lt;cv::superres::FrameSource&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone( cv::superres::createFrameSource_Empty() );
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_FrameSource

%index
superres_createFrameSource_Video
[32/64bit] superres_createFrameSource_Video
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string fileName
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): superres_createFrameSource_Video
元DLLエクスポート名: superres_createFrameSource_Video
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_FrameSource.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_createFrameSource_Video(const char *fileName, cv::Ptr&amp;lt;cv::superres::FrameSource&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone( cv::superres::createFrameSource_Video(fileName) );
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_FrameSource

%index
superres_createFrameSource_Video_CUDA
[32/64bit] superres_createFrameSource_Video_CUDA
%prm
p1,p2
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string fileName
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): superres_createFrameSource_Video_CUDA
元DLLエクスポート名: superres_createFrameSource_Video_CUDA
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_FrameSource.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_createFrameSource_Video_CUDA(const char *fileName, cv::Ptr&amp;lt;cv::superres::FrameSource&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone( cv::superres::createFrameSource_Video_CUDA(fileName) );
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_FrameSource

%index
superres_createFrameSource_Camera
[32/64bit] superres_createFrameSource_Camera
%prm
p1,p2
p1 = int : int deviceId
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): superres_createFrameSource_Camera
元DLLエクスポート名: superres_createFrameSource_Camera
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_FrameSource.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_createFrameSource_Camera(int deviceId, cv::Ptr&amp;lt;cv::superres::FrameSource&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone( cv::superres::createFrameSource_Camera(deviceId) );
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_FrameSource

%index
superres_Ptr_FrameSource_get
[32/64bit] cv::superres::FrameSource のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst



元関数名(C#): superres_Ptr_FrameSource_get
元DLLエクスポート名: superres_Ptr_FrameSource_get
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_FrameSource.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_Ptr_FrameSource_get(cv::Ptr&amp;lt;cv::superres::FrameSource&amp;gt; *ptr, cv::superres::FrameSource **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_FrameSource

%index
superres_Ptr_FrameSource_delete
[32/64bit] cv::superres::FrameSource のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst



元関数名(C#): superres_Ptr_FrameSource_delete
元DLLエクスポート名: superres_Ptr_FrameSource_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_FrameSource.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_Ptr_FrameSource_delete(cv::Ptr&amp;lt;cv::superres::FrameSource&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_FrameSource

%index
superres_SuperResolution_setInput
[32/64bit] 超解像アルゴリズムの入力フレームソースを設定します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr frameSource
%inst
元関数名(C#): superres_SuperResolution_setInput
元DLLエクスポート名: superres_SuperResolution_setInput
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_setInput(
    cv::superres::SuperResolution *obj, cv::Ptr&amp;lt;cv::superres::FrameSource&amp;gt; *frameSource)
{
    BEGIN_WRAP
    obj-&amp;gt;setInput(*frameSource);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_nextFrame
[32/64bit] 入力フレームの次のフレームを処理して，出力結果を返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr frame
%inst
cv::superres::FrameSource を実装します．

元関数名(C#): superres_SuperResolution_nextFrame
元DLLエクスポート名: superres_SuperResolution_nextFrame
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_nextFrame(
    cv::superres::SuperResolution *obj, cv::_OutputArray *frame)
{
    BEGIN_WRAP
    obj-&amp;gt;nextFrame(*frame);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_reset
[32/64bit] cv::superres::FrameSource を実装します．
%prm
p1
p1 = sptr : IntPtr obj
%inst
元関数名(C#): superres_SuperResolution_reset
元DLLエクスポート名: superres_SuperResolution_reset
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_reset(cv::superres::SuperResolution *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;reset();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_collectGarbage
[32/64bit] すべての内部バッファをクリアします．
%prm
p1
p1 = sptr : IntPtr obj
%inst
元関数名(C#): superres_SuperResolution_collectGarbage
元DLLエクスポート名: superres_SuperResolution_collectGarbage
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_collectGarbage(cv::superres::SuperResolution *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;collectGarbage();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_createSuperResolution_BTVL1
[32/64bit] 両側TV-L1超解像を作成します．
%prm
p1
p1 = var : out IntPtr returnValue
%inst
このクラスは，論文 [70] と [175] で述べられている超解像アルゴリズムを実装しています．アルゴリズムを制御するクラスの重要なメンバは以下の通りで，クラスのインスタンスを生成した後に設定することができます．

int iterations 反復回数．

double tau 最急降下法の漸近値．

double lambda data項とsmoothness項のバランスをとるための重みパラメータ．

double alpha Bilateral-TVでの空間分布のパラメータ。

int btvKernelSize Bilateral-TVフィルタのカーネルサイズ。

int blurKernelSize ガウス・ブラーのカーネルサイズ。

double blurSigma ガウスぼかしのシグマ．

int temporalAreaRadius 時間軸方向の探索領域の半径を指定します。

Ptr<DenseOpticalFlowExt> opticalFlow 密なオプティカルフローアルゴリズム．

元関数名(C#): superres_createSuperResolution_BTVL1
元DLLエクスポート名: superres_createSuperResolution_BTVL1
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_createSuperResolution_BTVL1(cv::Ptr&amp;lt;cv::superres::SuperResolution&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone( cv::superres::createSuperResolution_BTVL1() );
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_createSuperResolution_BTVL1_CUDA
[32/64bit] superres_createSuperResolution_BTVL1_CUDA
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): superres_createSuperResolution_BTVL1_CUDA
元DLLエクスポート名: superres_createSuperResolution_BTVL1_CUDA
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_createSuperResolution_BTVL1_CUDA(cv::Ptr&amp;lt;cv::superres::SuperResolution&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone( cv::superres::createSuperResolution_BTVL1_CUDA() );
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_Ptr_SuperResolution_get
[32/64bit] cv::superres::SuperResolution のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
超解像アルゴリズムのベースクラスです．

このクラスは，超解像アルゴリズムのファミリー全体に共通するインターフェースを定義するためにのみ使用されます．


元関数名(C#): superres_Ptr_SuperResolution_get
元DLLエクスポート名: superres_Ptr_SuperResolution_get
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_Ptr_SuperResolution_get(
    cv::Ptr&amp;lt;cv::superres::SuperResolution&amp;gt; *ptr, cv::superres::SuperResolution **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_Ptr_SuperResolution_delete
[32/64bit] cv::superres::SuperResolution のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
超解像アルゴリズムのベースクラスです．

このクラスは，超解像アルゴリズムのファミリー全体に共通するインターフェースを定義するためにのみ使用されます．


元関数名(C#): superres_Ptr_SuperResolution_delete
元DLLエクスポート名: superres_Ptr_SuperResolution_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_Ptr_SuperResolution_delete(cv::Ptr&amp;lt;cv::superres::SuperResolution&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_getScale
[32/64bit] スケールファクター。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
alsosetScale参照

元関数名(C#): superres_SuperResolution_getScale
元DLLエクスポート名: superres_SuperResolution_getScale
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_getScale(cv::superres::SuperResolution *obj, int *returnValue)              { BEGIN_WRAP *returnValue = obj-&amp;gt;getScale(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_setScale
[32/64bit] スケールファクター。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
alsogetScaleを参照してください。

元関数名(C#): superres_SuperResolution_setScale
元DLLエクスポート名: superres_SuperResolution_setScale
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_setScale(cv::superres::SuperResolution *obj, int val)                       { BEGIN_WRAP obj-&amp;gt;setScale(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_getIterations
[32/64bit] 反復回数.
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
alsosetIterationsを参照。

元関数名(C#): superres_SuperResolution_getIterations
元DLLエクスポート名: superres_SuperResolution_getIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_getIterations(cv::superres::SuperResolution *obj, int *returnValue)         { BEGIN_WRAP *returnValue = obj-&amp;gt;getIterations(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_setIterations
[32/64bit] 反復回数.
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
alsogetIterationsを参照。

元関数名(C#): superres_SuperResolution_setIterations
元DLLエクスポート名: superres_SuperResolution_setIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_setIterations(cv::superres::SuperResolution *obj, int val)                  { BEGIN_WRAP obj-&amp;gt;setIterations(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_getTau
[32/64bit] 最急降下法の漸近値。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
アルソセットタウを見る

元関数名(C#): superres_SuperResolution_getTau
元DLLエクスポート名: superres_SuperResolution_getTau
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_getTau(cv::superres::SuperResolution *obj, double *returnValue)             { BEGIN_WRAP *returnValue = obj-&amp;gt;getTau(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_setTau
[32/64bit] 最急降下法の漸近値。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
アルソージェットタウを見る

元関数名(C#): superres_SuperResolution_setTau
元DLLエクスポート名: superres_SuperResolution_setTau
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_setTau(cv::superres::SuperResolution *obj, double val)                      { BEGIN_WRAP obj-&amp;gt;setTau(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_getLambda
[32/64bit] data項とsmoothness項のバランスをとるためのウェイトパラメータ。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
アルソセットラムダを見る

元関数名(C#): superres_SuperResolution_getLambda
元DLLエクスポート名: superres_SuperResolution_getLambda
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_getLambda(cv::superres::SuperResolution *obj, double *returnValue)          { BEGIN_WRAP *returnValue = obj-&amp;gt;getLambda(); END_WRAP } 

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_setLambda
[32/64bit] data項とsmoothness項のバランスをとるためのウェイトパラメータ。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
アルソゲトラムダを見る

元関数名(C#): superres_SuperResolution_setLambda
元DLLエクスポート名: superres_SuperResolution_setLambda
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_setLambda(cv::superres::SuperResolution *obj, double val)                   { BEGIN_WRAP obj-&amp;gt;setLambda(val); END_WRAP } 

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_getAlpha
[32/64bit] Bilateral-TVの空間分布のパラメータです。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
アルソセットアルファー参照

元関数名(C#): superres_SuperResolution_getAlpha
元DLLエクスポート名: superres_SuperResolution_getAlpha
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_getAlpha(cv::superres::SuperResolution *obj, double *returnValue)           { BEGIN_WRAP *returnValue = obj-&amp;gt;getAlpha(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_setAlpha
[32/64bit] Bilateral-TVの空間分布のパラメータです。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
alsogetAlpha参照

元関数名(C#): superres_SuperResolution_setAlpha
元DLLエクスポート名: superres_SuperResolution_setAlpha
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_setAlpha(cv::superres::SuperResolution *obj, double val)                    { BEGIN_WRAP obj-&amp;gt;setAlpha(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_getKernelSize
[32/64bit] Bilateral-TV フィルタのカーネルサイズ．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
alsosetKernelSize を参照してください。

元関数名(C#): superres_SuperResolution_getKernelSize
元DLLエクスポート名: superres_SuperResolution_getKernelSize
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_getKernelSize(cv::superres::SuperResolution *obj, int *returnValue)         { BEGIN_WRAP *returnValue = obj-&amp;gt;getKernelSize(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_setKernelSize
[32/64bit] Bilateral-TV フィルタのカーネルサイズ．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
alsogetKernelSize を参照してください。

元関数名(C#): superres_SuperResolution_setKernelSize
元DLLエクスポート名: superres_SuperResolution_setKernelSize
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_setKernelSize(cv::superres::SuperResolution *obj, int val)                  { BEGIN_WRAP obj-&amp;gt;setKernelSize(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_getBlurKernelSize
[32/64bit] ガウスブラーのカーネルサイズ
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
alsosetBlurKernelSize参照。

元関数名(C#): superres_SuperResolution_getBlurKernelSize
元DLLエクスポート名: superres_SuperResolution_getBlurKernelSize
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_getBlurKernelSize(cv::superres::SuperResolution *obj, int *returnValue)     { BEGIN_WRAP *returnValue = obj-&amp;gt;getBlurKernelSize(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_setBlurKernelSize
[32/64bit] ガウスブラーのカーネルサイズ
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
alsogetBlurKernelSize参照

元関数名(C#): superres_SuperResolution_setBlurKernelSize
元DLLエクスポート名: superres_SuperResolution_setBlurKernelSize
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_setBlurKernelSize(cv::superres::SuperResolution *obj, int val)              { BEGIN_WRAP obj-&amp;gt;setBlurKernelSize(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_getBlurSigma
[32/64bit] ガウスぼかしのシグマ。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
参照：「alsosetBlurSigma

元関数名(C#): superres_SuperResolution_getBlurSigma
元DLLエクスポート名: superres_SuperResolution_getBlurSigma
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_getBlurSigma(cv::superres::SuperResolution *obj, double *returnValue)       { BEGIN_WRAP *returnValue = obj-&amp;gt;getBlurSigma(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_setBlurSigma
[32/64bit] ガウスぼかしのシグマ。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
参照：「alsogetBlurSigma

元関数名(C#): superres_SuperResolution_setBlurSigma
元DLLエクスポート名: superres_SuperResolution_setBlurSigma
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_setBlurSigma(cv::superres::SuperResolution *obj, double val)                { BEGIN_WRAP obj-&amp;gt;setBlurSigma(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_getTemporalAreaRadius
[32/64bit] 時間軸方向の検索領域の半径。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
参照：alsosetTemporalAreaRadius

元関数名(C#): superres_SuperResolution_getTemporalAreaRadius
元DLLエクスポート名: superres_SuperResolution_getTemporalAreaRadius
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_getTemporalAreaRadius(cv::superres::SuperResolution *obj, int *returnValue) { BEGIN_WRAP *returnValue = obj-&amp;gt;getTemporalAreaRadius(); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_setTemporalAreaRadius
[32/64bit] 時間軸方向の検索領域の半径。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
alsogetTemporalAreaRadius を参照してください。

元関数名(C#): superres_SuperResolution_setTemporalAreaRadius
元DLLエクスポート名: superres_SuperResolution_setTemporalAreaRadius
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_setTemporalAreaRadius(cv::superres::SuperResolution *obj, int val)          { BEGIN_WRAP obj-&amp;gt;setTemporalAreaRadius(val); END_WRAP }

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_getOpticalFlow
[32/64bit] superres_SuperResolution_getOpticalFlow
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): superres_SuperResolution_getOpticalFlow
元DLLエクスポート名: superres_SuperResolution_getOpticalFlow
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_getOpticalFlow(cv::superres::SuperResolution *obj, cv::Ptr&amp;lt;cv::superres::DenseOpticalFlowExt&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::Ptr&amp;lt;cv::superres::DenseOpticalFlowExt&amp;gt;(obj-&amp;gt;getOpticalFlow());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
superres_SuperResolution_setOpticalFlow
[32/64bit] 密なオプティカルフローアルゴリズム。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr val
%inst
関連項目： alsogetOpticalFlow

元関数名(C#): superres_SuperResolution_setOpticalFlow
元DLLエクスポート名: superres_SuperResolution_setOpticalFlow
参照元CSファイル: Internal\PInvoke\NativeMethods\superres\NativeMethods_superres_SuperResolution.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) superres_SuperResolution_setOpticalFlow(cv::superres::SuperResolution *obj, cv::Ptr&amp;lt;cv::superres::DenseOpticalFlowExt&amp;gt; *val)
{
    BEGIN_WRAP
    obj-&amp;gt;setOpticalFlow(*val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_superres_SuperResolution

%index
text_OCRTesseract_run1
[32/64bit] tesseract-ocr APIを用いてテキストを認識します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = sptr : IntPtr outputText
p4 = sptr : IntPtr componentRects
p5 = sptr : IntPtr componentTexts
p6 = sptr : IntPtr componentConfidences
p7 = int : int componentLevel
%inst
入力として画像を受け取り、output_textパラメータで認識したテキストを返します。オプションとして，検出された個々のテキスト要素（例えば，単語）のRectsと，それらのテキスト要素のリストとその信頼度の値も提供します．

元関数名(C#): text_OCRTesseract_run1
元DLLエクスポート名: text_OCRTesseract_run1
参照元CSファイル: Internal\PInvoke\NativeMethods\text\NativeMethods_text.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) text_OCRTesseract_run1(
    cv::text::OCRTesseract *obj,
    cv::Mat *image,
    std::string *output_text,
    std::vector&amp;lt;cv::Rect&amp;gt;* component_rects,
    std::vector&amp;lt;std::string&amp;gt;* component_texts,
    std::vector&amp;lt;float&amp;gt;* component_confidences,
    int component_level)
{
    BEGIN_WRAP
    obj-&amp;gt;run(*image, *output_text, component_rects, component_texts, component_confidences, component_level);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_text

%index
text_OCRTesseract_run2
[32/64bit] tesseract-ocr APIを用いてテキストを認識します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = sptr : IntPtr mask
p4 = sptr : IntPtr outputText
p5 = sptr : IntPtr componentRects
p6 = sptr : IntPtr componentTexts
p7 = sptr : IntPtr componentConfidences
p8 = int : int componentLevel
%inst
入力として画像を受け取り、output_textパラメータで認識したテキストを返します。オプションとして，検出された個々のテキスト要素（例えば，単語）のRectsと，それらのテキスト要素のリストとその信頼度の値も提供します．

元関数名(C#): text_OCRTesseract_run2
元DLLエクスポート名: text_OCRTesseract_run2
参照元CSファイル: Internal\PInvoke\NativeMethods\text\NativeMethods_text.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) text_OCRTesseract_run2(
    cv::text::OCRTesseract *obj,
    cv::Mat *image,
    cv::Mat *mask,
    std::string *output_text,
    std::vector&amp;lt;cv::Rect&amp;gt;* component_rects,
    std::vector&amp;lt;std::string&amp;gt;* component_texts,
    std::vector&amp;lt;float&amp;gt;* component_confidences,
    int component_level)
{
    BEGIN_WRAP
    obj-&amp;gt;run(*image, *mask, *output_text, component_rects, component_texts, component_confidences, component_level);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_text

%index
text_OCRTesseract_setWhiteList
[32/64bit] text_OCRTesseract_setWhiteList
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string charWhitelist
%inst
元関数名(C#): text_OCRTesseract_setWhiteList
元DLLエクスポート名: text_OCRTesseract_setWhiteList
参照元CSファイル: Internal\PInvoke\NativeMethods\text\NativeMethods_text.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) text_OCRTesseract_setWhiteList(
    cv::text::OCRTesseract *obj,
    const char *char_whitelist)
{
    BEGIN_WRAP
    obj-&amp;gt;setWhiteList(char_whitelist);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_text

%index
text_OCRTesseract_create
[32/64bit] OCRTesseract クラスのインスタンスを作成します．Tesseractを初期化します．
%prm
p1,p2,p3,p4,p5,p6
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string? datapath
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string? language
p3 = str : [MarshalAs(UnmanagedType.LPStr)] string? charWhitelist
p4 = int : int oem
p5 = int : int psmode
p6 = var : out IntPtr returnValue
%inst
元関数名(C#): text_OCRTesseract_create
元DLLエクスポート名: text_OCRTesseract_create
参照元CSファイル: Internal\PInvoke\NativeMethods\text\NativeMethods_text.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) text_OCRTesseract_create(
    const char* datapath,
    const char* language,
    const char* char_whitelist, 
    int oem, 
    int psmode,
    cv::Ptr&amp;lt;cv::text::OCRTesseract&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto result = cv::text::OCRTesseract::create(datapath, language, char_whitelist, oem, psmode);
    *returnValue = clone(result);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_text

%index
text_Ptr_OCRTesseract_delete
[32/64bit] cv::text::OCRTesseract のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
OCRTesseractクラスはC++でtesseract-ocr API (v3.02.02)とのインターフェイスを提供します。

これはtesseract-ocrが正しくインストールされている場合にのみコンパイルされることに注意してください。

備考

(C++) シーンテキスト検出と組み合わせたOCRTesseract認識の例は、end_to_end_recognitionデモで見ることができます： https://github.com/opencv/opencv_contrib/blob/master/modules/text/samples/end_to_end_recognition.cpp

(C++) シーンテキスト検出と組み合わせたOCRTesseract認識の別の例は、Webcam_demo: https://github.com/opencv/opencv_contrib/blob/master/modules/text/samples/webcam_demo.cpp で見ることができます。


元関数名(C#): text_Ptr_OCRTesseract_delete
元DLLエクスポート名: text_Ptr_OCRTesseract_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\text\NativeMethods_text.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) text_Ptr_OCRTesseract_delete(
    cv::Ptr&amp;lt;cv::text::OCRTesseract&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_text

%index
text_OCRTesseract_get
[32/64bit] cv::text::OCRTesseract のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
OCRTesseractクラスはC++でtesseract-ocr API (v3.02.02)とのインターフェイスを提供します。

これはtesseract-ocrが正しくインストールされている場合にのみコンパイルされることに注意してください。

備考

(C++) シーンテキスト検出と組み合わせたOCRTesseract認識の例は、end_to_end_recognitionデモで見ることができます： https://github.com/opencv/opencv_contrib/blob/master/modules/text/samples/end_to_end_recognition.cpp

(C++) シーンテキスト検出と組み合わせたOCRTesseract認識の別の例は、Webcam_demo: https://github.com/opencv/opencv_contrib/blob/master/modules/text/samples/webcam_demo.cpp で見ることができます。


元関数名(C#): text_OCRTesseract_get
元DLLエクスポート名: text_OCRTesseract_get
参照元CSファイル: Internal\PInvoke\NativeMethods\text\NativeMethods_text.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) text_OCRTesseract_get(
    cv::Ptr&amp;lt;cv::text::OCRTesseract&amp;gt; *obj, cv::text::OCRTesseract **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_text

%index
text_detectTextSWT
[32/64bit] ストローク幅変換演算子を適用した後、類似したストローク幅の接続されたコンポーネントのフィルタリングを行い、文字候補を返します。また，それらを近接度とサイズで連鎖させ，結果を chainBB に保存する．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr input
p2 = sptr : IntPtr result
p3 = int : int darkOnLight
p4 = sptr : IntPtr draw
p5 = sptr : IntPtr chainBBs
%inst
元関数名(C#): text_detectTextSWT
元DLLエクスポート名: text_detectTextSWT
参照元CSファイル: Internal\PInvoke\NativeMethods\text\NativeMethods_text.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) text_detectTextSWT(
    cv::_InputArray *input, std::vector&amp;lt;cv::Rect&amp;gt; *result, int dark_on_light, cv::_OutputArray *draw, cv::_OutputArray *chainBBs)
{
    BEGIN_WRAP
    cv::text::detectTextSWT(*input, *result, dark_on_light != 0, entity(draw), entity(chainBBs));
    END_WRAP    
}

</pre>
}html
%group
NativeMethods_text

%index
text_TextDetector_detect
[32/64bit] 画像内のテキストを検出するための迅速かつシンプルなインターフェースを提供するメソッド。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr inputImage
p3 = sptr : IntPtr bbox
p4 = sptr : IntPtr confidence
%inst
cv::text::TextDetectorCNN で実装されています．

元関数名(C#): text_TextDetector_detect
元DLLエクスポート名: text_TextDetector_detect
参照元CSファイル: Internal\PInvoke\NativeMethods\text\NativeMethods_text_TextDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) text_TextDetector_detect(cv::text::TextDetector *obj, cv::_InputArray *inputImage, std::vector&amp;lt;cv::Rect&amp;gt; *Bbox, std::vector&amp;lt;float&amp;gt; *confidence)
{
    BEGIN_WRAP
    obj-&amp;gt;detect(*inputImage, *Bbox, *confidence);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_text_TextDetector

%index
text_TextDetectorCNN_detect
[32/64bit] この関数は，便宜上，オーバーロードされたメンバ関数です．上の関数との違いは，どのような引数を受け取るかだけです．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr inputImage
p3 = sptr : IntPtr bbox
p4 = sptr : IntPtr confidence
%inst
cv::text::TextDetector を実装しています．

元関数名(C#): text_TextDetectorCNN_detect
元DLLエクスポート名: text_TextDetectorCNN_detect
参照元CSファイル: Internal\PInvoke\NativeMethods\text\NativeMethods_text_TextDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) text_TextDetectorCNN_detect(cv::text::TextDetectorCNN *obj, cv::_InputArray *inputImage, std::vector&amp;lt;cv::Rect&amp;gt; *Bbox, std::vector&amp;lt;float&amp;gt; *confidence)
{
    BEGIN_WRAP
    obj-&amp;gt;detect(*inputImage, *Bbox, *confidence);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_text_TextDetector

%index
text_TextDetectorCNN_create1
[32/64bit] 与えられたパラメータを用いて，TextDetectorCNN クラスのインスタンスを作成します．
%prm
p1,p2,p3,p4,p5
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string modelArchFilename
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string modelWeightsFilename
p3 = var : [MarshalAs(UnmanagedType.LPArray)] Size[] detectionSizes
p4 = int : int detectionSizesLength
p5 = var : out IntPtr returnValue
%inst
元関数名(C#): text_TextDetectorCNN_create1
元DLLエクスポート名: text_TextDetectorCNN_create1
参照元CSファイル: Internal\PInvoke\NativeMethods\text\NativeMethods_text_TextDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) text_TextDetectorCNN_create1(
    const char *modelArchFilename, const char *modelWeightsFilename, MyCvSize *detectionSizes, int detectionSizesLength,
    cv::Ptr&amp;lt;cv::text::TextDetectorCNN&amp;gt; **returnValue)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Size&amp;gt; detectionSizesVec;
    if (detectionSizes != nullptr)
    {
        detectionSizesVec.resize(detectionSizesLength);
        for (int i = 0; i &amp;lt; detectionSizesLength; i++)
            detectionSizesVec[i] = cpp(detectionSizes[i]);
    }

    const auto ptr = cv::text::TextDetectorCNN::create(modelArchFilename, modelWeightsFilename, detectionSizesVec);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_text_TextDetector

%index
text_TextDetectorCNN_create2
[32/64bit] 与えられたパラメータを用いて，TextDetectorCNN クラスのインスタンスを作成します．
%prm
p1,p2,p3
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string modelArchFilename
p2 = str : [MarshalAs(UnmanagedType.LPStr)] string modelWeightsFilename
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): text_TextDetectorCNN_create2
元DLLエクスポート名: text_TextDetectorCNN_create2
参照元CSファイル: Internal\PInvoke\NativeMethods\text\NativeMethods_text_TextDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) text_TextDetectorCNN_create2(
    const char *modelArchFilename, const char *modelWeightsFilename, cv::Ptr&amp;lt;cv::text::TextDetectorCNN&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::text::TextDetectorCNN::create(modelArchFilename, modelWeightsFilename);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_text_TextDetector

%index
text_Ptr_TextDetectorCNN_delete
[32/64bit] cv::text::TextDetectorCNN のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
TextDetectorCNNクラスは、テキストのバウンディングボックスを検出する機能を提供します。このクラスは，入力画像に含まれるテキスト単語のバウンディングボックスを検出するためのものです．このクラスは，OpenCV dnnモジュールを使用して，[146]に記載されている事前学習済みモデルをロードします．SSDのCaffeバージョンを修正したオリジナルのリポジトリ： https://github.com/MhLiao/TextBoxes.モデルはDropBoxからダウンロードできます。モデルの説明を含む修正された.prototxtファイルは、opencv_contrib/modules/text/samples/textbox.prototxtにあります。


元関数名(C#): text_Ptr_TextDetectorCNN_delete
元DLLエクスポート名: text_Ptr_TextDetectorCNN_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\text\NativeMethods_text_TextDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) text_Ptr_TextDetectorCNN_delete(cv::Ptr&amp;lt;cv::text::TextDetectorCNN&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_text_TextDetector

%index
text_Ptr_TextDetectorCNN_get
[32/64bit] cv::text::TextDetectorCNN のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
TextDetectorCNNクラスは、テキストのバウンディングボックスを検出する機能を提供します。このクラスは，入力画像に含まれるテキスト単語のバウンディングボックスを検出するためのものです．このクラスは，OpenCV dnnモジュールを使用して，[146]に記載されている事前学習済みモデルをロードします．SSDのCaffeバージョンを修正したオリジナルのリポジトリ： https://github.com/MhLiao/TextBoxes.モデルはDropBoxからダウンロードできます。モデルの説明を含む修正された.prototxtファイルは、opencv_contrib/modules/text/samples/textbox.prototxtにあります。


元関数名(C#): text_Ptr_TextDetectorCNN_get
元DLLエクスポート名: text_Ptr_TextDetectorCNN_get
参照元CSファイル: Internal\PInvoke\NativeMethods\text\NativeMethods_text_TextDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) text_Ptr_TextDetectorCNN_get(cv::Ptr&amp;lt;cv::text::TextDetectorCNN&amp;gt;* obj, cv::text::TextDetectorCNN **returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_text_TextDetector

%index
tracking_TrackerKCF_create1
[32/64bit] KCFトラッカーのインスタンスを作成します。
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): tracking_TrackerKCF_create1
元DLLエクスポート名: tracking_TrackerKCF_create1
参照元CSファイル: Internal\PInvoke\NativeMethods\traking\NativeMethods_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) tracking_TrackerKCF_create1(cv::Ptr&amp;lt;cv::TrackerKCF&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto p = cv::TrackerKCF::create();
    *returnValue = clone(p);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_tracking

%index
tracking_TrackerKCF_create2
[32bit] KCFトラッカーのインスタンスを作成します。
%prm
p1,p2
p1 = ARGS_TRACKERKCF_PARAMS : TrackerKCF.Params parameters
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): tracking_TrackerKCF_create2
元DLLエクスポート名: tracking_TrackerKCF_create2
参照元CSファイル: Internal\PInvoke\NativeMethods\traking\NativeMethods_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) tracking_TrackerKCF_create2(cv::TrackerKCF::Params *parameters, cv::Ptr&amp;lt;cv::TrackerKCF&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto p = cv::TrackerKCF::create(*parameters);
    *returnValue = clone(p);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_tracking

%index
tracking_TrackerKCF_create2
[64bit] KCFトラッカーのインスタンスを作成します。
%prm
p1,p2
p1 = var : TrackerKCF.Params parameters
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): tracking_TrackerKCF_create2
元DLLエクスポート名: tracking_TrackerKCF_create2
参照元CSファイル: Internal\PInvoke\NativeMethods\traking\NativeMethods_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) tracking_TrackerKCF_create2(cv::TrackerKCF::Params *parameters, cv::Ptr&amp;lt;cv::TrackerKCF&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto p = cv::TrackerKCF::create(*parameters);
    *returnValue = clone(p);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_tracking

%index
tracking_Ptr_TrackerKCF_delete
[32/64bit] cv::TrackerKCF のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
KCF（Kernelized Correlation Filter）トラッカー

KCFは，サーキュラント行列の特性を利用して処理速度を向上させる，新しいトラッキングフレームワークです．このトラッキング手法は，[108]の実装であり，それを色名の特徴を持つKCFに拡張したものです（[51]）．KCFの原論文は、http://www.robots.ox.ac.uk/~joao/publications/henriques_tpami2015.pdfで公開されており、matlabの実装も公開されています。色名の特徴を持つKCFについては、http://www.cvl.isy.liu.se/research/objrec/visualtracking/colvistrack/index.html を参照してください。


元関数名(C#): tracking_Ptr_TrackerKCF_delete
元DLLエクスポート名: tracking_Ptr_TrackerKCF_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\traking\NativeMethods_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) tracking_Ptr_TrackerKCF_delete(cv::Ptr&amp;lt;cv::TrackerKCF&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_tracking

%index
tracking_Ptr_TrackerKCF_get
[32/64bit] cv::TrackerKCF のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
KCF（Kernelized Correlation Filter）トラッカー

KCFは，サーキュラント行列の特性を利用して処理速度を向上させる，新しいトラッキングフレームワークです．このトラッキング手法は，[108]の実装であり，それを色名の特徴を持つKCFに拡張したものです（[51]）．KCFの原論文は、http://www.robots.ox.ac.uk/~joao/publications/henriques_tpami2015.pdfで公開されており、matlabの実装も公開されています。色名の特徴を持つKCFについては、http://www.cvl.isy.liu.se/research/objrec/visualtracking/colvistrack/index.html を参照してください。


元関数名(C#): tracking_Ptr_TrackerKCF_get
元DLLエクスポート名: tracking_Ptr_TrackerKCF_get
参照元CSファイル: Internal\PInvoke\NativeMethods\traking\NativeMethods_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) tracking_Ptr_TrackerKCF_get(cv::Ptr&amp;lt;cv::TrackerKCF&amp;gt; *ptr, cv::TrackerKCF **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_tracking

%index
tracking_TrackerCSRT_create1
[32/64bit] CSRTのトラッカーインスタンスを作成します。
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): tracking_TrackerCSRT_create1
元DLLエクスポート名: tracking_TrackerCSRT_create1
参照元CSファイル: Internal\PInvoke\NativeMethods\traking\NativeMethods_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) tracking_TrackerCSRT_create1(cv::Ptr&amp;lt;cv::TrackerCSRT&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto p = cv::TrackerCSRT::create();
    *returnValue = clone(p);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_tracking

%index
tracking_TrackerCSRT_create2
[32/64bit] CSRTのトラッカーインスタンスを作成します。
%prm
p1,p2
p1 = var : ref TrackerCSRT.Params parameters
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): tracking_TrackerCSRT_create2
元DLLエクスポート名: tracking_TrackerCSRT_create2
参照元CSファイル: Internal\PInvoke\NativeMethods\traking\NativeMethods_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) tracking_TrackerCSRT_create2(tracker_TrackerCSRT_Params* parameters, cv::Ptr&amp;lt;cv::TrackerCSRT&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto p = tracking_TrackerCSRT_Param_ToCpp(parameters);
    const auto obj = cv::TrackerCSRT::create(p);
    *returnValue = clone(obj);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_tracking

%index
tracking_Ptr_TrackerCSRT_delete
[32/64bit] cv::TrackerCSRT のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
CSRTトラッカー

実装は、[156] Discriminative Correlation Filter with Channel and Spatial Reliability に基づいています。


元関数名(C#): tracking_Ptr_TrackerCSRT_delete
元DLLエクスポート名: tracking_Ptr_TrackerCSRT_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\traking\NativeMethods_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) tracking_Ptr_TrackerCSRT_delete(cv::Ptr&amp;lt;cv::TrackerCSRT&amp;gt;* ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_tracking

%index
tracking_Ptr_TrackerCSRT_get
[32/64bit] cv::TrackerCSRT のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
CSRTトラッカー

実装は、[156] Discriminative Correlation Filter with Channel and Spatial Reliability に基づいています。


元関数名(C#): tracking_Ptr_TrackerCSRT_get
元DLLエクスポート名: tracking_Ptr_TrackerCSRT_get
参照元CSファイル: Internal\PInvoke\NativeMethods\traking\NativeMethods_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) tracking_Ptr_TrackerCSRT_get(cv::Ptr&amp;lt;cv::TrackerCSRT&amp;gt;* ptr, cv::TrackerCSRT **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_tracking

%index
tracking_TrackerCSRT_setInitialMask
[32/64bit] tracking_TrackerCSRT_setInitialMask
%prm
p1,p2
p1 = sptr : IntPtr tracker
p2 = sptr : IntPtr mask
%inst
元関数名(C#): tracking_TrackerCSRT_setInitialMask
元DLLエクスポート名: tracking_TrackerCSRT_setInitialMask
参照元CSファイル: Internal\PInvoke\NativeMethods\traking\NativeMethods_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) tracking_TrackerCSRT_setInitialMask(cv::TrackerCSRT *tracker, cv::_InputArray *mask)
{
    BEGIN_WRAP
    tracker-&amp;gt;setInitialMask(*mask);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_tracking

%index
video_BackgroundSubtractor_getBackgroundImage
[32/64bit] 背景画像を計算します。
%prm
p1,p2
p1 = sptr : IntPtr self
p2 = sptr : IntPtr backgroundImage
%inst
CV::bgsegm::BackgroundSubtractorLSBP, cv::bgsegm::BackgroundSubtractorGSOC, および cv::bgsegm::BackgroundSubtractorCNT で実装されています．

元関数名(C#): video_BackgroundSubtractor_getBackgroundImage
元DLLエクスポート名: video_BackgroundSubtractor_getBackgroundImage
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractor_getBackgroundImage(cv::BackgroundSubtractor *obj, cv::_OutputArray *backgroundImage)
{
    BEGIN_WRAP
    obj-&amp;gt;getBackgroundImage(*backgroundImage);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BackgroundSubtractor_apply
[32/64bit] 前景マスクを計算します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr self
p2 = sptr : IntPtr image
p3 = sptr : IntPtr fgmask
p4 = double : double learningRate
%inst
cv::bgsegm::BackgroundSubtractorLSBP, cv::bgsegm::BackgroundSubtractorGSOC, cv::BackgroundSubtractorMOG2, および cv::bgsegm::BackgroundSubtractorCNT で実装されています．

元関数名(C#): video_BackgroundSubtractor_apply
元DLLエクスポート名: video_BackgroundSubtractor_apply
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractor_apply(cv::BackgroundSubtractor *obj, cv::_InputArray *image, cv::_OutputArray *fgmask, double learningRate)
{
    BEGIN_WRAP
    obj-&amp;gt;apply(*image, *fgmask, learningRate);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_Ptr_BackgroundSubtractor_delete
[32/64bit] cv::BackgroundSubtractor のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
背景/前景セグメンテーションの基本クラス．

このクラスは，背景/前景セグメンテーションアルゴリズム群全体に共通するインタフェースを定義するためにのみ利用されます．


元関数名(C#): video_Ptr_BackgroundSubtractor_delete
元DLLエクスポート名: video_Ptr_BackgroundSubtractor_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_Ptr_BackgroundSubtractor_delete(cv::Ptr&amp;lt;cv::BackgroundSubtractor&amp;gt; *ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_Ptr_BackgroundSubtractor_get
[32/64bit] cv::BackgroundSubtractor のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
背景/前景セグメンテーションの基本クラス．

このクラスは，背景/前景セグメンテーションアルゴリズム群全体に共通するインタフェースを定義するためにのみ利用されます．


元関数名(C#): video_Ptr_BackgroundSubtractor_get
元DLLエクスポート名: video_Ptr_BackgroundSubtractor_get
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_Ptr_BackgroundSubtractor_get(cv::Ptr&amp;lt;cv::BackgroundSubtractor&amp;gt; *ptr, cv::BackgroundSubtractor **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_createBgSubtractorMOG2
[32/64bit][関数名変更] MOG2 Background Subtractorを作成します。
%prm
p1,p2,p3,p4
p1 = int : int history
p2 = double : double varThreshold
p3 = int : int detectShadows
p4 = var : out IntPtr returnValue
%inst
例： samples/cpp/segment_objects.cpp.

元関数名(C#): video_createBackgroundSubtractorMOG2
元DLLエクスポート名: video_createBackgroundSubtractorMOG2
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_createBackgroundSubtractorMOG2(int history, double varThreshold, int detectShadows, cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::createBackgroundSubtractorMOG2(history, varThreshold, detectShadows != 0);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_Ptr_BgSubtractorMOG2_delete
[32/64bit][関数名変更] cv::BackgroundSubtractorMOG2 のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
Gaussian Mixture-based Background/Foreground Segmentation Algorithm.

このクラスは，[299]および[298]で述べられているガウス混合モデルによる背景減算を実装しています．


元関数名(C#): video_Ptr_BackgroundSubtractorMOG2_delete
元DLLエクスポート名: video_Ptr_BackgroundSubtractorMOG2_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_Ptr_BackgroundSubtractorMOG2_delete(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_Ptr_BgSubtractorMOG2_get
[32/64bit][関数名変更] cv::BackgroundSubtractorMOG2 のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
Gaussian Mixture-based Background/Foreground Segmentation Algorithm.

このクラスは，[299]および[298]で述べられているガウス混合モデルによる背景減算を実装しています．


元関数名(C#): video_Ptr_BackgroundSubtractorMOG2_get
元DLLエクスポート名: video_Ptr_BackgroundSubtractorMOG2_get
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_Ptr_BackgroundSubtractorMOG2_get(
    cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, cv::BackgroundSubtractorMOG2 **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_getHistory
[32/64bit][関数名変更] 背景モデルに影響を与える最後のフレームの数を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out int returnValue
%inst
元関数名(C#): video_BackgroundSubtractorMOG2_getHistory
元DLLエクスポート名: video_BackgroundSubtractorMOG2_getHistory
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_getHistory(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getHistory();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_setHistory
[32/64bit][関数名変更] video_BgSubtractorMOG2_setHistory
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = int : int value
%inst
元関数名(C#): video_BackgroundSubtractorMOG2_setHistory
元DLLエクスポート名: video_BackgroundSubtractorMOG2_setHistory
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_setHistory(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, int value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setHistory(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_getNMixtures
[32/64bit][関数名変更] 背景モデルに含まれるガウス成分の数を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out int returnValue
%inst
元関数名(C#): video_BackgroundSubtractorMOG2_getNMixtures
元DLLエクスポート名: video_BackgroundSubtractorMOG2_getNMixtures
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_getNMixtures(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getNMixtures();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_setNMixtures
[32/64bit][関数名変更] 背景モデルのガウシアン成分の数を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = int : int value
%inst
メモリを確保するためにモデルを再起動する必要がある。

元関数名(C#): video_BackgroundSubtractorMOG2_setNMixtures
元DLLエクスポート名: video_BackgroundSubtractorMOG2_setNMixtures
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_setNMixtures(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, int value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setNMixtures(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_getBackgroundRatio
[32/64bit][関数名変更] アルゴリズムの "背景比率 "パラメーターを返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out double returnValue
%inst
前景のピクセルが backgroundRatio*history フレーム程度の間、半一定の値を維持する場合、そのピクセルは背景とみなされ、新しい成分の中心としてモデルに追加されます。これは論文中のTBパラメータに相当します。

元関数名(C#): video_BackgroundSubtractorMOG2_getBackgroundRatio
元DLLエクスポート名: video_BackgroundSubtractorMOG2_getBackgroundRatio
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_getBackgroundRatio(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getBackgroundRatio();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_setBackgroundRatio
[32/64bit][関数名変更] アルゴリズムの "background ratio "パラメータを設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = double : double value
%inst
元関数名(C#): video_BackgroundSubtractorMOG2_setBackgroundRatio
元DLLエクスポート名: video_BackgroundSubtractorMOG2_setBackgroundRatio
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_setBackgroundRatio(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, double value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setBackgroundRatio(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_getVarThreshold
[32/64bit][関数名変更] ピクセルとモデルのマッチングのための分散しきい値を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out double returnValue
%inst
サンプルが背景モデルによってよく記述されているかどうかを判断するための、二乗マハラノビス距離に関する主な閾値です。論文中の Cthr に関連しています。

元関数名(C#): video_BackgroundSubtractorMOG2_getVarThreshold
元DLLエクスポート名: video_BackgroundSubtractorMOG2_getVarThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_getVarThreshold(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getVarThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_setVarThreshold
[32/64bit][関数名変更] pixel-model match用の分散しきい値を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = double : double value
%inst
元関数名(C#): video_BackgroundSubtractorMOG2_setVarThreshold
元DLLエクスポート名: video_BackgroundSubtractorMOG2_setVarThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_setVarThreshold(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, double value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setVarThreshold(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_getVarThresholdGen
[32/64bit][関数名変更] Return the variance threshold for the pixel-model match used for new mixture component generation.
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out double returnValue
%inst
Threshold for squared Mahalanobis distance これは、サンプルが既存の成分に近いかどうかを判断するのに役立ちます（論文中の Tg に対応）。あるピクセルがどのコンポーネントにも近接していない場合、そのピクセルは前景とみなされ、新しいコンポーネントとして追加されます。3シグマ => Tg=3*3=9がデフォルトです。Tgの値を小さくすると、より多くのコンポーネントが生成されます。Tg値を大きくすると、成分の数は少なくても、大きくなりすぎてしまうことがあります。

元関数名(C#): video_BackgroundSubtractorMOG2_getVarThresholdGen
元DLLエクスポート名: video_BackgroundSubtractorMOG2_getVarThresholdGen
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_getVarThresholdGen(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, double *returnValue)
{
    BEGIN_WRAP
     *returnValue = (*ptr)-&amp;gt;getVarThresholdGen();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_setVarThresholdGen
[32/64bit][関数名変更] 新しい混合成分の生成に使われるピクセルとモデルのマッチングのための分散のしきい値を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = double : double value
%inst
元関数名(C#): video_BackgroundSubtractorMOG2_setVarThresholdGen
元DLLエクスポート名: video_BackgroundSubtractorMOG2_setVarThresholdGen
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_setVarThresholdGen(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, double value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setVarThresholdGen(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_getVarInit
[32/64bit][関数名変更] Return the initial variance of each gaussian components. （各ガウス成分の初期分散を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out double returnValue
%inst
元関数名(C#): video_BackgroundSubtractorMOG2_getVarInit
元DLLエクスポート名: video_BackgroundSubtractorMOG2_getVarInit
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_getVarInit(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getVarInit();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_setVarInit
[32/64bit][関数名変更] 各ガウシアンコンポーネントの初期分散を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = double : double value
%inst
元関数名(C#): video_BackgroundSubtractorMOG2_setVarInit
元DLLエクスポート名: video_BackgroundSubtractorMOG2_setVarInit
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_setVarInit(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, double value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setVarInit(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_getVarMin
[32/64bit][関数名変更] video_BgSubtractorMOG2_getVarMin
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out double returnValue
%inst
元関数名(C#): video_BackgroundSubtractorMOG2_getVarMin
元DLLエクスポート名: video_BackgroundSubtractorMOG2_getVarMin
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_getVarMin(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getVarMin();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_setVarMin
[32/64bit][関数名変更] video_BgSubtractorMOG2_setVarMin
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = double : double value
%inst
元関数名(C#): video_BackgroundSubtractorMOG2_setVarMin
元DLLエクスポート名: video_BackgroundSubtractorMOG2_setVarMin
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_setVarMin(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, double value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setVarMin(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_getVarMax
[32/64bit][関数名変更] video_BgSubtractorMOG2_getVarMax
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out double returnValue
%inst
元関数名(C#): video_BackgroundSubtractorMOG2_getVarMax
元DLLエクスポート名: video_BackgroundSubtractorMOG2_getVarMax
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_getVarMax(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getVarMax();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_setVarMax
[32/64bit][関数名変更] video_BgSubtractorMOG2_setVarMax
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = double : double value
%inst
元関数名(C#): video_BackgroundSubtractorMOG2_setVarMax
元DLLエクスポート名: video_BackgroundSubtractorMOG2_setVarMax
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_setVarMax(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, double value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setVarMax(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_getComplexityReductionThreshold
[32/64bit][関数名変更] 複雑さを軽減するための閾値を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out double returnValue
%inst
このパラメータは、成分の存在を証明するために受け入れるのに必要なサンプル数を定義します。CT=0.05は、すべてのサンプルに対するデフォルト値です。CT=0を設定することで、標準的なStauffer&Grimsonアルゴリズムに非常に似たアルゴリズムが得られます。

元関数名(C#): video_BackgroundSubtractorMOG2_getComplexityReductionThreshold
元DLLエクスポート名: video_BackgroundSubtractorMOG2_getComplexityReductionThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_getComplexityReductionThreshold(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getComplexityReductionThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_setComplexityReductionThreshold
[32/64bit][関数名変更] 複雑さ軽減のしきい値を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = double : double value
%inst
元関数名(C#): video_BackgroundSubtractorMOG2_setComplexityReductionThreshold
元DLLエクスポート名: video_BackgroundSubtractorMOG2_setComplexityReductionThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_setComplexityReductionThreshold(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, double value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setComplexityReductionThreshold(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_getDetectShadows
[32/64bit][関数名変更] 影の検出フラグを返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out int returnValue
%inst
trueの場合，アルゴリズムはシャドウを検出し，それをマークします。詳細は createBackgroundSubtractorMOG2 を参照してください。

元関数名(C#): video_BackgroundSubtractorMOG2_getDetectShadows
元DLLエクスポート名: video_BackgroundSubtractorMOG2_getDetectShadows
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_getDetectShadows(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getDetectShadows() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_setDetectShadows
[32/64bit][関数名変更] 影の検出を有効または無効にします。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = int : int value
%inst
元関数名(C#): video_BackgroundSubtractorMOG2_setDetectShadows
元DLLエクスポート名: video_BackgroundSubtractorMOG2_setDetectShadows
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_setDetectShadows(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, int value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setDetectShadows(value != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_getShadowValue
[32/64bit][関数名変更] 影の値を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out int returnValue
%inst
シャドウ値とは、フォアグラウンドマスクでシャドウをマークするために使われる値です。デフォルト値は 127 です。マスク内の値0は常に背景を意味し、255は前景を意味します。

元関数名(C#): video_BackgroundSubtractorMOG2_getShadowValue
元DLLエクスポート名: video_BackgroundSubtractorMOG2_getShadowValue
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_getShadowValue(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getShadowValue();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_setShadowValue
[32/64bit][関数名変更] シャドー値を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = int : int value
%inst
元関数名(C#): video_BackgroundSubtractorMOG2_setShadowValue
元DLLエクスポート名: video_BackgroundSubtractorMOG2_setShadowValue
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_setShadowValue(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, int value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setShadowValue(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_getShadowThreshold
[32/64bit][関数名変更] 影のしきい値を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out double returnValue
%inst
シャドウは、ピクセルが背景よりも暗くなっている場合に検出されます。シャドウしきい値（論文では Tau）は、シャドウがどれだけ暗くなるかを定義するしきい値です。Tau=0.5 は，ピクセルが 2 倍以上暗くなった場合，シャドウではないことを意味します。Prati, Mikic, Trivedi, Cucchiara, Detecting Moving Shadows...*, IEEE PAMI,2003を参照。

元関数名(C#): video_BackgroundSubtractorMOG2_getShadowThreshold
元DLLエクスポート名: video_BackgroundSubtractorMOG2_getShadowThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_getShadowThreshold(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getShadowThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BgSubtractorMOG2_setShadowThreshold
[32/64bit][関数名変更] 影のしきい値を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = double : double value
%inst
元関数名(C#): video_BackgroundSubtractorMOG2_setShadowThreshold
元DLLエクスポート名: video_BackgroundSubtractorMOG2_setShadowThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorMOG2_setShadowThreshold(cv::Ptr&amp;lt;cv::BackgroundSubtractorMOG2&amp;gt; *ptr, double value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setShadowThreshold(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_createBackgroundSubtractorKNN
[32/64bit] KNN背景減算器を作成します。
%prm
p1,p2,p3,p4
p1 = int : int history
p2 = double : double dist2Threshold
p3 = int : int detectShadows
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): video_createBackgroundSubtractorKNN
元DLLエクスポート名: video_createBackgroundSubtractorKNN
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_createBackgroundSubtractorKNN(
    int history, double dist2Threshold, int detectShadows, cv::Ptr&amp;lt;cv::BackgroundSubtractorKNN&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::createBackgroundSubtractorKNN(
        history, dist2Threshold, detectShadows != 0);
    *returnValue = clone(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_Ptr_BackgroundSubtractorKNN_delete
[32/64bit] cv::BackgroundSubtractorKNN のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
K-nearest neighboursに基づく背景/森林のセグメンテーションアルゴリズム。

このクラスは，[298]で説明されているK-nearest neighboursによる背景減算を実装しています．前景ピクセルの数が少ない場合は，非常に効率的です．


元関数名(C#): video_Ptr_BackgroundSubtractorKNN_delete
元DLLエクスポート名: video_Ptr_BackgroundSubtractorKNN_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_Ptr_BackgroundSubtractorKNN_delete(cv::Ptr&amp;lt;cv::BackgroundSubtractorKNN&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_Ptr_BackgroundSubtractorKNN_get
[32/64bit] cv::BackgroundSubtractorKNN のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
K-nearest neighboursに基づく背景/森林のセグメンテーションアルゴリズム。

このクラスは，[298]で説明されているK-nearest neighboursによる背景減算を実装しています．前景ピクセルの数が少ない場合は，非常に効率的です．


元関数名(C#): video_Ptr_BackgroundSubtractorKNN_get
元DLLエクスポート名: video_Ptr_BackgroundSubtractorKNN_get
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_Ptr_BackgroundSubtractorKNN_get(
    cv::Ptr&amp;lt;cv::BackgroundSubtractorKNN&amp;gt; *ptr, cv::BackgroundSubtractorKNN **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BackgroundSubtractorKNN_getHistory
[32/64bit] 背景モデルに影響を与える最後のフレームの数を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out int returnValue
%inst
元関数名(C#): video_BackgroundSubtractorKNN_getHistory
元DLLエクスポート名: video_BackgroundSubtractorKNN_getHistory
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorKNN_getHistory(cv::Ptr&amp;lt;cv::BackgroundSubtractorKNN&amp;gt; *ptr, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getHistory();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BackgroundSubtractorKNN_setHistory
[32/64bit] 背景モデルに影響を与える最後のフレームの数を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = int : int value
%inst
元関数名(C#): video_BackgroundSubtractorKNN_setHistory
元DLLエクスポート名: video_BackgroundSubtractorKNN_setHistory
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorKNN_setHistory(cv::Ptr&amp;lt;cv::BackgroundSubtractorKNN&amp;gt; *ptr, int value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setHistory(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BackgroundSubtractorKNN_getNSamples
[32/64bit] 背景モデルのデータサンプルの数を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out int returnValue
%inst
元関数名(C#): video_BackgroundSubtractorKNN_getNSamples
元DLLエクスポート名: video_BackgroundSubtractorKNN_getNSamples
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorKNN_getNSamples(cv::Ptr&amp;lt;cv::BackgroundSubtractorKNN&amp;gt; *ptr, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getNSamples();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BackgroundSubtractorKNN_setNSamples
[32/64bit] 背景モデルのデータサンプルの数を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = int : int value
%inst
メモリを確保するためにモデルを再起動する必要がある。

元関数名(C#): video_BackgroundSubtractorKNN_setNSamples
元DLLエクスポート名: video_BackgroundSubtractorKNN_setNSamples
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorKNN_setNSamples(cv::Ptr&amp;lt;cv::BackgroundSubtractorKNN&amp;gt; *ptr, int value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setNSamples(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BackgroundSubtractorKNN_getDist2Threshold
[32/64bit] 画素とサンプルの間の二乗距離の閾値を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out int returnValue
%inst
ピクセルがデータサンプルに近いかどうかを判断するための、ピクセルとサンプルの間の二乗距離のしきい値です。

元関数名(C#): video_BackgroundSubtractorKNN_getDist2Threshold
元DLLエクスポート名: video_BackgroundSubtractorKNN_getDist2Threshold
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorKNN_getDist2Threshold(cv::Ptr&amp;lt;cv::BackgroundSubtractorKNN&amp;gt; *ptr, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getDist2Threshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BackgroundSubtractorKNN_setDist2Threshold
[32/64bit] 二乗距離の閾値を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = double : double value
%inst
元関数名(C#): video_BackgroundSubtractorKNN_setDist2Threshold
元DLLエクスポート名: video_BackgroundSubtractorKNN_setDist2Threshold
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorKNN_setDist2Threshold(cv::Ptr&amp;lt;cv::BackgroundSubtractorKNN&amp;gt; *ptr, double value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setDist2Threshold(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BackgroundSubtractorKNN_getkNNSamples
[32/64bit] kNNのkである隣人の数を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out int returnValue
%inst
Kは、そのピクセルがkNN背景モデルにマッチしていると判断するために、dist2Threshold以内に収まる必要があるサンプルの数です。

元関数名(C#): video_BackgroundSubtractorKNN_getkNNSamples
元DLLエクスポート名: video_BackgroundSubtractorKNN_getkNNSamples
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorKNN_getkNNSamples(cv::Ptr&amp;lt;cv::BackgroundSubtractorKNN&amp;gt; *ptr, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getkNNSamples();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BackgroundSubtractorKNN_setkNNSamples
[32/64bit] kNNのkを設定します。何個の最近傍が一致する必要があるかです。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = int : int value
%inst
元関数名(C#): video_BackgroundSubtractorKNN_setkNNSamples
元DLLエクスポート名: video_BackgroundSubtractorKNN_setkNNSamples
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorKNN_setkNNSamples(cv::Ptr&amp;lt;cv::BackgroundSubtractorKNN&amp;gt; *ptr, int value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setkNNSamples(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BackgroundSubtractorKNN_getDetectShadows
[32/64bit] 影の検出フラグを返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out int returnValue
%inst
trueの場合、アルゴリズムは影を検出してマークします。詳細は createBackgroundSubtractorKNN を参照してください。

元関数名(C#): video_BackgroundSubtractorKNN_getDetectShadows
元DLLエクスポート名: video_BackgroundSubtractorKNN_getDetectShadows
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorKNN_getDetectShadows(cv::Ptr&amp;lt;cv::BackgroundSubtractorKNN&amp;gt; *ptr, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getDetectShadows() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BackgroundSubtractorKNN_setDetectShadows
[32/64bit] 影の検出を有効または無効にします。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = int : int value
%inst
元関数名(C#): video_BackgroundSubtractorKNN_setDetectShadows
元DLLエクスポート名: video_BackgroundSubtractorKNN_setDetectShadows
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorKNN_setDetectShadows(cv::Ptr&amp;lt;cv::BackgroundSubtractorKNN&amp;gt; *ptr, int value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setDetectShadows(value != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BackgroundSubtractorKNN_getShadowValue
[32/64bit] 影の値を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out int returnValue
%inst
シャドウ値とは、フォアグラウンドマスクでシャドウをマークするために使われる値です。デフォルト値は 127 です。マスク内の値0は常に背景を意味し、255は前景を意味します。

元関数名(C#): video_BackgroundSubtractorKNN_getShadowValue
元DLLエクスポート名: video_BackgroundSubtractorKNN_getShadowValue
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorKNN_getShadowValue(cv::Ptr&amp;lt;cv::BackgroundSubtractorKNN&amp;gt; *ptr, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getShadowValue();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BackgroundSubtractorKNN_setShadowValue
[32/64bit] シャドー値を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = int : int value
%inst
元関数名(C#): video_BackgroundSubtractorKNN_setShadowValue
元DLLエクスポート名: video_BackgroundSubtractorKNN_setShadowValue
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorKNN_setShadowValue(cv::Ptr&amp;lt;cv::BackgroundSubtractorKNN&amp;gt; *ptr, int value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setShadowValue(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BackgroundSubtractorKNN_getShadowThreshold
[32/64bit] 影のしきい値を返します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out double returnValue
%inst
シャドウは、ピクセルが背景よりも暗くなっている場合に検出されます。シャドウしきい値（論文では Tau）は、シャドウがどれだけ暗くなるかを定義するしきい値です。Tau=0.5 は，ピクセルが 2 倍以上暗くなった場合，シャドウではないことを意味します。Prati, Mikic, Trivedi, Cucchiara, Detecting Moving Shadows...*, IEEE PAMI,2003を参照。

元関数名(C#): video_BackgroundSubtractorKNN_getShadowThreshold
元DLLエクスポート名: video_BackgroundSubtractorKNN_getShadowThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorKNN_getShadowThreshold(cv::Ptr&amp;lt;cv::BackgroundSubtractorKNN&amp;gt; *ptr, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = (*ptr)-&amp;gt;getShadowThreshold();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_BackgroundSubtractorKNN_setShadowThreshold
[32/64bit] 影のしきい値を設定します。
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = double : double value
%inst
元関数名(C#): video_BackgroundSubtractorKNN_setShadowThreshold
元DLLエクスポート名: video_BackgroundSubtractorKNN_setShadowThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_BackgroundSubtractor.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_BackgroundSubtractorKNN_setShadowThreshold(cv::Ptr&amp;lt;cv::BackgroundSubtractorKNN&amp;gt; *ptr, double value)
{
    BEGIN_WRAP
    (*ptr)-&amp;gt;setShadowThreshold(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_BackgroundSubtractor

%index
video_CamShift
[32bit] オブジェクトの中心、サイズ、方向を見つける。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr probImage
p2 = var : ref Rect window
p3 = ARGS_TERMCRITERIA : TermCriteria criteria
p4 = var : out RotatedRect returnValue
%inst
色付きオブジェクトを追跡する OpenCV サンプル camshiftdemo.c を参照してください．

(Python）カムシフト・トラッキング・アルゴリズムを説明するサンプルは， opencv_source_code/samples/python/camshift.pyExamples: samples/cpp/camshiftdemo.cpp にあります．

元関数名(C#): video_CamShift
元DLLエクスポート名: video_CamShift
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_CamShift(
    cv::_InputArray *probImage, MyCvRect *window, MyCvTermCriteria criteria, MyCvBox2D *returnValue)
{
    BEGIN_WRAP
    cv::Rect window0 = cpp(*window);
    const auto ret = cv::CamShift(*probImage, window0, cpp(criteria));
    *window = c(window0);
    *returnValue = c(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_CamShift
[64bit] オブジェクトの中心、サイズ、方向を見つける。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr probImage
p2 = var : ref Rect window
p3 = var : TermCriteria criteria
p4 = var : out RotatedRect returnValue
%inst
色付きオブジェクトを追跡する OpenCV サンプル camshiftdemo.c を参照してください．

(Python）カムシフト・トラッキング・アルゴリズムを説明するサンプルは， opencv_source_code/samples/python/camshift.pyExamples: samples/cpp/camshiftdemo.cpp にあります．

元関数名(C#): video_CamShift
元DLLエクスポート名: video_CamShift
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_CamShift(
    cv::_InputArray *probImage, MyCvRect *window, MyCvTermCriteria criteria, MyCvBox2D *returnValue)
{
    BEGIN_WRAP
    cv::Rect window0 = cpp(*window);
    const auto ret = cv::CamShift(*probImage, window0, cpp(criteria));
    *window = c(window0);
    *returnValue = c(ret);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_meanShift
[32bit] バックプロジェクション画像上のオブジェクトを検索します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr probImage
p2 = var : ref Rect window
p3 = ARGS_TERMCRITERIA : TermCriteria criteria
p4 = var : out int returnValue
%inst
元関数名(C#): video_meanShift
元DLLエクスポート名: video_meanShift
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_meanShift(
    cv::_InputArray *probImage, MyCvRect *window, MyCvTermCriteria criteria, int *returnValue)
{
    BEGIN_WRAP
    cv::Rect window0 = cpp(*window);
    const auto ret = cv::meanShift(*probImage, window0, cpp(criteria));
    *window = c(window0);
    *returnValue = ret;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_meanShift
[64bit] バックプロジェクション画像上のオブジェクトを検索します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr probImage
p2 = var : ref Rect window
p3 = var : TermCriteria criteria
p4 = var : out int returnValue
%inst
元関数名(C#): video_meanShift
元DLLエクスポート名: video_meanShift
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_meanShift(
    cv::_InputArray *probImage, MyCvRect *window, MyCvTermCriteria criteria, int *returnValue)
{
    BEGIN_WRAP
    cv::Rect window0 = cpp(*window);
    const auto ret = cv::meanShift(*probImage, window0, cpp(criteria));
    *window = c(window0);
    *returnValue = ret;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_buildOpticalFlowPyramid1
[32/64bit] calcOpticalFlowPyrLK に渡すことのできる画像ピラミッドを構築します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr img
p2 = sptr : IntPtr pyramid
p3 = ARGS_SIZE : Size winSize
p4 = int : int maxLevel
p5 = int : int withDerivatives
p6 = int : int pyrBorder
p7 = int : int derivBorder
p8 = int : int tryReuseInputImage
p9 = var : out int returnValue
%inst
元関数名(C#): video_buildOpticalFlowPyramid1
元DLLエクスポート名: video_buildOpticalFlowPyramid1
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_buildOpticalFlowPyramid1(
    cv::_InputArray* img, cv::_OutputArray* pyramid,
    MyCvSize winSize, int maxLevel, int withDerivatives,
    int pyrBorder, int derivBorder, int tryReuseInputImage,
    int* returnValue)
{
    BEGIN_WRAP
    * returnValue = cv::buildOpticalFlowPyramid(
        *img, *pyramid, cpp(winSize), maxLevel, withDerivatives != 0,
        pyrBorder, derivBorder, tryReuseInputImage != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_buildOpticalFlowPyramid2
[32/64bit] calcOpticalFlowPyrLK に渡すことのできる画像ピラミッドを構築します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = sptr : IntPtr img
p2 = sptr : IntPtr pyramidVec
p3 = ARGS_SIZE : Size winSize
p4 = int : int maxLevel
p5 = int : int withDerivatives
p6 = int : int pyrBorder
p7 = int : int derivBorder
p8 = int : int tryReuseInputImage
p9 = var : out int returnValue
%inst
元関数名(C#): video_buildOpticalFlowPyramid2
元DLLエクスポート名: video_buildOpticalFlowPyramid2
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_buildOpticalFlowPyramid2(
    cv::_InputArray* img, std::vector&amp;lt;cv::Mat&amp;gt;* pyramidVec,
    MyCvSize winSize, int maxLevel, int withDerivatives,
    int pyrBorder, int derivBorder, int tryReuseInputImage,
    int* returnValue)
{
    BEGIN_WRAP
    * returnValue = cv::buildOpticalFlowPyramid(
        *img, *pyramidVec, cpp(winSize), maxLevel, withDerivatives != 0,
        pyrBorder, derivBorder, tryReuseInputImage != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_calcOpticalFlowPyrLK_InputArray
[32bit] ピラミッドを用いた反復ルーカス-カナード法を用いて，疎な特徴セットに対するオプティカルフローを計算します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11
p1 = sptr : IntPtr prevImg
p2 = sptr : IntPtr nextImg
p3 = sptr : IntPtr prevPts
p4 = sptr : IntPtr nextPts
p5 = sptr : IntPtr status
p6 = sptr : IntPtr err
p7 = ARGS_SIZE : Size winSize
p8 = int : int maxLevel
p9 = ARGS_TERMCRITERIA : TermCriteria criteria
p10 = int : int flags
p11 = double : double minEigThreshold
%inst
この関数は，Lucas-Canade オプティカルフローの疎な反復版をピラミッド型に実装したものです．30]を参照してください．注）Lucas-Kanadeオプティカルフローアルゴリズムを用いた例は，opencv_source_code/samples/cpp/lkdemo.cppにあります．

(Python) Lucas-Canade オプティカルフローアルゴリズムを用いた例は， opencv_source_code/samples/python/lk_track.py にあります．

(Python) Lucas-Kanade トラッカーを用いたホモグラフィマッチングの例は、opencv_source_code/samples/python/lk_homography.pyにあります。 サンプル: samples/cpp/lkdemo.cpp.

元関数名(C#): video_calcOpticalFlowPyrLK_InputArray
元DLLエクスポート名: video_calcOpticalFlowPyrLK_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_calcOpticalFlowPyrLK_InputArray(
    cv::_InputArray* prevImg, cv::_InputArray* nextImg,
    cv::_InputArray* prevPts, cv::_InputOutputArray* nextPts,
    cv::_OutputArray* status, cv::_OutputArray* err,
    MyCvSize winSize, int maxLevel, MyCvTermCriteria criteria,
    int flags, double minEigThreshold)
{
    BEGIN_WRAP
    cv::calcOpticalFlowPyrLK(*prevImg, *nextImg, *prevPts, *nextPts, *status, *err,
        cpp(winSize), maxLevel, cpp(criteria), flags, minEigThreshold);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_calcOpticalFlowPyrLK_InputArray
[64bit] ピラミッドを用いた反復ルーカス-カナード法を用いて，疎な特徴セットに対するオプティカルフローを計算します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11
p1 = sptr : IntPtr prevImg
p2 = sptr : IntPtr nextImg
p3 = sptr : IntPtr prevPts
p4 = sptr : IntPtr nextPts
p5 = sptr : IntPtr status
p6 = sptr : IntPtr err
p7 = ARGS_SIZE : Size winSize
p8 = int : int maxLevel
p9 = var : TermCriteria criteria
p10 = int : int flags
p11 = double : double minEigThreshold
%inst
この関数は，Lucas-Canade オプティカルフローの疎な反復版をピラミッド型に実装したものです．30]を参照してください．注）Lucas-Kanadeオプティカルフローアルゴリズムを用いた例は，opencv_source_code/samples/cpp/lkdemo.cppにあります．

(Python) Lucas-Canade オプティカルフローアルゴリズムを用いた例は， opencv_source_code/samples/python/lk_track.py にあります．

(Python) Lucas-Kanade トラッカーを用いたホモグラフィマッチングの例は、opencv_source_code/samples/python/lk_homography.pyにあります。 サンプル: samples/cpp/lkdemo.cpp.

元関数名(C#): video_calcOpticalFlowPyrLK_InputArray
元DLLエクスポート名: video_calcOpticalFlowPyrLK_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_calcOpticalFlowPyrLK_InputArray(
    cv::_InputArray* prevImg, cv::_InputArray* nextImg,
    cv::_InputArray* prevPts, cv::_InputOutputArray* nextPts,
    cv::_OutputArray* status, cv::_OutputArray* err,
    MyCvSize winSize, int maxLevel, MyCvTermCriteria criteria,
    int flags, double minEigThreshold)
{
    BEGIN_WRAP
    cv::calcOpticalFlowPyrLK(*prevImg, *nextImg, *prevPts, *nextPts, *status, *err,
        cpp(winSize), maxLevel, cpp(criteria), flags, minEigThreshold);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_calcOpticalFlowPyrLK_vector
[32bit] ピラミッドを用いた反復ルーカス-カナード法を用いて，疎な特徴セットに対するオプティカルフローを計算します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12
p1 = sptr : IntPtr prevImg
p2 = sptr : IntPtr nextImg
p3 = var : Point2f[] prevPts
p4 = int : int prevPtsSize
p5 = sptr : IntPtr nextPts
p6 = sptr : IntPtr status
p7 = sptr : IntPtr err
p8 = ARGS_SIZE : Size winSize
p9 = int : int maxLevel
p10 = ARGS_TERMCRITERIA : TermCriteria criteria
p11 = int : int flags
p12 = double : double minEigThreshold
%inst
この関数は，Lucas-Canade オプティカルフローの疎な反復版をピラミッド型に実装したものです．30]を参照してください．注）Lucas-Kanadeオプティカルフローアルゴリズムを用いた例は，opencv_source_code/samples/cpp/lkdemo.cppにあります．

(Python) Lucas-Canade オプティカルフローアルゴリズムを用いた例は， opencv_source_code/samples/python/lk_track.py にあります．

(Python) Lucas-Kanade トラッカーを用いたホモグラフィマッチングの例は、opencv_source_code/samples/python/lk_homography.pyにあります。 サンプル: samples/cpp/lkdemo.cpp.

元関数名(C#): video_calcOpticalFlowPyrLK_vector
元DLLエクスポート名: video_calcOpticalFlowPyrLK_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_calcOpticalFlowPyrLK_vector(
    cv::_InputArray* prevImg, cv::_InputArray* nextImg,
    cv::Point2f* prevPts, int prevPtsSize,
    std::vector&amp;lt;cv::Point2f&amp;gt;* nextPts,
    std::vector&amp;lt;uchar&amp;gt;* status,
    std::vector&amp;lt;float&amp;gt;* err,
    MyCvSize winSize, int maxLevel, MyCvTermCriteria criteria,
    int flags, double minEigThreshold)
{
    BEGIN_WRAP
    const std::vector&amp;lt;cv::Point2f&amp;gt; prevPtsVec(prevPts, prevPts + prevPtsSize);
    cv::calcOpticalFlowPyrLK(*prevImg, *nextImg, prevPtsVec, *nextPts,
    *status, *err, cpp(winSize), maxLevel, cpp(criteria), flags, minEigThreshold);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_calcOpticalFlowPyrLK_vector
[64bit] ピラミッドを用いた反復ルーカス-カナード法を用いて，疎な特徴セットに対するオプティカルフローを計算します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12
p1 = sptr : IntPtr prevImg
p2 = sptr : IntPtr nextImg
p3 = var : Point2f[] prevPts
p4 = int : int prevPtsSize
p5 = sptr : IntPtr nextPts
p6 = sptr : IntPtr status
p7 = sptr : IntPtr err
p8 = ARGS_SIZE : Size winSize
p9 = int : int maxLevel
p10 = var : TermCriteria criteria
p11 = int : int flags
p12 = double : double minEigThreshold
%inst
この関数は，Lucas-Canade オプティカルフローの疎な反復版をピラミッド型に実装したものです．30]を参照してください．注）Lucas-Kanadeオプティカルフローアルゴリズムを用いた例は，opencv_source_code/samples/cpp/lkdemo.cppにあります．

(Python) Lucas-Canade オプティカルフローアルゴリズムを用いた例は， opencv_source_code/samples/python/lk_track.py にあります．

(Python) Lucas-Kanade トラッカーを用いたホモグラフィマッチングの例は、opencv_source_code/samples/python/lk_homography.pyにあります。 サンプル: samples/cpp/lkdemo.cpp.

元関数名(C#): video_calcOpticalFlowPyrLK_vector
元DLLエクスポート名: video_calcOpticalFlowPyrLK_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_calcOpticalFlowPyrLK_vector(
    cv::_InputArray* prevImg, cv::_InputArray* nextImg,
    cv::Point2f* prevPts, int prevPtsSize,
    std::vector&amp;lt;cv::Point2f&amp;gt;* nextPts,
    std::vector&amp;lt;uchar&amp;gt;* status,
    std::vector&amp;lt;float&amp;gt;* err,
    MyCvSize winSize, int maxLevel, MyCvTermCriteria criteria,
    int flags, double minEigThreshold)
{
    BEGIN_WRAP
    const std::vector&amp;lt;cv::Point2f&amp;gt; prevPtsVec(prevPts, prevPts + prevPtsSize);
    cv::calcOpticalFlowPyrLK(*prevImg, *nextImg, prevPtsVec, *nextPts,
    *status, *err, cpp(winSize), maxLevel, cpp(criteria), flags, minEigThreshold);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_calcOpticalFlowFarneback
[32/64bit] Gunnar Farneback のアルゴリズムを用いて密なオプティカルフローを計算します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = sptr : IntPtr prev
p2 = sptr : IntPtr next
p3 = sptr : IntPtr flow
p4 = double : double pyrScale
p5 = int : int levels
p6 = int : int winSize
p7 = int : int iterations
p8 = int : int polyN
p9 = double : double polySigma
p10 = int : int flags
%inst
この関数は，[69] のアルゴリズムを用いて，各 prev ピクセルに対するオプティカルフローを求めます．(y,x)[1], x + \\(y,x)[0])＼(^o^)／注Gunnar Farneback氏のオプティカルフローアルゴリズムを用いた例はopencv_source_code/samples/cpp/fback.cppにあります。

(Python) Gunnar Farneback 氏のオプティカルフローアルゴリズムを使用した例は、opencv_source_code/samples/python/opt_flow.py にあります。

元関数名(C#): video_calcOpticalFlowFarneback
元DLLエクスポート名: video_calcOpticalFlowFarneback
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_calcOpticalFlowFarneback(
    cv::_InputArray* prev, cv::_InputArray* next,
    cv::_InputOutputArray* flow, double pyrScale, int levels, int winSize,
    int iterations, int polyN, double polySigma, int flags)
{
    BEGIN_WRAP
    cv::calcOpticalFlowFarneback(*prev, *next, *flow, pyrScale, levels, winSize,
        iterations, polyN, polySigma, flags);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_computeECC
[32/64bit] 2つの画像間の強化相関係数を計算します [67] ．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr templateImage
p2 = sptr : IntPtr inputImage
p3 = sptr : IntPtr inputMask
p4 = var : out double returnValue
%inst
参照：findTransformECC

元関数名(C#): video_computeECC
元DLLエクスポート名: video_computeECC
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_computeECC(cv::_InputArray *templateImage, cv::_InputArray *inputImage, cv::_InputArray *inputMask, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::computeECC(*templateImage, *inputImage, entity(inputMask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_findTransformECC1
[32bit] 2 つの画像間の幾何学的変換（ワープ）を，ECC 基準[67]に基づいて求めます．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr templateImage
p2 = sptr : IntPtr inputImage
p3 = sptr : IntPtr warpMatrix
p4 = int : int motionType
p5 = ARGS_TERMCRITERIA : TermCriteria criteria
p6 = sptr : IntPtr inputMask
p7 = int : int gaussFiltSize
p8 = var : out double returnValue
%inst
この関数は，ECC基準（[67]）に照らし合わせて，最適な変換（warpMatrix）を推定します．テンプレート画像と、最終的にワープした入力画像の相関係数である、最終的な拡張相関係数を返します。関数 findTransformECC は，findHomography や estimateRigidTransform とは異なり，強度の類似性を利用したエリアベースの位置合わせを行います．要するに，この関数は，画像を大まかに整列させる最初の変換を更新します．この情報が不足している場合は，初期化として identity warp（ユニティ行列）が利用されます．なお，画像が強い変位や回転を受ける場合は，画像を大まかに揃える初期変換が必要になります（例えば，画像の内容がほぼ同じになるような単純なユークリッド変換や類似性変換など）．1枚目の画像に近い画像を得るために，2枚目の画像に逆ワープを利用します．つまり，フラグ WARP_INVERSE_MAP と warpAffine または warpPerspective を利用します．この関数の使用方法を示す OpenCV のサンプル image_alignment.cpp も参照してください．他にも，ocomputeECC, estimateAffine2D, estimateAffinePartial2D, findHomographyExamples: samples/cpp/image_alignment.cpp を参照してください．

元関数名(C#): video_findTransformECC1
元DLLエクスポート名: video_findTransformECC1
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_findTransformECC1(
    cv::_InputArray *templateImage, cv::_InputArray *inputImage,
    cv::_InputOutputArray *warpMatrix, int motionType,
    MyCvTermCriteria criteria,
    cv::_InputArray *inputMask, int gaussFiltSize, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::findTransformECC(
        *templateImage, *inputImage, *warpMatrix, motionType, 
        cpp(criteria),entity(inputMask), gaussFiltSize);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_findTransformECC1
[64bit] 2 つの画像間の幾何学的変換（ワープ）を，ECC 基準[67]に基づいて求めます．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr templateImage
p2 = sptr : IntPtr inputImage
p3 = sptr : IntPtr warpMatrix
p4 = int : int motionType
p5 = var : TermCriteria criteria
p6 = sptr : IntPtr inputMask
p7 = int : int gaussFiltSize
p8 = var : out double returnValue
%inst
この関数は，ECC基準（[67]）に照らし合わせて，最適な変換（warpMatrix）を推定します．テンプレート画像と、最終的にワープした入力画像の相関係数である、最終的な拡張相関係数を返します。関数 findTransformECC は，findHomography や estimateRigidTransform とは異なり，強度の類似性を利用したエリアベースの位置合わせを行います．要するに，この関数は，画像を大まかに整列させる最初の変換を更新します．この情報が不足している場合は，初期化として identity warp（ユニティ行列）が利用されます．なお，画像が強い変位や回転を受ける場合は，画像を大まかに揃える初期変換が必要になります（例えば，画像の内容がほぼ同じになるような単純なユークリッド変換や類似性変換など）．1枚目の画像に近い画像を得るために，2枚目の画像に逆ワープを利用します．つまり，フラグ WARP_INVERSE_MAP と warpAffine または warpPerspective を利用します．この関数の使用方法を示す OpenCV のサンプル image_alignment.cpp も参照してください．他にも，ocomputeECC, estimateAffine2D, estimateAffinePartial2D, findHomographyExamples: samples/cpp/image_alignment.cpp を参照してください．

元関数名(C#): video_findTransformECC1
元DLLエクスポート名: video_findTransformECC1
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_findTransformECC1(
    cv::_InputArray *templateImage, cv::_InputArray *inputImage,
    cv::_InputOutputArray *warpMatrix, int motionType,
    MyCvTermCriteria criteria,
    cv::_InputArray *inputMask, int gaussFiltSize, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::findTransformECC(
        *templateImage, *inputImage, *warpMatrix, motionType, 
        cpp(criteria),entity(inputMask), gaussFiltSize);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_findTransformECC2
[32bit] 2 つの画像間の幾何学的変換（ワープ）を，ECC 基準[67]に基づいて求めます．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr templateImage
p2 = sptr : IntPtr inputImage
p3 = sptr : IntPtr warpMatrix
p4 = int : int motionType
p5 = ARGS_TERMCRITERIA : TermCriteria criteria
p6 = sptr : IntPtr inputMask
p7 = var : out double returnValue
%inst
この関数は，ECC基準（[67]）に照らし合わせて，最適な変換（warpMatrix）を推定します．テンプレート画像と、最終的にワープした入力画像の相関係数である、最終的な拡張相関係数を返します。関数 findTransformECC は，findHomography や estimateRigidTransform とは異なり，強度の類似性を利用したエリアベースの位置合わせを行います．要するに，この関数は，画像を大まかに整列させる最初の変換を更新します．この情報が不足している場合は，初期化として identity warp（ユニティ行列）が利用されます．なお，画像が強い変位や回転を受ける場合は，画像を大まかに揃える初期変換が必要になります（例えば，画像の内容がほぼ同じになるような単純なユークリッド変換や類似性変換など）．1枚目の画像に近い画像を得るために，2枚目の画像に逆ワープを利用します．つまり，フラグ WARP_INVERSE_MAP と warpAffine または warpPerspective を利用します．この関数の使用方法を示す OpenCV のサンプル image_alignment.cpp も参照してください．他にも，ocomputeECC, estimateAffine2D, estimateAffinePartial2D, findHomographyExamples: samples/cpp/image_alignment.cpp を参照してください．

元関数名(C#): video_findTransformECC2
元DLLエクスポート名: video_findTransformECC2
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_findTransformECC2(
    cv::_InputArray *templateImage, cv::_InputArray *inputImage,
    cv::_InputOutputArray *warpMatrix, int motionType,
    MyCvTermCriteria criteria, cv::_InputArray *inputMask, double* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::findTransformECC(
        *templateImage, *inputImage, *warpMatrix, motionType,
        cpp(criteria), entity(inputMask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_findTransformECC2
[64bit] 2 つの画像間の幾何学的変換（ワープ）を，ECC 基準[67]に基づいて求めます．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr templateImage
p2 = sptr : IntPtr inputImage
p3 = sptr : IntPtr warpMatrix
p4 = int : int motionType
p5 = var : TermCriteria criteria
p6 = sptr : IntPtr inputMask
p7 = var : out double returnValue
%inst
この関数は，ECC基準（[67]）に照らし合わせて，最適な変換（warpMatrix）を推定します．テンプレート画像と、最終的にワープした入力画像の相関係数である、最終的な拡張相関係数を返します。関数 findTransformECC は，findHomography や estimateRigidTransform とは異なり，強度の類似性を利用したエリアベースの位置合わせを行います．要するに，この関数は，画像を大まかに整列させる最初の変換を更新します．この情報が不足している場合は，初期化として identity warp（ユニティ行列）が利用されます．なお，画像が強い変位や回転を受ける場合は，画像を大まかに揃える初期変換が必要になります（例えば，画像の内容がほぼ同じになるような単純なユークリッド変換や類似性変換など）．1枚目の画像に近い画像を得るために，2枚目の画像に逆ワープを利用します．つまり，フラグ WARP_INVERSE_MAP と warpAffine または warpPerspective を利用します．この関数の使用方法を示す OpenCV のサンプル image_alignment.cpp も参照してください．他にも，ocomputeECC, estimateAffine2D, estimateAffinePartial2D, findHomographyExamples: samples/cpp/image_alignment.cpp を参照してください．

元関数名(C#): video_findTransformECC2
元DLLエクスポート名: video_findTransformECC2
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_findTransformECC2(
    cv::_InputArray *templateImage, cv::_InputArray *inputImage,
    cv::_InputOutputArray *warpMatrix, int motionType,
    MyCvTermCriteria criteria, cv::_InputArray *inputMask, double* returnValue)
{
    BEGIN_WRAP
    *returnValue = cv::findTransformECC(
        *templateImage, *inputImage, *warpMatrix, motionType,
        cpp(criteria), entity(inputMask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_KalmanFilter_new1
[32/64bit] cv::KalmanFilter のインスタンスを生成します
%prm
p1
p1 = var : out IntPtr returnValue
%inst
カルマンフィルタクラスです．

このクラスは，標準的なカルマンフィルタ http://en.wikipedia.org/wiki/Kalman_filter, [272] を実装しています．しかし， transitionMatrix, controlMatrix, measurementMatrix を変更することで，拡張カルマンフィルタの機能を得ることができます．注意 C API では， CvKalman* kalmanFilter 構造体が不要になった場合， cvReleaseKalman(&kalmanFilter) で解放されます．

例： samples/cpp/kalman.cpp.


元関数名(C#): video_KalmanFilter_new1
元DLLエクスポート名: video_KalmanFilter_new1
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_KalmanFilter_new1(cv::KalmanFilter **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::KalmanFilter;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_KalmanFilter_new2
[32/64bit] カルマンフィルタクラスです．

このクラスは，標準的なカルマンフィルタ http://en.wikipedia.org/wiki/Kalman_filter, [272] を実装しています．しかし， transitionMatrix, controlMatrix, measurementMatrix を変更することで，拡張カルマンフィルタの機能を得ることができます．注意 C API では， CvKalman* kalmanFilter 構造体が不要になった場合， cvReleaseKalman(&kalmanFilter) で解放されます．

例： samples/cpp/kalman.cpp.
%prm
p1,p2,p3,p4,p5
p1 = int : int dynamParams
p2 = int : int measureParams
p3 = int : int controlParams
p4 = int : int type
p5 = var : out IntPtr returnValue
%inst
元関数名(C#): video_KalmanFilter_new2
元DLLエクスポート名: video_KalmanFilter_new2
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_KalmanFilter_new2(int dynamParams, int measureParams, int controlParams, int type, cv::KalmanFilter **returnValue)
{
    BEGIN_WRAP
    *returnValue = new cv::KalmanFilter(dynamParams, measureParams, controlParams, type);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_KalmanFilter_init
[32/64bit] カルマンフィルタを再初期化します．以前の内容は破棄されます．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = int : int dynamParams
p3 = int : int measureParams
p4 = int : int controlParams
p5 = int : int type
%inst
元関数名(C#): video_KalmanFilter_init
元DLLエクスポート名: video_KalmanFilter_init
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_KalmanFilter_init(cv::KalmanFilter *obj, int dynamParams, int measureParams, int controlParams, int type)
{
    BEGIN_WRAP
    obj-&amp;gt;init(dynamParams, measureParams, controlParams, type);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_KalmanFilter_delete
[32/64bit] cv::KalmanFilter のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
カルマンフィルタクラスです．

このクラスは，標準的なカルマンフィルタ http://en.wikipedia.org/wiki/Kalman_filter, [272] を実装しています．しかし， transitionMatrix, controlMatrix, measurementMatrix を変更することで，拡張カルマンフィルタの機能を得ることができます．注意 C API では， CvKalman* kalmanFilter 構造体が不要になった場合， cvReleaseKalman(&kalmanFilter) で解放されます．

例： samples/cpp/kalman.cpp.


元関数名(C#): video_KalmanFilter_delete
元DLLエクスポート名: video_KalmanFilter_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_KalmanFilter_delete(cv::KalmanFilter *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_KalmanFilter_predict
[32/64bit] 予測される状態を計算します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr control
p3 = var : out IntPtr returnValue
%inst
例： samples/cpp/kalman.cpp.

元関数名(C#): video_KalmanFilter_predict
元DLLエクスポート名: video_KalmanFilter_predict
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_KalmanFilter_predict(cv::KalmanFilter *obj, cv::Mat *control, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto result = obj-&amp;gt;predict(entity(control));
    *returnValue = new cv::Mat(result);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_KalmanFilter_correct
[32/64bit] 測定値から予測状態を更新します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr measurement
p3 = var : out IntPtr returnValue
%inst
例： samples/cpp/kalman.cpp.

元関数名(C#): video_KalmanFilter_correct
元DLLエクスポート名: video_KalmanFilter_correct
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_KalmanFilter_correct(cv::KalmanFilter *obj, cv::Mat *measurement, cv::Mat **returnValue)
{
    BEGIN_WRAP
    const auto result = obj-&amp;gt;correct(*measurement);
    *returnValue = new cv::Mat(result);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_KalmanFilter_statePre
[32/64bit] cv::KalmanFilter::statePre 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
予測状態 (x'(k)): x(k)=A*x(k-1)+B*u(k)


元関数名(C#): video_KalmanFilter_statePre
元DLLエクスポート名: video_KalmanFilter_statePre
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_KalmanFilter_statePre(cv::KalmanFilter *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = &amp;(obj-&amp;gt;statePre);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_KalmanFilter_statePost
[32/64bit] cv::KalmanFilter::statePost 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
補正後の状態（x(k)）：x(k)=x'(k)+K(k)*(z(k)-H*x'(k))
例： samples/cpp/kalman.cpp.

元関数名(C#): video_KalmanFilter_statePost
元DLLエクスポート名: video_KalmanFilter_statePost
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_KalmanFilter_statePost(cv::KalmanFilter *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = &amp;(obj-&amp;gt;statePost);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_KalmanFilter_transitionMatrix
[32/64bit] cv::KalmanFilter::transitionMatrix 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
状態遷移行列(A)
例： samples/cpp/kalman.cpp.

元関数名(C#): video_KalmanFilter_transitionMatrix
元DLLエクスポート名: video_KalmanFilter_transitionMatrix
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_KalmanFilter_transitionMatrix(cv::KalmanFilter *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = &amp;(obj-&amp;gt;transitionMatrix);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_KalmanFilter_controlMatrix
[32/64bit] cv::KalmanFilter::controlMatrix 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
制御行列(B) (制御がない場合は使用しない)


元関数名(C#): video_KalmanFilter_controlMatrix
元DLLエクスポート名: video_KalmanFilter_controlMatrix
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_KalmanFilter_controlMatrix(cv::KalmanFilter *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = &amp;(obj-&amp;gt;controlMatrix);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_KalmanFilter_measurementMatrix
[32/64bit] cv::KalmanFilter::measurementMatrix 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
測定行列(H)
例： samples/cpp/kalman.cpp.

元関数名(C#): video_KalmanFilter_measurementMatrix
元DLLエクスポート名: video_KalmanFilter_measurementMatrix
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_KalmanFilter_measurementMatrix(cv::KalmanFilter *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = &amp;(obj-&amp;gt;measurementMatrix);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_KalmanFilter_processNoiseCov
[32/64bit] cv::KalmanFilter::processNoiseCov 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
プロセスノイズ共分散行列 (Q)
例： samples/cpp/kalman.cpp.

元関数名(C#): video_KalmanFilter_processNoiseCov
元DLLエクスポート名: video_KalmanFilter_processNoiseCov
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_KalmanFilter_processNoiseCov(cv::KalmanFilter *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = &amp;(obj-&amp;gt;processNoiseCov);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_KalmanFilter_measurementNoiseCov
[32/64bit] cv::KalmanFilter::measurementNoiseCov 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
測定ノイズ共分散行列 (R)
例： samples/cpp/kalman.cpp.

元関数名(C#): video_KalmanFilter_measurementNoiseCov
元DLLエクスポート名: video_KalmanFilter_measurementNoiseCov
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_KalmanFilter_measurementNoiseCov(cv::KalmanFilter *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = &amp;(obj-&amp;gt;measurementNoiseCov);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_KalmanFilter_errorCovPre
[32/64bit] cv::KalmanFilter::errorCovPre 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
プリオリ誤差推定共分散行列（P'(k)）。P'(k)=A*P(k-1)*At + Q)/*。


元関数名(C#): video_KalmanFilter_errorCovPre
元DLLエクスポート名: video_KalmanFilter_errorCovPre
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_KalmanFilter_errorCovPre(cv::KalmanFilter *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = &amp;(obj-&amp;gt;errorCovPre);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_KalmanFilter_gain
[32/64bit] cv::KalmanFilter::gain 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
カルマンゲイン行列(K(k)):K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R)


元関数名(C#): video_KalmanFilter_gain
元DLLエクスポート名: video_KalmanFilter_gain
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_KalmanFilter_gain(cv::KalmanFilter *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = &amp;(obj-&amp;gt;gain);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_KalmanFilter_errorCovPost
[32/64bit] cv::KalmanFilter::errorCovPost 変数を取得します
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out IntPtr returnValue
%inst
posteriori誤差推定共分散行列(P(k)):P(k)=(I-K(k)*H)*P'(k)
例： samples/cpp/kalman.cpp.

元関数名(C#): video_KalmanFilter_errorCovPost
元DLLエクスポート名: video_KalmanFilter_errorCovPost
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_KalmanFilter_errorCovPost(cv::KalmanFilter *obj, cv::Mat **returnValue)
{
    BEGIN_WRAP
    *returnValue = &amp;(obj-&amp;gt;errorCovPost);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_Tracker_init
[32bit] ターゲットを囲んだ既知のバウンディングボックスでトラッカーを初期化する。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = ARGS_RECT : Rect boundingBox
%inst
元関数名(C#): video_Tracker_init
元DLLエクスポート名: video_Tracker_init
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_Tracker_init(cv::Tracker* tracker, const cv::Mat* image, const MyCvRect boundingBox)
{
    BEGIN_WRAP
    tracker-&amp;gt;init(*image, cpp(boundingBox));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_Tracker_init
[64bit] ターゲットを囲んだ既知のバウンディングボックスでトラッカーを初期化する。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = var : Rect boundingBox
%inst
元関数名(C#): video_Tracker_init
元DLLエクスポート名: video_Tracker_init
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_Tracker_init(cv::Tracker* tracker, const cv::Mat* image, const MyCvRect boundingBox)
{
    BEGIN_WRAP
    tracker-&amp;gt;init(*image, cpp(boundingBox));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_Tracker_update
[32/64bit] トラッカーを更新し、ターゲットに最も適した新しいバウンディングボックスを見つける。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = var : ref Rect boundingBox
p4 = var : out int returnValue
%inst
元関数名(C#): video_Tracker_update
元DLLエクスポート名: video_Tracker_update
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_Tracker_update(cv::Tracker* tracker, const cv::Mat* image, MyCvRect* boundingBox, int* returnValue)
{
    BEGIN_WRAP
    cv::Rect bb = cpp(*boundingBox);
    const bool ret = tracker-&amp;gt;update(*image, bb);
    if (ret)
    {
        boundingBox-&amp;gt;x = bb.x;
        boundingBox-&amp;gt;y = bb.y;
        boundingBox-&amp;gt;width = bb.width;
        boundingBox-&amp;gt;height = bb.height;
    }

    *returnValue = ret ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_TrackerMIL_create1
[32/64bit] MILトラッカーのインスタンスを作成します。
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): video_TrackerMIL_create1
元DLLエクスポート名: video_TrackerMIL_create1
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_TrackerMIL_create1(cv::Ptr&amp;lt;cv::TrackerMIL&amp;gt;** returnValue)
{
    BEGIN_WRAP
    const auto p = cv::TrackerMIL::create();
    *returnValue = clone(p);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_TrackerMIL_create2
[32/64bit] MILトラッカーのインスタンスを作成します。
%prm
p1,p2
p1 = var : TrackerMIL.Params* parameters
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): video_TrackerMIL_create2
元DLLエクスポート名: video_TrackerMIL_create2
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_TrackerMIL_create2(cv::TrackerMIL::Params* parameters, cv::Ptr&amp;lt;cv::TrackerMIL&amp;gt;** returnValue)
{
    BEGIN_WRAP
    const auto p = cv::TrackerMIL::create(*parameters);
    *returnValue = clone(p);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_Ptr_TrackerMIL_delete
[32/64bit] cv::TrackerMIL のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
MILアルゴリズムは、オンラインで分類器を学習し、背景からオブジェクトを分離します。

複数インスタンス学習により、ドリフト問題を回避し、ロバストなトラッキングを実現します。実装は[13]を参考にしています．

オリジナルのコードは http://vision.ucsd.edu/~bbabenko/project_miltrack.shtml にあります。


元関数名(C#): video_Ptr_TrackerMIL_delete
元DLLエクスポート名: video_Ptr_TrackerMIL_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_Ptr_TrackerMIL_delete(cv::Ptr&amp;lt;cv::TrackerMIL&amp;gt;* ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_Ptr_TrackerMIL_get
[32/64bit] cv::TrackerMIL のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
MILアルゴリズムは、オンラインで分類器を学習し、背景からオブジェクトを分離します。

複数インスタンス学習により、ドリフト問題を回避し、ロバストなトラッキングを実現します。実装は[13]を参考にしています．

オリジナルのコードは http://vision.ucsd.edu/~bbabenko/project_miltrack.shtml にあります。


元関数名(C#): video_Ptr_TrackerMIL_get
元DLLエクスポート名: video_Ptr_TrackerMIL_get
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_Ptr_TrackerMIL_get(cv::Ptr&amp;lt;cv::TrackerMIL&amp;gt;* ptr, cv::TrackerMIL** returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_TrackerGOTURN_create1
[32/64bit] コンストラクタです。
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): video_TrackerGOTURN_create1
元DLLエクスポート名: video_TrackerGOTURN_create1
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_TrackerGOTURN_create1(cv::Ptr&amp;lt;cv::TrackerGOTURN&amp;gt;** returnValue)
{
    BEGIN_WRAP
    const auto p = cv::TrackerGOTURN::create();
    *returnValue = clone(p);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_TrackerGOTURN_create2
[32/64bit] コンストラクタです。
%prm
p1,p2
p1 = var : TrackerGOTURN.Params* parameters
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): video_TrackerGOTURN_create2
元DLLエクスポート名: video_TrackerGOTURN_create2
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_TrackerGOTURN_create2(cv::TrackerGOTURN::Params* parameters, cv::Ptr&amp;lt;cv::TrackerGOTURN&amp;gt;** returnValue)
{
    BEGIN_WRAP
    const auto p = cv::TrackerGOTURN::create(*parameters);
    *returnValue = clone(p);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_Ptr_TrackerGOTURN_delete
[32/64bit] cv::TrackerGOTURN のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr ptr
%inst
GOTURN (Generic Object Tracking Using Regression Networks) トラッカー

GOTURN（[107]）は、Convolutional Neural Networks（CNN）をベースにしたトラッカーの一種です。GOTURNはCNNをベースにしたトラッカーの一種です。CNNトラッカーのすべての利点を利用していますが、GOTURNはオンラインでの微調整を必要としないオフラインでのトレーニングにより、はるかに高速です。GOTURNトラッカーは、ビデオの最初のフレームにあるオブジェクトのバウンディングボックスのラベルが与えられた場合、そのオブジェクトをビデオの残りの部分で追跡するという、シングルターゲットのトラッキングの問題に対応しています。注意：現在のGOTURNはオクルージョンを扱いませんが、視点の変更、照明の変更、変形にはかなり強くなっています。GOTURNの入力は、227x227にリサイズされたTargetパッチとSearchパッチを表す2つのRGBパッチです。GOTURNの出力は、X1,Y1,X2,Y2のフォーマットで表された、サーチパッチの座標系に対する予測バウンディングボックス座標です。Original paper is here: http://davheld.github.io/GOTURN/GOTURN.pdf As long as original authors implementation: https://github.com/davheld/GOTURN#train-the-tracker 3d-party dependencies due to the Implementation of training algorithm is placed in separately here: https://github.com/Auron-X/GOTURN_Training_Toolkit GOTURN architecture goturn.prototxt and trained model goturn.caffemodel is accessible on opencv_extra GitHub repository.


元関数名(C#): video_Ptr_TrackerGOTURN_delete
元DLLエクスポート名: video_Ptr_TrackerGOTURN_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_Ptr_TrackerGOTURN_delete(cv::Ptr&amp;lt;cv::TrackerGOTURN&amp;gt;* ptr)
{
    BEGIN_WRAP
    delete ptr;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
video_Ptr_TrackerGOTURN_get
[32/64bit] cv::TrackerGOTURN のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
GOTURN (Generic Object Tracking Using Regression Networks) トラッカー

GOTURN（[107]）は、Convolutional Neural Networks（CNN）をベースにしたトラッカーの一種です。GOTURNはCNNをベースにしたトラッカーの一種です。CNNトラッカーのすべての利点を利用していますが、GOTURNはオンラインでの微調整を必要としないオフラインでのトレーニングにより、はるかに高速です。GOTURNトラッカーは、ビデオの最初のフレームにあるオブジェクトのバウンディングボックスのラベルが与えられた場合、そのオブジェクトをビデオの残りの部分で追跡するという、シングルターゲットのトラッキングの問題に対応しています。注意：現在のGOTURNはオクルージョンを扱いませんが、視点の変更、照明の変更、変形にはかなり強くなっています。GOTURNの入力は、227x227にリサイズされたTargetパッチとSearchパッチを表す2つのRGBパッチです。GOTURNの出力は、X1,Y1,X2,Y2のフォーマットで表された、サーチパッチの座標系に対する予測バウンディングボックス座標です。Original paper is here: http://davheld.github.io/GOTURN/GOTURN.pdf As long as original authors implementation: https://github.com/davheld/GOTURN#train-the-tracker 3d-party dependencies due to the Implementation of training algorithm is placed in separately here: https://github.com/Auron-X/GOTURN_Training_Toolkit GOTURN architecture goturn.prototxt and trained model goturn.caffemodel is accessible on opencv_extra GitHub repository.


元関数名(C#): video_Ptr_TrackerGOTURN_get
元DLLエクスポート名: video_Ptr_TrackerGOTURN_get
参照元CSファイル: Internal\PInvoke\NativeMethods\video\NativeMethods_video_tracking.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) video_Ptr_TrackerGOTURN_get(cv::Ptr&amp;lt;cv::TrackerGOTURN&amp;gt;* ptr, cv::TrackerGOTURN** returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_video_tracking

%index
ximgproc_niBlackThreshold
[32/64bit] Niblackの手法や、Niblackにインスパイアされた一般的なバリエーションを用いて、入力画像の閾値処理を行う。
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = double : double maxValue
p4 = int : int type
p5 = int : int blockSize
p6 = double : double k
p7 = int : int binarizationMethod
p8 = double : double r
%inst
この関数は，次の式に従って，グレースケール画像を2値画像に変換します：THRESH_BINARY

\dst(x,y) = ??? -? ???}}{if ??? src(x,y) > T(x,y)??}{0}{otherwise}].





thresh_binary_inv

\dst(x,y) = ??? -? ???{0}{if ??? src(x,y) > T(x,y)??}{0}{otherwise}\ [dst(x,y) = ??? -? ???{0{maxValue}}{0}{otherwise}\] 。



 ここで、????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? ) ????? )この関数は，画像をその場で処理することはできません．See alsothreshold, adaptiveThreshold

元関数名(C#): ximgproc_niBlackThreshold
元DLLエクスポート名: ximgproc_niBlackThreshold
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_niBlackThreshold(cv::_InputArray *src, cv::_OutputArray *dst,
    double maxValue, int type,
    int blockSize, double k, int binarizationMethod, double r)
{
    BEGIN_WRAP
    cv::ximgproc::niBlackThreshold(*src, *dst, maxValue, type, blockSize, k, binarizationMethod, r);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_thinning
[32/64bit] 入力画像をスケルチゼーションするために，2値のblobを間引く操作を行います．
%prm
p1,p2,p3
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int thinningType
%inst
この関数は， Zhang-Suen の手法を用いて，2値の blob 画像をスケルティッド形式に変換します．

元関数名(C#): ximgproc_thinning
元DLLエクスポート名: ximgproc_thinning
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_thinning(cv::_InputArray *src, cv::_OutputArray *dst, int thinningType)
{
    BEGIN_WRAP
    cv::ximgproc::thinning(*src, *dst, thinningType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_anisotropicDiffusion
[32/64bit] また，画像に対して異方性拡散を行います．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = float : float alpha
p4 = float : float K
p5 = int : int niters
%inst
この関数は，Perona-Malik異方性拡散を画像に適用します．これは，偏微分方程式の解である。\C(x,y,t)の関数としては、次のようなものがあります。\]

元関数名(C#): ximgproc_anisotropicDiffusion
元DLLエクスポート名: ximgproc_anisotropicDiffusion
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_anisotropicDiffusion(cv::_InputArray *src, cv::_OutputArray *dst, float alpha, float K, int niters)
{
    BEGIN_WRAP
    cv::ximgproc::anisotropicDiffusion(*src, *dst, alpha, K, niters);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_BrightEdges
[32/64bit] ximgproc_BrightEdges
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr original
p2 = sptr : IntPtr edgeview
p3 = int : int contrast
p4 = int : int shortRange
p5 = int : int longRange
%inst
元関数名(C#): ximgproc_BrightEdges
元DLLエクスポート名: ximgproc_BrightEdges
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_BrightEdges(cv::Mat *original, cv::Mat *edgeview, int contrast, int shortrange, int longrange)
{
    BEGIN_WRAP
    cv::ximgproc::BrightEdges(*original, *edgeview, contrast, shortrange, longrange);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_createQuaternionImage
[32/64bit] は、クォータニオンイメージを作成します。
%prm
p1,p2
p1 = sptr : IntPtr img
p2 = sptr : IntPtr qimg
%inst
元関数名(C#): ximgproc_createQuaternionImage
元DLLエクスポート名: ximgproc_createQuaternionImage
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_createQuaternionImage(cv::_InputArray *img, cv::_OutputArray *qimg)
{
    BEGIN_WRAP
    cv::ximgproc::createQuaternionImage(*img, *qimg);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_qconj
[32/64bit] 4元画像の共役を計算します．
%prm
p1,p2
p1 = sptr : IntPtr qimg
p2 = sptr : IntPtr qcimg
%inst
元関数名(C#): ximgproc_qconj
元DLLエクスポート名: ximgproc_qconj
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_qconj(cv::_InputArray *qimg, cv::_OutputArray *qcimg)
{
    BEGIN_WRAP
    cv::ximgproc::qconj(*qimg, *qcimg);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_qunitary
[32/64bit] は、各要素をそのモジュラスで除算します。
%prm
p1,p2
p1 = sptr : IntPtr qimg
p2 = sptr : IntPtr qnimg
%inst
元関数名(C#): ximgproc_qunitary
元DLLエクスポート名: ximgproc_qunitary
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_qunitary(cv::_InputArray *qimg, cv::_OutputArray *qnimg)
{
    BEGIN_WRAP
    cv::ximgproc::qunitary(*qimg, *qnimg);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_qmultiply
[32/64bit] 2つの配列の要素ごとのクォータニオン積を計算します。
%prm
p1,p2,p3
p1 = sptr : IntPtr src1
p2 = sptr : IntPtr src2
p3 = sptr : IntPtr dst
%inst
元関数名(C#): ximgproc_qmultiply
元DLLエクスポート名: ximgproc_qmultiply
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_qmultiply(cv::_InputArray *src1, cv::_InputArray *src2, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    cv::ximgproc::qmultiply(*src1, *src2, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_qdft
[32/64bit] 2次元のクォータニオン配列に対して，離散的クォータニオンフーリエ変換（順変換）または逆変換を行います．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr img
p2 = sptr : IntPtr qimg
p3 = int : int flags
p4 = int : int sideLeft
%inst
元関数名(C#): ximgproc_qdft
元DLLエクスポート名: ximgproc_qdft
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_qdft(cv::_InputArray *img, cv::_OutputArray *qimg, int flags, int sideLeft)
{
    BEGIN_WRAP
    cv::ximgproc::qdft(*img, *qimg, flags, sideLeft != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_colorMatchTemplate
[32/64bit] カラーテンプレートを，オーバーラップしたカラー画像領域と比較します．
%prm
p1,p2,p3
p1 = sptr : IntPtr img
p2 = sptr : IntPtr templ
p3 = sptr : IntPtr result
%inst
元関数名(C#): ximgproc_colorMatchTemplate
元DLLエクスポート名: ximgproc_colorMatchTemplate
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_colorMatchTemplate(cv::_InputArray *img, cv::_InputArray *templ, cv::_OutputArray *result)
{
    BEGIN_WRAP
    cv::ximgproc::colorMatchTemplate(*img, *templ, *result);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_GradientDericheY
[32/64bit] Y Dericheフィルタを画像に適用します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr op
p2 = sptr : IntPtr dst
p3 = double : double alpha
p4 = double : double omega
%inst
この実装の詳細については，http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.476.5736&rep=rep1&type=pdf を参照してください．

元関数名(C#): ximgproc_GradientDericheY
元DLLエクスポート名: ximgproc_GradientDericheY
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_GradientDericheY(cv::_InputArray *op, cv::_OutputArray *dst, double alpha, double omega)
{
    BEGIN_WRAP
    cv::ximgproc::GradientDericheY(*op, *dst, alpha, omega);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_GradientDericheX
[32/64bit] X Deriche フィルタを画像に適用します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr op
p2 = sptr : IntPtr dst
p3 = double : double alpha
p4 = double : double omega
%inst
この実装の詳細については，http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.476.5736&rep=rep1&type=pdf を参照してください．

元関数名(C#): ximgproc_GradientDericheX
元DLLエクスポート名: ximgproc_GradientDericheX
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_GradientDericheX(cv::_InputArray *op, cv::_OutputArray *dst, double alpha, double omega)
{
    BEGIN_WRAP
    cv::ximgproc::GradientDericheX(*op, *dst, alpha, omega);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_edgePreservingFilter
[32/64bit] Edge-Preerving フィルタを使って，画像を滑らかにします．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int d
p4 = double : double threshold
%inst
この関数は，ガウシアンノイズだけでなく，ソルト＆ペッパーノイズも平滑化します．この実装の詳細については、[ReiWoe18] Reich, S. and Worgotter, F. and Dellen, B. (2018).A Real-Time Edge-Preserving Denoising Filter.Proceedings of the 13th International Joint Conference on Computer Vision, Imaging and Computer Graphics Theory and Applications (VISIGRAPP):Visapp, 85-94, 4.doi: 10.5220/0006509000850094.

元関数名(C#): ximgproc_edgePreservingFilter
元DLLエクスポート名: ximgproc_edgePreservingFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_edgePreservingFilter(cv::_InputArray *src, cv::_OutputArray *dst, int d, double threshold)
{
    BEGIN_WRAP
    cv::ximgproc::edgePreservingFilter(*src, *dst, d, threshold);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_covarianceEstimation
[32/64bit] スライディングウィンドウ法を用いて，画像の共分散行列の推定値を計算します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int windowRows
p4 = int : int windowCols
%inst
元関数名(C#): ximgproc_covarianceEstimation
元DLLエクスポート名: ximgproc_covarianceEstimation
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_covarianceEstimation(
    cv::_InputArray *src, cv::_OutputArray *dst, int windowRows, int windowCols)
{
    BEGIN_WRAP
    cv::ximgproc::covarianceEstimation(*src, *dst, windowRows, windowCols);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_FastHoughTransform
[32/64bit] 画像の2次元高速ハフ変換を計算します．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int dstMatDepth
p4 = int : int angleRange
p5 = int : int op
p6 = int : int makeSkew
%inst
この関数は，全角，半角，1/4角の範囲で高速ハフ変換を計算します．

元関数名(C#): ximgproc_FastHoughTransform
元DLLエクスポート名: ximgproc_FastHoughTransform
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_FastHoughTransform(
    cv::_InputArray* src, cv::_OutputArray* dst,
    int dstMatDepth, int angleRange, int op, int makeSkew)
{
    BEGIN_WRAP
    cv::ximgproc::FastHoughTransform(*src, *dst, dstMatDepth, angleRange, op, makeSkew);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_HoughPoint2Line
[32/64bit] Hough空間における点に対応する線分の座標を求めます．
%prm
p1,p2,p3,p4,p5,p6
p1 = ARGS_POINT : Point houghPoint
p2 = sptr : IntPtr srcImgInfo
p3 = int : int angleRange
p4 = int : int makeSkew
p5 = int : int rules
p6 = var : out Vec4i returnValue
%inst
戻り値

  

    [Vec4i]Hough空間における点に対応する線分の座標．備考パラメータ rules が RO_STRICT に設定されている場合，返される線分は元画像の境界線に沿って切断されます．



rulesパラメータがRO_WEAKに設定されている場合, Hough画像の不正な部分に属する点の場合, 返される線は元画像と交差しません. この関数は, Hough空間における点に対応する線分の座標を計算します.

元関数名(C#): ximgproc_HoughPoint2Line
元DLLエクスポート名: ximgproc_HoughPoint2Line
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_HoughPoint2Line(MyCvPoint houghPoint, cv::_InputArray* srcImgInfo,
    int angleRange, int makeSkew, int rules, CvVec4i* returnValue)
{
    BEGIN_WRAP
    *returnValue = c(cv::ximgproc::HoughPoint2Line(cpp(houghPoint), *srcImgInfo, angleRange, makeSkew, rules));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_GradientPaillouY
[32/64bit] 画像にPaillouフィルタをかけます。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr op
p2 = sptr : IntPtr dst
p3 = double : double alpha
p4 = double : double omega
%inst
この実装の詳細については，[189]を参照してください． GradientPaillouX, GradientPaillouY も参照してください．

元関数名(C#): ximgproc_GradientPaillouY
元DLLエクスポート名: ximgproc_GradientPaillouY
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_GradientPaillouY(cv::_InputArray* op, cv::_OutputArray* dst, double alpha, double omega)
{
    BEGIN_WRAP
    cv::ximgproc::GradientPaillouY(*op, *dst, alpha, omega);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_GradientPaillouX
[32/64bit] ximgproc_GradientPaillouX
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr op
p2 = sptr : IntPtr dst
p3 = double : double alpha
p4 = double : double omega
%inst
元関数名(C#): ximgproc_GradientPaillouX
元DLLエクスポート名: ximgproc_GradientPaillouX
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_GradientPaillouX(cv::_InputArray* op, cv::_OutputArray* dst, double alpha, double omega)
{
    BEGIN_WRAP
    cv::ximgproc::GradientPaillouX(*op, *dst, alpha, omega);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_PeiLinNormalization_Mat23d
[32/64bit] Pei&Lin Normalization を用いて，与えられた画像を正規化するアフィン変換を求めます．
%prm
p1,p2
p1 = sptr : IntPtr I
p2 = var : double* returnValue
%inst
I=T(\bar{I})\は正規化された画像、\(T\)はこの画像を並進、回転、スケーリング、スキューなどで歪ませるアフィン変換を表します。この関数は，[PeiLin95]で述べられている変換\(T^{-1}\)に対応するアフィン変換行列を返します．この実装の詳細については，[PeiLin95] Soo-Chang Pei and Chao-Nan Lin を参照してください．パターン認識のための画像正規化.Image and Vision Computing, Vol.13, N.10, pp.711-723, 1995.

元関数名(C#): ximgproc_PeiLinNormalization_Mat23d
元DLLエクスポート名: ximgproc_PeiLinNormalization_Mat23d
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_PeiLinNormalization_Mat23d(cv::_InputArray *I, double *returnValue)
{
    BEGIN_WRAP
    auto ret = cv::ximgproc::PeiLinNormalization(*I);
    for (int r = 0; r &amp;lt; 2; r++)
    {
        for (int c = 0; c &amp;lt; 3; ++c)
        {
            returnValue[r * 3 + c] = ret(r, c);
        }
    }
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_PeiLinNormalization_OutputArray
[32/64bit] Pei&Lin Normalization を用いて，与えられた画像を正規化するアフィン変換を求めます．
%prm
p1,p2
p1 = sptr : IntPtr I
p2 = sptr : IntPtr T
%inst
I=T(\bar{I})\は正規化された画像、\(T\)はこの画像を並進、回転、スケーリング、スキューなどで歪ませるアフィン変換を表します。この関数は，[PeiLin95]で述べられている変換\(T^{-1}\)に対応するアフィン変換行列を返します．この実装の詳細については，[PeiLin95] Soo-Chang Pei and Chao-Nan Lin を参照してください．パターン認識のための画像正規化.Image and Vision Computing, Vol.13, N.10, pp.711-723, 1995.

元関数名(C#): ximgproc_PeiLinNormalization_OutputArray
元DLLエクスポート名: ximgproc_PeiLinNormalization_OutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_PeiLinNormalization_OutputArray(cv::_InputArray *I, cv::_OutputArray *T)
{
    BEGIN_WRAP
    cv::ximgproc::PeiLinNormalization(*I, *T);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_rl_threshold
[32/64bit] 各配列要素に固定レベルの閾値を適用します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr rlDest
p3 = double : double thresh
p4 = int : int type
%inst
元関数名(C#): ximgproc_rl_threshold
元DLLエクスポート名: ximgproc_rl_threshold
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_rl_threshold(cv::_InputArray *src, cv::_OutputArray *rlDest, double thresh, int type)
{
    BEGIN_WRAP
    cv::ximgproc::rl::threshold(*src, *rlDest, thresh, type);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_rl_dilate
[32/64bit] 特定の構造化要素を用いて，ランレングス符号化された2値画像を希釈します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr rlSrc
p2 = sptr : IntPtr rlDest
p3 = sptr : IntPtr rlKernel
p4 = ARGS_POINT : Point anchor
%inst
元関数名(C#): ximgproc_rl_dilate
元DLLエクスポート名: ximgproc_rl_dilate
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_rl_dilate(
    cv::_InputArray *rlSrc, cv::_OutputArray *rlDest, cv::_InputArray *rlKernel, MyCvPoint anchor)
{
    BEGIN_WRAP
    cv::ximgproc::rl::dilate(*rlSrc, *rlDest, *rlKernel, cpp(anchor));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_rl_erode
[32/64bit] 特定の構造化要素を用いてランレングス符号化された二値画像を電極化する。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr rlSrc
p2 = sptr : IntPtr rlDest
p3 = sptr : IntPtr rlKernel
p4 = int : int bBoundaryOn
p5 = ARGS_POINT : Point anchor
%inst
元関数名(C#): ximgproc_rl_erode
元DLLエクスポート名: ximgproc_rl_erode
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_rl_erode(
    cv::_InputArray *rlSrc, cv::_OutputArray *rlDest, cv::_InputArray *rlKernel,
    int bBoundaryOn, MyCvPoint anchor)
{
    BEGIN_WRAP
    cv::ximgproc::rl::erode(*rlSrc, *rlDest, *rlKernel, bBoundaryOn != 0, cpp(anchor));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_rl_getStructuringElement
[32/64bit] ximgproc_rl_getStructuringElement
%prm
p1,p2,p3
p1 = int : int shape
p2 = ARGS_SIZE : Size ksize
p3 = sptr : IntPtr outValue
%inst
元関数名(C#): ximgproc_rl_getStructuringElement
元DLLエクスポート名: ximgproc_rl_getStructuringElement
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_rl_getStructuringElement(int shape, MyCvSize ksize, cv::Mat *outValue)
{
    BEGIN_WRAP
    auto result = cv::ximgproc::rl::getStructuringElement(shape, cpp(ksize));
    result.copyTo(*outValue);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_rl_paint
[32bit] ランレングス符号化されたバイナリ画像を，画像にペイントします．
%prm
p1,p2,p3
p1 = sptr : IntPtr image
p2 = sptr : IntPtr rlSrc
p3 = ARGS_SCALAR : Scalar value
%inst
元関数名(C#): ximgproc_rl_paint
元DLLエクスポート名: ximgproc_rl_paint
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_rl_paint(cv::_InputOutputArray *image, cv::_InputArray *rlSrc, MyCvScalar value)
{
    BEGIN_WRAP
    cv::ximgproc::rl::paint(*image, *rlSrc, cpp(value));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_rl_paint
[64bit] ランレングス符号化されたバイナリ画像を，画像にペイントします．
%prm
p1,p2,p3
p1 = sptr : IntPtr image
p2 = sptr : IntPtr rlSrc
p3 = var : Scalar value
%inst
元関数名(C#): ximgproc_rl_paint
元DLLエクスポート名: ximgproc_rl_paint
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_rl_paint(cv::_InputOutputArray *image, cv::_InputArray *rlSrc, MyCvScalar value)
{
    BEGIN_WRAP
    cv::ximgproc::rl::paint(*image, *rlSrc, cpp(value));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_rl_isRLMorphologyPossible
[32/64bit] カスタムメイドの構造化要素をランレングスモフォロジカルオペレーションで使用できるかどうかをチェックします。(カスタムメイドの構造化要素がランレングスモフォロジカルオペレーションで使用できるかどうかをチェックします。）
%prm
p1,p2
p1 = sptr : IntPtr rlStructuringElement
p2 = var : out int outValue
%inst
元関数名(C#): ximgproc_rl_isRLMorphologyPossible
元DLLエクスポート名: ximgproc_rl_isRLMorphologyPossible
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_rl_isRLMorphologyPossible(cv::_InputArray *rlStructuringElement, int *outValue)
{
    BEGIN_WRAP
    *outValue = cv::ximgproc::rl::isRLMorphologyPossible(*rlStructuringElement) ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_rl_createRLEImage
[32/64bit] runのベクトル(列開始、列終了、行)からランレングスエンコードされた画像を作成する。
%prm
p1,p2,p3,p4
p1 = var : Point3i[] runs
p2 = sptr : nint runsLength
p3 = sptr : IntPtr res
p4 = ARGS_SIZE : Size size
%inst
元関数名(C#): ximgproc_rl_createRLEImage
元DLLエクスポート名: ximgproc_rl_createRLEImage
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_rl_createRLEImage(MyCvPoint3D32i *runs, size_t runsLength, cv::_OutputArray *res, MyCvSize size)
{
    BEGIN_WRAP
    std::vector&amp;lt;cv::Point3i&amp;gt; runsVec(runsLength);
    for (size_t i = 0; i &amp;lt; runsLength; i++)
    {
        runsVec[i] = cpp(runs[i]);
    }
    cv::ximgproc::rl::createRLEImage(runsVec, *res, cpp(size));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_rl_morphologyEx
[32/64bit] ランレングスエンコードされた2値画像に対して，モルフォロジカルな処理を行います．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr rlSrc
p2 = sptr : IntPtr rlDest
p3 = int : int op
p4 = sptr : IntPtr rlKernel
p5 = int : int bBoundaryOnForErosion
p6 = ARGS_POINT : Point anchor
%inst
元関数名(C#): ximgproc_rl_morphologyEx
元DLLエクスポート名: ximgproc_rl_morphologyEx
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_rl_morphologyEx(
    cv::_InputArray *rlSrc, cv::_OutputArray *rlDest, int op, cv::_InputArray *rlKernel,
    int bBoundaryOnForErosion, MyCvPoint anchor)
{
    BEGIN_WRAP
    cv::ximgproc::rl::morphologyEx(*rlSrc, *rlDest, op, *rlKernel, bBoundaryOnForErosion != 0, cpp(anchor));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_weightedMedianFilter
[32/64bit] 画像に重み付けされたメディアンフィルタを適用します．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr joint
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
p4 = int : int r
p5 = double : double sigma
p6 = int : int weightType
p7 = sptr : IntPtr mask
%inst
この実装の詳細については、[292]参照：somedianBlur, jointBilateralFilter

元関数名(C#): ximgproc_weightedMedianFilter
元DLLエクスポート名: ximgproc_weightedMedianFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_weightedMedianFilter(
    cv::_InputArray* joint, cv::_InputArray* src, cv::_OutputArray* dst,
    int r, double sigma, int weightType, cv::Mat* mask)
{
    BEGIN_WRAP
    cv::ximgproc::weightedMedianFilter(*joint, *src, *dst, r, sigma,
        static_cast&amp;lt;cv::ximgproc::WMFWeightType&amp;gt;(weightType), entity(mask));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc

%index
ximgproc_EdgeBoxes_getBoundingBoxes
[32/64bit] 提案ボックスを含む配列を返します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr edgeMap
p3 = sptr : IntPtr orientationMap
p4 = sptr : IntPtr boxes
%inst
元関数名(C#): ximgproc_EdgeBoxes_getBoundingBoxes
元DLLエクスポート名: ximgproc_EdgeBoxes_getBoundingBoxes
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_getBoundingBoxes(
    cv::ximgproc::EdgeBoxes *obj, cv::_InputArray *edge_map, 
    cv::_InputArray *orientation_map, std::vector&amp;lt;cv::Rect&amp;gt; *boxes)
{
    BEGIN_WRAP
    obj-&amp;gt;getBoundingBoxes(*edge_map, *orientation_map, *boxes);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_getAlpha
[32/64bit] スライディングウィンドウサーチのステップサイズを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): ximgproc_EdgeBoxes_getAlpha
元DLLエクスポート名: ximgproc_EdgeBoxes_getAlpha
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_getAlpha(cv::ximgproc::EdgeBoxes *obj, float *returnValue)          { BEGIN_WRAP *returnValue = obj-&amp;gt;getAlpha(); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_setAlpha
[32/64bit] スライディングウィンドウサーチのステップサイズを設定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float value
%inst
元関数名(C#): ximgproc_EdgeBoxes_setAlpha
元DLLエクスポート名: ximgproc_EdgeBoxes_setAlpha
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_setAlpha(cv::ximgproc::EdgeBoxes *obj, float value)                 { BEGIN_WRAP obj-&amp;gt;setAlpha(value); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_getBeta
[32/64bit] オブジェクト提案のnms閾値を返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): ximgproc_EdgeBoxes_getBeta
元DLLエクスポート名: ximgproc_EdgeBoxes_getBeta
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_getBeta(cv::ximgproc::EdgeBoxes *obj, float *returnValue)           { BEGIN_WRAP *returnValue = obj-&amp;gt;getBeta(); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_setBeta
[32/64bit] 提案されたオブジェクトの nms 閾値を設定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float value
%inst
元関数名(C#): ximgproc_EdgeBoxes_setBeta
元DLLエクスポート名: ximgproc_EdgeBoxes_setBeta
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_setBeta(cv::ximgproc::EdgeBoxes *obj, float value)                  { BEGIN_WRAP obj-&amp;gt;setBeta(value); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_getEta
[32/64bit] Return adaptation rate for nms threshold.
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): ximgproc_EdgeBoxes_getEta
元DLLエクスポート名: ximgproc_EdgeBoxes_getEta
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_getEta(cv::ximgproc::EdgeBoxes *obj, float *returnValue)            { BEGIN_WRAP *returnValue = obj-&amp;gt;getEta(); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_setEta
[32/64bit] nmsしきい値の適応率を設定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float value
%inst
元関数名(C#): ximgproc_EdgeBoxes_setEta
元DLLエクスポート名: ximgproc_EdgeBoxes_setEta
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_setEta(cv::ximgproc::EdgeBoxes *obj, float value)                   { BEGIN_WRAP obj-&amp;gt;setEta(value); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_getMinScore
[32/64bit] 検出するボックスの最小スコアを返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): ximgproc_EdgeBoxes_getMinScore
元DLLエクスポート名: ximgproc_EdgeBoxes_getMinScore
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_getMinScore(cv::ximgproc::EdgeBoxes *obj, float *returnValue)       { BEGIN_WRAP *returnValue = obj-&amp;gt;getMinScore(); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_setMinScore
[32/64bit] 検出するボックスの最小スコアを設定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float value
%inst
元関数名(C#): ximgproc_EdgeBoxes_setMinScore
元DLLエクスポート名: ximgproc_EdgeBoxes_setMinScore
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_setMinScore(cv::ximgproc::EdgeBoxes *obj, float value)              { BEGIN_WRAP obj-&amp;gt;setMinScore(value); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_getMaxBoxes
[32/64bit] Returns the max number of boxes to detect detective
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ximgproc_EdgeBoxes_getMaxBoxes
元DLLエクスポート名: ximgproc_EdgeBoxes_getMaxBoxes
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_getMaxBoxes(cv::ximgproc::EdgeBoxes *obj, int *returnValue)         { BEGIN_WRAP *returnValue = obj-&amp;gt;getMaxBoxes(); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_setMaxBoxes
[32/64bit] 検出するボックスの最大数を設定する
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): ximgproc_EdgeBoxes_setMaxBoxes
元DLLエクスポート名: ximgproc_EdgeBoxes_setMaxBoxes
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_setMaxBoxes(cv::ximgproc::EdgeBoxes *obj, int value)                { BEGIN_WRAP obj-&amp;gt;setMaxBoxes(value); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_getEdgeMinMag
[32/64bit] Returns the edge min magnitude.
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): ximgproc_EdgeBoxes_getEdgeMinMag
元DLLエクスポート名: ximgproc_EdgeBoxes_getEdgeMinMag
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_getEdgeMinMag(cv::ximgproc::EdgeBoxes *obj, float *returnValue)     { BEGIN_WRAP *returnValue = obj-&amp;gt;getEdgeMinMag(); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_setEdgeMinMag
[32/64bit] エッジの最小の大きさを設定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float value
%inst
元関数名(C#): ximgproc_EdgeBoxes_setEdgeMinMag
元DLLエクスポート名: ximgproc_EdgeBoxes_setEdgeMinMag
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_setEdgeMinMag(cv::ximgproc::EdgeBoxes *obj, float value)            { BEGIN_WRAP obj-&amp;gt;setEdgeMinMag(value); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_getEdgeMergeThr
[32/64bit] Returns the edge merge threshold.
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): ximgproc_EdgeBoxes_getEdgeMergeThr
元DLLエクスポート名: ximgproc_EdgeBoxes_getEdgeMergeThr
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_getEdgeMergeThr(cv::ximgproc::EdgeBoxes *obj, float *returnValue)   { BEGIN_WRAP *returnValue = obj-&amp;gt;getEdgeMergeThr(); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_setEdgeMergeThr
[32/64bit] エッジのマージしきい値を設定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float value
%inst
元関数名(C#): ximgproc_EdgeBoxes_setEdgeMergeThr
元DLLエクスポート名: ximgproc_EdgeBoxes_setEdgeMergeThr
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_setEdgeMergeThr(cv::ximgproc::EdgeBoxes *obj, float value)          { BEGIN_WRAP obj-&amp;gt;setEdgeMergeThr(value); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_getClusterMinMag
[32/64bit] Returns the cluster min magnitude.
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): ximgproc_EdgeBoxes_getClusterMinMag
元DLLエクスポート名: ximgproc_EdgeBoxes_getClusterMinMag
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_getClusterMinMag(cv::ximgproc::EdgeBoxes *obj, float *returnValue)  { BEGIN_WRAP *returnValue = obj-&amp;gt;getClusterMinMag(); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_setClusterMinMag
[32/64bit] クラスターの最小の大きさを設定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float value
%inst
元関数名(C#): ximgproc_EdgeBoxes_setClusterMinMag
元DLLエクスポート名: ximgproc_EdgeBoxes_setClusterMinMag
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_setClusterMinMag(cv::ximgproc::EdgeBoxes *obj, float value)         { BEGIN_WRAP obj-&amp;gt;setClusterMinMag(value); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_getMaxAspectRatio
[32/64bit] Returns the max aspect ratio of boxes.
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): ximgproc_EdgeBoxes_getMaxAspectRatio
元DLLエクスポート名: ximgproc_EdgeBoxes_getMaxAspectRatio
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_getMaxAspectRatio(cv::ximgproc::EdgeBoxes *obj, float *returnValue) { BEGIN_WRAP *returnValue = obj-&amp;gt;getMaxAspectRatio(); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_setMaxAspectRatio
[32/64bit] ボックスのアスペクト比の最大値を設定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float value
%inst
元関数名(C#): ximgproc_EdgeBoxes_setMaxAspectRatio
元DLLエクスポート名: ximgproc_EdgeBoxes_setMaxAspectRatio
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_setMaxAspectRatio(cv::ximgproc::EdgeBoxes *obj, float value)        { BEGIN_WRAP obj-&amp;gt;setMaxAspectRatio(value); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_getMinBoxArea
[32/64bit] Returns the minimum area of boxes - ボックスの最小面積を返します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): ximgproc_EdgeBoxes_getMinBoxArea
元DLLエクスポート名: ximgproc_EdgeBoxes_getMinBoxArea
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_getMinBoxArea(cv::ximgproc::EdgeBoxes *obj, float *returnValue)     { BEGIN_WRAP *returnValue = obj-&amp;gt;getMinBoxArea(); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_setMinBoxArea
[32/64bit] ボックスの最小面積を設定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float value
%inst
元関数名(C#): ximgproc_EdgeBoxes_setMinBoxArea
元DLLエクスポート名: ximgproc_EdgeBoxes_setMinBoxArea
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_setMinBoxArea(cv::ximgproc::EdgeBoxes *obj, float value)            { BEGIN_WRAP obj-&amp;gt;setMinBoxArea(value); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_getGamma
[32/64bit] Return the affinity sensitivity.
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): ximgproc_EdgeBoxes_getGamma
元DLLエクスポート名: ximgproc_EdgeBoxes_getGamma
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_getGamma(cv::ximgproc::EdgeBoxes *obj, float *returnValue)          { BEGIN_WRAP *returnValue = obj-&amp;gt;getGamma(); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_setGamma
[32/64bit] 親和性の感度を設定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float value
%inst
元関数名(C#): ximgproc_EdgeBoxes_setGamma
元DLLエクスポート名: ximgproc_EdgeBoxes_setGamma
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_setGamma(cv::ximgproc::EdgeBoxes *obj, float value)                 { BEGIN_WRAP obj-&amp;gt;setGamma(value); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_getKappa
[32/64bit] Return the scale sensitivity.
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): ximgproc_EdgeBoxes_getKappa
元DLLエクスポート名: ximgproc_EdgeBoxes_getKappa
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_getKappa(cv::ximgproc::EdgeBoxes *obj, float *returnValue)          { BEGIN_WRAP *returnValue = obj-&amp;gt;getKappa(); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_EdgeBoxes_setKappa
[32/64bit] スケールの感度を設定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float value
%inst
元関数名(C#): ximgproc_EdgeBoxes_setKappa
元DLLエクスポート名: ximgproc_EdgeBoxes_setKappa
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_EdgeBoxes_setKappa(cv::ximgproc::EdgeBoxes *obj, float value)                 { BEGIN_WRAP obj-&amp;gt;setKappa(value); END_WRAP }

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_createEdgeBoxes
[32/64bit] Edgeboxes を作成します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13
p1 = float : float alpha
p2 = float : float beta
p3 = float : float eta
p4 = float : float minScore
p5 = int : int maxBoxes
p6 = float : float edgeMinMag
p7 = float : float edgeMergeThr
p8 = float : float clusterMinMag
p9 = float : float maxAspectRatio
p10 = float : float minBoxArea
p11 = float : float gamma
p12 = float : float kappa
p13 = var : out IntPtr returnValue
%inst
元関数名(C#): ximgproc_createEdgeBoxes
元DLLエクスポート名: ximgproc_createEdgeBoxes
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_createEdgeBoxes(
    float alpha,  float beta, float eta, float minScore, int maxBoxes, float edgeMinMag, float edgeMergeThr,
    float clusterMinMag, float maxAspectRatio, float minBoxArea, float gamma, float kappa,
    cv::Ptr&amp;lt;cv::ximgproc::EdgeBoxes&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(cv::ximgproc::createEdgeBoxes(alpha, beta, eta, minScore, maxBoxes, edgeMinMag, edgeMergeThr,
        clusterMinMag, maxAspectRatio, minBoxArea, gamma, kappa));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_Ptr_EdgeBoxes_delete
[32/64bit] cv::ximgproc::EdgeBoxes のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
297]の EdgeBoxes アルゴリズムを実装したクラス．


元関数名(C#): ximgproc_Ptr_EdgeBoxes_delete
元DLLエクスポート名: ximgproc_Ptr_EdgeBoxes_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_EdgeBoxes_delete(cv::Ptr&amp;lt;cv::ximgproc::EdgeBoxes&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_Ptr_EdgeBoxes_get
[32/64bit] cv::ximgproc::EdgeBoxes のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
297]の EdgeBoxes アルゴリズムを実装したクラス．


元関数名(C#): ximgproc_Ptr_EdgeBoxes_get
元DLLエクスポート名: ximgproc_Ptr_EdgeBoxes_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeBoxes.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_EdgeBoxes_get(cv::Ptr&amp;lt;cv::ximgproc::EdgeBoxes&amp;gt; *ptr, cv::ximgproc::EdgeBoxes **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeBoxes

%index
ximgproc_Ptr_DTFilter_delete
[32/64bit] cv::ximgproc::DTFilter のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
Domain Transformフィルタを実現するためのインタフェースです．

このフィルタの詳細については，[87]を参照してください．


元関数名(C#): ximgproc_Ptr_DTFilter_delete
元DLLエクスポート名: ximgproc_Ptr_DTFilter_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_DTFilter_delete(
    cv::Ptr&amp;lt;cv::ximgproc::DTFilter&amp;gt;* obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_Ptr_DTFilter_get
[32/64bit] cv::ximgproc::DTFilter のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
Domain Transformフィルタを実現するためのインタフェースです．

このフィルタの詳細については，[87]を参照してください．


元関数名(C#): ximgproc_Ptr_DTFilter_get
元DLLエクスポート名: ximgproc_Ptr_DTFilter_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_DTFilter_get(
    cv::Ptr&amp;lt;cv::ximgproc::DTFilter&amp;gt;* ptr, cv::ximgproc::DTFilter** returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_DTFilter_filter
[32/64bit] 入力画像に対して，ドメイン変換によるフィルタリング処理を行います．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
p4 = int : int dDepth
%inst
元関数名(C#): ximgproc_DTFilter_filter
元DLLエクスポート名: ximgproc_DTFilter_filter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_DTFilter_filter(
    cv::ximgproc::DTFilter* obj,
    cv::_InputArray *src, cv::_OutputArray *dst, int dDepth)
{
    BEGIN_WRAP
    obj-&amp;gt;filter(*src, *dst, dDepth);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_createDTFilter
[32/64bit] DTFilter のインスタンスを作成し，初期化ルーチンを生成するファクトリーメソッド．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr guide
p2 = double : double sigmaSpatial
p3 = double : double sigmaColor
p4 = int : int mode
p5 = int : int numIters
p6 = var : out IntPtr returnValue
%inst
Domain Transformフィルタのパラメータの詳細については，原著論文[87]およびDomain Transformフィルタのホームページを参照してください．

元関数名(C#): ximgproc_createDTFilter
元DLLエクスポート名: ximgproc_createDTFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_createDTFilter(
    cv::_InputArray *guide, double sigmaSpatial, double sigmaColor, int mode, int numIters,
    cv::Ptr&amp;lt;cv::ximgproc::DTFilter&amp;gt;** returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::ximgproc::createDTFilter(*guide, sigmaSpatial, sigmaColor, mode, numIters);
    *returnValue = new cv::Ptr&amp;lt;cv::ximgproc::DTFilter&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_dtFilter
[32/64bit] シンプルな1行のDomain Transformフィルタ呼び出し。もし，同じガイド画像を使ってフィルタリングする画像が複数ある場合は，初期化段階での余分な計算を避けるために DTFilter インタフェースを利用してください．
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr guide
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
p4 = double : double sigmaSpatial
p5 = double : double sigmaColor
p6 = int : int mode
p7 = int : int numIters
%inst
関連項目： バイラテラルフィルタ，ガイド付きフィルタ，AMフィルタ

元関数名(C#): ximgproc_dtFilter
元DLLエクスポート名: ximgproc_dtFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_dtFilter(
    cv::_InputArray *guide, cv::_InputArray *src, cv::_OutputArray *dst, double sigmaSpatial, double sigmaColor, int mode, int numIters)
{
    BEGIN_WRAP
    cv::ximgproc::dtFilter(*guide, *src, *dst, sigmaSpatial, sigmaColor, mode, numIters);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_Ptr_GuidedFilter_delete
[32/64bit] cv::ximgproc::GuidedFilter のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
ガイド付きフィルタを実現するためのインターフェースです。

このフィルタの詳細については [106] を参照してください。


元関数名(C#): ximgproc_Ptr_GuidedFilter_delete
元DLLエクスポート名: ximgproc_Ptr_GuidedFilter_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_GuidedFilter_delete(
    cv::Ptr&amp;lt;cv::ximgproc::GuidedFilter&amp;gt;* obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_Ptr_GuidedFilter_get
[32/64bit] cv::ximgproc::GuidedFilter のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
ガイド付きフィルタを実現するためのインターフェースです。

このフィルタの詳細については [106] を参照してください。


元関数名(C#): ximgproc_Ptr_GuidedFilter_get
元DLLエクスポート名: ximgproc_Ptr_GuidedFilter_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_GuidedFilter_get(
    cv::Ptr&amp;lt;cv::ximgproc::GuidedFilter&amp;gt;* ptr, cv::ximgproc::GuidedFilter** returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_GuidedFilter_filter
[32/64bit] フィルタリング画像に Guided Filter を適用します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
p4 = int : int dDepth
%inst
元関数名(C#): ximgproc_GuidedFilter_filter
元DLLエクスポート名: ximgproc_GuidedFilter_filter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_GuidedFilter_filter(
    cv::ximgproc::GuidedFilter* obj,
    cv::_InputArray* src, cv::_OutputArray* dst, int dDepth)
{
    BEGIN_WRAP
    obj-&amp;gt;filter(*src, *dst, dDepth);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_createGuidedFilter
[32/64bit] GuidedFilter のインスタンスを作成したり、初期化ルーチンを生成するファクトリーメソッドです。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr guide
p2 = int : int radius
p3 = double : double eps
p4 = var : out IntPtr returnValue
%inst
Guided Filter のパラメータの詳細については，原著論文 [106] を参照してください．

元関数名(C#): ximgproc_createGuidedFilter
元DLLエクスポート名: ximgproc_createGuidedFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_createGuidedFilter(
    cv::_InputArray* guide, int radius, double eps, 
    cv::Ptr&amp;lt;cv::ximgproc::GuidedFilter&amp;gt;** returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::ximgproc::createGuidedFilter(*guide, radius, eps);
    *returnValue = new cv::Ptr&amp;lt;cv::ximgproc::GuidedFilter&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_guidedFilter
[32/64bit] シンプルな1行のGuided Filterの呼び出しです。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr guide
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
p4 = int : int radius
p5 = double : double eps
p6 = int : int dDepth
%inst
同じガイド画像を使って複数の画像をフィルタリングする場合は、GuidedFilterインターフェイスを使うと、初期化時に余分な計算をしなくて済みます。他にも、bilateralFilter, dtFilter, amFilterを参照してください。

元関数名(C#): ximgproc_guidedFilter
元DLLエクスポート名: ximgproc_guidedFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_guidedFilter(
    cv::_InputArray *guide, cv::_InputArray *src, cv::_OutputArray *dst, int radius, double eps, int dDepth)
{
    BEGIN_WRAP
    cv::ximgproc::guidedFilter(*guide, *src, *dst, radius, eps, dDepth);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_Ptr_AdaptiveManifoldFilter_delete
[32/64bit] cv::ximgproc::AdaptiveManifoldFilter のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
アダプティブ・マニホールド・フィルターを実現するためのインターフェイスです。

このフィルターの詳細については、[88]およびReferences_を参照してください。

Algorithm::set関数で設定できるオプション・パラメータを以下に示します。

member double sigma_s = 16.0 空間的な標準偏差。

member double sigma_r = 0.2 色空間の標準偏差.

member int tree_height = -1 マニフォールドツリーの高さ (default = -1 : 自動計算).

member int num_pca_iterations = 1 固有ベクトルを計算するための反復回数。

member bool adjust_outliers = false 式(9)を用いて外れ値を調整するかどうかを指定する。

member bool use_RNG = true 固有ベクトルの計算に乱数発生器を使用するかどうかを指定する。


元関数名(C#): ximgproc_Ptr_AdaptiveManifoldFilter_delete
元DLLエクスポート名: ximgproc_Ptr_AdaptiveManifoldFilter_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_AdaptiveManifoldFilter_delete(
    cv::Ptr&amp;lt;cv::ximgproc::AdaptiveManifoldFilter&amp;gt;* obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_Ptr_AdaptiveManifoldFilter_get
[32/64bit] cv::ximgproc::AdaptiveManifoldFilter のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
アダプティブ・マニホールド・フィルターを実現するためのインターフェイスです。

このフィルターの詳細については、[88]およびReferences_を参照してください。

Algorithm::set関数で設定できるオプション・パラメータを以下に示します。

member double sigma_s = 16.0 空間的な標準偏差。

member double sigma_r = 0.2 色空間の標準偏差.

member int tree_height = -1 マニフォールドツリーの高さ (default = -1 : 自動計算).

member int num_pca_iterations = 1 固有ベクトルを計算するための反復回数。

member bool adjust_outliers = false 式(9)を用いて外れ値を調整するかどうかを指定する。

member bool use_RNG = true 固有ベクトルの計算に乱数発生器を使用するかどうかを指定する。


元関数名(C#): ximgproc_Ptr_AdaptiveManifoldFilter_get
元DLLエクスポート名: ximgproc_Ptr_AdaptiveManifoldFilter_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_AdaptiveManifoldFilter_get(
    cv::Ptr&amp;lt;cv::ximgproc::AdaptiveManifoldFilter&amp;gt;* ptr, cv::ximgproc::AdaptiveManifoldFilter** returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_AdaptiveManifoldFilter_filter
[32/64bit] 適応型多様体を用いた高次元フィルタリングの適用。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
p4 = sptr : IntPtr joint
%inst
元関数名(C#): ximgproc_AdaptiveManifoldFilter_filter
元DLLエクスポート名: ximgproc_AdaptiveManifoldFilter_filter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_AdaptiveManifoldFilter_filter(
    cv::ximgproc::AdaptiveManifoldFilter* obj,
    cv::_InputArray* src, cv::_OutputArray* dst, cv::_InputArray *joint)
{
    BEGIN_WRAP
    obj-&amp;gt;filter(*src, *dst, entity(joint));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_AdaptiveManifoldFilter_collectGarbage
[32/64bit] ximgproc_AdaptiveManifoldFilter_collectGarbage
%prm
p1
p1 = sptr : IntPtr obj
%inst
元関数名(C#): ximgproc_AdaptiveManifoldFilter_collectGarbage
元DLLエクスポート名: ximgproc_AdaptiveManifoldFilter_collectGarbage
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_AdaptiveManifoldFilter_collectGarbage(
    cv::ximgproc::AdaptiveManifoldFilter* obj)
{
    BEGIN_WRAP
    obj-&amp;gt;collectGarbage();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_AdaptiveManifoldFilter_getSigmaS
[32/64bit] alsosetSigmaSを参照してください。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): ximgproc_AdaptiveManifoldFilter_getSigmaS
元DLLエクスポート名: ximgproc_AdaptiveManifoldFilter_getSigmaS
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_AdaptiveManifoldFilter_getSigmaS(cv::ximgproc::AdaptiveManifoldFilter* obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getSigmaS();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_AdaptiveManifoldFilter_setSigmaS
[32/64bit] アルソジェットシグマSを参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): ximgproc_AdaptiveManifoldFilter_setSigmaS
元DLLエクスポート名: ximgproc_AdaptiveManifoldFilter_setSigmaS
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_AdaptiveManifoldFilter_setSigmaS(cv::ximgproc::AdaptiveManifoldFilter* obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setSigmaS(val);
    END_WRAP    
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_AdaptiveManifoldFilter_getSigmaR
[32/64bit] ximgproc_AdaptiveManifoldFilter_getSigmaR
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): ximgproc_AdaptiveManifoldFilter_getSigmaR
元DLLエクスポート名: ximgproc_AdaptiveManifoldFilter_getSigmaR
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_AdaptiveManifoldFilter_getSigmaR(cv::ximgproc::AdaptiveManifoldFilter* obj, double* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getSigmaR();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_AdaptiveManifoldFilter_setSigmaR
[32/64bit] アルソセットシグマRを参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double val
%inst
元関数名(C#): ximgproc_AdaptiveManifoldFilter_setSigmaR
元DLLエクスポート名: ximgproc_AdaptiveManifoldFilter_setSigmaR
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_AdaptiveManifoldFilter_setSigmaR(cv::ximgproc::AdaptiveManifoldFilter* obj, double val)
{
    BEGIN_WRAP
    obj-&amp;gt;setSigmaR(val);
    END_WRAP    
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_AdaptiveManifoldFilter_getTreeHeight
[32/64bit] アルソセットツリーの高さを見る
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ximgproc_AdaptiveManifoldFilter_getTreeHeight
元DLLエクスポート名: ximgproc_AdaptiveManifoldFilter_getTreeHeight
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_AdaptiveManifoldFilter_getTreeHeight(cv::ximgproc::AdaptiveManifoldFilter* obj, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getTreeHeight();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_AdaptiveManifoldFilter_setTreeHeight
[32/64bit] アルソジェットツリーハイトを参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ximgproc_AdaptiveManifoldFilter_setTreeHeight
元DLLエクスポート名: ximgproc_AdaptiveManifoldFilter_setTreeHeight
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_AdaptiveManifoldFilter_setTreeHeight(cv::ximgproc::AdaptiveManifoldFilter* obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setTreeHeight(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_AdaptiveManifoldFilter_getPCAIterations
[32/64bit] アルソセットPCAIterationsを見る
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ximgproc_AdaptiveManifoldFilter_getPCAIterations
元DLLエクスポート名: ximgproc_AdaptiveManifoldFilter_getPCAIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_AdaptiveManifoldFilter_getPCAIterations(cv::ximgproc::AdaptiveManifoldFilter* obj, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getPCAIterations();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_AdaptiveManifoldFilter_setPCAIterations
[32/64bit] アルソジェットPCAIterationsを参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ximgproc_AdaptiveManifoldFilter_setPCAIterations
元DLLエクスポート名: ximgproc_AdaptiveManifoldFilter_setPCAIterations
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_AdaptiveManifoldFilter_setPCAIterations(cv::ximgproc::AdaptiveManifoldFilter* obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setPCAIterations(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_AdaptiveManifoldFilter_getAdjustOutliers
[32/64bit] アルソセットアジャストアウトライアを見る
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ximgproc_AdaptiveManifoldFilter_getAdjustOutliers
元DLLエクスポート名: ximgproc_AdaptiveManifoldFilter_getAdjustOutliers
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_AdaptiveManifoldFilter_getAdjustOutliers(cv::ximgproc::AdaptiveManifoldFilter* obj, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getAdjustOutliers();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_AdaptiveManifoldFilter_setAdjustOutliers
[32/64bit] alsogetAdjustOutliersを参照。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ximgproc_AdaptiveManifoldFilter_setAdjustOutliers
元DLLエクスポート名: ximgproc_AdaptiveManifoldFilter_setAdjustOutliers
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_AdaptiveManifoldFilter_setAdjustOutliers(cv::ximgproc::AdaptiveManifoldFilter* obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setAdjustOutliers(val);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_AdaptiveManifoldFilter_getUseRNG
[32/64bit] 参照：「UseRNG」（英語
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ximgproc_AdaptiveManifoldFilter_getUseRNG
元DLLエクスポート名: ximgproc_AdaptiveManifoldFilter_getUseRNG
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_AdaptiveManifoldFilter_getUseRNG(cv::ximgproc::AdaptiveManifoldFilter* obj, int* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getUseRNG() ? 1 : 0;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_AdaptiveManifoldFilter_setUseRNG
[32/64bit] alsogetUseRNGを参照
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int val
%inst
元関数名(C#): ximgproc_AdaptiveManifoldFilter_setUseRNG
元DLLエクスポート名: ximgproc_AdaptiveManifoldFilter_setUseRNG
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_AdaptiveManifoldFilter_setUseRNG(cv::ximgproc::AdaptiveManifoldFilter* obj, int val)
{
    BEGIN_WRAP
    obj-&amp;gt;setUseRNG(val != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_createAMFilter
[32/64bit] AdaptiveManifoldFilterのインスタンスを生成し、初期化ルーチンを生成するファクトリーメソッドです。
%prm
p1,p2,p3,p4
p1 = double : double sigma_s
p2 = double : double sigma_r
p3 = int : int adjust_outliers
p4 = var : out IntPtr returnValue
%inst
Adaptive Manifold Filter のパラメータの詳細については，原著論文 [88] を参照してください． 注： CV_8U と CV_16U の深度を持つ結合画像は，処理前に CV_32F の深度と [0; 1] の色域を持つ画像に変換されます．したがって，色空間のシグマ sigma_r は， bilateralFilter や dtFilter のシグマとは異なり， [0; 1] の範囲になければいけません．

元関数名(C#): ximgproc_createAMFilter
元DLLエクスポート名: ximgproc_createAMFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_createAMFilter(
    double sigma_s, double sigma_r, int adjust_outliers,
    cv::Ptr&amp;lt;cv::ximgproc::AdaptiveManifoldFilter&amp;gt;** returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::ximgproc::createAMFilter(sigma_s, sigma_r, adjust_outliers != 0);
    *returnValue = new cv::Ptr&amp;lt;cv::ximgproc::AdaptiveManifoldFilter&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_amFilter
[32/64bit] シンプルな1行のAdaptive Manifold Filterコールです。
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr joint
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
p4 = double : double sigma_s
p5 = double : double sigma_r
p6 = int : int adjust_outliers
%inst
注意ジョイント画像のうち，深度が CV_8U と CV_16U のものは，処理の前に深度が CV_32F，色域が [0; 1] の画像に変換されます．そのため，色空間シグマ sigma_r は [0; 1] の範囲になければいけません（bilateralFilter や dtFilter のシグマとは異なります）。

元関数名(C#): ximgproc_amFilter
元DLLエクスポート名: ximgproc_amFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_amFilter(
    cv::_InputArray *joint, cv::_InputArray *src, cv::_OutputArray *dst, double sigma_s, double sigma_r, int adjust_outliers)
{
    BEGIN_WRAP
    cv::ximgproc::amFilter(*joint, *src, *dst, sigma_s, sigma_r, adjust_outliers != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_jointBilateralFilter
[32/64bit] ジョイントバイラテラルフィルターを画像に適用します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr joint
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
p4 = int : int d
p5 = double : double sigmaColor
p6 = double : double sigmaSpace
p7 = int : int borderType
%inst
また、bilateralFilter や jointBilateralFilter では、L1 ノルムを使って色の違いを計算しています。

元関数名(C#): ximgproc_jointBilateralFilter
元DLLエクスポート名: ximgproc_jointBilateralFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_jointBilateralFilter(cv::_InputArray *joint, cv::_InputArray *src, cv::_OutputArray *dst, int d, double sigmaColor, double sigmaSpace, int borderType)
{
    BEGIN_WRAP
    cv::ximgproc::jointBilateralFilter(*joint, *src, *dst, d, sigmaColor, sigmaSpace, borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_bilateralTextureFilter
[32/64bit] バイラテラルテクスチャフィルタを画像に適用します。構造保持型のテクスチャフィルタです。このフィルタの詳細については，[47]をご覧ください．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int fr
p4 = int : int numIter
p5 = double : double sigmaAlpha
p6 = double : double sigmaAvg
%inst
関連項目：ローリングガイダンスフィルター、バイラテラルフィルター

元関数名(C#): ximgproc_bilateralTextureFilter
元DLLエクスポート名: ximgproc_bilateralTextureFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_bilateralTextureFilter(cv::_InputArray *src, cv::_OutputArray *dst, int fr, int numIter, double sigmaAlpha, double sigmaAvg)
{
    BEGIN_WRAP
    cv::ximgproc::bilateralTextureFilter(*src, *dst, fr, numIter, sigmaAlpha, sigmaAvg);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_rollingGuidanceFilter
[32/64bit] ローリングガイドフィルターを画像に適用します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = int : int d
p4 = double : double sigmaColor
p5 = double : double sigmaSpace
p6 = int : int numOfIter
p7 = int : int borderType
%inst
詳しくは[291]NoterollingGuidanceFilterでは、エッジ保存フィルタとしてjointBilateralFilterを使っています。jointBilateralFilter, bilateralFilter, amFilterも参照してください。

元関数名(C#): ximgproc_rollingGuidanceFilter
元DLLエクスポート名: ximgproc_rollingGuidanceFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_rollingGuidanceFilter(cv::_InputArray *src, cv::_OutputArray *dst, int d, double sigmaColor, double sigmaSpace, int numOfIter, int borderType)
{
    BEGIN_WRAP
    cv::ximgproc::rollingGuidanceFilter(*src, *dst, d, sigmaColor, sigmaSpace, numOfIter, borderType);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_Ptr_FastBilateralSolverFilter_delete
[32/64bit] cv::ximgproc::FastBilateralSolverFilter のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
Fast Bilateral Solver（高速バイラテラルソルバー）を実装するためのインターフェースです。

このソルバーの詳細は[15]を参照してください。


元関数名(C#): ximgproc_Ptr_FastBilateralSolverFilter_delete
元DLLエクスポート名: ximgproc_Ptr_FastBilateralSolverFilter_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_FastBilateralSolverFilter_delete(
    cv::Ptr&amp;lt;cv::ximgproc::FastBilateralSolverFilter&amp;gt;* obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_Ptr_FastBilateralSolverFilter_get
[32/64bit] cv::ximgproc::FastBilateralSolverFilter のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
Fast Bilateral Solver（高速バイラテラルソルバー）を実装するためのインターフェースです。

このソルバーの詳細は[15]を参照してください。


元関数名(C#): ximgproc_Ptr_FastBilateralSolverFilter_get
元DLLエクスポート名: ximgproc_Ptr_FastBilateralSolverFilter_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_FastBilateralSolverFilter_get(
    cv::Ptr&amp;lt;cv::ximgproc::FastBilateralSolverFilter&amp;gt;* ptr, cv::ximgproc::FastBilateralSolverFilter** returnValue)
{
    BEGIN_WRAP
    * returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_FastBilateralSolverFilter_filter
[32/64bit] 入力画像に，スムージング処理を施します．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr src
p3 = sptr : IntPtr confidence
p4 = sptr : IntPtr dst
%inst
注深さが CV_8U の信頼度画像は [0, 255]，CV_32F の信頼度画像は [0, 1] の範囲になると思われます．

元関数名(C#): ximgproc_FastBilateralSolverFilter_filter
元DLLエクスポート名: ximgproc_FastBilateralSolverFilter_filter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_FastBilateralSolverFilter_filter(
    cv::ximgproc::FastBilateralSolverFilter* obj,
    cv::_InputArray* src, cv::_InputArray *confidence, cv::_OutputArray* dst)
{
    BEGIN_WRAP
    obj-&amp;gt;filter(*src, *confidence , *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_createFastBilateralSolverFilter
[32/64bit] ファクトリーメソッドで，FastBilateralSolverFilter のインスタンスを生成し，初期化ルーチンを実行します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr guide
p2 = double : double sigma_spatial
p3 = double : double sigma_luma
p4 = double : double sigma_chroma
p5 = double : double lambda
p6 = int : int num_iter
p7 = double : double max_tol
p8 = var : out IntPtr returnValue
%inst
Fast Bilateral Solverのパラメータについての詳細は、オリジナルの論文[15]を参照してください。

元関数名(C#): ximgproc_createFastBilateralSolverFilter
元DLLエクスポート名: ximgproc_createFastBilateralSolverFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_createFastBilateralSolverFilter(
    cv::_InputArray *guide, double sigma_spatial, double sigma_luma, double sigma_chroma, double lambda, int num_iter, double max_tol,
    cv::Ptr&amp;lt;cv::ximgproc::FastBilateralSolverFilter&amp;gt;** returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::ximgproc::createFastBilateralSolverFilter(*guide, sigma_spatial, sigma_luma, sigma_chroma, lambda, num_iter, max_tol);
    *returnValue = new cv::Ptr&amp;lt;cv::ximgproc::FastBilateralSolverFilter&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_fastBilateralSolverFilter
[32/64bit] シンプルな一行の高速バイラテラルソルバーのフィルターコール。同じガイドで複数の画像をフィルタリングする場合は、FastBilateralSolverFilterインターフェースを使うと、余分な計算をしなくて済みます。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
p1 = sptr : IntPtr guide
p2 = sptr : IntPtr src
p3 = sptr : IntPtr confidence
p4 = sptr : IntPtr dst
p5 = double : double sigma_spatial
p6 = double : double sigma_luma
p7 = double : double sigma_chroma
p8 = double : double lambda
p9 = int : int num_iter
p10 = double : double max_tol
%inst
高速バイラテラルソルバーのパラメータに関する詳細は，原著論文[15]を参照してください．注意深さが CV_8U の信頼度画像は [0, 255]，CV_32F の信頼度画像は [0, 1]の範囲に収まることが期待されます．

元関数名(C#): ximgproc_fastBilateralSolverFilter
元DLLエクスポート名: ximgproc_fastBilateralSolverFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_fastBilateralSolverFilter(
    cv::_InputArray *guide, cv::_InputArray *src, cv::_InputArray *confidence, cv::_OutputArray *dst, 
    double sigma_spatial, double sigma_luma, double sigma_chroma, double lambda, int num_iter, double max_tol)
{
    BEGIN_WRAP
    cv::ximgproc::fastBilateralSolverFilter(*guide, *src, *confidence, *dst,
        sigma_spatial, sigma_luma, sigma_chroma, lambda, num_iter, max_tol);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_Ptr_FastGlobalSmootherFilter_delete
[32/64bit] cv::ximgproc::FastGlobalSmootherFilter のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
Fast Global Smootherフィルタを実装するためのインタフェース．

このフィルタの詳細については，[172]と[68]を参照してください．


元関数名(C#): ximgproc_Ptr_FastGlobalSmootherFilter_delete
元DLLエクスポート名: ximgproc_Ptr_FastGlobalSmootherFilter_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_FastGlobalSmootherFilter_delete(
    cv::Ptr&amp;lt;cv::ximgproc::FastGlobalSmootherFilter&amp;gt;* obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_Ptr_FastGlobalSmootherFilter_get
[32/64bit] cv::ximgproc::FastGlobalSmootherFilter のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
Fast Global Smootherフィルタを実装するためのインタフェース．

このフィルタの詳細については，[172]と[68]を参照してください．


元関数名(C#): ximgproc_Ptr_FastGlobalSmootherFilter_get
元DLLエクスポート名: ximgproc_Ptr_FastGlobalSmootherFilter_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_FastGlobalSmootherFilter_get(
    cv::Ptr&amp;lt;cv::ximgproc::FastGlobalSmootherFilter&amp;gt;* ptr, cv::ximgproc::FastGlobalSmootherFilter** returnValue)
{
    BEGIN_WRAP
    * returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_FastGlobalSmootherFilter_filter
[32/64bit] 入力画像に，スムージング処理を施します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
%inst
元関数名(C#): ximgproc_FastGlobalSmootherFilter_filter
元DLLエクスポート名: ximgproc_FastGlobalSmootherFilter_filter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_FastGlobalSmootherFilter_filter(
    cv::ximgproc::FastGlobalSmootherFilter* obj,
    cv::_InputArray* src, cv::_OutputArray* dst)
{
    BEGIN_WRAP
    obj-&amp;gt;filter(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_createFastGlobalSmootherFilter
[32/64bit] FastGlobalSmootherFilter のインスタンスを生成し，初期化ルーチンを実行するファクトリメソッド．
%prm
p1,p2,p3,p4,p5,p6
p1 = sptr : IntPtr guide
p2 = double : double lambda
p3 = double : double sigma_color
p4 = double : double lambda_attenuation
p5 = int : int num_iter
p6 = var : out IntPtr returnValue
%inst
Fast Global Smootherのパラメータの詳細については、オリジナルの論文[172]を参照してください。ただし、いくつかの違いがあることに注意してください。論文に記載されているラムダ減衰は、実装方法が少し異なるため、論文と同じ結果を期待してはいけません。論文に記載されているsigma_colorの値は、同じ効果を得るために255.0を乗じる必要があります。また，ソース画像とガイド画像が同じである画像フィルタリングの場合，著者は，各反復の後にガイド画像を動的に更新することを提案しています．性能を最大限に引き出すため，この機能はここでは実装されていない．

元関数名(C#): ximgproc_createFastGlobalSmootherFilter
元DLLエクスポート名: ximgproc_createFastGlobalSmootherFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_createFastGlobalSmootherFilter(
    cv::_InputArray *guide, double lambda, double sigma_color, double lambda_attenuation, int num_iter,
    cv::Ptr&amp;lt;cv::ximgproc::FastGlobalSmootherFilter&amp;gt;** returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::ximgproc::createFastGlobalSmootherFilter(*guide, lambda, sigma_color, lambda_attenuation, num_iter);
    *returnValue = new cv::Ptr&amp;lt;cv::ximgproc::FastGlobalSmootherFilter&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_fastGlobalSmootherFilter
[32/64bit] シンプルな1行のFast Global Smootherフィルターコール。同じガイドで複数の画像をフィルタリングする場合は、FastGlobalSmootherFilterインターフェイスを使うと、余分な計算をしなくて済みます。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = sptr : IntPtr guide
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
p4 = double : double lambda
p5 = double : double sigma_color
p6 = double : double lambda_attenuation
p7 = int : int num_iter
%inst
元関数名(C#): ximgproc_fastGlobalSmootherFilter
元DLLエクスポート名: ximgproc_fastGlobalSmootherFilter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_fastGlobalSmootherFilter(
    cv::_InputArray *guide, cv::_InputArray *src, cv::_OutputArray *dst, double lambda, double sigma_color, double lambda_attenuation, int num_iter)
{
    BEGIN_WRAP
    cv::ximgproc::fastGlobalSmootherFilter(*guide, *src, *dst,
        lambda, sigma_color, lambda_attenuation, num_iter);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_l0Smooth
[32/64bit] L0勾配最小化によるグローバルな画像スムージング。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr src
p2 = sptr : IntPtr dst
p3 = double : double lambda
p4 = double : double kappa
%inst
L0 Smootherの詳細については，原著論文[280]を参照してください．

元関数名(C#): ximgproc_l0Smooth
元DLLエクスポート名: ximgproc_l0Smooth
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_EdgeFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_l0Smooth(cv::_InputArray *src, cv::_OutputArray *dst, double lambda, double kappa)
{
    BEGIN_WRAP
    cv::ximgproc::l0Smooth(*src, *dst, lambda, kappa);
    END_WRAP    
}

</pre>
}html
%group
NativeMethods_ximgproc_EdgeFilter

%index
ximgproc_Ptr_FastLineDetector_delete
[32/64bit] cv::ximgproc::FastLineDetector のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
136]に記載されているFLD(Fast Line Detector)アルゴリズムを実装したクラス。

#include <iostream>#include "opencv2/imgproc.hpp "#include "opencv2/ximgproc.hpp "#include "opencv2/imgcodecs.hpp "#include "opencv2/highgui.hpp "using namespace std;using namespace cv;using namespace cv::ximgproc;int main(int argc, char** argv){ string in; CommandLineParser parser(argc, argv, "{@input|corridor.jpg|input image}{help h||show help message}"); if (parser.has("help")) { parser.printMessage(); return 0; } in = samples::findFile(parser.get<string>("@input")); Mat image = imread(in, IMREAD_GRAYSCALE); if( image.empty() )    { return -1; }.    // FLD 検出器の作成 // Param Default value Description // length_threshold 10 - これよりも短いセグメントは破棄されます // distance_threshold 1.41421356 - 仮説線から // これよりも遠いセグメントに置かれた点は // 外れ値とみなされる // canny_th1 50 - Canny() のヒステリシス処理のための // 第 1 の閾値 // canny_th2 50 - Canny() のヒステリシス処理のための // 第 2 の閾値 // canny_aperture_size 3 - Canny() の sobel 演算子のための開口サイズ．    // 0の場合，Canny()は適用されず，入力画像は // エッジ画像として扱われます．    // do_merge false - true の場合，セグメントのインクリメンタルなマージが // 行われます int length_threshold = 10; float distance_threshold = 1.41421356f; double canny_th1 = 50.0; double canny_th2 = 50.0; int canny_aperture_size = 3; bool do_merge = false; Ptr<FastLineDetector> fld = createFastLineDetector(length_threshold, distance_threshold, canny_th1, canny_th2, canny_aperture_size, do_merge); vector<Vec4f> lines; // CPUのパワーストラテジーによっては、アルゴリズムの最初の実行に時間がかかることがあるようです。for (int run_count = 0; run_count < 5; run_count++) { double freq = getTickFrequency(); lines.clear(); int64 start = getTickCount(); // FLDでラインを検出 fld->detect(image, lines); double duration_ms = double(getTickCount() - start) * 1000 / freq; cout << "FLDの経過時間 " << duration_ms << " ms.".<< endl; }。    // FLD で見つかった線を表示する Mat line_image_fld(image); fld->drawSegments(line_image_fld, lines); imshow("FLD result", line_image_fld); waitKey(1); Ptr<EdgeDrawing> ed = createEdgeDrawing(); ed->params.ed->params.EdgeDetectionOperator = EdgeDrawing::SOBEL; ed->params.GradientThresholdValue = 38; ed->params.AnchorThresholdValue = 8; vector<Vec6d> ellipses; for (int run_count = 0; run_count < 5; run_count++) { double freq = getTickFrequency(); lines.clear(); int64 start = getTickCount(); // エッジを検出する // detectLines() と detectEllipses() の前に呼び出す必要がある ed->detectEdges(image); // ラインを検出する ed->detectLines(lines); double duration_ms = double(getTickCount() - start) * 1000 / freq; cout << "EdgeDrawing の経過時間 detectLines " << duration_ms << " ms.".<< endl; start = getTickCount(); // 円と楕円の検出 ed->detectEllipses(ellipses); duration_ms = double(getTickCount() - start) * 1000 / freq; cout << "EdgeDrawing detectEllipsesの経過時間 " << duration_ms << " ms.".<< endl; }。    Mat edge_image_ed = Mat::zeros(image.size(), CV_8UC3); vector<vector<Point> > segments = ed->getSegments(); for (size_t i = 0; i < segments.size(); i++) { const Point* pts = &segments[i][0]; int n = (int)segments[i].size(); polylines(edge_image_ed, &pts, &n, 1, false, Scalar((rand() & 255), (rand() & 255), (rand() & 255), 1); } imshow("EdgeDrawing detected edges", edge_image_ed); Mat line_image_ed(image); fld->drawSegments(line_image_ed, lines); // 円と楕円の描画 for (size_t i = 0; i < ellipses.size(); i++) { Point center((int)ellipses[i][0], (int)ellipses[i][1]);        Size axes((int)ellipses[i][2] + (int)ellipses[i][3], (int)ellipses[i][2] + (int)ellipses[i][4]); double angle(ellipses[i][5]); Scalar color = ellipses[i][2] == 0 ?Scalar(255, 255, 0) : Scalar(0, 255, 0); ellipse(line_image_ed, center, axes, angle, 0, 360, color, 2, LINE_AA); } imshow("EdgeDrawing result", line_image_ed); waitKey(); return 0;}。


元関数名(C#): ximgproc_Ptr_FastLineDetector_delete
元DLLエクスポート名: ximgproc_Ptr_FastLineDetector_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_FastLineDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_FastLineDetector_delete(
    cv::Ptr&amp;lt;cv::ximgproc::FastLineDetector&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_FastLineDetector

%index
ximgproc_Ptr_FastLineDetector_get
[32/64bit] cv::ximgproc::FastLineDetector のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
136]に記載されているFLD(Fast Line Detector)アルゴリズムを実装したクラス。

#include <iostream>#include "opencv2/imgproc.hpp "#include "opencv2/ximgproc.hpp "#include "opencv2/imgcodecs.hpp "#include "opencv2/highgui.hpp "using namespace std;using namespace cv;using namespace cv::ximgproc;int main(int argc, char** argv){ string in; CommandLineParser parser(argc, argv, "{@input|corridor.jpg|input image}{help h||show help message}"); if (parser.has("help")) { parser.printMessage(); return 0; } in = samples::findFile(parser.get<string>("@input")); Mat image = imread(in, IMREAD_GRAYSCALE); if( image.empty() )    { return -1; }.    // FLD 検出器の作成 // Param Default value Description // length_threshold 10 - これよりも短いセグメントは破棄されます // distance_threshold 1.41421356 - 仮説線から // これよりも遠いセグメントに置かれた点は // 外れ値とみなされる // canny_th1 50 - Canny() のヒステリシス処理のための // 第 1 の閾値 // canny_th2 50 - Canny() のヒステリシス処理のための // 第 2 の閾値 // canny_aperture_size 3 - Canny() の sobel 演算子のための開口サイズ．    // 0の場合，Canny()は適用されず，入力画像は // エッジ画像として扱われます．    // do_merge false - true の場合，セグメントのインクリメンタルなマージが // 行われます int length_threshold = 10; float distance_threshold = 1.41421356f; double canny_th1 = 50.0; double canny_th2 = 50.0; int canny_aperture_size = 3; bool do_merge = false; Ptr<FastLineDetector> fld = createFastLineDetector(length_threshold, distance_threshold, canny_th1, canny_th2, canny_aperture_size, do_merge); vector<Vec4f> lines; // CPUのパワーストラテジーによっては、アルゴリズムの最初の実行に時間がかかることがあるようです。for (int run_count = 0; run_count < 5; run_count++) { double freq = getTickFrequency(); lines.clear(); int64 start = getTickCount(); // FLDでラインを検出 fld->detect(image, lines); double duration_ms = double(getTickCount() - start) * 1000 / freq; cout << "FLDの経過時間 " << duration_ms << " ms.".<< endl; }。    // FLD で見つかった線を表示する Mat line_image_fld(image); fld->drawSegments(line_image_fld, lines); imshow("FLD result", line_image_fld); waitKey(1); Ptr<EdgeDrawing> ed = createEdgeDrawing(); ed->params.ed->params.EdgeDetectionOperator = EdgeDrawing::SOBEL; ed->params.GradientThresholdValue = 38; ed->params.AnchorThresholdValue = 8; vector<Vec6d> ellipses; for (int run_count = 0; run_count < 5; run_count++) { double freq = getTickFrequency(); lines.clear(); int64 start = getTickCount(); // エッジを検出する // detectLines() と detectEllipses() の前に呼び出す必要がある ed->detectEdges(image); // ラインを検出する ed->detectLines(lines); double duration_ms = double(getTickCount() - start) * 1000 / freq; cout << "EdgeDrawing の経過時間 detectLines " << duration_ms << " ms.".<< endl; start = getTickCount(); // 円と楕円の検出 ed->detectEllipses(ellipses); duration_ms = double(getTickCount() - start) * 1000 / freq; cout << "EdgeDrawing detectEllipsesの経過時間 " << duration_ms << " ms.".<< endl; }。    Mat edge_image_ed = Mat::zeros(image.size(), CV_8UC3); vector<vector<Point> > segments = ed->getSegments(); for (size_t i = 0; i < segments.size(); i++) { const Point* pts = &segments[i][0]; int n = (int)segments[i].size(); polylines(edge_image_ed, &pts, &n, 1, false, Scalar((rand() & 255), (rand() & 255), (rand() & 255), 1); } imshow("EdgeDrawing detected edges", edge_image_ed); Mat line_image_ed(image); fld->drawSegments(line_image_ed, lines); // 円と楕円の描画 for (size_t i = 0; i < ellipses.size(); i++) { Point center((int)ellipses[i][0], (int)ellipses[i][1]);        Size axes((int)ellipses[i][2] + (int)ellipses[i][3], (int)ellipses[i][2] + (int)ellipses[i][4]); double angle(ellipses[i][5]); Scalar color = ellipses[i][2] == 0 ?Scalar(255, 255, 0) : Scalar(0, 255, 0); ellipse(line_image_ed, center, axes, angle, 0, 360, color, 2, LINE_AA); } imshow("EdgeDrawing result", line_image_ed); waitKey(); return 0;}。


元関数名(C#): ximgproc_Ptr_FastLineDetector_get
元DLLエクスポート名: ximgproc_Ptr_FastLineDetector_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_FastLineDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_FastLineDetector_get(
    cv::Ptr&amp;lt;cv::ximgproc::FastLineDetector&amp;gt; *ptr, cv::ximgproc::FastLineDetector **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_FastLineDetector

%index
ximgproc_FastLineDetector_detect_OutputArray
[32/64bit] 入力画像から線を見つけます。これは，上に示した画像にアルゴリズムのデフォルトパラメータを適用した場合の出力です．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = sptr : IntPtr lines
%inst
イメージ

元関数名(C#): ximgproc_FastLineDetector_detect_OutputArray
元DLLエクスポート名: ximgproc_FastLineDetector_detect_OutputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_FastLineDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_FastLineDetector_detect_OutputArray(
    cv::ximgproc::FastLineDetector *obj, cv::_InputArray *image, cv::_OutputArray *lines)
{
    BEGIN_WRAP
    obj-&amp;gt;detect(*image, *lines);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_FastLineDetector

%index
ximgproc_FastLineDetector_detect_vector
[32/64bit] 入力画像から線を見つけます。これは，上に示した画像にアルゴリズムのデフォルトパラメータを適用した場合の出力です．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = sptr : IntPtr lines
%inst
イメージ

元関数名(C#): ximgproc_FastLineDetector_detect_vector
元DLLエクスポート名: ximgproc_FastLineDetector_detect_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_FastLineDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_FastLineDetector_detect_vector(
    cv::ximgproc::FastLineDetector *obj, cv::_InputArray *image, std::vector&amp;lt;cv::Vec4f&amp;gt; *lines)
{
    BEGIN_WRAP
    obj-&amp;gt;detect(*image, *lines);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_FastLineDetector

%index
ximgproc_FastLineDetector_drawSegments_InputArray
[32/64bit] 与えられた画像上に線分を描画します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = sptr : IntPtr lines
p4 = int : int draw_arrow
%inst
元関数名(C#): ximgproc_FastLineDetector_drawSegments_InputArray
元DLLエクスポート名: ximgproc_FastLineDetector_drawSegments_InputArray
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_FastLineDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_FastLineDetector_drawSegments_InputArray(
    cv::ximgproc::FastLineDetector *obj, cv::_InputOutputArray *image, cv::_InputArray *lines, int draw_arrow)
{
    BEGIN_WRAP
    obj-&amp;gt;drawSegments(*image, *lines, draw_arrow != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_FastLineDetector

%index
ximgproc_FastLineDetector_drawSegments_vector
[32/64bit] 与えられた画像上に線分を描画します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = sptr : IntPtr lines
p4 = int : int draw_arrow
%inst
元関数名(C#): ximgproc_FastLineDetector_drawSegments_vector
元DLLエクスポート名: ximgproc_FastLineDetector_drawSegments_vector
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_FastLineDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_FastLineDetector_drawSegments_vector(
    cv::ximgproc::FastLineDetector *obj, cv::_InputOutputArray *image, std::vector&amp;lt;cv::Vec4f&amp;gt; *lines, int draw_arrow)
{
    BEGIN_WRAP
    obj-&amp;gt;drawSegments(*image, *lines, draw_arrow != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_FastLineDetector

%index
ximgproc_createFastLineDetector
[32/64bit] FastLineDetector オブジェクトへのスマート ポインタを作成し、それを初期化します。
%prm
p1,p2,p3,p4,p5,p6,p7
p1 = int : int length_threshold
p2 = float : float distance_threshold
p3 = double : double canny_th1
p4 = double : double canny_th2
p5 = int : int canny_aperture_size
p6 = int : int do_merge
p7 = var : out IntPtr returnValue
%inst
例：fld_lines.cpp.

元関数名(C#): ximgproc_createFastLineDetector
元DLLエクスポート名: ximgproc_createFastLineDetector
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_FastLineDetector.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_createFastLineDetector(
    int length_threshold, float distance_threshold, double canny_th1, double canny_th2, int canny_aperture_size, int do_merge,
    cv::Ptr&amp;lt;cv::ximgproc::FastLineDetector&amp;gt; **returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::ximgproc::createFastLineDetector(
        length_threshold, distance_threshold, canny_th1, canny_th2, canny_aperture_size, do_merge != 0);
    *returnValue = new cv::Ptr&amp;lt;cv::ximgproc::FastLineDetector&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_FastLineDetector

%index
ximgproc_RidgeDetectionFilter_create
[32/64bit] リッジ検出フィルタへのポインタを作成します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = int : int ddepth
p2 = int : int dx
p3 = int : int dy
p4 = int : int ksize
p5 = int : int out_dtype
p6 = double : double scale
p7 = double : double delta
p8 = int : int borderType
p9 = var : out IntPtr returnValue
%inst
Sobel, threshold, getStructuringElement, morphologyEx.も参照してください（さらなる改良のため）．

元関数名(C#): ximgproc_RidgeDetectionFilter_create
元DLLエクスポート名: ximgproc_RidgeDetectionFilter_create
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_RidgeDetectionFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_RidgeDetectionFilter_create(
    int ddepth, int dx, int dy, int ksize, int out_dtype, double scale, double delta, int borderType,
    cv::Ptr&amp;lt;cv::ximgproc::RidgeDetectionFilter&amp;gt; **returnValue)
{
    BEGIN_WRAP
    auto obj = cv::ximgproc::RidgeDetectionFilter::create(
        ddepth, dx, dy, ksize, out_dtype, scale, delta, borderType);
    *returnValue = clone(obj);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_RidgeDetectionFilter

%index
ximgproc_RidgeDetectionFilter_getRidgeFilteredImage
[32/64bit] リッジ検出フィルタを入力画像に適用します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr _img
p3 = sptr : IntPtr @out
%inst
元関数名(C#): ximgproc_RidgeDetectionFilter_getRidgeFilteredImage
元DLLエクスポート名: ximgproc_RidgeDetectionFilter_getRidgeFilteredImage
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_RidgeDetectionFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_RidgeDetectionFilter_getRidgeFilteredImage(
    cv::ximgproc::RidgeDetectionFilter *obj,
    cv::_InputArray *_img, cv::_OutputArray *out)
{
    BEGIN_WRAP
    obj-&amp;gt;getRidgeFilteredImage(*_img, *out);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_RidgeDetectionFilter

%index
ximgproc_Ptr_RidgeDetectionFilter_delete
[32/64bit] cv::ximgproc::RidgeDetectionFilter のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
Ridge Detection Filter を入力画像に適用します。入力画像のヘシアン行列の固有値を使った Mathematica と同様のリッジ検出を，Sobel 微分を使って実行します．スケルトン化や2値化を使って，さらに精密化することができます．66]および[165]より引用。


元関数名(C#): ximgproc_Ptr_RidgeDetectionFilter_delete
元DLLエクスポート名: ximgproc_Ptr_RidgeDetectionFilter_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_RidgeDetectionFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_RidgeDetectionFilter_delete(cv::Ptr&amp;lt;cv::ximgproc::RidgeDetectionFilter&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_RidgeDetectionFilter

%index
ximgproc_Ptr_RidgeDetectionFilter_get
[32/64bit] cv::ximgproc::RidgeDetectionFilter のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
Ridge Detection Filter を入力画像に適用します。入力画像のヘシアン行列の固有値を使った Mathematica と同様のリッジ検出を，Sobel 微分を使って実行します．スケルトン化や2値化を使って，さらに精密化することができます．66]および[165]より引用。


元関数名(C#): ximgproc_Ptr_RidgeDetectionFilter_get
元DLLエクスポート名: ximgproc_Ptr_RidgeDetectionFilter_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_RidgeDetectionFilter.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_RidgeDetectionFilter_get(cv::Ptr&amp;lt;cv::ximgproc::RidgeDetectionFilter&amp;gt; *ptr, cv::ximgproc::RidgeDetectionFilter **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_RidgeDetectionFilter

%index
ximgproc_seg_createGraphSegmentation
[32/64bit][関数名変更] グラフベースのセメンタを作成します。
%prm
p1,p2,p3,p4
p1 = double : double sigma
p2 = float : float k
p3 = int : int minSize
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): ximgproc_segmentation_createGraphSegmentation
元DLLエクスポート名: ximgproc_segmentation_createGraphSegmentation
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_createGraphSegmentation(
    double sigma, float k, int min_size, cv::Ptr&amp;lt;cv::ximgproc::segmentation::GraphSegmentation&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(cv::ximgproc::segmentation::createGraphSegmentation(sigma, k, min_size));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_Ptr_GraphSegmentation_delete
[32/64bit][関数名変更] cv::ximgproc::segmentation::GraphSegmentation のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
グラフベースのセグメンテーションアルゴリズム．このクラスは，[73]で述べられているアルゴリズムを実装しています．


元関数名(C#): ximgproc_segmentation_Ptr_GraphSegmentation_delete
元DLLエクスポート名: ximgproc_segmentation_Ptr_GraphSegmentation_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_Ptr_GraphSegmentation_delete(cv::Ptr&amp;lt;cv::ximgproc::segmentation::GraphSegmentation&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_Ptr_GraphSegmentation_get
[32/64bit][関数名変更] cv::ximgproc::segmentation::GraphSegmentation のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
グラフベースのセグメンテーションアルゴリズム．このクラスは，[73]で述べられているアルゴリズムを実装しています．


元関数名(C#): ximgproc_segmentation_Ptr_GraphSegmentation_get
元DLLエクスポート名: ximgproc_segmentation_Ptr_GraphSegmentation_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_Ptr_GraphSegmentation_get(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::GraphSegmentation&amp;gt; *ptr, 
    cv::ximgproc::segmentation::GraphSegmentation **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_GraphSegmentation_processImage
[32/64bit][関数名変更] 画像を分割し，その出力を dst に格納します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
%inst
元関数名(C#): ximgproc_segmentation_GraphSegmentation_processImage
元DLLエクスポート名: ximgproc_segmentation_GraphSegmentation_processImage
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_GraphSegmentation_processImage(cv::ximgproc::segmentation::GraphSegmentation *obj, cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    obj-&amp;gt;processImage(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_GraphSegmentation_setSigma
[32/64bit][関数名変更] ximgproc_seg_GraphSegmentation_setSigma
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = double : double value
%inst
元関数名(C#): ximgproc_segmentation_GraphSegmentation_setSigma
元DLLエクスポート名: ximgproc_segmentation_GraphSegmentation_setSigma
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_GraphSegmentation_setSigma(cv::ximgproc::segmentation::GraphSegmentation *obj, double value)
{
    BEGIN_WRAP
    obj-&amp;gt;setSigma(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_GraphSegmentation_getSigma
[32/64bit][関数名変更] ximgproc_seg_GraphSegmentation_getSigma
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out double returnValue
%inst
元関数名(C#): ximgproc_segmentation_GraphSegmentation_getSigma
元DLLエクスポート名: ximgproc_segmentation_GraphSegmentation_getSigma
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_GraphSegmentation_getSigma(cv::ximgproc::segmentation::GraphSegmentation *obj, double *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getSigma();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_GraphSegmentation_setK
[32/64bit][関数名変更] ximgproc_seg_GraphSegmentation_setK
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = float : float value
%inst
元関数名(C#): ximgproc_segmentation_GraphSegmentation_setK
元DLLエクスポート名: ximgproc_segmentation_GraphSegmentation_setK
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_GraphSegmentation_setK(cv::ximgproc::segmentation::GraphSegmentation *obj, float value)
{
    BEGIN_WRAP
    obj-&amp;gt;setK(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_GraphSegmentation_getK
[32/64bit][関数名変更] ximgproc_seg_GraphSegmentation_getK
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out float returnValue
%inst
元関数名(C#): ximgproc_segmentation_GraphSegmentation_getK
元DLLエクスポート名: ximgproc_segmentation_GraphSegmentation_getK
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_GraphSegmentation_getK(cv::ximgproc::segmentation::GraphSegmentation *obj, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getK();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_GraphSegmentation_setMinSize
[32/64bit][関数名変更] ximgproc_seg_GraphSegmentation_setMinSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int value
%inst
元関数名(C#): ximgproc_segmentation_GraphSegmentation_setMinSize
元DLLエクスポート名: ximgproc_segmentation_GraphSegmentation_setMinSize
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_GraphSegmentation_setMinSize(cv::ximgproc::segmentation::GraphSegmentation *obj, int value)
{
    BEGIN_WRAP
    obj-&amp;gt;setMinSize(value);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_GraphSegmentation_getMinSize
[32/64bit][関数名変更] ximgproc_seg_GraphSegmentation_getMinSize
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ximgproc_segmentation_GraphSegmentation_getMinSize
元DLLエクスポート名: ximgproc_segmentation_GraphSegmentation_getMinSize
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_GraphSegmentation_getMinSize(cv::ximgproc::segmentation::GraphSegmentation *obj, int *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getMinSize();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_SeleSchSegStrat_setImage
[32/64bit][関数名変更] セグメンテーションされた初期画像をセットします．
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr img
p3 = sptr : IntPtr regions
p4 = sptr : IntPtr sizes
p5 = int : int image_id
%inst
元関数名(C#): ximgproc_segmentation_SelectiveSearchSegmentationStrategy_setImage
元DLLエクスポート名: ximgproc_segmentation_SelectiveSearchSegmentationStrategy_setImage
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_SelectiveSearchSegmentationStrategy_setImage(
    cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy *obj, cv::_InputArray *img, cv::_InputArray *regions, cv::_InputArray *sizes, int image_id)
{
    BEGIN_WRAP
    obj-&amp;gt;setImage(*img, *regions, *sizes, image_id);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_SeleSchSegStrat_get
[32/64bit][関数名変更] 2つのリージョン間のスコア（0?1）を返す
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = int : int r1
p3 = int : int r2
p4 = var : out float returnValue
%inst
元関数名(C#): ximgproc_segmentation_SelectiveSearchSegmentationStrategy_get
元DLLエクスポート名: ximgproc_segmentation_SelectiveSearchSegmentationStrategy_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_SelectiveSearchSegmentationStrategy_get(
    cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy *obj, int r1, int r2, float *returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;get(r1, r2);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_SeleSchSegStrat_merge
[32/64bit][関数名変更] 2つのリージョンが統合されることをストラテジーに伝えます。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = int : int r1
p3 = int : int r2
%inst
元関数名(C#): ximgproc_segmentation_SelectiveSearchSegmentationStrategy_merge
元DLLエクスポート名: ximgproc_segmentation_SelectiveSearchSegmentationStrategy_merge
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_SelectiveSearchSegmentationStrategy_merge(
    cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy *obj, int r1, int r2)
{
    BEGIN_WRAP
    obj-&amp;gt;merge(r1, r2);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_createSeleSchSegStratColor
[32/64bit][関数名変更] 新しい色ベースの戦略を作る。
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): ximgproc_segmentation_createSelectiveSearchSegmentationStrategyColor
元DLLエクスポート名: ximgproc_segmentation_createSelectiveSearchSegmentationStrategyColor
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_createSelectiveSearchSegmentationStrategyColor(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyColor&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyColor());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_createSeleSchSegStratSize
[32/64bit][関数名変更] サイズベースのストラテジーを作成します。
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): ximgproc_segmentation_createSelectiveSearchSegmentationStrategySize
元DLLエクスポート名: ximgproc_segmentation_createSelectiveSearchSegmentationStrategySize
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_createSelectiveSearchSegmentationStrategySize(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategySize&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategySize());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_createSeleSchSegStratTexture
[32/64bit][関数名変更] サイズベースのストラテジーを作成します。
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): ximgproc_segmentation_createSelectiveSearchSegmentationStrategyTexture
元DLLエクスポート名: ximgproc_segmentation_createSelectiveSearchSegmentationStrategyTexture
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_createSelectiveSearchSegmentationStrategyTexture(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyTexture&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyTexture());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_createSeleSchSegStratFill
[32/64bit][関数名変更] 塗り潰しストラテジーを新規に作成します。
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): ximgproc_segmentation_createSelectiveSearchSegmentationStrategyFill
元DLLエクスポート名: ximgproc_segmentation_createSelectiveSearchSegmentationStrategyFill
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_createSelectiveSearchSegmentationStrategyFill(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyFill&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyFill());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_Ptr_SeleSchSegStratColor_delete
[32/64bit][関数名変更] cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyColor のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
選択的探索セグメンテーションアルゴリズムのためのカラーベースストラテジー このクラスは、[252]に記載されているアルゴリズムから実装されています。


元関数名(C#): ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyColor_delete
元DLLエクスポート名: ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyColor_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyColor_delete(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyColor&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_Ptr_SeleSchSegStratSize_delete
[32/64bit][関数名変更] cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategySize のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
サイズベース戦略 選択的検索セグメンテーションアルゴリズムのためのサイズベース戦略 このクラスは、[252]で説明されているアルゴリズムから実装されています。


元関数名(C#): ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategySize_delete
元DLLエクスポート名: ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategySize_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategySize_delete(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategySize&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_Ptr_SeleSchSegStratTexture_delete
[32/64bit][関数名変更] cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyTexture のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
このクラスは、[252]で説明したアルゴリズムから実装されています。


元関数名(C#): ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyTexture_delete
元DLLエクスポート名: ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyTexture_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyTexture_delete(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyTexture&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_Ptr_SeleSchSegStratFill_delete
[32/64bit][関数名変更] cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyFill のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
選択的検索セグメンテーションアルゴリズムのためのフィルベースの戦略 このクラスは、[252]で説明したアルゴリズムから実装されています。


元関数名(C#): ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyFill_delete
元DLLエクスポート名: ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyFill_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyFill_delete(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyFill&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_Ptr_SeleSchSegStratColor_get
[32/64bit][関数名変更] cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyColor のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
選択的探索セグメンテーションアルゴリズムのためのカラーベースストラテジー このクラスは、[252]に記載されているアルゴリズムから実装されています。


元関数名(C#): ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyColor_get
元DLLエクスポート名: ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyColor_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyColor_get(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyColor&amp;gt; *ptr, 
    cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyColor **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_Ptr_SeleSchSegStratSize_get
[32/64bit][関数名変更] cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategySize のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
サイズベース戦略 選択的検索セグメンテーションアルゴリズムのためのサイズベース戦略 このクラスは、[252]で説明されているアルゴリズムから実装されています。


元関数名(C#): ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategySize_get
元DLLエクスポート名: ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategySize_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategySize_get(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategySize&amp;gt; *ptr, 
    cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategySize **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_Ptr_SeleSchSegStratTexture_get
[32/64bit][関数名変更] cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyTexture のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
このクラスは、[252]で説明したアルゴリズムから実装されています。


元関数名(C#): ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyTexture_get
元DLLエクスポート名: ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyTexture_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyTexture_get(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyTexture&amp;gt; *ptr, 
    cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyTexture **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_Ptr_SeleSchSegStratFill_get
[32/64bit][関数名変更] cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyFill のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
選択的検索セグメンテーションアルゴリズムのためのフィルベースの戦略 このクラスは、[252]で説明したアルゴリズムから実装されています。


元関数名(C#): ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyFill_get
元DLLエクスポート名: ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyFill_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyFill_get(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyFill&amp;gt; *ptr, 
    cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyFill **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_SeleSchSegStratMultiple_addStrategy
[32/64bit][関数名変更] 新しいサブストラテジーを追加します。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr g
p3 = float : float weight
%inst
元関数名(C#): ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_addStrategy
元DLLエクスポート名: ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_addStrategy
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_addStrategy(
    cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple *obj, cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&amp;gt; *g, float weight)
{
    BEGIN_WRAP
    obj-&amp;gt;addStrategy(*g, weight);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_SeleSchSegStratMultiple_clearStrategies
[32/64bit][関数名変更] すべてのサブストラテジーを削除する。
%prm
p1
p1 = sptr : IntPtr obj
%inst
元関数名(C#): ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_clearStrategies
元DLLエクスポート名: ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_clearStrategies
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_clearStrategies(cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;clearStrategies();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_createSeleSchSegStratMultiple0
[32/64bit][関数名変更] 新しい多重戦略を作成し、サブ戦略を1つ設定する。
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple0
元DLLエクスポート名: ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple0
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple0(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_createSeleSchSegStratMultiple1
[32/64bit][関数名変更] 選択的探索セグメンテーションアルゴリズムのために、複数のストラテジーを再編成する。
%prm
p1,p2
p1 = sptr : IntPtr s1
p2 = var : out IntPtr returnValue
%inst
元関数名(C#): ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple1
元DLLエクスポート名: ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple1
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple1(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&amp;gt; *s1, 
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(createSelectiveSearchSegmentationStrategyMultiple(*s1));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_createSeleSchSegStratMultiple2
[32/64bit][関数名変更] 選択的探索セグメンテーションアルゴリズムのために、複数のストラテジーを再編成する。
%prm
p1,p2,p3
p1 = sptr : IntPtr s1
p2 = sptr : IntPtr s2
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple2
元DLLエクスポート名: ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple2
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple2(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&amp;gt; *s1, 
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&amp;gt; *s2, 
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(createSelectiveSearchSegmentationStrategyMultiple(*s1, *s2));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_createSeleSchSegStratMultiple3
[32/64bit][関数名変更] 新しいマルチ戦略を作成し、3つのサブ戦略を同じ重みで設定する。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr s1
p2 = sptr : IntPtr s2
p3 = sptr : IntPtr s3
p4 = var : out IntPtr returnValue
%inst
元関数名(C#): ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple3
元DLLエクスポート名: ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple3
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple3(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&amp;gt; *s1,
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&amp;gt; *s2,
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&amp;gt; *s3, 
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple(*s1, *s2, *s3));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_createSeleSchSegStratMultiple4
[32/64bit][関数名変更] 新規に複数のストラテジーを作成し、4つのサブストラテジーを均等なウェイトで設定します。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr s1
p2 = sptr : IntPtr s2
p3 = sptr : IntPtr s3
p4 = sptr : IntPtr s4
p5 = var : out IntPtr returnValue
%inst
元関数名(C#): ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple4
元DLLエクスポート名: ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple4
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple4(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&amp;gt; *s1,
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&amp;gt; *s2, 
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&amp;gt; *s3, 
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&amp;gt; *s4, 
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple(*s1, *s2, *s3, *s4));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_Ptr_SeleSchSegStratMultiple_delete
[32/64bit][関数名変更] cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
選択的探索セグメンテーションアルゴリズムのために、複数のストラテジーを再編成する。


元関数名(C#): ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyMultiple_delete
元DLLエクスポート名: ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyMultiple_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyMultiple_delete(cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_Ptr_SeleSchSegStratMultiple_get
[32/64bit][関数名変更] cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
選択的探索セグメンテーションアルゴリズムのために、複数のストラテジーを再編成する。


元関数名(C#): ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyMultiple_get
元DLLエクスポート名: ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyMultiple_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_Ptr_SelectiveSearchSegmentationStrategyMultiple_get(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple&amp;gt; *ptr, 
    cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_SeleSchSeg_setBaseImage
[32/64bit][関数名変更] switch*関数がクラスを初期化する際に使用するイメージを設定します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr img
%inst
元関数名(C#): ximgproc_segmentation_SelectiveSearchSegmentation_setBaseImage
元DLLエクスポート名: ximgproc_segmentation_SelectiveSearchSegmentation_setBaseImage
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_SelectiveSearchSegmentation_setBaseImage(
    cv::ximgproc::segmentation::SelectiveSearchSegmentation *obj, cv::_InputArray *img)
{
    BEGIN_WRAP
    obj-&amp;gt;setBaseImage(*img);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_SeleSchSeg_switchToSingleStrategy
[32/64bit][関数名変更] 252]で説明した「Single stragegy」パラメータでクラスを初期化する。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = int : int k
p3 = float : float sigma
%inst
元関数名(C#): ximgproc_segmentation_SelectiveSearchSegmentation_switchToSingleStrategy
元DLLエクスポート名: ximgproc_segmentation_SelectiveSearchSegmentation_switchToSingleStrategy
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_SelectiveSearchSegmentation_switchToSingleStrategy(
    cv::ximgproc::segmentation::SelectiveSearchSegmentation *obj, int k, float sigma)
{
    BEGIN_WRAP
    obj-&amp;gt;switchToSingleStrategy(k, sigma);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_SeleSchSeg_switchToSelectiveSearchFast
[32/64bit][関数名変更] 252]で述べた「Selective search fast」パラメータでクラスを初期化します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = int : int base_k
p3 = int : int inc_k
p4 = float : float sigma
%inst
元関数名(C#): ximgproc_segmentation_SelectiveSearchSegmentation_switchToSelectiveSearchFast
元DLLエクスポート名: ximgproc_segmentation_SelectiveSearchSegmentation_switchToSelectiveSearchFast
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_SelectiveSearchSegmentation_switchToSelectiveSearchFast(
    cv::ximgproc::segmentation::SelectiveSearchSegmentation *obj, int base_k, int inc_k, float sigma)
{
    BEGIN_WRAP
    obj-&amp;gt;switchToSelectiveSearchFast(base_k, inc_k, sigma);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_SeleSchSeg_switchToSelectiveSearchQuality
[32/64bit][関数名変更] 252]で述べた「Selective search fast」パラメータでクラスを初期化します。
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr obj
p2 = int : int base_k
p3 = int : int inc_k
p4 = float : float sigma
%inst
元関数名(C#): ximgproc_segmentation_SelectiveSearchSegmentation_switchToSelectiveSearchQuality
元DLLエクスポート名: ximgproc_segmentation_SelectiveSearchSegmentation_switchToSelectiveSearchQuality
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_SelectiveSearchSegmentation_switchToSelectiveSearchQuality(
    cv::ximgproc::segmentation::SelectiveSearchSegmentation *obj, int base_k, int inc_k, float sigma) 
{
    BEGIN_WRAP
    obj-&amp;gt;switchToSelectiveSearchQuality(base_k, inc_k, sigma);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_SeleSchSeg_addImage
[32/64bit][関数名変更] 処理する画像のリストに新しい画像を追加します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr img
%inst
元関数名(C#): ximgproc_segmentation_SelectiveSearchSegmentation_addImage
元DLLエクスポート名: ximgproc_segmentation_SelectiveSearchSegmentation_addImage
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_SelectiveSearchSegmentation_addImage(cv::ximgproc::segmentation::SelectiveSearchSegmentation *obj, cv::_InputArray *img)
{
    BEGIN_WRAP
    obj-&amp;gt;addImage(*img);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_SeleSchSeg_clearImages
[32/64bit][関数名変更] 処理する画像のリストを消去します。
%prm
p1
p1 = sptr : IntPtr obj
%inst
元関数名(C#): ximgproc_segmentation_SelectiveSearchSegmentation_clearImages
元DLLエクスポート名: ximgproc_segmentation_SelectiveSearchSegmentation_clearImages
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_SelectiveSearchSegmentation_clearImages(cv::ximgproc::segmentation::SelectiveSearchSegmentation *obj)
{
    BEGIN_WRAP
    obj-&amp;gt;clearImages();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_SeleSchSeg_addGraphSegmentation
[32/64bit][関数名変更] 処理するグラフセグメンテーションのリストに新しいグラフセグメンテーションを追加します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr g
%inst
元関数名(C#): ximgproc_segmentation_SelectiveSearchSegmentation_addGraphSegmentation
元DLLエクスポート名: ximgproc_segmentation_SelectiveSearchSegmentation_addGraphSegmentation
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_SelectiveSearchSegmentation_addGraphSegmentation(
    cv::ximgproc::segmentation::SelectiveSearchSegmentation *obj, cv::Ptr&amp;lt;cv::ximgproc::segmentation::GraphSegmentation&amp;gt; *g)
{
    BEGIN_WRAP
    obj-&amp;gt;addGraphSegmentation(*g);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_SeleSchSeg_clearGraphSegmentations
[32/64bit][関数名変更] 処理するグラフセグメンテーションのリストを消去する；。
%prm
p1
p1 = sptr : IntPtr obj
%inst
元関数名(C#): ximgproc_segmentation_SelectiveSearchSegmentation_clearGraphSegmentations
元DLLエクスポート名: ximgproc_segmentation_SelectiveSearchSegmentation_clearGraphSegmentations
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_SelectiveSearchSegmentation_clearGraphSegmentations(cv::ximgproc::segmentation::SelectiveSearchSegmentation *obj) 
{
    BEGIN_WRAP
    obj-&amp;gt;clearGraphSegmentations();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_SeleSchSeg_addStrategy
[32/64bit][関数名変更] 処理するストラテジのリストに新しいストラテジを追加する。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr s
%inst
元関数名(C#): ximgproc_segmentation_SelectiveSearchSegmentation_addStrategy
元DLLエクスポート名: ximgproc_segmentation_SelectiveSearchSegmentation_addStrategy
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_SelectiveSearchSegmentation_addStrategy(
    cv::ximgproc::segmentation::SelectiveSearchSegmentation *obj, cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&amp;gt; *s)
{
    BEGIN_WRAP
    obj-&amp;gt;addStrategy(*s);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_SeleSchSeg_clearStrategies
[32/64bit][関数名変更] 処理するストラテジーのリストを消去する；。
%prm
p1
p1 = sptr : IntPtr obj
%inst
元関数名(C#): ximgproc_segmentation_SelectiveSearchSegmentation_clearStrategies
元DLLエクスポート名: ximgproc_segmentation_SelectiveSearchSegmentation_clearStrategies
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_SelectiveSearchSegmentation_clearStrategies(
    cv::ximgproc::segmentation::SelectiveSearchSegmentation *obj) 
{
    BEGIN_WRAP
    obj-&amp;gt;clearStrategies();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_SeleSchSeg_process
[32/64bit][関数名変更] 全ての画像、グラフ分割、stragies に基づいて、可能な全ての rects を計算し、それらを返す。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr rects
%inst
元関数名(C#): ximgproc_segmentation_SelectiveSearchSegmentation_process
元DLLエクスポート名: ximgproc_segmentation_SelectiveSearchSegmentation_process
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_SelectiveSearchSegmentation_process(
    cv::ximgproc::segmentation::SelectiveSearchSegmentation *obj, std::vector&amp;lt;cv::Rect&amp;gt; *rects) 
{
    BEGIN_WRAP
    obj-&amp;gt;process(*rects);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_createSeleSchSeg
[32/64bit][関数名変更] 新しい色ベースの戦略を作る。
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): ximgproc_segmentation_createSelectiveSearchSegmentation
元DLLエクスポート名: ximgproc_segmentation_createSelectiveSearchSegmentation
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_createSelectiveSearchSegmentationStrategyColor(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyColor&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyColor());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_Ptr_SeleSchSeg_delete
[32/64bit][関数名変更] cv::ximgproc::segmentation::SelectiveSearchSegmentation のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
選択的探索セグメンテーションアルゴリズム このクラスは，[252]で述べられているアルゴリズムを実装しています．


元関数名(C#): ximgproc_segmentation_Ptr_SelectiveSearchSegmentation_delete
元DLLエクスポート名: ximgproc_segmentation_Ptr_SelectiveSearchSegmentation_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_Ptr_SelectiveSearchSegmentation_delete(cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentation&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_seg_Ptr_SeleSchSeg_get
[32/64bit][関数名変更] cv::ximgproc::segmentation::SelectiveSearchSegmentation のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
選択的探索セグメンテーションアルゴリズム このクラスは，[252]で述べられているアルゴリズムを実装しています．


元関数名(C#): ximgproc_segmentation_Ptr_SelectiveSearchSegmentation_get
元DLLエクスポート名: ximgproc_segmentation_Ptr_SelectiveSearchSegmentation_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Segmentation.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_segmentation_Ptr_SelectiveSearchSegmentation_get(
    cv::Ptr&amp;lt;cv::ximgproc::segmentation::SelectiveSearchSegmentation&amp;gt; *ptr, cv::ximgproc::segmentation::SelectiveSearchSegmentation **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Segmentation

%index
ximgproc_createRFFeatureGetter
[32/64bit] ximgproc_createRFFeatureGetter
%prm
p1
p1 = var : out IntPtr returnValue
%inst
元関数名(C#): ximgproc_createRFFeatureGetter
元DLLエクスポート名: ximgproc_createRFFeatureGetter
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_StructuredEdgeDetection.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_createRFFeatureGetter(cv::Ptr&amp;lt;cv::ximgproc::RFFeatureGetter&amp;gt; **returnValue)
{
    BEGIN_WRAP
    *returnValue = clone(cv::ximgproc::createRFFeatureGetter());
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_StructuredEdgeDetection

%index
ximgproc_Ptr_RFFeatureGetter_delete
[32/64bit] cv::ximgproc::RFFeatureGetter のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
P. Dollar and C. L. Zitit] の学習部分のヘルパークラスです．Dollar and C. L. Zitnick.Structured Forests for Fast Edge Detection, 2013] のトレーニング部分のヘルパークラスです．


元関数名(C#): ximgproc_Ptr_RFFeatureGetter_delete
元DLLエクスポート名: ximgproc_Ptr_RFFeatureGetter_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_StructuredEdgeDetection.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_RFFeatureGetter_delete(cv::Ptr&amp;lt;cv::ximgproc::RFFeatureGetter&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_StructuredEdgeDetection

%index
ximgproc_Ptr_RFFeatureGetter_get
[32/64bit] cv::ximgproc::RFFeatureGetter のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
P. Dollar and C. L. Zitit] の学習部分のヘルパークラスです．Dollar and C. L. Zitnick.Structured Forests for Fast Edge Detection, 2013] のトレーニング部分のヘルパークラスです．


元関数名(C#): ximgproc_Ptr_RFFeatureGetter_get
元DLLエクスポート名: ximgproc_Ptr_RFFeatureGetter_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_StructuredEdgeDetection.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_RFFeatureGetter_get(cv::Ptr&amp;lt;cv::ximgproc::RFFeatureGetter&amp;gt; *ptr, cv::ximgproc::RFFeatureGetter **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_StructuredEdgeDetection

%index
ximgproc_RFFeatureGetter_getFeatures
[32/64bit] この関数は，srcから特徴チャンネルを抽出します．StructureEdgeDetection は，この特徴空間を利用してエッジを検出します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr src
p3 = sptr : IntPtr features
p4 = int : int gnrmRad
p5 = int : int gsmthRad
p6 = int : int shrink
p7 = int : int outNum
p8 = int : int gradNum
%inst
元関数名(C#): ximgproc_RFFeatureGetter_getFeatures
元DLLエクスポート名: ximgproc_RFFeatureGetter_getFeatures
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_StructuredEdgeDetection.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_RFFeatureGetter_getFeatures(
    cv::ximgproc::RFFeatureGetter *obj, cv::Mat *src, cv::Mat *features,
    const int gnrmRad, const int gsmthRad, const int shrink, const int outNum, const int gradNum)
{
    BEGIN_WRAP
    obj-&amp;gt;getFeatures(*src, *features, gnrmRad, gsmthRad, shrink, outNum, gradNum);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_StructuredEdgeDetection

%index
ximgproc_createStructuredEdgeDetection
[32/64bit] 唯一のコンストラクタ
%prm
p1,p2,p3
p1 = str : [MarshalAs(UnmanagedType.LPStr)] string model
p2 = sptr : IntPtr howToGetFeatures
p3 = var : out IntPtr returnValue
%inst
元関数名(C#): ximgproc_createStructuredEdgeDetection
元DLLエクスポート名: ximgproc_createStructuredEdgeDetection
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_StructuredEdgeDetection.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_createStructuredEdgeDetection(
    const char *model, cv::Ptr&amp;lt;cv::ximgproc::RFFeatureGetter&amp;gt; *howToGetFeatures, cv::Ptr&amp;lt;cv::ximgproc::StructuredEdgeDetection&amp;gt; **returnValue)
{
    BEGIN_WRAP
    if (howToGetFeatures == nullptr)
        *returnValue = clone(cv::ximgproc::createStructuredEdgeDetection(model));
    else
        *returnValue = clone(cv::ximgproc::createStructuredEdgeDetection(model, *howToGetFeatures));
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_StructuredEdgeDetection

%index
ximgproc_Ptr_StructuredEdgeDetection_delete
[32/64bit] cv::ximgproc::StructuredEdgeDetection のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
57]のエッジ検出アルゴリズムを実装したクラス．


元関数名(C#): ximgproc_Ptr_StructuredEdgeDetection_delete
元DLLエクスポート名: ximgproc_Ptr_StructuredEdgeDetection_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_StructuredEdgeDetection.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_StructuredEdgeDetection_delete(cv::Ptr&amp;lt;cv::ximgproc::StructuredEdgeDetection&amp;gt; *obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_StructuredEdgeDetection

%index
ximgproc_Ptr_StructuredEdgeDetection_get
[32/64bit] cv::ximgproc::StructuredEdgeDetection のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
57]のエッジ検出アルゴリズムを実装したクラス．


元関数名(C#): ximgproc_Ptr_StructuredEdgeDetection_get
元DLLエクスポート名: ximgproc_Ptr_StructuredEdgeDetection_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_StructuredEdgeDetection.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_StructuredEdgeDetection_get(cv::Ptr&amp;lt;cv::ximgproc::StructuredEdgeDetection&amp;gt; *ptr, cv::ximgproc::StructuredEdgeDetection **returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_StructuredEdgeDetection

%index
ximgproc_StructuredEdgeDetection_detectEdges
[32/64bit] この関数は，srcからエッジを検出し，それをdstに描画します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
%inst
この関数を支えるアルゴリズムは，例えば Sobel などの一般的な手法よりも，テクスチャの存在に対してより頑健です．

元関数名(C#): ximgproc_StructuredEdgeDetection_detectEdges
元DLLエクスポート名: ximgproc_StructuredEdgeDetection_detectEdges
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_StructuredEdgeDetection.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_StructuredEdgeDetection_detectEdges(cv::ximgproc::StructuredEdgeDetection *obj, cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    obj-&amp;gt;detectEdges(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_StructuredEdgeDetection

%index
ximgproc_StructuredEdgeDetection_computeOrientation
[32/64bit] この関数は，エッジ画像から向きを求めます．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr src
p3 = sptr : IntPtr dst
%inst
元関数名(C#): ximgproc_StructuredEdgeDetection_computeOrientation
元DLLエクスポート名: ximgproc_StructuredEdgeDetection_computeOrientation
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_StructuredEdgeDetection.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_StructuredEdgeDetection_computeOrientation(cv::ximgproc::StructuredEdgeDetection *obj, cv::_InputArray *src, cv::_OutputArray *dst)
{
    BEGIN_WRAP
    obj-&amp;gt;computeOrientation(*src, *dst);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_StructuredEdgeDetection

%index
ximgproc_StructuredEdgeDetection_edgesNms
[32/64bit] この関数は，エッジ画像中のエッジを検出し，直交する方向に強いエッジを抑制します．
%prm
p1,p2,p3,p4,p5,p6,p7,p8
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr edge_image
p3 = sptr : IntPtr orientation_image
p4 = sptr : IntPtr dst
p5 = int : int r
p6 = int : int s
p7 = float : float m
p8 = int : int isParallel
%inst
元関数名(C#): ximgproc_StructuredEdgeDetection_edgesNms
元DLLエクスポート名: ximgproc_StructuredEdgeDetection_edgesNms
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_StructuredEdgeDetection.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_StructuredEdgeDetection_edgesNms(cv::ximgproc::StructuredEdgeDetection *obj,
    cv::_InputArray *edge_image, cv::_InputArray *orientation_image, cv::_OutputArray *dst, 
    int r, int s, float m, int isParallel)
{
    BEGIN_WRAP
    obj-&amp;gt;edgesNms(*edge_image, *orientation_image, *dst, r, s, m, isParallel != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_StructuredEdgeDetection

%index
ximgproc_Ptr_SuperpixelLSC_delete
[32/64bit] cv::ximgproc::SuperpixelLSC のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
141]で述べられているLSC (Linear Spectral Clustering) スーパーピクセルアルゴリズムを実装したクラスです．

LSC (Linear Spectral Clustering) は，コンパクトで均一なスーパーピクセルを低い計算コストで生成します．基本的には、画像ピクセル間の色の類似性と空間の近接性を測定する類似性メトリックに基づいて、スーパーピクセルのセグメンテーションの正規化されたカットの定式化が採用されます。LSCは直線的な計算量と高いメモリ効率を持ち、画像の大域的な特性を保持することができます。


元関数名(C#): ximgproc_Ptr_SuperpixelLSC_delete
元DLLエクスポート名: ximgproc_Ptr_SuperpixelLSC_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_SuperpixelLSC_delete(
    cv::Ptr&amp;lt;cv::ximgproc::SuperpixelLSC&amp;gt;* obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_Ptr_SuperpixelLSC_get
[32/64bit] cv::ximgproc::SuperpixelLSC のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
141]で述べられているLSC (Linear Spectral Clustering) スーパーピクセルアルゴリズムを実装したクラスです．

LSC (Linear Spectral Clustering) は，コンパクトで均一なスーパーピクセルを低い計算コストで生成します．基本的には、画像ピクセル間の色の類似性と空間の近接性を測定する類似性メトリックに基づいて、スーパーピクセルのセグメンテーションの正規化されたカットの定式化が採用されます。LSCは直線的な計算量と高いメモリ効率を持ち、画像の大域的な特性を保持することができます。


元関数名(C#): ximgproc_Ptr_SuperpixelLSC_get
元DLLエクスポート名: ximgproc_Ptr_SuperpixelLSC_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_SuperpixelLSC_get(
    cv::Ptr&amp;lt;cv::ximgproc::SuperpixelLSC&amp;gt;* ptr, cv::ximgproc::SuperpixelLSC** returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_SuperpixelLSC_getNumberOfSuperpixels
[32/64bit] SuperpixelLSCオブジェクトに格納された、与えられたセグメンテーション上の実際のスーパーピクセルの量を計算します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ximgproc_SuperpixelLSC_getNumberOfSuperpixels
元DLLエクスポート名: ximgproc_SuperpixelLSC_getNumberOfSuperpixels
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_SuperpixelLSC_getNumberOfSuperpixels(
    cv::ximgproc::SuperpixelLSC* obj,
    int* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getNumberOfSuperpixels();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_SuperpixelLSC_iterate
[32/64bit] SuperpixelLSC オブジェクトに初期化されたパラメータを用いて、与えられた画像上のスーパーピクセル・セグメンテーションを計算します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int num_iterations
%inst
この関数は，createSuperpixelLSC()でアルゴリズムを初期化することなく，再度呼び出すことができます．この関数は，関数 createSuperpixelLSC() で初期化されたパラメータを用いて，画像のスーパープリントセグメンテーションを計算します．このアルゴリズムは，スーパーピクセルのグリッドから始まり，エッジの境界の更新を提案することで，その境界を精密化します．

元関数名(C#): ximgproc_SuperpixelLSC_iterate
元DLLエクスポート名: ximgproc_SuperpixelLSC_iterate
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_SuperpixelLSC_iterate(
    cv::ximgproc::SuperpixelLSC* obj, int num_iterations)
{
    BEGIN_WRAP
    obj-&amp;gt;iterate(num_iterations);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_SuperpixelLSC_getLabels
[32/64bit] 画像のセグメンテーションラベリングを返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr labels_out
%inst
各ラベルはスーパーピクセルを表し，各ピクセルは1つのスーパーピクセルラベルに割り当てられます．この関数は，スーパーピクセル・セグメンテーションのラベルを含む画像を返します．ラベルは [0, getNumberOfSuperpixels()] の範囲にあります。

元関数名(C#): ximgproc_SuperpixelLSC_getLabels
元DLLエクスポート名: ximgproc_SuperpixelLSC_getLabels
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_SuperpixelLSC_getLabels(
    cv::ximgproc::SuperpixelLSC* obj, cv::_OutputArray *labels_out)
{
    BEGIN_WRAP
    obj-&amp;gt;getLabels(*labels_out);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_SuperpixelLSC_getLabelContourMask
[32/64bit] SuperpixelLSCオブジェクトに格納されているスーパーピクセル・セグメンテーションのマスクを返します。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = int : int thick_line
%inst
この関数は，スーパーピクセル・セグメンテーションの境界を返します．

元関数名(C#): ximgproc_SuperpixelLSC_getLabelContourMask
元DLLエクスポート名: ximgproc_SuperpixelLSC_getLabelContourMask
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_SuperpixelLSC_getLabelContourMask(
    cv::ximgproc::SuperpixelLSC* obj,
    cv::_OutputArray *image, int thick_line)
{
    BEGIN_WRAP
    obj-&amp;gt;getLabelContourMask(*image, thick_line != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_SuperpixelLSC_enforceLabelConnectivity
[32/64bit] ラベルの接続性を強制します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int min_element_size
%inst
この関数は，小さすぎるコンポーネントをマージし，以前に見つかった隣接ラベルをこのコンポーネントに割り当てます．この関数を呼び出すと，最終的なスーパピクセルの数が変わる可能性があります．

元関数名(C#): ximgproc_SuperpixelLSC_enforceLabelConnectivity
元DLLエクスポート名: ximgproc_SuperpixelLSC_enforceLabelConnectivity
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_SuperpixelLSC_enforceLabelConnectivity(
    cv::ximgproc::SuperpixelLSC* obj,
    int min_element_size)
{
    BEGIN_WRAP
    obj-&amp;gt;enforceLabelConnectivity(min_element_size);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_createSuperpixelLSC
[32/64bit] LSC (Linear Spectral Clustering) スーパーピクセルを実装するクラス．
%prm
p1,p2,p3,p4
p1 = sptr : IntPtr image
p2 = int : int region_size
p3 = float : float ratio
p4 = var : out IntPtr returnValue
%inst
この関数は，入力画像に対して SuperpixelLSC オブジェクトを初期化します．Superpixelアルゴリズムのパラメータである，region_sizeとrulerを設定します．また，与えられた画像に対する今後の計算反復のために，いくつかのバッファを事前に確保します．LSCの例を以下の図に示します。カラー画像の場合は、3×3の小さなカーネルでガウスぼかしをかけ、さらにCieLABの色空間に変換するなどの前処理を行うと、よりよい結果が得られるでしょう。

元関数名(C#): ximgproc_createSuperpixelLSC
元DLLエクスポート名: ximgproc_createSuperpixelLSC
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_createSuperpixelLSC(
    cv::_InputArray *image, int region_size, float ratio, cv::Ptr&amp;lt;cv::ximgproc::SuperpixelLSC&amp;gt;** returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::ximgproc::createSuperpixelLSC(*image, region_size, ratio);
    *returnValue = new cv::Ptr&amp;lt;cv::ximgproc::SuperpixelLSC&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_Ptr_SuperpixelSEEDS_delete
[32/64bit] cv::ximgproc::SuperpixelSEEDS のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
SEEDS (Superpixels Extracted via Energy-Driven Sampling) Superpixels アルゴリズムを実装したクラス [257] 。

このアルゴリズムでは，効率的な丘登りアルゴリズムを用いて，カラーヒストグラムとオプションである境界項に基づいたスーパーピクセルのエネルギー関数を最適化します．エネルギー関数は、スーパーピクセルが同じ色になるように促し、境界項が有効な場合、スーパーピクセルは滑らかな境界を持ち、似た形状になります。実際には、スーパーピクセルの規則的なグリッドからスタートし、境界にあるピクセルまたはピクセルのブロックを移動させて解を洗練させます。このアルゴリズムは、1つのCPUを使ってリアルタイムで実行されます。


元関数名(C#): ximgproc_Ptr_SuperpixelSEEDS_delete
元DLLエクスポート名: ximgproc_Ptr_SuperpixelSEEDS_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_SuperpixelSEEDS_delete(
    cv::Ptr&amp;lt;cv::ximgproc::SuperpixelSEEDS&amp;gt;* obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_Ptr_SuperpixelSEEDS_get
[32/64bit] cv::ximgproc::SuperpixelSEEDS のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
SEEDS (Superpixels Extracted via Energy-Driven Sampling) Superpixels アルゴリズムを実装したクラス [257] 。

このアルゴリズムでは，効率的な丘登りアルゴリズムを用いて，カラーヒストグラムとオプションである境界項に基づいたスーパーピクセルのエネルギー関数を最適化します．エネルギー関数は、スーパーピクセルが同じ色になるように促し、境界項が有効な場合、スーパーピクセルは滑らかな境界を持ち、似た形状になります。実際には、スーパーピクセルの規則的なグリッドからスタートし、境界にあるピクセルまたはピクセルのブロックを移動させて解を洗練させます。このアルゴリズムは、1つのCPUを使ってリアルタイムで実行されます。


元関数名(C#): ximgproc_Ptr_SuperpixelSEEDS_get
元DLLエクスポート名: ximgproc_Ptr_SuperpixelSEEDS_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_SuperpixelSEEDS_get(
    cv::Ptr&amp;lt;cv::ximgproc::SuperpixelSEEDS&amp;gt;* ptr, cv::ximgproc::SuperpixelSEEDS** returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_SuperpixelSEEDS_getNumberOfSuperpixels
[32/64bit] SuperpixelSEEDS オブジェクトに格納されている，与えられた画像のスーパーピクセル分割を計算します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
この関数は，関数 createSuperpixelSEEDS() で初期化されたパラメータを用いて，画像のスーパープixel segmentationを計算します．

元関数名(C#): ximgproc_SuperpixelSEEDS_getNumberOfSuperpixels
元DLLエクスポート名: ximgproc_SuperpixelSEEDS_getNumberOfSuperpixels
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_SuperpixelSEEDS_getNumberOfSuperpixels(
    cv::ximgproc::SuperpixelSEEDS* obj,
    int* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getNumberOfSuperpixels();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_SuperpixelSEEDS_iterate
[32/64bit] SuperpixelSEEDSオブジェクトに初期化されたパラメータを用いて，与えられた画像のスーパープリントセグメンテーションを計算します．
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr img
p3 = int : int num_iterations
%inst
この関数は， createSuperpixelSEEDS() でアルゴリズムを初期化しなくても，他の画像に対して再度呼び出すことができます．この関数は，関数 createSuperpixelSEEDS() で初期化されたパラメータを用いて，画像のスーパープリントセグメンテーションを計算します．このアルゴリズムは，スーパーピクセルのグリッドから始まり，境界に位置するピクセルのブロックを大きいサイズから小さいサイズに更新することで境界を絞り込み，最後にピクセルの更新を提案します．その例を以下に示します。

元関数名(C#): ximgproc_SuperpixelSEEDS_iterate
元DLLエクスポート名: ximgproc_SuperpixelSEEDS_iterate
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_SuperpixelSEEDS_iterate(
    cv::ximgproc::SuperpixelSEEDS* obj, cv::_InputArray *img, int num_iterations)
{
    BEGIN_WRAP
    obj-&amp;gt;iterate(*img, num_iterations);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_SuperpixelSEEDS_getLabels
[32/64bit] 画像のセグメンテーションラベリングを返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr labels_out
%inst
各ラベルはスーパーピクセルを表し，各ピクセルは1つのスーパーピクセルラベルに割り当てられます．この関数は，スーパーピクセル・セグメンテーションのラベルを含む画像を返します．ラベルは [0, getNumberOfSuperpixels()] の範囲にあります。

元関数名(C#): ximgproc_SuperpixelSEEDS_getLabels
元DLLエクスポート名: ximgproc_SuperpixelSEEDS_getLabels
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_SuperpixelSEEDS_getLabels(
    cv::ximgproc::SuperpixelSEEDS* obj, cv::_OutputArray* labels_out)
{
    BEGIN_WRAP
    obj-&amp;gt;getLabels(*labels_out);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_SuperpixelSEEDS_getLabelContourMask
[32/64bit] SuperpixelSEEDSオブジェクトに格納されているスーパーピクセル・セグメンテーションのマスクを返します。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = int : int thick_line
%inst
この関数は，スーパーピクセル・セグメンテーションの境界を返します．

(Python) Webカメラからの画像にスーパーピクセルを生成する方法のデモは， opencv_source_code/samples/python2/seeds.py にあります．

(cpp) ウェブカメラからの画像にスーパーピクセルを生成する方法についてのデモは、opencv_source_code/modules/ximgproc/samples/seeds.cpp にあります。コマンドライン引数にファイル画像を追加することで、ウェブカメラの代わりに静止画像が使用されます。

ウェブカムからの映像に、スーパーピクセルの境界が赤く表示されたウィンドウが表示されます（下記参照）。出力モードを切り替えるにはSpaceを使います。ウィンドウの上部には4つのスライダがあり、スーパーピクセルの数、ブロックレベルの数、形状を修正するための境界先行項の強さ、ピクセルレベルでの反復回数をその場で変更することができます。これは、パラメータを弄り、ユーザーの都合に合わせて設定するのに便利です。コンソールには，アルゴリズムのフレームレートが表示されます．

元関数名(C#): ximgproc_SuperpixelSEEDS_getLabelContourMask
元DLLエクスポート名: ximgproc_SuperpixelSEEDS_getLabelContourMask
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_SuperpixelSEEDS_getLabelContourMask(
    cv::ximgproc::SuperpixelSEEDS* obj,
    cv::_OutputArray* image, int thick_line)
{
    BEGIN_WRAP
    obj-&amp;gt;getLabelContourMask(*image, thick_line != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_createSuperpixelSEEDS
[32/64bit] SuperpixelSEEDSオブジェクトを初期化します。
%prm
p1,p2,p3,p4,p5,p6,p7,p8,p9
p1 = int : int image_width
p2 = int : int image_height
p3 = int : int image_channels
p4 = int : int num_superpixels
p5 = int : int num_levels
p6 = int : int prior
p7 = int : int histogram_bins
p8 = int : int double_step
p9 = var : out IntPtr returnValue
%inst
この関数は，入力画像に対して SuperpixelSEEDS オブジェクトを初期化します．これは，画像のパラメータである image_width, image_height, image_channels を格納します．また，SEEDS スーパーピクセルアルゴリズムのパラメータである num_superpixels, num_levels, use_prior, histogram_bins, double_step も設定されます．num_levels のレベル数は，アルゴリズムが最適化に利用するブロックレベルの量を定義します．初期設定では，スーパーピクセルが画像の幅と高さに均等に配置されたグリッドになっています．大きいブロックはスーパーピクセルのサイズに対応し、小さいブロックのレベルは、大きいブロックを2×2のピクセルのブロックに分割し、小さいブロックのレベルまで再帰的に形成されます。4つのブロックレベルの初期化の例を以下の図に示します。

元関数名(C#): ximgproc_createSuperpixelSEEDS
元DLLエクスポート名: ximgproc_createSuperpixelSEEDS
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_createSuperpixelSEEDS(
    int image_width, int image_height, int image_channels,
    int num_superpixels, int num_levels, int prior,
    int histogram_bins, int double_step,
    cv::Ptr&amp;lt;cv::ximgproc::SuperpixelSEEDS&amp;gt;** returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::ximgproc::createSuperpixelSEEDS(
        image_width, image_height, image_channels, num_superpixels, num_levels, prior, histogram_bins, double_step);
    *returnValue = new cv::Ptr&amp;lt;cv::ximgproc::SuperpixelSEEDS&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_Ptr_SuperpixelSLIC_delete
[32/64bit] cv::ximgproc::SuperpixelSLIC のインスタンスを破棄します
%prm
p1
p1 = sptr : IntPtr obj
%inst
1]で紹介したSLIC(Simple Linear Iterative Clustering)スーパーピクセルアルゴリズムを実装したクラス。

SLIC(Simple Linear Iterative Clustering)は、画素チャンネルと画像平面の空間を利用して画素をクラスタリングし、コンパクトでほぼ均一なスーパーピクセルを効率的に生成します。SLICのアプローチはシンプルであるため、スーパーピクセルの数を指定するだけで非常に簡単に使用することができ、アルゴリズムの効率性は非常に実用的です。SLICクラスにはいくつかの最適化機能があります。SLICOは、"Zero parameter SLIC "の略で、[1]で説明したベースラインSLICの最適化です。MSLICは、"Manifold SLIC "の略で、[150]で説明したベースラインSLICの最適化です。


元関数名(C#): ximgproc_Ptr_SuperpixelSLIC_delete
元DLLエクスポート名: ximgproc_Ptr_SuperpixelSLIC_delete
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_SuperpixelSLIC_delete(
    cv::Ptr&amp;lt;cv::ximgproc::SuperpixelSLIC&amp;gt;* obj)
{
    BEGIN_WRAP
    delete obj;
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_Ptr_SuperpixelSLIC_get
[32/64bit] cv::ximgproc::SuperpixelSLIC のインスタンスポインタを取得します
%prm
p1,p2
p1 = sptr : IntPtr ptr
p2 = var : out IntPtr returnValue
%inst
1]で紹介したSLIC(Simple Linear Iterative Clustering)スーパーピクセルアルゴリズムを実装したクラス。

SLIC(Simple Linear Iterative Clustering)は、画素チャンネルと画像平面の空間を利用して画素をクラスタリングし、コンパクトでほぼ均一なスーパーピクセルを効率的に生成します。SLICのアプローチはシンプルであるため、スーパーピクセルの数を指定するだけで非常に簡単に使用することができ、アルゴリズムの効率性は非常に実用的です。SLICクラスにはいくつかの最適化機能があります。SLICOは、"Zero parameter SLIC "の略で、[1]で説明したベースラインSLICの最適化です。MSLICは、"Manifold SLIC "の略で、[150]で説明したベースラインSLICの最適化です。


元関数名(C#): ximgproc_Ptr_SuperpixelSLIC_get
元DLLエクスポート名: ximgproc_Ptr_SuperpixelSLIC_get
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_Ptr_SuperpixelSLIC_get(
    cv::Ptr&amp;lt;cv::ximgproc::SuperpixelSLIC&amp;gt;* ptr, cv::ximgproc::SuperpixelSLIC** returnValue)
{
    BEGIN_WRAP
    *returnValue = ptr-&amp;gt;get();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_SuperpixelSLIC_getNumberOfSuperpixels
[32/64bit] SuperpixelSLIC オブジェクトに格納されている、与えられたセグメンテーション上のスーパーピクセルの実際の量を計算します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = var : out int returnValue
%inst
元関数名(C#): ximgproc_SuperpixelSLIC_getNumberOfSuperpixels
元DLLエクスポート名: ximgproc_SuperpixelSLIC_getNumberOfSuperpixels
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_SuperpixelSLIC_getNumberOfSuperpixels(
    cv::ximgproc::SuperpixelSLIC* obj,
    int* returnValue)
{
    BEGIN_WRAP
    *returnValue = obj-&amp;gt;getNumberOfSuperpixels();
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_SuperpixelSLIC_iterate
[32/64bit] SuperpixelSLIC オブジェクトで初期化されたパラメータを用いて，与えられた画像上のスーパーピクセル・セグメンテーションを計算します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int num_iterations
%inst
この関数は，createSuperpixelSLIC()でアルゴリズムを初期化することなく，再度呼び出すことができます。この関数は，関数 createSuperpixelSLIC() で初期化されたパラメータを用いて，画像のスーパープリントセグメンテーションを計算します．このアルゴリズムは，スーパーピクセルのグリッドから始まり，エッジの境界の更新を提案することで，境界を洗練していきます．

元関数名(C#): ximgproc_SuperpixelSLIC_iterate
元DLLエクスポート名: ximgproc_SuperpixelSLIC_iterate
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_SuperpixelSLIC_iterate(
    cv::ximgproc::SuperpixelSLIC* obj, int num_iterations)
{
    BEGIN_WRAP
    obj-&amp;gt;iterate(num_iterations);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_SuperpixelSLIC_getLabels
[32/64bit] 画像のセグメンテーションラベリングを返します．
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr labels_out
%inst
各ラベルはスーパーピクセルを表し，各ピクセルは1つのスーパーピクセルラベルに割り当てられます．この関数は，スーパーピクセル・セグメンテーションのラベルを含む画像を返します．ラベルは [0, getNumberOfSuperpixels()] の範囲にあります。

元関数名(C#): ximgproc_SuperpixelSLIC_getLabels
元DLLエクスポート名: ximgproc_SuperpixelSLIC_getLabels
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_SuperpixelSLIC_getLabels(
    cv::ximgproc::SuperpixelSLIC* obj, cv::_OutputArray* labels_out)
{
    BEGIN_WRAP
    obj-&amp;gt;getLabels(*labels_out);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_SuperpixelSLIC_getLabelContourMask
[32/64bit] SuperpixelSLICオブジェクトに格納されたスーパーピクセルセグメンテーションのマスクを返します。
%prm
p1,p2,p3
p1 = sptr : IntPtr obj
p2 = sptr : IntPtr image
p3 = int : int thick_line
%inst
この関数は，スーパーピクセル・セグメンテーションの境界を返します．

元関数名(C#): ximgproc_SuperpixelSLIC_getLabelContourMask
元DLLエクスポート名: ximgproc_SuperpixelSLIC_getLabelContourMask
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_SuperpixelSLIC_getLabelContourMask(
    cv::ximgproc::SuperpixelSLIC* obj,
    cv::_OutputArray* image, int thick_line)
{
    BEGIN_WRAP
    obj-&amp;gt;getLabelContourMask(*image, thick_line != 0);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_SuperpixelSLIC_enforceLabelConnectivity
[32/64bit] ラベルの接続性を強制します。
%prm
p1,p2
p1 = sptr : IntPtr obj
p2 = int : int min_element_size
%inst
この関数は，小さすぎるコンポーネントをマージし，以前に見つかった隣接ラベルをこのコンポーネントに割り当てます．この関数を呼び出すと，最終的なスーパピクセルの数が変わる可能性があります．

元関数名(C#): ximgproc_SuperpixelSLIC_enforceLabelConnectivity
元DLLエクスポート名: ximgproc_SuperpixelSLIC_enforceLabelConnectivity
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_SuperpixelSLIC_enforceLabelConnectivity(
    cv::ximgproc::SuperpixelSLIC* obj,
    int min_element_size)
{
    BEGIN_WRAP
    obj-&amp;gt;enforceLabelConnectivity(min_element_size);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

%index
ximgproc_createSuperpixelSLIC
[32/64bit] SuperpixelSLICオブジェクトの初期化を行います。
%prm
p1,p2,p3,p4,p5
p1 = sptr : IntPtr image
p2 = int : int algorithm
p3 = int : int region_size
p4 = float : float ruler
p5 = var : out IntPtr returnValue
%inst
この関数は，入力画像に対して SuperpixelSLIC オブジェクトを初期化します．また，選択された superpixel アルゴリズムのパラメータである， region_size と ruler を設定します．また，与えられた画像に対して将来的に計算を繰り返すための，いくつかのバッファを事前に確保します．カラー画像の場合は、3×3の小さなカーネルを使ってガウスぼかしをかけ、CieLABの色空間に変換することをお勧めします。SLICとSLICOおよびMSLICの比較例を以下の画像に示します。

元関数名(C#): ximgproc_createSuperpixelSLIC
元DLLエクスポート名: ximgproc_createSuperpixelSLIC
参照元CSファイル: Internal\PInvoke\NativeMethods\ximgproc\NativeMethods_ximgproc_Superpixel.cs
▼ C言語側関数定義
html{
<pre>
CVAPI(ExceptionStatus) ximgproc_createSuperpixelSLIC(
    cv::_InputArray *image, int algorithm, int region_size, float ruler,
    cv::Ptr&amp;lt;cv::ximgproc::SuperpixelSLIC&amp;gt;** returnValue)
{
    BEGIN_WRAP
    const auto ptr = cv::ximgproc::createSuperpixelSLIC(
        *image, algorithm, region_size, ruler);
    *returnValue = new cv::Ptr&amp;lt;cv::ximgproc::SuperpixelSLIC&amp;gt;(ptr);
    END_WRAP
}

</pre>
}html
%group
NativeMethods_ximgproc_Superpixel

